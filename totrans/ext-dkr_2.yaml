- en: Chapter 2. Introducing First-party Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker provides several tools that extend the functionality outside of the
    core Docker engine. In this chapter, you will walk-through installing, configuring,
    and running the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Toolbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools, while not as functional as some of the more advanced ones that
    we will be working with in the upcoming chapters, will serve as a good introduction
    to both adding additional functionality to core Docker engine as well as concepts
    for deploying and orchestrating your containers, which we will be doing more of
    towards the end of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start to look at how to use the three other tools, we should look
    at installing them on our local machine. In the previous chapter, we downloaded
    a script supplied by Docker and piped it through bash to quickly configure the
    official Docker YUM or APT repository (depending on the operating system you are
    running) on an already provisioned server, the command we executed was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is useful if you already have a Linux-based server up and running on one
    of the many cloud services or locally on virtual machine; however, what if you
    want to install Docker on a non-Linux operating system such as Mac OSX or Windows?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always check the source. It is best practice to check the source of the bash
    script that you are going to be downloading and installing; in our case, you can
    check this by going to [https://get.docker.com/](https://get.docker.com/) in your
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at the tools that Docker provides to do just that, we should
    answer the question why?
  prefs: []
  type: TYPE_NORMAL
- en: Why install Docker locally?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, why would we want to install Docker Toolbox, Compose, Machine, and Swarm
    on a non-Linux machine? Well, to start with, you need to remember that Docker,
    at its core, is an API to Linux Kernel-based technologies, such as run ([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc))
    and LXC ([https://linuxcontainers.org](https://linuxcontainers.org)), so while
    you will not be able to launch containers on your Mac OS X or Windows machine,
    you will be able to interact with a Docker installation on a Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to interact with Docker from your local machine means that you launch
    and interact with containers across multiple hosts that can be hosted externally
    on a public cloud/hosting service or locally on a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Docker has you covered for installing Docker and the three other services
    that we are going to be looking at in this chapter on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker Toolbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker provides a global installer for all of their tools called Docker Toolbox,
    it makes installing the following software as painless as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Kitematic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VM VirtualBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, you will need to be running a machine that either has Mac OS
    X 10.8+ or has Windows 7+ installed. In my case, I am running Mac OS X 10.11 (El
    Capitan); there is very little difference between the Mac OS X and Windows installers:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, to get started, you will need to download the installer from the
    Docker website. You can find links to download an executable for your chosen operating
    system at [https://www.docker.com/docker-toolbox/](https://www.docker.com/docker-toolbox/).![Installing
    Docker Toolbox](img/B05468_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have downloaded the installer, you can launch it by double-clicking
    on it. You will then be presented by a series of screens and install options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first screen is a welcome page that confirms the version of the toolbox
    you are running. If you downloaded from the page in the preceding screenshot,
    then you will always have the latest version:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Installing Docker Toolbox](img/B05468_02_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To move to the next step of the installation, click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen goes into more detail about the packages that will be installed,
    as well as the location at which they will be installed. There is also a box,
    which, if left ticked, will gather data about the machine you are installing Docker
    Toolbox on, anonymize it, and then submit it back to Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This information is useful in giving Docker an idea about the types of machine
    their software is being installed on, and also it will report back any errors
    that you may encounter when running the installer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Installing Docker Toolbox](img/B05468_02_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: I always recommend keeping this box ticked, as it all goes toward Docker making
    a better product and improving the experience of future versions of the installer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To progress to the next step of the installation, click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen will give you the option of which disk you would like to install
    the various tools on. In most cases, you should stick with the defaults, unless
    you are running applications across multiple drives:![Installing Docker Toolbox](img/B05468_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To move on to the next step of the installation, again click on the **Continue**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For majority of the people, a standard installation will be enough; however,
    if its not to install one of the tools, you can click the **Customize** button.
    The only two tools you have to install are the Docker Client and Docker Machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As I want to install all of the tools, I have chosen to go with the standard
    installation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Installing Docker Toolbox](img/B05468_02_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once you have chosen either a standard or custom installation, you can perform
    the installation by clicking the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The installation itself takes a few minutes, during which you will get feedback
    on the task the installer is running:![Installing Docker Toolbox](img/B05468_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installation is complete, click on the **Continue** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As running the installer also acts as an upgrader for any components you have
    installed, it will run a check to see if any of the files managed by the services
    (such as the virtual machine images used by the various tools) need to be updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on the size of any updates and how much data you have, this process
    can take several minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This process only applies to updates, so if you have performed a fresh installation
    like I have done, this section will be skipped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that the tools have been installed, you will be given the options of launching
    either the Docker Quickstart Terminal or Kitematic. For the purpose of this book,
    we will be skipping past this screen by clicking on the **Continue** button:![Installing
    Docker Toolbox](img/B05468_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything has gone as planned, you will see a message confirming that the
    installation has been completed and you can click on the **Close** button to quit
    the installer:![Installing Docker Toolbox](img/B05468_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have all of the tools installed on your local machine to continue with
    the rest of the chapter and the book.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start to look at the individual tools, we need to configure the Docker
    agent. To do this, run the **Docker Quickstart Terminal** application. If you
    have multiple terminal emulators installed, it will pop up a prompt asking you
    which one you would like to use; I prefer to use the one that ships with Mac OS
    X, so I chose Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have made your selection, a new terminal window will open and the
    application will configure your local installation of Docker for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Docker Toolbox](img/B05468_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In my case, I got the preceding terminal output when launching the **Docker
    Quickstart Terminal** application.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, when you ran the **Docker Quickstart Terminal** application, it created
    a bunch of certificates, SSH keys, and configured your user's environment to run
    Docker. It also launched a virtual machine running Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Developing locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Docker Quickstart Terminal** application did this using Docker machine,
    you can check the status of the machine launched by the application by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list the names of any active machines, the default machine launched
    when you first install Docker is called `default`, if you run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It should tell you that the virtual machine is currently running. Finally,
    you should be able to SSH into the virtual machine by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that when you SSH into the virtual machine, it is running the
    Boot2Docker distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boot2Docker is an extremely lightweight Linux distribution based on Tiny Core
    Linux, and its one purpose is to run Docker. Due to this, the entire distribution
    comes in at less than 30 MB, and it boots in around five seconds, which makes
    it perfect for running local development machines. For more information on Boot2Docker,
    refer to [http://boot2docker.io/](http://boot2docker.io/), and for Tiny Core Linux,
    refer to [http://tinycorelinux.net/](http://tinycorelinux.net/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should something similar to the following terminal session when running
    these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing locally](img/B05468_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There isn''t much need to SSH into the virtual machine, though, as the Docker
    client that was installed by toolbox has been configured to connect to the Docker
    Engine on the virtual machine, this means that when you run the Docker commands
    locally, it passes all the calls through Docker on the virtual machine, try running
    the `hello-world` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing locally](img/B05468_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this stage, you may be thinking to yourself, this all is very good, but it's
    hardly a tool to get excited about. Well, you are wrong. Docker Machine has a
    few more tricks up its sleeve than being able to launch a Boot2Docker virtual
    machine locally.
  prefs: []
  type: TYPE_NORMAL
- en: Heading into the cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Machine is able to connect to the following services, provision an instance,
    and configure your local Docker client to be able to communicate to the cloud-based
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The public cloud providers that currently are supported are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Web Services (AWS)**: [https://aws.amazon.com/](https://aws.amazon.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DigitalOcean**: [https://www.digitalocean.com/](https://www.digitalocean.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Azure**: [https://azure.microsoft.com/](https://azure.microsoft.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Compute Engine**: [https://cloud.google.com/compute/](https://cloud.google.com/compute/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rackspace**: [http://www.rackspace.co.uk/cloud/](http://www.rackspace.co.uk/cloud/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IBM SoftLayer**: [http://www.softlayer.com](http://www.softlayer.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exoscale**: [https://www.exoscale.ch/](https://www.exoscale.ch/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware vCloud Air**: [http://vcloud.vmware.com/](http://vcloud.vmware.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following self-hosted platforms can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenStack**: [https://www.openstack.org/](https://www.openstack.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Hyper-V**: [http://www.microsoft.com/virtualization/](http://www.microsoft.com/virtualization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware vSphere**: [http://www.vmware.com/uk/products/vsphere/](http://www.vmware.com/uk/products/vsphere/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DigitalOcean driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start creating some instances in the cloud. First, let's launch a machine
    in DigitalOcean.
  prefs: []
  type: TYPE_NORMAL
- en: There are two prerequisites for launching an instance with Docker Machine in
    DigitalOcean, the first is a DigitalOcean account and the second is an API token.
  prefs: []
  type: TYPE_NORMAL
- en: To sign up for a DigitalOcean account, visit [https://www.digitalocean.com/](https://www.digitalocean.com/)
    and click on the **Sign Up** button. Once you have logged in to your account,
    you can generate an API token by clicking on the **API** link in the top menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'To grab your token, click on the **Generate New Token** button and follow the
    on-screen instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You only get one chance to make a record of your token, make sure that you store
    it somewhere safe, as it will allow anyone who has it to launch instances into
    your account.
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have the token, you can launch your instance using Docker Machine.
    To do this, run the following command; make sure to replace the example API token
    with your own:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using a backslash: As we have a lot options to pass to the `docker-machine`
    command, we are using \ to split the command over multiple lines so that it''s
    easier to follow what is going on.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch a `dotest` instance into your DigitalOcean account, you will
    see something similar to the following terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you check your DigitalOcean control panel, you will now see that the instance
    that was created by Docker Machine is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have two instances launched by Docker Machine, one running locally running
    on our machine called `default` and one hosted in DigitalOcean called `dotest`.
    We can confirm this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return all of the machines we have running and confirm their state,
    IP address, Docker version, and name. There is also a column that allows you to
    know which of the two machines your local environment is configured to communicate
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, our local Docker client is configured to communicate
    with the `default` instance, which is the run running locally. Let's change it
    so that it interacts with the DigitalOcean instance.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you have change some local environment variables, luckily, Docker
    Machine provides an easy way to find out what these are and also change them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out what they all you have to do is simple, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell you exactly what you need to run to change from the `default`
    machine to `dotest`. The best thing is that the command itself formats the results
    in such a way that they can be executed, so we run the command again, but this
    time in a way where the output will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you get a listing from Docker Machine, you will notice that the `dotest`
    environment is now the active one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our DigitalOcean instance active, you can run the `docker`
    command on your local machine, and they will have been executed on the DigitalOcean
    instance. Let's test this by running the hello-world container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the following command, you should see the image download and then
    the output of running the hello-world container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you then run the following command, you will see that the hello-world image
    exited a few seconds ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is demonstrated by the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, I used `ssh` to get into the DigitalOcean instance and ran the
    `docker ps –a` and `docker images` commands to demonstrate that the commands I
    ran locally were executed on the DigitalOcean instance; however, the beauty of
    this setup is that you shouldn't have to SSH instance often.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you may have noticed is that all we told Docker Machine is that we
    want to use DigitalOcean and our API token; at no point did we tell it which region
    to launch the instance in, what specification we wanted, or which SSH key to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Machine has some following sensible defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '`digitalocean-image = ubuntu-15-10-x64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digitalocean-region = nyc3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digitalocean-size = 512mb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As I am based in the UK, let''s look at changing the region and the specifications
    of the machine. First of all, we should remove the `dotest` instance by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will terminate the `512mb` instance running in NYC3.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to terminate instances that you are not using, as they will
    be costing you for each hour they are active. Remember one of the key advantages
    of using Docker Machine is that you can spin up instances both quickly and with
    as little interaction as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have removed the old instance, let''s add some additional flags
    to our `docker-machine` command to launch the new instance in the desired region
    and specification, we will be calling our new instance `douktest`. The updated
    `docker-machine create` command now looks similar to the following (remember to
    replace the example API token with your own):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see similar output from the command as before, once the instance
    has been deployed, you can make it active by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![The DigitalOcean driver](img/B05468_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you enter the control panel, you will notice that the instance has launched
    in the specified region and at the desired specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For full details on each of the regions and what machine types are available
    in each one, you can query the DigitalOcean API by running the following command
    (remember to replace the API token):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will output information about each region.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing, we still haven''t found out about the SSH key. Each time you
    run Docker Machine, a new SSH key for the instance you are launching is created
    and uploaded to the provider, each key is stored in the `.docker` folder in your
    user''s home directory. For example, the key for `douktest` can be found by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you will also find the certificates used to authenticate the Docker agent
    with the Docker installation on the instance and also the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DigitalOcean driver](img/B05468_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This covers DigitalOcean, what about other services? Let's quickly look at Amazon
    Web Services so that we can get an idea between the drivers for the different
    cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: The Amazon Web Services driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't already have an Amazon Web Services account, you should sign up
    for one at [http://aws.amazon.com/](http://aws.amazon.com/). If you are new to
    AWS, then you will eligible for their free tier at [http://aws.amazon.com/free/](http://aws.amazon.com/free/).
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend reading through Amazon's getting started guide if you are
    unfamiliar with AWS before working through this section of the chapter, you can
    find the guide at [http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-intro/gsg-aws-intro.html](http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-intro/gsg-aws-intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The AWS driver is similar to the DigitalOcean driver and it has some sensible
    defaults, rather than going into too much detail about how to customize the EC2
    instance launched by Docker Machine, I will stick to the defaults. For AWS driver,
    the defaults are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`amazonec2-region = us-east-1 (North Virginia)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amazonec2-ami = ami-26d5af4c (Ubuntu 15.10)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amazonec2-instance-type = t2.micro`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amazonec2-root-size = 16GB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amazonec2-security-group = docker-machine`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we launch our instance, we will also need to know our AWS access and
    secret keys, and also the VPC ID will be launching our instance. To get these,
    log in to the AWS console that can be found at [https://console.aws.amazon.com/](https://console.aws.amazon.com/).
  prefs: []
  type: TYPE_NORMAL
- en: You should already have a copy of your access and secret ID as these are created
    when your user was first created in AWS. If you have lost these, then you can
    generate a new pair by navigating to **Services** | **IAM** | **Users**, then
    selecting your user, and finally going to the **Security Credentials** tab. There
    you should see a button that says **Create Access Key**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon describes Amazon **Virtual Private Cloud** (**VPC**) as letting you provision
    a logically-isolated section of the AWS cloud, where you can launch resources
    in a virtual network that you define. You have complete control over your virtual
    networking environment, including selection of your own IP address range, creation
    of subnets, and configuration of route tables and network gateways.
  prefs: []
  type: TYPE_NORMAL
- en: Before you find your VPC ID, you should make sure that you are in the correct
    region by ensuring that it says **N. Virginia** at the top right-hand corner of
    your AWS console, if it doesn't select it from the drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have ensured you are in the correct region, go to **Services** | **VPC**
    and click on **Your VPCs**. You don''t need to worry about creating and configuring
    a VPC as Amazon provides you with a default VPC in each region. Select the VPC
    and you should see the something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Amazon Web Services driver](img/B05468_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Make a note of the VPC ID, you should now have enough information to launch
    your instance using Docker Machine. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should see something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Amazon Web Services driver](img/B05468_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should also be able to see an EC2 instance launched in the AWS Console
    by navigating to **Services** | **EC2** | **Instances**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Amazon Web Services driver](img/B05468_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may have noticed that Docker Machine created the security group and also
    assigned an SSH key to the instance without any need for us to get involved, keeping
    within the principle that you don't need to be an expert in configuring the environments
    that you are launching your Docker instance into.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we terminate the instance, let''s switch our local Docker client over
    to use the AWS instance and launch the `Hello World` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Amazon Web Services driver](img/B05468_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, once you have launched an instance using Docker Machine and
    switched your local Docker client to it, there is no difference in usage between
    running Docker locally and on a cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start to rack up the cost, we should terminate our test AWS instance
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then confirm that the instance has been terminated correctly in the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Amazon Web Services driver](img/B05468_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you don't do this, the EC2 instance will quite happily sit there costing
    you **$0.013** per hour until it is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is not Amazon's **Elastic Container Service** (**ECS**). We will
    be covering Amazon ECS in [Chapter 7](ch07.html "Chapter 7. Looking at Schedulers"),
    *Looking at Schedulers*.
  prefs: []
  type: TYPE_NORMAL
- en: Other considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from examples we have worked through, Docker Machine is a powerful
    part of Docker Toolbox as it allows users of all skill levels to be able to launch
    an instance either locally or in a cloud provider without having to roll their
    sleeves up and get stuck in configuring server instances or their local Docker
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples we have used in this chapter have been launching either Boot2Docker
    or Ubuntu. Docker machine also supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debian (8.0+)**: [https://www.debian.org/](https://www.debian.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red Hat Enterprise Linux (7.0+)**: [https://www.redhat.com/](https://www.redhat.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CentOS (7+)**: [https://www.centos.org/](https://www.centos.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fedora (21+)**: [https://getfedora.org/](https://getfedora.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RancherOS (0.3)**: [http://rancher.com/rancher-os/](http://rancher.com/rancher-os/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other thing to mention about Docker Machine is that, by default, it operates
    and opts in for crash reporting, considering the amount of different configuration/environment
    combinations Docker Machine can be used with, it is important that Docker get
    notified of any problems to help them make a better product. If, for any reason,
    you want to opt-out, then running the following command will disable crash reporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information on Docker Machine, you can refer to the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Machine**: [https://docs.docker.com/machine/](https://docs.docker.com/machine/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Machine Drivers**: [https://docs.docker.com/machine/drivers/](https://docs.docker.com/machine/drivers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Machine Command Reference**: [https://docs.docker.com/machine/reference/](https://docs.docker.com/machine/reference/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have discussed how to launch individual Docker instances using Docker
    Machine, let's get a little more adventurous and create a cluster of instances.
    To do this, Docker ships a tool called Swarm. When deployed, it acts as a scheduler
    between your Docker client and host Docker instances, deciding where to launch
    containers based on scheduling rules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, we are going to be using Docker Machine to create a cluster locally
    using VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org)), which
    is bundled with Docker Toolbox. To start, we are going to launch a VM to generate
    a discovery token. To do this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then configure your Docker client to use the newly created local instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can check that your Docker client is configured to use the `discover` instance
    by running `docker-machine ls` and making sure that `discover` has a star in the
    active column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can install the discovery service by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download and run the discovery service and generate the token. At
    the end of the process, you will be given a token; it is important that you keep
    a note of this for the next steps. If everything went as planned, you should see
    something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a local cluster](img/B05468_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the token is `40c3bf4866eed5ad14ade6633fc4cefc`. Now
    that we have our token, we need to launch an instance that will act as the scheduler,
    this is know as a Swarm manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, enter the following command, making sure that you replace the token
    with the one you generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the Swarm manager VM up and running, we can start launching
    VMs that act as nodes within the cluster. Again, using the discovery token, run
    the following commands to launch two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then launch the second node using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check our VMs by running the `docker-machine ls` command and then switch
    our Docker client to use the cluster by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that your Docker client is communicating with the cluster, you can run
    `docker info` to find information about all the nodes and the cluster itself,
    you will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a local cluster](img/B05468_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, now we have a three CPU, 3-GB cluster running over three nodes. To test
    it, let''s run the `Hello World` container and then run `docker ps -a` so that
    we can see which node the container launched on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a local cluster](img/B05468_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the terminal output, the container was launched on `swarm-node-01`,
    running the container again should launch it on our second node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a local cluster](img/B05468_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So there you have it, a really basic Docker Swarm cluster that you can launch
    your containers into using your local Docker client, all launched a managed using
    Docker Machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move onto the next section, we should remove the local cluster. To
    do this, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Click on `yes` when prompted. You can then check whether the VMs have been terminated
    by running the `docker-machine ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Remote Cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move onto looking at the next tool, let's launch a cluster in the
    cloud. I am going to be using DigitalOcean for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a new discovery token. As all we need to do is
    generate a discovery token, there is no need to launch an instance in DigitalOcean
    just for this task, so we will simply bring up a machine locally, make a note
    of the discovery token and then remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our discovery token, let''s launch our Swarm cluster in DigitalOcean,
    first of all we will look into Swarm manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the we will use the two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, I launched the cluster in DigitalOcean''s
    London datacenter and gave the two nodes additional resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Remote Cluster](img/B05468_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will configure our local Docker client to use the remote cluster using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Remote Cluster](img/B05468_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to be using this cluster for the next part of this chapter, so
    try to keep it running for now. If you can''t, then you can remove the cluster
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You should also double the DigitalOcean control panel to ensure that your instances
    have terminated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that with public cloud services, you are paying for that you use, so
    if you have an instance sat powered on, even if it is an `errored` state, with
    Docker Machine, the meter is running and you will be incurring cost.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, it is worth pointing out that Docker allows you to swap out the
    Discovery backends, at the moment we are using the default one which the Hosted
    Discovery with Docker Hub, which isn't recommend for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swarm supports the following discovery services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**etcd**: [https://coreos.com/etcd/](https://coreos.com/etcd/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consul**: [https://www.consul.io/](https://www.consul.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ZooKeeper**: [https://zookeeper.apache.org/](https://zookeeper.apache.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the time being, we are just going to be looking at the tools Docker provides
    rather than any third-party options, so we are going to stick to the default Discovery
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the one thing that the default Discovery backend doesn't give
    you is high availability, this means that our Swarm manager is a single point
    of failure. For our needs, this isn't a problem; however, I would not recommend
    running this configuration in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the different discovery backends and high availability
    with Swarm, refer to the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovery backends**: [https://docs.docker.com/swarm/discovery/](https://docs.docker.com/swarm/discovery/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swarm High Availability**: [https://docs.docker.com/swarm/multi-manager-setup/](https://docs.docker.com/swarm/multi-manager-setup/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to be looking a lot more at schedulers in later chapters, so for
    now, let's move onto the final service installed by Docker Toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in our exploration of the tools that ship with Docker Toolbox, we have
    been using services which manage our Docker host machines, the final service that
    we are going to look at in this chapter deals with containers. I am sure that
    you will agree that so far the tools provided by Docker are quite intuitive, Docker
    Compose is no different. It start off life as third-party service called Fig and
    was written by Orchard Labs (the project's original website is still available
    at [http://fig.sh/](http://fig.sh/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The original project''s goal was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Provide fast, isolated development environments using Docker"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since Fig became part of Docker, they haven''t strayed too far from the original
    goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Compose is a tool for defining and running multi-container Docker applications.
    With Compose, you use a Compose file to configure your application''s services.
    Then, using a single command, you create and start all the services from your
    configuration."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before we start looking at Compose files and start containers up, let's think
    of why a tool such as Compose is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Why Compose?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Launching individual containers is as simple as running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will launch and then attach to an Ubuntu container. As we have already
    touched upon, there is a little more to it than just launching simple containers
    though. Docker is not here to replace virtual machines, it is here to run a single
    application.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you shouldn't really run an entire LAMP stack in single container,
    instead, you should look at running Apache and PHP in one container, which is
    then linked with a second container running MySQL. You could take this further,
    running a NGINX container, a PHP-FPM container, and also a MySQL container. This
    is where it gets complicated. All of sudden, your simple line for launching is
    now several lines, all of which have to executed in the correct order with the
    correct flags.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the problem Docker Compose tries to fix. Rather than several
    long commands, you can define your containers using a YAML file. This means that
    you will be able to launch your application with a single command and leave the
    logic of the order in which the containers will be launched to Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**YAML Ain''t Markup Language** (**YAML**) is a human-friendly data serialization
    standard for all programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: It also means that you can ship your application's Compose file with your code
    base or directly to another developer/administrator and they will be able to launch
    your application exactly how you intended it be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Compose files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost everyone at some point would have installed, used, or read about WordPress,
    so for the next few examples, we will be using the official WordPress container
    from the Docker Hub, you can find details on the container at [https://hub.docker.com/_/wordpress/](https://hub.docker.com/_/wordpress/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WordPress is web software that you can use to create a beautiful website, blog,
    or app. We like to say that WordPress is both free and priceless at the same time.
    For more information, check out [https://wordpress.org/](https://wordpress.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by getting a basic WordPress installation up and running, first
    of all create a folder called `wordpress` and then add the following content to
    a file called `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be able to launch the application using your Swarm cluster by making
    sure that your local Docker client is configured to use it, run `docker-machine
    ls` and make sure that it is active and then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your client is configured to communicate with your Swarm cluster, run
    the following command within the folder containing the `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using the `-d` flag at the end of the command launches the containers in detached
    mode, this means that they will run in the background. If we didn't use the -d
    flag, then our containers would have launched in the foreground and we would not
    have been able to carry on using the same terminal session without stopping the
    running containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B05468_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, you can find out the IP address of the node where the WordPress
    application has been launched by running `docker ps`. If you were to go to the
    IP address shown in the figure, where `port 80` is listed, you will see a WordPress
    installation screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compose files](img/B05468_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the interesting things to note is that although the `my-wordpress-app`
    container was defined first in the `docker-compose.yml` file, Compose recognized
    that it was linked to the `my-wordpress-database` container and it launched that
    one first. Also, you may have noticed that the `wordpress:latest` and `mysql:latest`
    images were pulled down on all of the nodes in the Swarm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: So, what of the `docker-compose.yml` file itself? Let's look at it again, but
    this time with some comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as Compose is concerned, our WordPress application is split into two
    applications, one called **wordpress** and another called **mysql**. Let''s look
    at the `docker-compose.yml` file again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At the top level, we have the application name. From here, we then start to
    define the configuration for the application by giving a key and value, making
    sure that you pay close attention to the indentation. I tend to use two spaces
    to make it clear that the indent is there, but not so much that it becomes unreadable.
  prefs: []
  type: TYPE_NORMAL
- en: The first key that we are defining is `container_name`, we don't have to do
    this as Compose will name our containers automatically, based on the name of the
    folder we are in and the application name. If we hadn't defined this key, then
    our containers would have been called `wordpress_wordpress_01` and `wordpress_mysql_01`.
  prefs: []
  type: TYPE_NORMAL
- en: The next key tells the application which `image` to use, this will pull the
    image straight from the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define the `ports`, not that we only define the ports for the **wordpress**
    application and not the **mysql** one. As we want our **wordpress** application
    to listen on port of the host machine, we have given 80:80\. In this case, the
    first 80 is the **host** port and the second one is the **container** port that
    we want to expose.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the next key is only used on the **wordpress** application, this defines
    the `links`. Links are used to link containers together, exposing, in this case,
    the **mysql** container to the **wordpress** container. This means that when the
    **wordpress** container is launched, it will know the IP address of the **mysql**
    container and only its ports will be exposed to the **wordpress** container.
  prefs: []
  type: TYPE_NORMAL
- en: The final key we are defining is `environment`, here are we passing further
    keys and values that will be set as environment variables on the containers when
    they launch.
  prefs: []
  type: TYPE_NORMAL
- en: A full break down of all of the keys available in compose files can be found
    in the official documentation at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  prefs: []
  type: TYPE_NORMAL
- en: Launching more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the advantages of using Compose is that each of the environments it
    launches is isolated, let''s launch another WordPress installation using the following
    `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, other than the container names, it is exactly the same as the
    previous environment we launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching more](img/B05468_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other thing you will notice is that the `my-other-wordpress` containers
    launched on the second node in the cluster. At the moment, each Compose environment
    will launch on a single node. As we launch more, we will start to have to change
    port assignments as they will start to clash on the hosts (that is, you can't
    have two `port 80` assigned to a single host).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to remove any cloud-based instances that you have launched by using
    the `docker-machine rm` command and also check your cloud provider's control panel
    to ensure that the instances have correctly terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the additional client tools provided by Docker
    to extend the functionality of your core Docker installation, all of the tools
    that we have looked at have been designed to slot into your workflow and be as
    simple as possible to use. In the later chapters, we will be looking at how to
    expand some of the core functionality of Docker using third-party services. When
    we do, we will revisit a few of the tools that we have been through in this chapter
    and look at how they add additional functionality to them.
  prefs: []
  type: TYPE_NORMAL
