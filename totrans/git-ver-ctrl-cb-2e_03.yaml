- en: Branching, Merging, and Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing your local branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branches with remotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a merge commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using git reuse recorded resolution (rerere) to merge Git conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the difference between branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orphan branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are developing a small application in a big corporation as a developer,
    or you are trying to wrap your head around an open source project from GitHub,
    you have already been using branches with Git.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you may have just been working on a local development or master
    branch, and so didn't care so much about other branches.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will show you different branch types and how to work with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing your local branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you just have your local Git repository, and, at the moment, you have
    no intention of sharing the code with others; you can, however, easily share the
    knowledge you have while working with a repository with one or more remotes. Local
    branches with no remotes work exactly in this fashion. As you can see in the examples,
    we are cloning a repository, and thus we have a remote.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a few local branches.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following command to clone the `jgit` repository to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to manage your local branches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you start working on a bug fix or a new feature in your project, you
    should create a branch. You can do so using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newBugFix` branch points to the current `HEAD` you were on at the time
    of the creation. You can see the `HEAD` with `git log -1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to add a description to the branch, you can do this with the `--edit-description`
    option for the git branch command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will open an editor where you can type in a description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Close the editor and the message will be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git stores the information in the local `git config` file; this also means that
    you cannot push this information to a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the description for the branch, you can use the `--get` flag for
    the `git config` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will be beneficial when we automate some tasks in [Chapter 7](fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml),
    *Enhancing Your Daily Work with Git Hooks*, *Aliases, and Scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to perform a checkout of `newBugFix` before you start working on it.
    This must be done with the Git checkout of `newBugFix`. If you are in a hurry,
    you can create and checkout a new branch in a single command. Just give the option
    `-b` to `checkout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The branch information is stored as a file in `.git/refs/heads/newBugFix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is the same commit hash we retrieved with the `git log` command.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps you want to create specific branches from specific commit hashes. The
    first thought might be to check out the commit, and then create a branch; however,
    it is much easier to use the `git branch` command to create the branches without
    checking out the commits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a branch from a specific commit hash, you can create it with the
    `git branch` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the abbreviated commit hash is shown when you use `%h`, and
    the full commit hash is shown when you use `%H`. You can see that the abbreviated
    commit hash is the same as the one used to create the branch. Most of the time,
    you want to create and start working on the branch immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Git switches to the new branch immediately after it creates the branch. Verify
    with `gitk` to see whether the `lastBugFix` branch is checked out and another
    `BugFix` branch is at the same commit hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be shown via a screenshot as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77c7e1a2-9511-4240-878c-ab4d41cdafe5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of using Gitk, you can also add `-v` to the `git branch` command or
    even another `-v`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With `-v`, you can see the abbreviated commit hash for each branch, and with
    `-vv`, you can also see that the master branch tracks the origin/master branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Branches with remotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, it is very likely that you have cloned somebody's repository.
    This means that you have an associated remote. The remote is usually called origin
    because it is where the source originated from.
  prefs: []
  type: TYPE_NORMAL
- en: While working with Git and remotes, you will get some benefits from Git.
  prefs: []
  type: TYPE_NORMAL
- en: We can start with git status and see what we get while working with the remote.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by checking out a local branch that tracks a remote branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous command creates and checks out the `remoteBugFix` branch that will
    track the `origin/stable-3.2` branch. Therefore, for instance, executing `git
    status` will automatically show how different your branch is from `origin/stable-3.2`,
    and it will also show whether your branch's `HEAD` can be fast forwarded to the
    `HEAD` of the remote branch or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To provide an example of how the previous step works, we need to do some manual
    work that will simulate this situation. First, we find a commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will list the last 10 commits on the `stable-3.2` branch from the
    remote origin. The `--oneline` option will show the abbreviated commit hash and
    the commit subject. For this recipe, we will be using the following commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will reset the `remoteBugFix` branch to the `2e0d178` commit hash. We are
    now ready to continue using the free benefits of Git when we have a remote tracking
    branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are resetting to a commit that is accessible from the `origin/stable-3.2`
    remote tracking branch; this is done to simulate that we have performed a Git
    fetch and new commits were downloaded for the `origin/stable-3.2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will try a few commands that assist you when you have a remote tracking
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by executing `git status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Git is very descriptive when you have a tracking branch and you use `git status`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the message, you can use `git pull` to update your local
    branch, which we will try in the next example. The message says it can be fast-forwarded.
    It simply means that Git can advance the `HEAD` without merging. Now, we will
    just perform the merge:'
  prefs: []
  type: TYPE_NORMAL
- en: The `git pull` command is just a `git fetch` command and then a `git merge`
    command with the remote tracking branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From the output, you can see it is a fast-forward merge, as Git predicted in
    the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: output of `git status`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also add a remote to an existing branch, which is very handy when you
    realize that you actually wanted a remote tracking branch but forgot to add the
    tracking information while creating the branch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a local branch at the `2e0d17` commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remoteBugFix2` branch is just a local branch at the moment with no tracking
    information; to set the tracking branch, we need to use `--set-upstream-to`  or
    `-u` as a flag to the `git branch` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the Git output, we are now tracking the `stable-3.2` branch
    from the origin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from the Git output that you are nine commits ahead, and you can
    use `git pull` to update the branch. Remember that a `git pull` command is just
    a `git fetch` command, followed by a `git merge` command with the upstream branch,
    which we also call the remote tracking branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, you can see that the branch has been fast forwarded to the
    `f839d383e` commit hash, which is equivalent to `origin/stable-3.2`. You can verify
    this with `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Forcing a merge commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have seen a lot of basic examples of software delivery chains and
    branching models before reading this book. It is very likely that you have been
    trying to use different strategies and found that none of them completely support
    your scenario, which is perfectly fine as long as the tool can support your specific
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Git supports almost any workflow. We have often encountered a situation that
    requires a merge commit while merging a feature, even though it can be done with
    a fast-forward merge. Those who requested it often use it to indicate that you
    have actually merged in a feature and want to store the information in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Git has fast and easy access to all the commit messages, so the repository should
    be used as a journal, and not just a backup of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by checking out a local branch `remoteOldbugFix` that tracks `origin/stable-3.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show you how to force a merge commit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To force a merge commit, you need to use the `--no-ff` flag; *no-ff* means
    no fast forward. We will also use the `--quiet` flag to minimize the output and
    `--edit` to allow us to edit the commit message. Unless you have a merge conflict,
    Git will create the merge commit for you automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The commit message editor will open, and you can write a commit message. Closing
    the editor creates the merge commit and we are done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To verify this, you can reset back to `origin/stable-3.1` and perform the merge
    without the `--no-ff` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, perform the merge with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the difference using Gitk. The following screenshot shows the fast-
    forward merge; as you can see, our `remoteOldBugFix` branch points to `origin/stable-3.2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/89096683-4d34-4b7c-83f8-f2a6c4d6ca81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot shows the merge commit we forced Git to create. Our branch
    `remoteOldBugFix` is ahead of `remotes/origin/stable-3.2`, and then we performed
    the commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/58b2d86a-c920-4e9e-ba1e-4c28cf78ec48.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although most branching scenarios expect you to completely merge branches, there
    are situations when, while working in a real environment, you only need to merge
    specific pieces of one branch into another branch. Using the `--no-commit` option,
    Git will make the merge and stop before committing, allowing you to modify and
    add files to the merge commit before committing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have been working with projects where versions of strings have
    been updated in the feature branch but not in the master branch. So, an automatic
    merge into master would replace the current version string used on the master
    branch, which, in this case, was not the intention. In the following example,
    we will use a simple Git repository with a few commits and files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by checking out a local `remotePartlyMerge` branch that tracks `origin/release/1.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to create the merge and allow you to decide what will be part of the
    commit, you can use `--no-commit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, Git is very informative; you can see from the output that everything
    went well and Git stopped before committing as requested. To continue, let's pretend
    we didn't want the `LICENSE` file to be part of the merge commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To achieve this, we reset the directory using the `git reset <path>` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from the output that you have unstaged changes after the reset;
    this is exactly what we want. You can check which unstaged changes you have by
    running `git status`. Now, we will just finish the merge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The merge commit is complete. If you run a `git status` command now, you will
    still have the unstaged changes in you work area. To verify whether the result
    is as expected, we can compute the difference for this using `git diff` to show
    that the files are as they are on the `origin/master` branch, excluding the `LICENSE`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is no output from diff; this is the expected result. We are telling the
    `diff` command to `diff` our current `HEAD` commit and branch `origin/master`,
    and we do not care about the diffs in `LICENSE`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't specify `HEAD`, you will `diff` with your current `WA`, and the
    `diff` command will have a lot of output as you have unstaged changes.
  prefs: []
  type: TYPE_NORMAL
- en: Using git reuse recorded resolution (rerere) to merge Git conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on a feature branch, you probably like to merge daily or perhaps
    more often, but when you work on long-living feature branches, you end up in a
    situation where you have the same conflicts occurring repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can use `git rerere`, which stands for *reuse recorded resolution*.
    Git rerere is not enabled by default, but can be enabled with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can configure it globally by adding `--global` to the `git config` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to merge the known conflicts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `jgit` repository folder, start by checking out a branch that tracks `origin/stable-2.2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the maven-compiler-plugin version to something personalized, such
    as 2.5.2, as this is in line 211 in `pom.xml`. If you run `git diff`, you should
    get a result very similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the file and create a commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Store your current commit in a backup branch named `rerereExample2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, `git branch rerereExample2` is just storing the current commit as a branch,
    as we need to use that for the second rerere example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to perform the first merge that will fail on auto merge. Then
    we can solve that. After solving it, we can reuse the merge resolution to solve
    the same problem in the future:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have `git rerere` enabled, we can use `git rerere status` to see which
    files or paths will be recorded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `pom.xml` file (around line 229) and solve the merge conflict so that
    you can get the `diff` output shown as follows. You have to remove the line with
    3.1 and the merge markers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merge markers are lines that begin with `<<<<<<`, `>>>>>>`, or `======`; these
    lines indicate the points where Git could not perform an auto merge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Mark the merge as complete by adding `pom.xml` to the staging area using `git
    add` and then run `git commit` to finish the merge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note the recorded resolution for the `pom.xml` output from Git; this will not
    be here without enabling `git rerere`. Git has recorded this resolution to this
    particular merge conflict and will also record how to resolve this. Now, we can
    try to `rebase` the change to another branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by checking out the `rerereExample2` branch from our repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to rebase your change on top of the `origin/stable-3.2` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You should notice the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As the merge conflict is the same in `pom.xml`, Git can solve the conflict
    in the file for you. This is very clear when you open the file and see there are
    no merge markers, as the resolution Git had recorded has been applied. Finish
    the merge by adding `pom.xml` and continue the `rebase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Start Gitk to see that the commit has been rebased on top of the `origin/stable-3.2`
    branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/910cc116-cd54-4833-b72a-488fa62440c4.png)'
  prefs: []
  type: TYPE_IMG
- en: You can try the same scenario with merging and it will merge the file automatically
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you merge different branches often and you are not sure which branch a
    specific error fix is a part of, it is actually quite easy to find out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to find a commit for which you are interested in getting this information.
    Then, use the `--contains` flag for the `git branch` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command lists all the branches that have the specific commit.
    If you leave out the commit argument (`8e2886897`), Git will check `HEAD`. So,
    for instance, checking out the `rerereExample2` branch and executing the following
    command, you will see the commit is present only on that branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` option indicates that you wish to check all the remote branches as
    well. If you leave this out, it will check only local branches.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you can see, our commit is not on any remote branch, as the commit
    has just been created locally and has not been pushed to any remotes yet.
  prefs: []
  type: TYPE_NORMAL
- en: You can use tags, branch names, or commit hashes while using the git branch
    `-a --contains` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to see the branches where the `v2.3.0.201302130906` tag is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That tag can be found in quite a lot of branches.
  prefs: []
  type: TYPE_NORMAL
- en: Compute the difference between branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking the difference between branches can show valuable information before
    merging.
  prefs: []
  type: TYPE_NORMAL
- en: A regular `git diff` between two branches will show you all the information,
    but it can be rather exhausting to sit and look at; maybe you are only interested
    in one file. Thus, you don't need the long unified diff.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, we decide on two branches, tags, or commits we want to see the
    difference between. Then, to list files that have changed between these branches,
    you can use the `--name-only` flag.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to see the difference between the branches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Diff `origin/stable-3.1` with the `origin/stable-3.2` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We are building the command in this pattern, that is, `git diff [options] <commit>
    <commit> <path>`. Then, we can diff what we care about while looking into the
    differences between branches. This is very useful if you are responsible for a
    subset of the source code, and you wish to diff that area only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try the same diff between branches, but this time we will diff the entire
    branches, not just a sub-directory; however, we only want to show the deleted
    or added files between the branches. This is done by using the `--diff-filter=DA`
    and `--name-status` options. The `--name-status` option will only show the filenames
    and the type of change. The `--diff-filter=DA` option will only show the deleted
    and added files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This shows the files that have been added and deleted while moving from `origin/stable-3.1` to
    `origin/stable-3.2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we switch the branches around, as in the following command, we will get
    the opposite result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that the indication letters A and D switched places because now we want
    to know what happens if we move from `origin/stable-3.2` to `origin/stable-3.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Orphan branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now familiar with Git's data model, the DAG. You have seen that objects
    have a parent. When you create a new branch, the commit is its parent. However,
    in some situations, it is useful to have a branch with no parent.
  prefs: []
  type: TYPE_NORMAL
- en: One example would be an instance where you have your code base in two separate
    repositories, but, for some reason, you now want to consolidate it into one. One
    way is to simply copy the files and add them to one of the repositories, but the
    disadvantage is that you will lose the histories. The second way is to use an
    orphan branch that can help you to fetch one repository in another.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is actually easy to create an orphan branch. The flag `--orphan` to `checkout`
    will do it. It can be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a branch with no parent. You can verify it by examining the commit
    log as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`Fresh start` does not mean that you are starting from scratch. The files and
    directories that have been added to the repository still exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need a fresh start, you can delete the files (but remember not to delete `.git`)
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You have a branch with no files and no commits. Moreover, the branch does not
    share any commit history with your `master` branch. You could add another repository
    and fetch all its commits using `git remote add` and `git fetch`. Instead, we
    will simply add a text file to illustrate it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Commit is the only thing in the history that you can verify with the command
    `git log`. If you fetch another repository into the branch, you will see all the
    commits and, more importantly you will have a copy of the repository's history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your commits in place on the orphan branch, it is time to merge
    them into your master branch. However, your first attempt will fail. For example,
    check the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the orphan branch does not share history with the master branch,
    and git will not allow you to merge the branch. It shouldn''t come as a surprise,
    since it is basically what an orphan branch is all about. However, you can still
    merge an orphan branch by allowing unrelated histories to be merged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It is unlikely that you will use orphan branches on a daily basis, but it is
    a strong feature to know when you need to reorganize your code base.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more options in the help files for Git. Just run `git merge --help`
    or `git branch --help` to see what other options are available.
  prefs: []
  type: TYPE_NORMAL
