<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Managing Repositories</h1></div></div></div><p>One of the advantages of using Gitolite is that you do not need to create new repositories manually, set their permissions, and so on. Gitolite does all this for you, based on the contents of a specific file (<code class="literal">conf/gitolite.conf</code>) in the gitolite-admin repository. In this chapter, we will show how you can add new repositories to Gitolite, as well as how to bring in existing repositories in to Gitolite's ambit.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Adding repositories</h1></div></div></div><p>To add a<a id="id98" class="indexterm"/> new<a id="id99" class="indexterm"/> repository, you will need to do the following in your clone of the gitolite-admin repository.</p><p>First, edit the <code class="literal">conf/gitolite.conf</code> file. This file should have some content already, for example:</p><div><pre class="programlisting">
<strong>repo    gitolite-admin</strong>
<strong>    RW+     =   adam</strong>
<strong>repo    testing</strong>
<strong>    RW+     =   @all</strong>
</pre></div><p>This basically says that only the user called <code class="literal">adam</code> has the permission to make changes to the <code class="literal">gitolite-admin</code> repository<a id="id100" class="indexterm"/>, and all users have the permission to make changes to the testing repository.</p><p>To add a new repository, you will need to add a repo line, as well as at least one access control rule. For example:</p><div><pre class="programlisting">
<strong>repo    my-repo-1</strong>
<strong>    RW+     =   adam</strong>
</pre></div><p>This will create a repository called <code class="literal">my-repo-1</code>, making <code class="literal">adam</code> the only user who can read or write it.</p><p>If you do not add an access rule, the repository is not created. For example, if you had the following:</p><div><pre class="programlisting">
<strong>repo    my-repo-1</strong>
<strong>repo    my-repo-2</strong>
<strong>    RW+     =   adam</strong>
</pre></div><p>then the <code class="literal">my-repo-1</code> repository is neither created, not even recognized by Gitolite in any way.</p><p>However, <a id="id101" class="indexterm"/>you can specify more than one repository name in the <code class="literal">repo</code> line, so the following command is perfectly fine:</p><div><pre class="programlisting">
<strong>repo    my-repo-1 my-repo-2</strong>
<strong>    RW+     =   adam</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Adding existing repositories</h1></div></div></div><p>Adding a <a id="id102" class="indexterm"/>repository, as described in the previous section, will create an empty, bare, repository on the server. You can then populate that repository by pushing whatever content you like. This is certainly one way to bring existing content under Gitolite's control, as long as those repositories did not have their own Git hooks in place earlier.</p><p>However, most sites will have several existing repositories that need to be brought under Gitolite's control, and the technique of creating an empty repository and pushing content from a workstation can be really slow, especially if the content is already available on the server. This section will tell you how to do this quickly and easily.</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>It is always advisable to have backups so that you can recover if something unexpected happens while following the procedure described.</p></div></div><p>First, make sure the existing repositories you are looking at are bare repositories. A bare Git repository is a repository that does not have a working tree. You cannot reliably push to a repository that has a working tree attached, so server repositories must always be bare. A bare repository is usually created by passing the <code class="literal">--bare</code> option to the <code class="literal">git init</code> or <code class="literal">git clone</code> commands. A later section in this chapter describes how to convert non-bare repositories to bare repositories.</p><p>Next, move or copy the bare repositories to <code class="literal">$HOME/repositories</code>, which is where Gitolite expects to find all the repositories it is managing. When doing this, make sure the name of the repository ends in <code class="literal">.git</code>.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>In common Git usage, it is merely a convention to name bare repositories with names ending in <code class="literal">.git</code>, while non-bare repositories do not have an extension. With Gitolite however, the trailing <code class="literal">.git</code> is necessary; it is no longer just a convention.</p></div></div><p>Once you have all the repositories in place, run the <code class="literal">gitolite setup</code> command.</p><p>Finally, in <a id="id103" class="indexterm"/>a clone of the gitolite-admin repository, add these repositories to the <code class="literal">conf/gitolite.conf</code> file as described earlier, save the changes, add, commit, and push.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Common problems and troubleshooting</h1></div></div></div><p>You may<a id="id104" class="indexterm"/> need to modify the procedure described<a id="id105" class="indexterm"/> earlier under some circumstances. This section will describe some of the problems that you may find and how to work around them.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec26"/>Ownership and permissions</h2></div></div></div><p>Gitolite<a id="id106" class="indexterm"/> expects that all the files and directories inside <code class="literal">$HOME/repositories</code> are owned by the Gitolite hosting user, and that this user is allowed to write to all of them. If this condition is not met, both Git and Gitolite will be affected.</p><p>The most common reason<a id="id107" class="indexterm"/> for such a condition to be violated is that the administrator has copied some files (such as a bunch of existing repositories perhaps) as root. When files are copied as root, they are not usually given the owner and group ID of the directory in which they are being placed, but that of the original owner or the user executing the copy.</p><p>You can see this by running <code class="literal">ls -alR</code> on the repository in question; if the owner and group of all the files and directories are not <code class="literal">git</code> (the hosting user), then you will need to modify the ownership of that repository.</p><p>To fix this, run the following command: (As in earlier chapters, we assume the Gitolite hosting user is git; if not, please substitute accordingly.)</p><div><pre class="programlisting">
<strong># as root</strong>
<strong>cd ~git</strong>
<strong>chown -R git:git repositories</strong>
<strong>chmod -R u+rwX repositories</strong>
</pre></div><p>If there are no ownership problems, but for some reason you do have permission issues, you can omit the <code class="literal">chown</code> command<a id="id108" class="indexterm"/> and do the rest as <code class="literal">git</code> (that is, you do not need to log in as root).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Converting a non-bare repository to a bare repository</h2></div></div></div><p>A bare repository<a id="id109" class="indexterm"/> is a repository without the working tree attached to it. Instead, the files and directories that, in a non-bare repository<a id="id110" class="indexterm"/>, are contained within the special <code class="literal">.git</code> directory are directly placed in the repository at the top level.</p><p>One way to convert a non-bare repository to a bare repository is to clone it using the<code class="literal"> --bare</code> option. The following command is the most generic way of doing this:</p><div><pre class="programlisting">
<strong>git clone –bare /somewhere/repo ~/repositories/repo.git</strong>
</pre></div><p>However,<a id="id111" class="indexterm"/> this makes a full copy of the source to the target, which might be a problem if the repository is very large. But if the source repository is on the same filesystem as the target, there is a very useful optimization that Git provides, which you can take advantage of. This is affected by adding a <code class="literal">-l</code> option to the <code class="literal">clone</code> command:</p><div><pre class="programlisting">
<strong>git clone –bare -l ~/somewhere/repo ~/repositories/repo.git</strong>
</pre></div><p>The <code class="literal">-l</code> option tells Git to use hardlinks instead of copying the files over to the new repository, and is almost instantaneous, regardless of how big the repository actually is. Since it uses hardlinks (and not symlinks), you are free to delete the source repository after the clone is done; it will not harm the newly created target repository.</p><p>Either way, at this point you will need to copy any hooks that already exist in your repository from the <code class="literal">hooks</code> directory of the source to that of the destination. This is because the <code class="literal">clone</code> method does not carry the hooks over.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Git experts will realize that another way to convert a non-bare repo, say <code class="literal">my-repo</code>, is to promote the <code class="literal">.git</code> directory up one level, renaming it <code class="literal">my-repo.git</code>. That is, by running the command <code class="literal">mv my-repo/.git my-repo.git</code>. At this point, the old <code class="literal">my-repo</code> directory can be deleted. As always, make sure you have backups before deleting anything.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>Gitolite and the update hook</h2></div></div></div><p>Gitolite's access <a id="id112" class="indexterm"/>control mechanism for a push operation involves hooking into Git's <code class="literal">update</code> hook mechanism (see the man page for <code class="literal">githooks</code> to get details on the various hooks that Git provides).</p><p>Therefore, if your existing repository already had an update hook, running the <code class="literal">gitolite setup</code> described previously will wipe out this existing hook and install Gitolite's own update hook in its place.</p><p>Gitolite <em>does</em> provide a mechanism that allows your old <code class="literal">update</code> hook to also run, but it needs to be run by Gitolite. There is a supported mechanism for this called <code class="literal">VREF</code>, which will be described briefly in <a class="link" href="ch07.html" title="Chapter 7. Advanced Access Control and Configuration">Chapter 7</a>, <em>Advanced Access Control and Configuration</em>, and in detail in <a class="link" href="ch10.html" title="Chapter 10. Understanding VREFs">Chapter 10</a>, Understanding <em>VREFs</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Summary</h1></div></div></div><p>This chapter showed you how to add your own repositories, and told you about some common problems that may occur when bringing in existing repositories in to Gitolite's control. The previous chapter has already covered adding users, so we are now ready to start looking at access control. Access control is the reason Gitolite exists, and the next chapter will (finally!) show you some basic access control syntax, rules, and other details.</p></div></body></html>