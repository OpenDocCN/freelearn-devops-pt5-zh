<html><head></head><body>
        

                            
                    <h1 class="header-title">Repository Maintenance</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Pruning remote branches</li>
<li>Running garbage collection manually</li>
<li>Turning off automatic garbage collection</li>
<li>Splitting a repository</li>
<li>Rewriting history – changing a single file</li>
<li>Creating a backup of your repositories as mirror repositories</li>
<li>A quick "how-to" submodule</li>
<li>Subtree merging</li>
<li>Submodule versus subtree merging</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, we'll take a look at various tools used for repository maintenance. We'll look at how we can easily delete branches in the local repository that have been deleted from the remote repository. We'll also see how we can trigger garbage collection and how to turn it off. We'll take a look at how a repository can be split with the <kbd>filter-branch</kbd> command, and how the same command can be used to rewrite the history of a repository. Finally, we'll take a quick look at how to integrate other Git projects into a Git repository as subprojects, with either the submodule functionality or the subtree strategy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pruning remote branches</h1>
                
            
            
                
<p>Often, the development of a software project tracked by Git happens on feature branches, and, as time goes by, an increasing number of feature branches are merged to the mainline. Usually, these feature branches are deleted in the main repository (the origin). However, branches are not automatically deleted from all clones while fetching and pulling request. Git must explicitly be told to delete branches from the local repository that have been deleted from the origin.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>First, we'll set up two repositories and use one of them as a remote for the other. We will use the <kbd>Git-Version-Control-Second-Edition_hello_world_flow_model</kbd> repository, but first we'll clone a repository to a local bare repository:</p>
<pre><strong>$ git clone --bare https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model.git </strong><strong>hello_world_flow_model_remote<br/></strong><strong>Cloning into bare repository 'hello_world_flow_model_remote'...</strong><br/><strong>remote: Counting objects: 51, done.</strong><br/><strong>remote: Total 51 (delta 0), reused 0 (delta 0), pack-reused 51</strong><br/><strong>Unpacking objects: 100% (51/51), done.<br/></strong></pre>
<p>Next, we'll clone the newly cloned repository to a local one with a working directory:</p>
<pre><strong>$ git clone hello_world_flow_model_remote hello_world_flow_model</strong> </pre>
<p>Now, let's delete a couple of merged feature branches in the bare repository:</p>
<pre><strong>$ cd hello_world_flow_model_remote</strong> 
<strong>$ git branch -D feature/continents </strong> 
<strong>$ git branch -D feature/printing </strong> 
<strong>$ git branch -D release/1.0 </strong> 
<strong>$ cd ..</strong> </pre>
<p>Finally, change the directory to your working copy and make sure <kbd>develop</kbd> branch is checked out:</p>
<pre><strong>$ cd hello_world_flow_model</strong> 
<strong>$ git checkout develop</strong> 
<strong>$ git reset --hard origin/develop</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start by listing all of the branches using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch -a</strong> 
<strong>* develop</strong> 
<strong>  remotes/origin/HEAD -&gt; origin/develop</strong> 
<strong>  remotes/origin/develop</strong> 
<strong>  remotes/origin/feature/cities</strong> 
<strong>  remotes/origin/feature/continents</strong> 
<strong>  remotes/origin/feature/printing</strong> 
<strong>  remotes/origin/master</strong> 
<strong>  remotes/origin/release/1.0</strong> </pre>
<ol start="2">
<li>Let's try to fetch or pull and see whether anything happens, using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fetch</strong> 
<strong>$ git pull</strong> 
<strong>Already up to date.</strong> 
<strong>$ git branch -a</strong> 

<strong>* develop</strong> 
<strong>  remotes/origin/HEAD -&gt; origin/develop</strong> 
<strong>  remotes/origin/develop</strong> 
<strong>  remotes/origin/feature/cities</strong> 
<strong>  remotes/origin/feature/continents</strong> 
<strong>  remotes/origin/feature/printing</strong> 
<strong>  remotes/origin/master</strong> 
<strong>  remotes/origin/release/1.0</strong> </pre>
<ol start="3">
<li>The branches are still there, even if they have been deleted in the remote repository. We need to tell Git explicitly to delete the branches that have also been deleted from the remote repository, using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fetch --prune</strong> 
<strong> x [deleted]         (none)     -&gt; origin/feature/continents</strong> 
<strong> x [deleted]         (none)     -&gt; origin/feature/printing</strong> 
<strong> x [deleted]         (none)     -&gt; origin/release/1.0</strong> 
<strong>$ git branch -a</strong> 
<strong>* develop</strong> 
<strong>  remotes/origin/HEAD -&gt; origin/develop</strong> 
<strong>  remotes/origin/develop</strong> 
<strong>  remotes/origin/feature/cities</strong> 
<strong>  remotes/origin/master</strong></pre>
<p>The branches have now also been deleted from our local repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Git simply checks the remote-tracking branches under the remote or origin namespace and removes branches that are not found on the remote any more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are several ways to remove the branches from Git that have been deleted from the master. It can be done while updating the local repository, as we saw with <kbd>git fetch --prune</kbd>, and also with <kbd>git pull --prune</kbd>. It can even be performed with the <kbd>git remote prune origin</kbd> command. This will also remove the branches from Git that are no longer available on the remote, but it will not update remote-tracking branches in the repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running garbage collection manually</h1>
                
            
            
                
<p>When using Git on a regular basis, you might notice that some commands sometimes trigger Git to perform garbage collection and pack loose objects into a pack file (Git's objects storage). The garbage collection and packing of loose objects can also be triggered manually by executing the <kbd>git gc</kbd> command. Triggering <kbd>git gc</kbd> is useful if you have a lot of loose objects. A loose object can, for example, be a blob, a tree, or a commit. As we saw in <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>, <kbd>blob-</kbd>, <kbd>tree-</kbd>, and <kbd>commit</kbd> objects are added to Git's database when we add files and create commits. These objects are first stored as unreachable objects in Git's object storage as single files inside the <kbd>.git/objects</kbd> folder. Eventually, or by manual request, Git packs the loose objects into pack files, which can reduce disk usage. A lot  of objects can become loose after adding many files to Git, for example, when starting a new project or after frequent adds and commits. Running garbage collection will make sure that loose objects are packed, and objects not referred to by any reference or object will be deleted. The latter is useful when you have deleted some branches/commits and want to make sure that the objects referenced by them are also deleted.</p>
<p>Let's see how we can trigger garbage collection and remove some objects from the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>First, we need a repository to perform the garbage collection on. We'll use the same repository as in the previous example:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model.git </strong> 
<strong>$ cd hello_world_flow_model</strong> 
<strong>$ git checkout develop</strong> 
<strong>$ git reset --hard origin/develop</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we'll check the repository for unpacked objects; we can do this with the <kbd>count-objects</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git count-objects</strong> 
<strong>51 objects, 204 kilobytes</strong> </pre>
<ol start="2">
<li>We'll also check for unreachable objects, which are objects that can't be reached from any reference (tag, branch, or other object). The unreachable objects will be deleted when the garbage collection runs. We also check the size of the <kbd>.git</kbd> directory using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fsck --unreachable</strong> 
<strong>Checking object directories: 100% (256/256), done.</strong> 

<strong>$ du -sh .git</strong> 

<strong>292K  .git</strong> <strong># Linux - 1K = 1024 bytes</strong><br/><strong>300K  .git # MacOS - 1K = 1000 bytes</strong></pre>
<ol start="3">
<li>There are no unreachable objects. This is because we just cloned and haven't actually worked in the repository. If we delete the origin remotely, the remote branches (<kbd>remotes/origin/*</kbd>) will be deleted, and we'll lose the reference to some of the objects in the repository; they'll be displayed as unreachable while running <kbd>fsck</kbd> and can be garbage collected:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git remote rm origin</strong> 
<strong>$ git fsck --unreachable</strong> 
<strong>Checking object directories: 100% (256/256), done.</strong> 
<strong>unreachable commit 127c621039928c5d99e4221564091a5bf317dc27</strong> 
<strong>unreachable commit 472a3dd2fda0c15c9f7998a98f6140c4a3ce4816</strong> 
<strong>unreachable blob e26174ff5c0a3436454d0833f921943f0fc78070<br/>unreachable tree f03964e50809d5a0a9d35c208001b141ac36d997</strong> 
<strong>unreachable commit f336166c7812337b83f4e62c269deca8ccfa3675</strong> </pre>
<ol start="4">
<li>We can see that we have some unreachable objects due to the deletion of the remote. Let's try to trigger garbage collection manually:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git gc</strong> 
<strong>Counting objects: 46, done.</strong> 
<strong>Delta compression using up to 8 threads.</strong> 
<strong>Compressing objects: 100% (44/44), done.</strong> 
<strong>Writing objects: 100% (46/46), done.</strong> 
<strong>Total 46 (delta 18), reused 0 (delta 0)</strong> </pre>
<ol start="5">
<li>If we investigate the repository now, we will see the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git count-objects</strong> 
<strong>5 objects, 20 kilobytes</strong> 
<strong>$ git fsck --unreachable</strong> 
<strong>Checking object directories: 100% (256/256), done.</strong> 
<strong>Checking objects: 100% (46/46), done.</strong> 
<strong>unreachable commit 127c621039928c5d99e4221564091a5bf317dc27</strong> 
<strong>unreachable commit 472a3dd2fda0c15c9f7998a98f6140c4a3ce4816</strong> 
<strong>unreachable blob e26174ff5c0a3436454d0833f921943f0fc78070</strong> <br/><strong>unreachable tree f03964e50809d5a0a9d35c208001b141ac36d997
unreachable commit f336166c7812337b83f4e62c269deca8ccfa3675</strong> 
<strong>$ du -sh .git</strong> 
<strong>120K  .git</strong> <strong># Linux<br/>124K  .git # MacOS</strong></pre>
<ol start="6">
<li>The object count is smaller. Git has packed the objects to the pack file stored in the <kbd>.git/objects/pack</kbd> folder. The size of the repository is also smaller, as Git compresses and optimizes the objects in the pack file. However, there are still some unreachable objects left. This is because objects will only be deleted if they are older than what is specified in the <kbd>gc.pruneexpire</kbd> configuration option, which defaults to two weeks (<kbd>config value: 2.weeks.ago</kbd>). We can override the default or configured option by running the <kbd>--prune=now</kbd> option:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git gc --prune=now</strong> 
<strong>Counting objects: 46, done.</strong> 
<strong>Delta compression using up to 8 threads.</strong> 
<strong>Compressing objects: 100% (26/26), done.</strong> 
<strong>Writing objects: 100% (46/46), done.</strong> 
<strong>Total 46 (delta 18), reused 46 (delta 18)</strong></pre>
<ol start="7">
<li>Investigating the repository gives the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git count-objects</strong> 
<strong>0 objects, 0 kilobytes</strong> 
<strong>$ git fsck --unreachable</strong> 
<strong>Checking object directories: 100% (256/256), done.</strong> 
<strong>Checking objects: 100% (46/46), done.</strong> 
<strong>$ du -sh .git</strong> 
<strong>100K  .git</strong> <strong># Linux<br/>104K  .git # MacOS</strong></pre>
<p>The unreachable objects have been deleted, there are no loose objects, and the repository size is smaller now that the objects have been deleted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>git gc</kbd> command optimizes the repository by compressing file revisions and deleting objects that there are no references to. The objects can be commits, and so on. On an abandoned (deleted) branch, blobs from invocations of git add, commits discarded/redone with <kbd>git commit --amend</kbd>, or other commands can leave objects behind. Objects are, by default, already compressed with <kbd>zlib</kbd> when they are created and, when moved into the pack file, Git makes sure to only store the necessary changes. For example, if you change only a single line in a large file, storing the entire file in the pack file again would waste a bit of space. Instead, Git stores the latest file as a whole in the pack file and only the delta for the older version. This is pretty smart, as you are more likely to require the latest version of the file, and Git doesn't have to do delta calculations for this. This might seem like a contradiction to the information from <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>, where we learned that Git stores snapshots and not deltas. However, remember how the snapshot is made. Git hashes all of the file content in blobs, makes <kbd>tree</kbd> and <kbd>commit</kbd> objects, and the commit object describes the full tree state with the <kbd>root-tree sha-1</kbd> hash. Storing objects inside the pack-files has no effect on the computation of the tree state. When you check out an earlier version of commit, Git makes sure the sha-1 hashes match the branch, commit, or tag you requested.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Turning off automatic garbage collection</h1>
                
            
            
                
<p>The automatic triggering of garbage collection can be turned off so that it will not run unless manually triggered. This can be useful if you are searching the repository for a lost commit/file and want to make sure that it is not being garbage collected while searching (running Git commands).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the <kbd>Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model</kbd> repository again for this example:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model.git</strong> 
<strong>Cloning into 'Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model'...</strong> 
<strong>remote: Reusing existing pack: 51, done.</strong> 
<strong>remote: Total 51 (delta 0), reused 0 (delta 0)</strong> 
<strong>Unpacking objects: 100% (51/51), done.</strong> 
<strong>Checking connectivity... done.</strong> 
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model</strong> 
<strong>$ git checkout develop</strong> 
<strong>Already on 'develop'</strong> 
<strong>Your branch is up-to-date with 'origin/develop'.</strong> 
<strong>$ git reset --hard origin/develop</strong> 
<strong>HEAD is now at 2269dcf Merge branch 'release/1.0' into develop</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>To switch off automatic garbage collection from being triggered, we need to set the <kbd>gc.auto</kbd> configuration to 0. First, we'll check the existing setting, and then we can set it and verify the configuration using the following commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config gc.auto # exit code is 1 when not set<br/>$ echo $?</strong><br/><strong>1
$ git config gc.auto 0</strong> 
<strong>$ git config gc.auto</strong> 
<strong>0</strong></pre>
<ol start="2">
<li>Now we can try to run <kbd>git gc</kbd> with the <kbd>--auto</kbd> flag, as it will be called when normally triggered from an other command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git gc --auto</strong></pre>
<ol start="3">
<li>As expected, nothing happens, as the configuration disables automatic garbage collection. We can still trigger it manually though (without the <kbd>--auto</kbd> flag):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git gc</strong> 
<strong>Counting objects: 51, done.</strong> 
<strong>Delta compression using up to 8 threads.</strong> 
<strong>Compressing objects: 100% (49/49), done.</strong> 
<strong>Writing objects: 100% (51/51), done.</strong> 
<strong>Total 51 (delta 23), reused 0 (delta 0)</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Splitting a repository</h1>
                
            
            
                
<p>Sometimes, a project tracked with Git is not one logical project, but consists of several projects. This may be fully intentional and there is nothing wrong with that, but there can also be cases where projects tracked in the same Git repository really should belong to two different repositories. You can imagine a project where the code base grows and, at some point in time, one of the subprojects could have value as an independent project. This can be achieved by splitting the subfolders and/or files that contain the project that should have its own repository with the full history of commits touching the files and/or folders.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this example, we'll use the JGit repository, so we'll have some history to filter through. The subfolders we split into are not really projects, but serve well as an example for this exercise.</p>
<ol>
<li>First, clone the JGit repository and create local branches of the remote ones using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git clone https://git.eclipse.org/r/jgit/jgit</strong> 
<strong>Cloning into 'jgit'...</strong> 
<strong>remote: Counting objects: 98, done</strong><br/><strong>remote: Total 95247 (delta 0), reused 95247 (delta 0)</strong><br/><strong>Receiving objects: 100% (95247/95247), 41.25 MiB | 1.91 MiB/s, done.</strong><br/><strong>Resolving deltas: 100% (41334/41334), done.</strong>
<strong>$ cd jgit</strong> 
<strong>$ git checkout master</strong> 
<strong>Already on 'master'</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong></pre>
<ol start="2">
<li>Save the name of the current branch in a variable named <kbd>current</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ current=$(git rev-parse --symbolic-full-name --abbrev-ref HEAD)</strong> </pre>
<ol start="3">
<li>In the following step, we create local branches from all the remote branches in the repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ for br in $(git branch -a | grep -v $current | grep remotes | grep -v HEAD);</strong> 
<strong>  do</strong> 
<strong>    git branch ${br##*/} $br;</strong> 
<strong>  done</strong> 

<strong>Branch stable-0.10 set up to track remote branch stable-0.10 from origin.</strong> 
<strong>Branch stable-0.11 set up to track remote branch stable-0.11 from origin.</strong> 
<strong>Branch stable-0.12 set up to track remote branch stable-0.12 from origin.</strong> 
<strong>...</strong> </pre>
<p style="padding-left: 60px">First, we filter the branches. From all the branches (<kbd>git branch -a</kbd>), we exclude branches that match the <kbd>$current</kbd> variable somewhere in the name (<kbd>grep -v $current</kbd>). Then, we include only the branches that match the remote (<kbd>grep remotes</kbd>). Finally, we exclude all branches with <kbd>HEAD</kbd> (<kbd>grep -v HEAD</kbd>). For each of the branches (<kbd>$br</kbd>), we create a local branch with the name given after the last "<kbd>/</kbd>" in the full name of the branch (<kbd>git branch ${br##*/} $br</kbd>). For example, the branch <kbd>remotes/origin/stable-0.10</kbd> becomes the local branch <kbd>stable-0.10</kbd>.</p>
<ol start="4">
<li>Now, we'll prepare a short script that will delete everything apart from the input to the shell script from the Git index. Save the following to the <kbd>clean-tree</kbd> file in the folder that contains the JGit repository (not the repository itself):</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong> 
<strong># Clean the tree for unwanted dirs and files</strong> 
<strong># $1 Files and dirs to keep</strong> 

<strong>clean-tree () {</strong> 
<strong>  # Remove everything but $1 from the git index/staging area</strong> 
<strong>  for f in $(git ls-files | grep -v -E "$1" | grep -o -E "^[^/\"]+" | sort -u); do</strong> 
<strong>    git rm -rq --cached --ignore-unmatch $f</strong> 
<strong>  done</strong> 
<strong>}</strong> 
<br/><strong>clean-tree $1</strong> </pre>
<p style="padding-left: 60px">The short script filters all the files currently in the staging area (<kbd>git ls-files</kbd>), excluding the ones that match the input (<kbd>grep -v -E "$1"</kbd>). It lists only the first part of their <kbd>name/path</kbd> up to the first "<kbd>/</kbd>" (<kbd>grep -o -E "^[^/\"]"</kbd>), and finally sorts them by unique entries (<kbd>sort -u</kbd>). The entries in the remaining list (<kbd>$f</kbd>) are removed from the staging of Git (<kbd>git rm -rq --cached --ignore-unmatch $f</kbd>). The <kbd>--cached</kbd> option tells Git to remove them from the staging area and <kbd>--ignore-unmatched</kbd> tells Git not to fail if the file does not exist in the staging area. The <kbd>-rq</kbd> option is recursive and quiet respectively.</p>
<p>The staging area contains all the files tracked by Git in the last snapshot (commit) and files (modified or new) you have added with <kbd>git add</kbd>. However, you only see differences between the latest commit and the staging area when you run <kbd>git status</kbd>, along with differences between the working tree and the staging area.</p>
<ol start="5">
<li>Make the file executable using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ chmod +x clean-tree</strong> </pre>
<ol start="6">
<li>Now we are ready to split out a subpart of the repository.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we'll decide which folders and files to keep in the new repository; we'll delete everything from the repository except those files. We'll store the files and folders to be kept in a string separated by <kbd>|</kbd> so that we can feed it to <kbd>grep</kbd> as a regular expression, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>keep="org.eclipse.jgit.http|LICENSE|.gitignore|README.md|.gitattributes"</strong> </pre>
<ol start="2">
<li>Now we are ready to start the conversion of the repository. We'll use the <kbd>git filter-branch</kbd> command, which can rewrite the entire history of the repository; just what we need for this task.</li>
</ol>
<p>Always remember to make sure you have a backup of the repository you are about to run <kbd>git filter-branch</kbd> on, in case something goes wrong.</p>
<ol start="3">
<li>We'll use the <kbd>--index-filter</kbd> option to filter the branch. The option allows us to rewrite the index or staging area just before each commit is recorded, and we'll do this with the <kbd>clean-tree</kbd> script we created previously. We'll also preserve tags using <kbd>cat</kbd> as the <kbd>tag-name-filter</kbd>. We'll perform the rewrite on all branches and remember to use the absolute path to the clean-tree script:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git filter-branch --prune-empty  --index-filter "\"/absolute/path/to/clean-tree\" \"$keep\"" --tag-name-filter cat -- --all</strong> 
<strong>...</strong>
<strong>Rewrite 720734983bae056955bec3b36cc7e3847a0bb46a (13/3051)</strong> 
<strong>Rewrite 6e1571d5b9269ec79eadad0dbd5916508a4fee82 (23/3051)</strong> 
<strong>Rewrite 2bfe561f269afdd7f4772f8ebf34e5e25884942b (37/3051)</strong> 
<strong>Rewrite 2086fdaedd5e71621470865c34ad075d2668af99 (60/3051)</strong> 
<strong>...</strong> </pre>
<ol start="4">
<li>The rewrite takes a bit of time, as all commits need to be processed. Once the rewrite is done, we can see that everything is deleted, except the files and folders we wanted to keep:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git ls-tree --abbrev HEAD</strong> 
<strong>100644 blob f57840b7e .gitattributes</strong><br/><strong>100644 blob 3679a3365 .gitignore</strong><br/><strong>100644 blob 1b85c6466 LICENSE</strong><br/><strong>100644 blob 54133e1d3 README.md</strong><br/><strong>040000 tree 2edd8e193 org.eclipse.jgit.http.apache</strong><br/><strong>040000 tree cda583881 org.eclipse.jgit.http.server</strong><br/><strong>040000 tree daace995c org.eclipse.jgit.http.test</strong></pre>
<ol start="5">
<li>The cleanup isn't done just yet. <kbd>git filter-branch</kbd> saves all the original references, branches and tags, under the <kbd>refs/original</kbd> namespace in the repository. After verification, the new history looks good, and we can get rid of the original <kbd>refs</kbd>, as these point to objects that are not in our current history and take up a lot of disk space. We'll delete all the original refs and run the garbage collector to clear the repository of old objects:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ du -sh .git</strong> 
<strong> 53M  .git # MacOS</strong></pre>
<ol start="6">
<li>Delete original references, <kbd>refs/original</kbd>, and remove old objects with <kbd>git gc</kbd>, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git for-each-ref --format="%(refname)" refs/original/ | xargs -n 1 git update-ref -d</strong> 
<strong>$ git reflog expire --expire=now --all</strong> 
<strong>$ git gc --prune=now</strong> 
<strong>Counting objects: 96863, done.</strong><br/><strong>Delta compression using up to 4 threads.</strong><br/><strong>Compressing objects: 100% (28811/28811), done.</strong><br/><strong>Writing objects: 100% (96863/96863), done.</strong><br/><strong>Total 96863 (delta 42589), reused 94395 (delta 41334) </strong></pre>
<ol start="7">
<li>Check the size of the repository after garbage collection:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ du -sh .git</strong> 
<strong>44M  .git</strong> <strong># MacOS</strong></pre>
<ol start="8">
<li>The repository is now clean of all old objects, the size has been reduced, and the history is preserved for the files and directories we listed to keep.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>git filter-branch</kbd> command has different filter options depending on what needs to be done when rewriting the repository. In this example, where we are only removing files and folders from the repository; the <kbd>index-filter</kbd> is highly usable, as it allows us to rewrite the index just before recording a commit in the database without actually checking out the tree on disk, thereby saving a lot of disk I/O. The <kbd>clean-tree</kbd> script we prepared previously is then used to remove the unwanted files and folders from the index. First, we list the content of the index and filter the files and folders we want to keep. Then, we remove the remaining files and folders (<kbd>$f</kbd>) from the index with the following command:</p>
<pre><strong>git rm -rq --cached --ignore-unmatch $f</strong> </pre>
<p>The <kbd>--cached</kbd> option tells Git to remove the index from files, and the <kbd>-rq</kbd> option tells it to remove <kbd>recursive (r)</kbd> option and be quiet (<kbd>q</kbd>). Finally, the <kbd>--ignore-unmatch</kbd> option is used so that <kbd>git rm</kbd> will not exit with an error if it tries to remove a file that is not in the index.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are many more filters for <kbd>git filter-branch</kbd>; the most common ones and their use cases are as follows:</p>
<ul>
<li><kbd>env-filter</kbd>: This filter is used to modify the environment where commits are recorded. This is particularly useful when rewriting author and committer information.</li>
<li><kbd>tree-filter</kbd>: The <kbd>tree-filter</kbd> is used to rewrite the tree. This is useful if you need to add or modify files in the tree, for example, to remove sensitive data from a repository.</li>
<li><kbd>msg-filter</kbd>: This filter is used to update the commit message.</li>
<li><kbd>subdirectory-filter</kbd>: This filter can be used if you want to extract a single subdirectory to a new repository and keep the history of that subdirectory. The subdirectory will be the root of the new repository.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Rewriting history – changing a single file</h1>
                
            
            
                
<p>In this example, we'll see how we can use Git <kbd>filter-branch</kbd> to remove sensitive data from a file throughout the repository history.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For simplicity, we'll use a very simple example repository. It contains a few files. One of them is .credentials, which contains a username and password. Start by cloning the repository and changing the directory, as shown in the following command:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_Remove-Credentials.git</strong> 
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_Remove-Credentials</strong> </pre>
<p>Before proceeding, you can take a look at the content of the repository using <kbd>ls</kbd> and examine the history with <kbd>git log</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>As we need to modify a file when rewriting the history of this repository, we'll use the <kbd>tree-filter</kbd> option to filter the branch. The <kbd>.credentials</kbd> file looks as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>username = foobar</strong>
<strong>password = verysecret</strong> </pre>
<ol start="2">
<li>All we need to do is remove everything after the equals sign on each line of the file. We can use the following <kbd>sed</kbd> command to do this:</li>
</ol>
<pre style="padding-left: 60px"><strong>sed -i '' -e 's/^\(.*=\).*$/\1/'</strong> </pre>
<ol start="3">
<li>We can now run the filter branch with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git filter-branch --prune-empty  --tree-filter "test -f .credentials &amp;&amp; sed -i '' -e 's/^\(.*=\).*$/\1/' .credentials || true" -- --all</strong> </pre>
<ol start="4">
<li>If we look at the file now, we can see that the username and password are gone:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cat .credentials</strong> 
<strong>username =</strong> 
<strong>password =</strong> </pre>
<ol start="5">
<li>As we saw in the previous example, we still need to clean up after  <kbd>filter-branch</kbd>, by deleting original references, expiring the <kbd>reflog</kbd>, and triggering garbage collection. But, at this point, you can compare the content and commit history of the repository. </li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>For each commit in the repository, Git will check the content of that commit and run <kbd>tree-filter</kbd>. If the filter fails with a non-zero exit code, <kbd>filter-branch</kbd> will fail. Therefore, it is important to remember to handle cases where <kbd>tree-filter</kbd> might fail. This is the reason why the previous <kbd>tree-filter</kbd> checks whether the <kbd>.credentials</kbd> file exists, runs the <kbd>sed</kbd> command if it does, and otherwise returns true to continue the <kbd>filter-branch</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a backup of your repositories as mirror repositories</h1>
                
            
            
                
<p>Even though Git is distributed and every clone is essentially a backup, there are some tricks that can be useful when backing up Git repositories. A normal Git repository has a working copy of the files it tracks and the full history of the repository in the <kbd>.git</kbd> folder of that repository. The repositories on the server, the ones you push to and pull from, will usually be bare repositories. A bare repository is a repository without a working copy. Roughly, it is just the <kbd>.git</kbd> folder of a normal repository. A mirror repository is almost the same as a bare repository, except it fetches all the references under <kbd>refs/*</kbd>, whereas a bare repository only fetches the references that fall under <kbd>refs/heads/*</kbd>. We'll now take a closer look at a normal, a bare, and a mirror clone of the JGit repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll start by creating three clones of the JGit repository: a normal, a bare, and a mirror clone. When we create the first clone, we can use that as a reference repository for the other clones. In this way, we can share the objects in the database, and we don't have to transfer the same data three times:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit</strong> 
<strong>$ git clone --reference jgit --bare https://git.eclipse.org/r/jgit/jgit</strong> 
<strong>$ git clone --mirror --reference jgit https://git.eclipse.org/r/jgit/jgit jgit.mirror</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>One of the differences between a normal repository and a bare or mirror one is that there are no remote branches in a bare repository. All the branches are created locally. We can see this in the three repositories by listing the branches with the <kbd>git branch</kbd> command as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd jgit</strong> 
<strong>$ git branch</strong> 
<strong>* master</strong> 
<strong>$ cd ../jgit.git # or cd ../jgit.mirror</strong> 
<strong>$ git branch</strong> 
<strong>* master</strong> 
<strong>  stable-0.10</strong> 
<strong>  stable-0.11</strong> 
<strong>  stable-0.12</strong> 
<strong>...</strong> </pre>
<ol start="2">
<li>To see the difference between the bare and mirror repositories, we need to list the different refspecs fetches and the different <kbd>refs</kbd> namespaces. List the fetch <kbd>refspec</kbd> of origin in the mirror repository (<kbd>jgit.mirror</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ../jgit.mirror<br/>$ git config remote.origin.fetch</strong> 
<strong>+refs/*:refs/*</strong> </pre>
<ol start="3">
<li>List the different <kbd>refs</kbd> namespaces in the mirror repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show-ref | cut -f2 -d " " | cut -f1,2 -d / | sort -u</strong> 
<strong>refs/cache-automerge</strong> 
<strong>refs/changes</strong> 
<strong>refs/heads</strong> 
<strong>refs/meta</strong> 
<strong>refs/notes</strong> 
<strong>refs/tags</strong> </pre>
<ol start="4">
<li>There is no explicit <kbd>refspec</kbd> fetch in the configuration for origin in the bare repository (<kbd>jgit.git</kbd>). When no configuration entry is found, Git uses the default <kbd>refspec</kbd> fetch, as it does in a normal repository. We can check the remote URL of origin using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ../jgit.git<br/>$ git config remote.origin.url</strong> 
<strong>https://git.eclipse.org/r/jgit/jgit</strong> </pre>
<ol start="5">
<li>List the different <kbd>refs</kbd> namespaces in the bare repository using the following command and see the difference:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show-ref | cut -f2 -d " " | cut -f1,2 -d / | sort -u</strong> 
<strong>refs/heads</strong> 
<strong>refs/tags</strong> </pre>
<ol start="6">
<li>Finally, we can list the <kbd>refspec</kbd> fetch and <kbd>refs</kbd> namespaces for the normal repository (<kbd>jgit</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ../jgit <br/>$ git config remote.origin.fetch</strong> 
<strong>+refs/heads/*:refs/remotes/origin/*</strong> 
<strong>$ git show-ref | cut -f2 -d " " | cut -f1,2 -d / | sort -u</strong> 
<strong>refs/heads</strong> 
<strong>refs/remotes</strong> 
<strong>refs/tags</strong> </pre>
<ol start="7">
<li>The mirror repository has four ref namespaces not found in either the normal or the bare repositories: <kbd>refs-cache-automerge</kbd>, <kbd>changes</kbd>, <kbd>meta</kbd>, and <kbd>notes</kbd>. The normal repository is the only one that has the <kbd>refs/remote</kbd> namespace.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The normal and bare repositories are pretty similar, only the mirror one sticks out. This is due to the <kbd>refspec</kbd> fetch on the mirror repository, <kbd>+refs/*:refs/*</kbd>, which will fetch all <kbd>refs</kbd> from the remote and not just <kbd>refs/heads/*</kbd> and <kbd>refs/tags/*</kbd> as a normal repository (and a <kbd>bare</kbd> repository) does. The many different <kbd>ref</kbd> namespaces on the JGit repository is because the JGit repository is managed by Gerrit Code Review. It uses different namespaces for repository-specific content, such as change branches for all commits submitted for code review, and metadata on code review score.</p>
<p>The <kbd>mirror</kbd> repositories are ideal when you would like a quick way to back up a Git repository. It ensures that you have everything included without the need for additional access than the Git access to the machine that hosts the Git repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The repositories on GitHub store extra information in some refs namespaces. If a repository has had a pull request made, the pull request will be recorded in the <kbd>refs/pull/*</kbd> namespace. Let's look at this in the following example:</p>
<pre><strong>$ git clone --mirror git@github.com:jenkinsci/extreme-feedback-plugin.git</strong> 
<strong>$ cd extreme-feedback-plugin.git</strong> 
<strong>$ git show-ref | cut -f2 -d " " | cut -f1,2 -d / | sort -u</strong> 
<strong>refs/heads</strong> 
<strong>refs/meta</strong> 
<strong>refs/pull</strong> 
<strong>refs/tags</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">A quick "how-to" submodule</h1>
                
            
            
                
<p>When working on a software project, you sometimes find yourself in a situation where you need to use another project as a part of your project. This other project can be anything, from another project you are developing to a third-party library. You want to keep projects separate, even though you need to use one project for the other. Git has a mechanism for this kind of project dependency, called submodules. The basic idea is that you can clone another Git repository into your project as a subdirectory, but keep the commits from the two repositories separate, as shown in the following diagram:</p>
<div><img class="alignnone size-full wp-image-338 image-border" src="img/272fa5ac-8cd1-4483-8660-0637a3408093.png" style="width:41.33em;height:17.83em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll start by cloning an example repository to be used as the super project:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_Super.git</strong> 
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_Super</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol start="1">
<li>We'll add a subproject, <kbd>lib_a</kbd>, to the super project as a Git submodule:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git submodule add https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_lib_a.git lib_a</strong> 
<strong>Cloning into 'lib_a'...</strong> 
<strong>remote: Counting objects: 18, done.</strong> 
<strong>remote: Compressing objects: 100% (14/14), done.</strong> 
<strong>remote: Total 18 (delta 4), reused 17 (delta 3)</strong> 
<strong>Receiving objects: 100% (18/18), done.</strong> 
<strong>Resolving deltas: 100% (4/4), done.</strong> 
<strong>Checking connectivity... done.</strong> </pre>
<ol start="2">
<li>Let's check <kbd>git status</kbd> using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong> 

<strong>Changes to be committed:</strong> 
<strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>  

<strong>  new file:   .gitmodules</strong> 
<strong>  new file:   lib_a</strong> </pre>
<ol start="3">
<li>We can take a closer look at the two files in the Git index; <kbd>.gitmodules</kbd> is a regular file, so we can use <kbd>cat</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cat .gitmodules</strong> 
<strong>[submodule "lib_a"]</strong> 
<strong>  path = lib_a</strong> 
<strong>  url = https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_lib_a.git</strong> 
<strong>$ git diff --cached lib_a</strong> 
<strong>diff --git a/lib_a b/lib_a</strong> 
<strong>new file mode 160000</strong> 
<strong>index 0000000..0d96e7c</strong> 
<strong>--- /dev/null</strong> 
<strong>+++ b/lib_a</strong> 
<strong>@@ -0,0 +1 @@</strong> 
<strong>+Subproject commit 0d96e7cfc4d4db64002e63af0f7325d33bdaf84f</strong></pre>
<p style="padding-left: 60px">The <kbd>.gitmodules</kbd> file, as above, contains information about all the submodules registered in the repository. The <kbd>lib_a</kbd> file stores which commit the submodule's <kbd>HEAD</kbd> is pointing to when added to the super project. Whenever the submodule is updated with new commits (created locally or fetched), the super project will show the submodule as having changed while running <kbd>git status</kbd>. If the changes to the submodule can be accepted, the submodule revision in the super project is updated by adding the submodule file and committing this to the super project.</p>
<ol start="4">
<li>We'll update the submodule, <kbd>lib_a</kbd>, to the latest change on the develop branch using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd lib_a</strong> 
<strong>$ git checkout develop</strong> 
<strong>Branch develop set up to track remote branch develop from origin by rebasing.</strong> 
<strong>Switched to a new branch 'develop'</strong> 
<strong>$ cd ..</strong> 
<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong> 
<strong>  (use "git push" to publish your local commits)</strong> 

<strong>Changes not staged for commit:</strong> 
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong> 
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong> 

<strong>  modified:   lib_a (new commits)</strong> 

<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong> </pre>
<ol start="5">
<li>Let's just check whether there are any updates to the submodule:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git submodule update</strong> 
<strong>Submodule path 'lib_a': checked out '0d96e7cfc4d4db64002e63af0f7325d33bdaf84f'</strong> </pre>
<ol start="6">
<li>Oops! Now we actually reset our submodule to the state described in the file for that submodule. We need to switch to the submodule again, check develop, and this time create a commit in the super repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd lib_a</strong> 
<strong>$ git status</strong> 
<strong>HEAD detached at 0d96e7c</strong> 
<strong>nothing to commit, working directory clean</strong> 
<strong>$ git checkout develop</strong> 
<strong>Previous HEAD position was 0d96e7c... Fixes book title in README</strong> 
<strong>Switched to branch 'develop'</strong> 
<strong>Your branch is up-to-date with 'origin/develop'.</strong> 
<strong>$ cd ..</strong> 
<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is ahead of 'origin/master' by 1 commit.</strong> 
<strong>  (use "git push" to publish your local commits)</strong> 

<strong>Changes not staged for commit:</strong> 
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong> 
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong> 

<strong>  modified:   lib_a (new commits)</strong> 

<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong> 
<strong>$ git add lib_a</strong> 
<strong>$ git commit -m 'Updated lib_a to newest version'</strong> 
<strong>[master 4d371bb] Updated lib_a to newest version</strong> 
<strong> 2 files changed, 4 insertions(+)<br/> create mode 100644 .gitmodules<br/> create mode 160000 lib_a</strong> </pre>
<p style="padding-left: 60px">Notice that, by default, the submodule is in a detached head state, which means that <kbd>HEAD</kbd> is pointing directly to a commit instead of a branch. You can still edit the submodule and record commits; however, if you perform a submodule update in the super repository without first committing a new submodule state, your changes can be hard to find. Always remember to check out or create a branch while switching to a submodule to work on. If so, you can just check out the branch again and get your changes back. Since Git Version 1.8.2, it has been possible to make submodules track a branch rather than a single commit. Git 1.8.2 was released on March 13, 2013, and you can check your version by running <kbd>git --version</kbd>.</p>
<ol start="7">
<li>To make Git track the branch of a submodule rather than a specific commit, we need to record the name of the branch we want to track. This is done in the <kbd>.gitmodules</kbd> file for the submodule; here, we'll use the stable branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config -f .gitmodules submodule.lib_a.branch stable</strong> 
<strong>$ cat .gitmodules</strong> 
<strong>[submodule "lib_a"]</strong> 
<strong>  path = lib_a</strong></pre>
<pre style="padding-left: 60px"><strong>  url = https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_lib_a.git</strong> 
<strong>  branch = stable</strong> </pre>
<ol start="8">
<li>We can now add and commit the submodule, and then try to update it using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add .gitmodules</strong> 
<strong>$ git commit -m 'Make lib_a module track its stable branch'</strong> 
<strong>[master bf9b9ba] Make lib_a module track its stable branch</strong> 
<strong> 1 file changed, 1 insertion(+)</strong> 
<strong>$ git submodule update --remote</strong> 
<strong>Submodule path 'lib_a': checked out '8176a16db21a48a0969e18a51f2c2fb1869418fb'</strong> 
<strong>$ git status</strong> 
<strong>On branch master</strong> 
<strong>Your branch is ahead of 'origin/master' by 2 commits.</strong> 
<strong>  (use "git push" to publish your local commits)</strong> 

<strong>Changes not staged for commit:</strong> 
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong> 
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong> 

<strong>  modified:   lib_a (new commits)</strong> 

<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong> </pre>
<p>The submodule is still in the detached <kbd>HEAD</kbd> state. However, when updating the submodule with <kbd>git submodule update --remote</kbd>, changes from the submodule's remote repository will be fetched and the submodule will be updated to the latest commit on the branch it is tracking. We still need to record a commit to the super repository, specifying the state of the submodule.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>When you are cloning a repository that contains one or more submodules, you need to explicitly fetch them after the clone. We can try this with our newly created submodule repository:</p>
<pre><strong>$ git clone super super_clone</strong> 
<strong>Cloning into 'super_clone'...</strong> 
<strong>done.</strong></pre>
<p>Now, initialize and update the submodules:</p>
<pre><strong>$ cd super_clone</strong> 
<strong>$ git submodule init</strong> 
<strong>Submodule 'lib_a' (https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_lib_a.git) registered for path 'lib_a'</strong> 
<strong>$ git submodule update --remote</strong> 
<strong>Cloning into 'lib_a'...</strong> 
<strong>remote: Counting objects: 18, done.</strong> 
<strong>remote: Compressing objects: 100% (14/14), done.</strong> 
<strong>remote: Total 18 (delta 4), reused 17 (delta 3)</strong> 
<strong>Receiving objects: 100% (18/18), done.</strong> 
<strong>Resolving deltas: 100% (4/4), done.</strong> 
<strong>Checking connectivity... done.</strong> 
<strong>Submodule path 'lib_a': checked out '8176a16db21a48a0969e18a51f2c2fb1869418fb'</strong> </pre>
<p>The repository is ready for development!</p>
<p>When cloning the repository, the submodules can be initialized and updated directly after the clone if the <kbd>--recursive</kbd> or <kbd>--recurse-submodules</kbd> option is given.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Subtree merging</h1>
                
            
            
                
<p>An alternative to submodules is subtree merging. Subtree merging is a strategy that can be used when performing merges with Git. The strategy is useful when merging a branch (or, as we'll see in this recipe, another project) into a subdirectory of a Git repository instead of the root directory. When using the subtree merge strategy, the history of the subproject is joined with the history of the super project, while the subproject's history can be kept clean, except for commits intended to go upstream.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the same repositories as in the last recipe, and we'll reclone the super project to get rid of the submodule setup:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_Super.git</strong>
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition_Super</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>We'll add the subproject as a new remote and fetch the history:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git remote add lib_a https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_lib_a.git</strong>
<strong>$ git fetch lib_a</strong> 
<strong>warning: no common commits</strong> 
<strong>remote: Reusing existing pack: 18, done.</strong> 
<strong>remote: Total 18 (delta 0), reused 0 (delta 0)</strong> 
<strong>Unpacking objects: 100% (18/18), done.</strong> 
<strong>From https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_lib_a.git</strong> 
<strong> * [new branch]      develop    -&gt; lib_a/develop</strong> 
<strong> * [new branch]      master     -&gt; lib_a/master</strong> 
<strong> * [new branch]      stable     -&gt; lib_a/stable</strong> </pre>
<ol start="2">
<li>We can now create a local branch, <kbd>lib_a_master</kbd>, which points to the same commit as the master branch in lib a (<kbd>lib_a/master</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b lib_a_master lib_a/master</strong> 
<strong>Branch lib_a_master set up to track remote branch master from lib_a by rebasing.</strong> 
<strong>Switched to a new branch 'lib_a_master'</strong> </pre>
<ol start="3">
<li>We can check the content of our working tree using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ls</strong> 
<strong>README.md  a.txt</strong></pre>
<ol start="4">
<li>If we switch back to the <kbd>master</kbd> branch, we should see the content of the super repository in our directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout master</strong> 
<strong>Switched to branch 'master'</strong> 
<strong>Your branch is up-to-date with 'origin/master'.</strong> 
<strong>$ ls</strong> 
<strong>README.md  super.txt</strong> </pre>
<ol start="5">
<li>Git changes branches and populates the working directory as normal, even though the branches are originally from two different repositories. Now, we want to merge the history from <kbd>lib_a</kbd> into a subdirectory. First, we prepare a merge commit by merging with the <kbd>ours</kbd> strategy and make sure the commit isn't completed (we need to bring in all the files):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ </strong><strong>git merge -s ours --no-commit --allow-unrelated-histories lib_a_master</strong> 
<strong>Automatic merge went well; stopped before committing as requested</strong> </pre>
<p style="padding-left: 60px">In short, what the <kbd>ours</kbd> strategy tells Git to do is the following: merge in this branch, but keep the resulting tree the same as the tree on the tip of this branch. So, the branch is merged, but all the changes it introduced are discarded. In our previous command line, we also passed the <kbd>--no-commit</kbd> option. This option stops Git from completing the merge, but leaves the repository in a merging state. We can now add the content of the <kbd>lib_a</kbd> repository to the <kbd>lib_a</kbd> folder in the repository root. We do this with <kbd>git read-tree</kbd> to make sure the two trees are exactly the same, as follows:</p>
<pre style="padding-left: 60px"><strong>$ git read-tree --prefix=lib_a/ -u lib_a_master</strong> </pre>
<ol start="6">
<li>Our current directory structure looks as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ tree</strong> 
<strong>.</strong> 
<strong>|-- README.md</strong> 
<strong>|-- lib_a</strong> 
<strong>|   |-- README.md</strong> 
<strong>|   '-- a.txt</strong> 
<strong>'-- super.txt</strong> </pre>
<ol start="7">
<li>It is time to conclude the merge commit we started using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit -m 'Initial add of lib_a project'</strong> 
<strong>[master 5066b7b] Initial add of lib_a project</strong></pre>
<p style="padding-left: 60px">Now, the subproject is added. Next, we'll see how we can update the super project with new commits from the subproject and how to copy commits made in the super project to the subproject.</p>
<ol start="8">
<li>We need to add and commit a few changes to the super project using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "Lib_a included!" &gt;&gt; super.txt</strong> 
<strong>$ git add super.txt</strong> 
<strong>$ git commit -m "Update super.txt"</strong> 
<strong>[master 83ef9a4] Update super.txt</strong> 
<strong> 1 file changed, 1 insertion(+)</strong> </pre>
<ol start="9">
<li>Changes are made to the subproject and committed in the super project:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "The b file in lib_a" &gt;&gt; lib_a/b.txt</strong> 
<strong>$ git add lib_a/b.txt</strong> 
<strong>$ git commit -m "[LIB_A] Enhance lib_a with b.txt"</strong> 
<strong>[master debe836] [LIB_A] Enhance lib_a with b.txt</strong> 
<strong> 1 file changed, 1 insertion(+)</strong> 
<strong> create mode 100644 lib_a/b.txt</strong> </pre>
<p style="padding-left: 60px">The current history looks like the following screenshot:</p>
<div><img class="alignnone size-full wp-image-339 image-border" src="img/d983deb6-1f1c-4003-905f-5688b88b8e6d.png" style="width:39.92em;height:19.75em;"/></div>
<p style="padding-left: 60px">The merge can be seen in the preceding screenshot, and also the two root commits of the repository: the original root commit and the root from <kbd>lib_a</kbd>.</p>
<ol start="10">
<li>Now, we will learn how to integrate new commits into the super repository made in the subproject, <kbd>lib_a</kbd>. Normally, we would do this by checking out the <kbd>lib_a_master</kbd> branch and performing pull on it to get the latest commit from the remote repository. However, as we are working with example repositories in this recipe, no new commits are available on the master branch. Instead, we'll use the <kbd>develop</kbd> and <kbd>stable</kbd> branches from <kbd>lib_a</kbd>. We'll now integrate commits from the develop branch into <kbd>lib_a</kbd>. We do this directly using the <kbd>lib_a/develop</kbd> reference in the repository as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge -m '[LIB_A] Update lib_a project to latest state' -s  subtree lib_a/develop</strong> 
<strong>Merge made by the 'subtree' strategy.</strong> 
<strong> lib_a/a.txt | 2 ++</strong> 
<strong> 1 file changed, 2 insertions(+)</strong> </pre>
<p style="padding-left: 60px">Our master branch has now been updated with the commits from <kbd>lib_a/develop</kbd>, as shown in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-340 image-border" src="img/7cdb3cb4-19d3-4f0b-bf13-195d9a1b5a5e.png" style="width:32.83em;height:16.58em;"/></div>
<ol start="11">
<li>Now, it is time to add the commits we made in the <kbd>lib_a</kbd> directory back to the <kbd>lib_a</kbd> project. First, we'll change the <kbd>lib_a_master</kbd> branch and merge that with <kbd>lib_a/develop</kbd> to be as up-to-date as possible:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout lib_a_master</strong> 
<strong>$ git merge lib_a/develop</strong> 
<strong>Updating 0d96e7c..ab47aca</strong> 
<strong>Fast-forward</strong> 
<strong> a.txt | 2 ++</strong> 
<strong> 1 file changed, 2 insertions(+)</strong></pre>
<ol start="12">
<li>We are now ready to merge changes from the super project with the subproject. In order to not merge the history of the super project with the subproject, we'll use the <kbd>--squash</kbd> option. This option stops Git from completing the merge and, unlike the previous case, where we also stopped a merge from recording a commit, it does not leave the repository in a merging state. The state of the working directory and staging area are, however, set as though a real merge has happened:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge --squash -s subtree --no-commit master</strong> 
<strong>Squash commit -- not updating HEAD</strong> 
<strong>Automatic merge went well; stopped before committing as requested</strong> </pre>
<ol start="13">
<li>Now, we can record a commit with all the changes made in <kbd>lib_a</kbd> from the super project:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit -m 'Enhance lib_a with b.txt'</strong> 
<strong>[lib_a_master 01e45f7] Enhance lib_a with b.txt</strong> 
<strong> 1 file changed, 1 insertion(+)</strong> 
<strong> create mode 100644 b.txt</strong> </pre>
<p style="padding-left: 60px">The history for the <kbd>lib_a</kbd> repository is seen in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-341 image-border" src="img/65298db8-e8a5-4a83-afb3-97360e546772.png" style="width:37.17em;height:12.42em;"/></div>
<ol start="14">
<li>We can integrate more changes from <kbd>lib_a/stable</kbd> into the super project, but first we'll update the <kbd>lib_a_master</kbd> branch so that we can integrate them from here:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge lib_a/stable</strong> 
<strong>Merge made by the 'recursive' strategy.</strong> 
<strong> a.txt | 2 ++</strong> 
<strong> 1 file changed, 2 insertions(+)</strong></pre>
<p style="padding-left: 60px">A new commit was added to the subproject, as shown in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-342 image-border" src="img/3969f74d-fbc1-494b-9153-1002f42732dd.png" style="width:34.67em;height:12.92em;"/></div>
<ol start="15">
<li>The last task is to integrate the new commit on <kbd>lib_a_master</kbd> into the <kbd>master</kbd> branch in the super repository. This is done as in the previous case, using the <kbd>subtree strategy</kbd> option to <kbd>git merge</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout master</strong> 
<strong>$ git merge -s subtree -m '[LIB_A] Update to latest state of lib_a' lib_a_master</strong> 
<strong>Merge made by the 'subtree' strategy.</strong> 
<strong> lib_a/a.txt | 2 ++</strong> 
<strong> 1 file changed, 2 insertions(+)</strong> </pre>
<p style="padding-left: 60px">The resulting history is shown in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-343 image-border" src="img/b03aa1d4-b6ed-4159-9725-a57dcaca49cb.png" style="width:32.25em;height:20.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When using the subtree strategy, Git finds out which subtree in your repository the branch you are trying to merge fits into. This is why we added the content of the <kbd>lib_a</kbd> repository with the <kbd>read-tree</kbd> command, to make sure we got the exact same SHA-1 ID for the <kbd>lib_a</kbd> directory in the super project as the root tree in the <kbd>lib_a</kbd> project. In the following example, the SHA-1 is found in the first command.</p>
<p>We can verify this by finding the SHA-1 of the <kbd>lib_a</kbd> tree in the super project in the commit that we merged the subproject with:</p>
<pre><strong>$ git log -1 | head -1 | awk '{print $2}'<br/></strong><strong>0f10e563c6824402d30380c9f8fbf87769e64e8a</strong><strong><br/>$ git ls-tree 0f10e563c6824402d30380c9f8fbf87769e64e8a</strong> <strong>100644 blob 456a5df638694a699fff7a7ff31a496630b12d01 README.md</strong> <strong>040000 tree 7d66ad11cb22c6d101c7ac9c309f7dce25231394 lib_a</strong> <strong>100644 blob c552dead26fdba634c91d35708f1cfc2c4b2a100 super.txt</strong></pre>
<p>The ID of the root tree at <kbd>lib_a/master</kbd> can be found out by using the following command:</p>
<pre><strong>$ git cat-file -p lib_a/master</strong> 
<strong>tree 7d66ad11cb22c6d101c7ac9c309f7dce25231394</strong> 
<strong>parent a7d76d9114941b9d35dd58e42f33ed7e32a9c134</strong> 
<strong>author John Doe &lt;john.doe@example.com&gt; 1396553189 +0200</strong> 
<strong>committer John Doe &lt;john.doe@example.com&gt; 1396553189 +0200</strong> 

<strong>Fixes book title in README</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>Another way of using subtree merging is with the <kbd>git subtree</kbd> command. This is not enabled by default in many Git installations, but has been distributed with Git since 1.7.11. You can see how to install and use it at the following links:</p>
<ul>
<li>For installation, go to <a href="https://github.com/git/git/blob/master/contrib/subtree/INSTALL">https://github.com/git/git/blob/master/contrib/subtree/INSTALL</a></li>
<li>To understand how to use a subtree, go to <a href="https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt">https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt</a></li>
</ul>
<p>If you are a Homebrew or an Ubuntu user, their basic packages have support for subtrees. For Fedora, you must install additional packages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Submodule versus subtree merging</h1>
                
            
            
                
<p>There is no easy answer to the question of whether or not to use submodules or subtree merging for a project. When choosing submodules, a lot of extra pressure is put on the developers working on the project, as they need to make sure they keep the submodules and the super project in sync. When choosing to add a project by subtree merging, little to no extra complexity is added for developers. The repository maintainer, however, needs to make sure the subproject is up-to-date and that commits are added back to the subproject. Both methods work and are in use, and it is probably just a matter of getting used to either method. A completely different solution is to use the build system of the super project to fetch the necessary dependencies, as for example, Maven or Gradle does.</p>


            

            
        
    </body></html>