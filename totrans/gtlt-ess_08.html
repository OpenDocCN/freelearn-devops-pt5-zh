<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Allowing Users to Create Repos</h1></div></div></div><p>Until now, everything we have seen indicates that the administrator is the only person who can create new repositories. He can share the load of doing this, simply by giving some trusted users the right to read and write the gitolite-admin repository, but that's as far as it goes.</p><p>In some environments, your users may need more flexibility. You could have several users who need not be administrators, in the sense that they neither want nor need to manage <em>all </em>repositories, but they do wish to be able to create their own repositories and control access to those repositories. In fact, we would like the administrator's role in this to be a one-time setup, after which no more changes to Gitolite's <em>conf</em> file would be required.</p><p>If there are several users who need to do this, it seems like a good idea to think about how we could allow this and still maintain the required security over the repositories that were created by the administrator in the usual way.</p><p>In this chapter, we'll work out a solution to the problem described in the introduction. We'll begin by talking about some features that help us with parts of the solution, and then add the missing pieces one by one to build up a solution.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Putting repositories in Sub-directories</h1></div></div></div><p>The first part of the <a id="id169" class="indexterm"/>solution is that, as was hinted at in the first chapter, Gitolite allows you to group repositories in subdirectories, just like you can do with files in a filesystem. For example, you could put all the open source projects you're managing under a subdirectory called <code class="literal">foss</code>, like the following:</p><div><pre class="programlisting">
<strong>repo foss/apache</strong>
<strong>    ...access rules for the apache repo...</strong>
<strong>repo foss/linux</strong>
<strong>    ...access rules for the linux repo...</strong>
<strong>...etc...</strong>
</pre></div><p>We can make use of this in solving our current problem. Let's say we had users Alice and Bob, and we wanted to let them create and manage repositories. We could come up with a way by which Alice's repositories would be in a subdirectory called, say <code class="literal">dev/alice</code>, and Bob's repositories would, similarly, be within <code class="literal">dev/bob</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Repository wildcards</h1></div></div></div><p>A repository wildcard<a id="id170" class="indexterm"/> is a regular expression that describes a whole range of possible repository names. For example, the line <code class="literal">repo</code> <code class="literal">dev/alice/[a-z].*</code> represents all repositories whose names start with <code class="literal">dev/alice/</code>, followed by an alphabetic character, followed optionally by anything else. The repository <code class="literal">dev/alice/foo</code> would qualify, but <code class="literal">dev/alice/123</code> would not, nor would just <code class="literal">dev/alice</code>.</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>Due to the need to properly represent repositories such as <code class="literal">gtk+</code> and <code class="literal">c++</code>, if the <code class="literal">+</code> character is the only regular expression metacharacter in the repo name, it will be taken to be a normal repository, not a repository wildcard. To specify <code class="literal">foo.+</code>, you should instead say <code class="literal">foo..*</code>. You can also say <code class="literal">[f]oo.+</code>—the presence of the bracket tells Gitolite it is a regular expression.</p></div></div><p>Gitolite allows <code class="literal">repo</code> lines to use wildcards instead of individual repository names. This gives us the next step to our solution; we can now write:</p><div><pre class="programlisting">repo dev/alice/[a-z].*
    RW+       =  alice
    RW        =  bob
    R         =  @all
repo dev/bob/[a-z].*
    RW+       =  bob
    RW        =  alice
    R         =  @all</pre></div><p>This says that Bob can push (but not rewind or delete) branches to all of Alice's repositories, and vice versa, and that other authenticated users of the system can clone both those sets of repositories.</p><p>Sadly, though, a wildcard repository specification by itself does not actually <em>create</em> any repositories, since the pattern itself can match billions of possible repository names!</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec40"/>Creating a wildcard repository</h2></div></div></div><p>Now it's time to<a id="id171" class="indexterm"/> introduce the first part of the additional syntax that Gitolite provides to help in solving the problem we started this chapter with. As we noted, the wildcard specification lines don't actually create the repositories that Alice or Bob need.</p><p>To enable that, we add a new line to the access rules specification:</p><div><pre class="programlisting">
<strong>repo dev/alice/[a-z].*</strong>
<strong>    C    =  alice</strong>
<strong>    ...other rules stay the same...</strong>
<strong>repo dev/bob/[a-z].*</strong>
<strong>    C    =  bob</strong>
<strong>    ...other rules stay the same...</strong>
</pre></div><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>This is different than the <em>create branch</em> permission we saw in the <em>Types of write operations</em> section in <a class="link" href="ch07.html" title="Chapter 7. Advanced Access Control and Configuration">Chapter 7</a>, <em>Advanced Access Control and Configuration</em>. The one described here is the single letter <code class="literal">C</code> by itself, while the other can only exist as a modifier to <code class="literal">RW</code> or <code class="literal">RW+</code>.</p></div></div><p>This access rule says that, merely by cloning or pushing a repository with a matching name, Alice <em>can cause repositories to be created on the server</em>! In other words, Alice can run the following command:</p><div><pre class="programlisting">
<strong>$ git clone  git@host:dev/alice/my-new-repo</strong>
<strong>Cloning into 'my-new-repo'...</strong>

<strong>Initialized empty Git repository in /home/git/repositories/dev/alice/my-new-repo.git/</strong>

<strong>warning: You appear to have cloned an empty repository.</strong>
</pre></div><p>It would be as if the administrator had added a new set of rules as follows:</p><div><pre class="programlisting">
<strong>repo dev/alice/my-new-repo</strong>
<strong>    RW+       =  alice</strong>
<strong>    RW        =  bob</strong>
<strong>    R         =  @all</strong>
</pre></div><p>except that the administrator doesn't have to!</p><p>Don't miss the <code class="literal">Initialized empty...</code> line in the preceding output; that came from the server, telling you a brand new repository was created as a result of this clone! In addition, if Alice ran the <code class="literal">info</code> command, she might see something as follows:</p><div><pre class="programlisting">
<strong>$ ssh git@host info </strong>

<strong>hello alice, this is git@host running gitolite3 v3.5.3.1-7-g31d11b9 on git 1.8.3.1</strong>



<strong>     C  dev/CREATOR/..*</strong>
<strong> R W    dev/u1/my-new-repo</strong>
<strong> R W    testing</strong>
</pre></div><p>which <a id="id172" class="indexterm"/>shows you the repository that was just created.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>A downside is that a simple typo can cause useless repositories to be created. If you wish to prevent this, edit <code class="literal">$HOME/.gitolite.rc</code> and uncomment the <code class="literal">create</code> command as well as the <code class="literal">no-auto-create</code> option. Then your users can run the more explicit <code class="literal">create</code> command, for example: <code class="literal">ssh git@host create dev/alice/my-new-repo</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec41"/>Giving access to other users</h2></div></div></div><p>We have so <a id="id173" class="indexterm"/>far simply hardcoded the permissions—Alice and Bob have some access to each other's repositories, and everyone else can read both sets of repositories. This is clearly not flexible enough, Alice may want some repositories to be writable by David, and some should not be readable by <code class="literal">@all</code>, and so on.</p><p>On the face of it, this is a difficult problem because it seems to imply that Alice might want to actually make changes or additions to the rules themselves, and thus, directly or indirectly, touch Gitolite's <em>conf</em> file.</p><p>The way Gitolite solves these problems is to allow the administrator to define roles, and then allow the user to specify which users she wants in each role. The following is an example using role names that are defined by default in Gitolite:</p><div><pre class="programlisting">
<strong>repo dev/alice/[a-z].*</strong>
<strong>    C          =  alice</strong>
<strong>    RW+        =  alice</strong>
<strong>    RW         =  WRITERS</strong>
<strong>    R          =  READERS</strong>
</pre></div><p>
<code class="literal">READERS</code> and <code class="literal">WRITERS</code> are role names that are predefined in Gitolite. Note that the role names themselves don't have any special meaning in terms of what access rights a role has—that is entirely up to the administrator.</p><p>At the moment, however, this is not complete. The rules do not actually say that Bob is a writer (and thus has <code class="literal">RW</code> permission on Alice's repositories) or that everyone else (<code class="literal">@all</code>) can read it.</p><p>This is where <a id="id174" class="indexterm"/>the <code class="literal">perms</code> command comes in. Here's how Alice would use it to add Bob to the <code class="literal">WRITERS</code> role:</p><div><pre class="programlisting">
<strong>ssh  git@host perms dev/alice/my-new-repo + WRITERS bob</strong>
</pre></div><p>Similarly, to add <code class="literal">@all</code> to the <code class="literal">READERS</code> role, she would run the following command:</p><div><pre class="programlisting">
<strong>ssh  git@host perms dev/alice/my-new-repo + READERS @all</strong>
</pre></div><p>If she wishes to check what the current role assignments for her repository are, she can run.</p><div><pre class="programlisting">
<strong>ssh  git@host perms -l dev/alice/my-new-repo</strong>
</pre></div><p>which will dutifully print:</p><div><pre class="programlisting">
<strong>READERS @all</strong>
<strong>WRITERS bob</strong>
</pre></div><p>One advantage you should see right away is that now the role assignment is <em>per repository</em>. That is, Alice can have completely different role assignments for other repositories she owns. In fact, if she does not run the perms command on a repository, no one else will have any access­—it becomes her private repository. Or she can add multiple people to each role too if she wishes. The <code class="literal">perms</code> command can only be used to add one user to one role in one go. So Alice may have to run this multiple times. If she added someone whom she now wishes to remove, that is also possible. As normal for all Gitolite commands, <code class="literal">perms</code> responds to a single argument of <code class="literal">-h</code> to provide a usage message.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec42"/>Generalizing the ruleset</h2></div></div></div><p>We'll <a id="id175" class="indexterm"/>now look at the ruleset as it stands for each user, and then discuss how to generalize it to any number of users. At this point, if you recall from the previous section, the rules look as follows:</p><div><pre class="programlisting">
<strong>repo dev/alice/[a-z].*</strong>
<strong>    C         =  alice</strong>
<strong>    RW+       =  alice</strong>
<strong>    RW        =  WRITERS</strong>
<strong>    R         =  READERS</strong>
</pre></div><p>You might notice that other than the word alice in the first three lines being replaced by Bob, this is precisely what you need for Bob's repositories as well. It certainly does not make sense to have to repeat this for every user who might need this feature!</p><p>The final part of the solution to allowing users to create, and (to some extent) manage, their own repositories is the <code class="literal">CREATOR</code> keyword. Here's the canonical example again:</p><div><pre class="programlisting">
<strong>repo dev/CREATOR/[a-z].*</strong>
<strong>    C         =  alice bob carol dave</strong>
<strong>    RW+       =  CREATOR</strong>
<strong>    RW        =  WRITERS</strong>
<strong>    R         =  READERS</strong>
</pre></div><p>Notice the<a id="id176" class="indexterm"/> changes we made. First, the <code class="literal">C</code> permission line now lists all the users who are allowed to create their own repositories and manage it as we have described earlier. Only these four users can do this, in this ruleset. Alternatively, you can replace the four usernames with some group name that you may have defined, or even use <code class="literal">@all</code> to allow all authenticated users to use the facility of creating private repositories they can selectively open up to others.</p><p>Next, the repository name pattern contains <code class="literal">CREATOR</code> instead of <code class="literal">alice</code>, as does the <code class="literal">RW+</code> line. For repositories that do not yet exist, these are effectively treated as the name of the user who's trying to create the repository. For existing repositories, this is treated as the name of the user who created it, which is recorded and kept track of.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>When a repository does not exist, the only permission that Gitolite cares about is the <code class="literal">C</code> permission that allows creating a repository. Whoever is on the right side of such a rule is allowed to create repositories matching the pattern. One error to watch out for is to put in <code class="literal">C  =  CREATOR</code>, instead of a list of actual users or user groups. Because, as described above, this is treated as the name of user attempting to create the repository, this allows any authenticated user to create such a repository. If that is what you want, it's better to be clear and actually use <code class="literal">@all</code> instead of <code class="literal">CREATOR</code>; the latter is just a side-effect and not supported behavior.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Explaining wild repos to your users</h1></div></div></div><p>Your users,<a id="id177" class="indexterm"/> of course, do not need all of this explanation! In fact, one of the goals of this feature is that Gitolite users (as opposed to Gitolite <em>administrators</em>) should <em>not</em> be burdened with learning the nuances of <code class="literal">RW</code>, <code class="literal">RW+</code>, <em>deny</em> rules, and so on.</p><p>The example setup we have been using till now is the canonical example: it contains an owner (who is the only user allowed to rewind or delete branches), a set of writers (who can push/create but not rewind/delete), and a set of readers who cannot push at all.</p><p>The only thing left to do is to explain to the user what repositories she is allowed to create (most users do not know regular expressions very well, so it's best to keep your patterns simple enough to be explained in English), and that she can add or remove people from each of those <em>lists of users</em>.</p><p>The list <a id="id178" class="indexterm"/>names (in our example, <code class="literal">READERS</code> and <code class="literal">WRITERS</code>) should be supplied, and explained as representing what the users in each list can do.</p><p>Finally, show them three examples of the <code class="literal">perms</code> command used to maintain these user lists:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ssh</code> git@host <code class="literal">perms dev/alice/repo + WRITERS dave</code> to add a user</li><li class="listitem" style="list-style-type: disc"><code class="literal">ssh</code> git@host <code class="literal">perms dev/alice/repo - WRITERS dave</code> to remove a user (notice the minus sign instead of the plus sign)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ssh</code> git@host <code class="literal">perms -l dev/alice/repo</code> to list current user lists</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Managing with just wild repos</h1></div></div></div><p>If you think about<a id="id179" class="indexterm"/> the example we've been working on throughout this chapter, it does not allow the user to trust anyone <em>else</em> with <code class="literal">RW+</code> permissions; if any rewinding or deleting of branches is required it has to be the owner herself that does it.</p><p>We can rectify this by changing the <code class="literal">RW+</code> permission line to:</p><div><pre class="programlisting">
<strong>    RW+    =  CREATOR TRUSTED</strong>
</pre></div><p>Thus, defining a new role (or list of users, if you will) called <code class="literal">TRUSTED</code>. Of course, for this to work, you—as the administrator—must log on to the server and edit <code class="literal">$HOME/.gitolite.rc</code> to add this new role to the list of roles defined in that file under the <code class="literal">ROLES</code> hash. Then you can tell your user that there is a third list of users, called <code class="literal">TRUSTED</code>, which she can use to specify users she would like to allow to rewind or delete branches or tags.</p><p>Now that we have started going this route, we can go a little further and then a little more, until we end up with something that is essentially a one-time setup of Gitolite, requiring little to no further maintenance, from the administrator, once it has been set up. This can be very useful in sites where most of the users are somewhat autonomous.</p><p>Here's a comprehensive example of such a ruleset. To make things easier to copy and use, we've added the description of the rulesets as comments so you can copy them too:</p><div><pre class="programlisting">
<strong># completely private repo; no sharing even possible</strong>
<strong>repo private/CREATOR/..*</strong>
<strong>    C          =  @all</strong>
<strong>    RW+        =  CREATOR</strong>

<strong># public template; anyone can read but writes only by owner</strong>
<strong>repo public/CREATOR/..*</strong>
<strong>    C          =  @all</strong>
<strong>    RW+        =  CREATOR</strong>
<strong>    R          =  @all</strong>

<strong># a controlled repo with 3 roles allowing RW+, RW, and R</strong>
<strong>repo controlled/CREATOR/..*</strong>
<strong>    C         =  @all</strong>
<strong>    RW+       =  CREATOR</strong>
<strong>    RW+       =  TRUSTED</strong>
<strong>    RW        =  WRITERS</strong>
<strong>    R         =  READERS</strong>

<strong># a "corporate" type template with managers, testers, etc.</strong>
<strong># Junior devs cant write 'master', can't rewind.  Testers</strong>
<strong># (and *only* testers) can push versioned tags.  Managers</strong>
<strong># can read any repo.</strong>
<strong>repo corporate/CREATOR/..*</strong>
<strong>    C               =  @all</strong>
<strong>    RW+             =  CREATOR</strong>
<strong>    RW refs/tags/v[0-9]  =  TESTERS</strong>
<strong>    -  refs/tags/v[0-9]  =  @all</strong>
<strong>    RW+             =  SENIOR_DEVS</strong>
<strong>    -  master       =  JUNIOR_DEVS</strong>
<strong>    RW              =  JUNIOR_DEVS</strong>
<strong>    R               =  MANAGERS</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Deleting wild repositories</h1></div></div></div><p>With the <a id="id180" class="indexterm"/>example in the previous section, the administrator's job is much lightened (albeit at the expense of <em>some</em> loss of control). However, there still remains one feature that your users will eventually want: deleting repositories that have served their purpose.</p><p>In order to allow users to delete repositories that they have created (it need not be said that a user cannot delete anything else!), the administrator needs to enable the <code class="literal">D</code> command by uncommenting the corresponding line in the list of commands in <code class="literal">$HOME/.gitolite.rc</code>. Then the user can run the <code class="literal">D</code> command to delete repositories.</p><p>Repositories are locked against accidental deletion by default, so every delete is actually two steps—the <code class="literal">unlock</code> sub-command, then the <code class="literal">rm</code> sub-command:</p><div><pre class="programlisting">
<strong>ssh  git@host D unlock dev/alice/my-new-repo</strong>
<strong>ssh  git@host D rm dev/alice/my-new-repo</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Summary</h1></div></div></div><p>This may be one of the most important chapters in this book, since it talks about a very popular feature of Gitolite. While it is not suitable in sites where strict control and auditability are required, it is very useful in most other sites, not only saving the administrator a lot of time, but the users also do not have to wait on the administrator for something they need quickly.</p><p>In the next chapter, we will talk about what <strong>core</strong> Gitolite is and what <strong>non-core is</strong>, look at some non-core programs that come with Gitolite, and discuss customizing Gitolite by adding our own non-core code.</p></div></body></html>