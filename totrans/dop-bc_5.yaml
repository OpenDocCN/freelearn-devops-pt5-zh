- en: Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technology is nothing. What's important is that you have a faith in people,
    that they're basically good and smart, and if you give them tools, they'll do
    wonderful things with them                                                    
                                                                             - Steve
    Jobs
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at different DevOps practices such as continuous integration,
    containers, and configuration management. Now we will look at how to deploy a
    package file in to a web container or web server. We will use Apache Tomcat as
    a web server in cloud virtual machines to deploy our Java-based application.
  prefs: []
  type: TYPE_NORMAL
- en: The main objective of this chapter is to make you the reader aware of different
    ways to deploy an application package into a web server. These ways can be utilized
    based on the access available to the team and, once we achieve this automated
    delivery into the web server, then we can utilize this operation in the overall
    build orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can create a build pipeline and this orchestration will help us to achieve
    continuous delivery and continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery in Docker container using Jenkins plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery in AWS EC2 and Microsoft Azure VM using script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery in AWS Elastic Beanstalk using a Jenkins plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery in Microsoft Azure App Services using FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery in Microsoft Azure App Services using VSTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery in Docker container using Jenkins Plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand how we can deploy a web application in Tomcat using the Jenkins
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow a few steps for that:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Apache Tomcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the proper IP address and port number combination to navigate to the Tomcat
    home page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go to the `conf` directory and then open `tomcat-users.xml` in your Tomcat installation
    directory and un-comment the role and user lines or rewrite them. Set manager-script
    as the rolename for testing purposes. We need manager-script for deployment via
    the `Deploy to Container` plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the Jenkins deploy plugin, change the rolename to manager-script as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the manager application link on the Tomcat home page and enter the
    username and password you set in `tomcat-users.xml`. Now we can access the management
    application. For a local Tomcat, we can use localhost to access the Tomcat page
    or we can use the IP address as well. For a remote web server, we can utilize
    an IP address or domain name to access Tomcat.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restart Tomcat and visit `https://<IP Address>:8080/manager/text/list`. You
    should see this output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the Jenkins job build page and click on Configure. Select the proper
    JDK configuration for the Jenkins agent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Under Post-build Actions, select Deploy war/ear to a container. Provide the
    location of the WAR file in the Jenkins workspace, the Tomcat manager credentials,
    and the Tomcat URL with the port:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Apply and Save. Click on Build now on the Jenkins build''s page. Verify
    that the console output is showing a fresh deployment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the build is successful, visit the URL from your browser and notice the
    context. It is similar to the name of the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We already know the basic operations available in Docker, as we covered them
    in [Chapter 3](part0059.html#1O8H60-651ea628c0544d18a4415dfef8fe6271), *Containers*.
    We have created a customized Tomcat image with `tomcat-users.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Docker is up and running, we are ready to create a Docker container. Note
    the IP address of the default Docker machine in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To change the name of the container, use :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the name using :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00073.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the virtual machine IP address and use 9999 as a port number to access
    Tomcat running in the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify the manager access with the `manager-script` role using the following URL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s just try to deploy an application using the `Deploy to Container` plugin
    in Tomcat. If one build job generates a WAR file, then copy it from that build
    using the **copy artifact** plugin:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Post-build actions, select Deploy war/ear to a container. Give the user
    name and password provided in `tomcat-users.xml`. We will then provide the Tomcat
    URL, shown as follows. After filling in the details , click on Apply/Save:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Build Now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to console output and verify the deployment process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Verify the application URL using the Tomcat URL and application context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome!! We have successfully created an image and a container, and deployed
    the application in the Tomcat container.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery in AWS EC2 and Microsoft Azure VM using Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already created VMs in AWS and Microsoft Azure in [Chapter 4](part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271),
    *Cloud Computing and Configuration Management*. To deploy an application in AWS
    and Microsoft Azure VM, we need a WAR package file. Once it is created by the
    Jenkins build job, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s configure the build job to execute the deployment of the WAR file in
    the AWS instance by executing the commands shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Give rights to `ec2-user` in the `webapps` directory of Tomcat so we can copy
    the WAR file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the WAR file into the remote directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start/restart the Tomcat service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `Copy Artifact` plugin to copy the **WAR** file from another build
    job and then execute the preceding commands in Execute Shell Build Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Save and then execute the build job. For application deployment in
    Microsoft Azure VM, utilize Jenkins plugin (Deploy to Container) or script utilized
    for AWS with required modification as self exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery in AWS Elastic Beanstalk using Jenkins Plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS Elastic Beanstalk is a **Platform as a Service**(**PaaS**) offering from
    Amazon. We will use it to deploy the PetClinic application on the AWS platform.
    The good part is we don''t need to manage the infrastructure or even the platform,
    as it is a PaaS offering. We can configure scaling and other details. These are
    the steps to deploy an application on AWS Elastic Beanstalk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's create a sample application to understand how Elastic Beanstalk works
    and then use the `Jenkins` plugin to deploy an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the AWS management console and verify whether we have a default **Virtual
    Private Cloud** (**VPC**). If you''ve deleted the default VPC and subnet by accident,
    send a request to AWS customer support to recreate it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Services in the AWS management console and select AWS Elastic Beanstalk.
    Create a new application named petclinic. Select Tomcat as a Platform and select
    the Sample application radio button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify the sequence of events for the creation of a sample application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will take a while, and once the environment has been created, it will be
    highlighted in green, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the petclinic environment and verify Health and Running Version in
    the dashboard:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify the environment ID and URL. Click on the URL and verify the default
    page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Install the AWS Elastic Beanstalk `Publisher` plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details, visit [https://wiki.jenkins-ci.org/display/JENKINS/AWS+Beanstalk+Publisher+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/AWS+Beanstalk+Publisher+Plugin).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Jenkins dashboard and go to Build job. Click on Post-build Actions
    and select Deploy into AWS Elastic Beanstalk:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A new section will come up in Post-build Actions for Elastic Beanstalk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the Jenkins dashboard and select Credentials; add your AWS credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to your Jenkins build and select AWS Credential, which is set in the global
    configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select AWS Region from the list and click on Get Available Applications. As
    we have created a sample application, it will show up like this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In EnvironmentLookup, provide an environment ID in the Get Environments By
    Name box and click on Get Available Environments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Save the configuration and click on Build now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s verify the AWS management console to check whether the **WAR** file
    is being copied in Amazon S3 or not:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to S3 Services and check the available buckets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since the WAR file is large, it will take a while to upload to Amazon S3\. Once
    it is uploaded, it will be available in the Amazon S3 bucket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Verify the build job''s execution status in Jenkins. Some sections of the expected
    output are that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test case execution and WAR file creation are successful
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The build is successful
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now check the AWS management console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to Services, click on AWS Elastic Beanstalk, and verify the environment.
    The previous version was Sample Application. Now, the version is updated as given
    in **Version Label Format** in the Jenkins build job configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go to the dashboard and verify Health and Running Version again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once everything has been verified, click on the URL for the environment, and
    our PetClinic application is live:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the application deployment is successful, terminate the environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have thus successfully deployed our application on Elastic Beanstalk.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery in Microsoft Azure App Services Using FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Azure app services is a PaaS. In this section, we will look at the
    Azure Web App and how we can deploy our PetClinic application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the `Publish Over FTP` plugin in Jenkins. We will use the Azure
    Web App''s FTP details to publish the PetClinic WAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Microsoft Azure portal at [https://portal.azure.com](https://portal.azure.com).
    Click on App Services and then on Add. Provide values for App Name, Subscription,
    Resource Group, and App Service plan/Location. Click on Create:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the Azure Web App is created, see whether it shows up in the Azure portal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on DevOpsPetClinic in details related to the URL, Status, Location, and
    so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on All Settings, go to the GENERAL section and click on Application settings
    to configure the Azure Web App for Java web application hosting. Select the Java
    version, Java Minor version, Web container, and Platform, and click on Always
    On:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Visit the URL of an Azure Web App from your browser and verify that it is ready
    for hosting our sample spring application, PetClinic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's go to the Jenkins dashboard. Click on New Item and select Freestyle project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on All Settings, and go to Deployment credentials in the PUBLISHING section.
    Provide a username and password, and save your changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In Jenkins, go to Manage Jenkins and click on Configure | Configure FTP settings.
    Provide a Hostname, Username, and Password, available in the Azure portal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to `devopspetclinic.scm.azurewebsites.net` and download the Kudu console.
    Navigate to the different options and find the `site directory` and `webapps`
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on Test Configuration and, once you get a Success message, you are ready
    to deploy the PetClinic application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the build job we created, go to the Build section and configure Copy artifacts
    from another project. We will copy the WAR file to a specific location on a virtual
    machine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Post-build Actions, click on Send build artifacts over FTP. Select the FTP
    Server Name configured in Jenkins. Configure Source files and the Remove prefix accordingly
    for deployment of an Azure Web App:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tick Verbose output in console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Build now and see what happens behind the scenes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to the Kudu console, click on DebugConsole, and go to Powershell. Go to
    site | wwwroot | webapps. Check whether the WAR file has been copied:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visit the Azure Web App URL in the browser with the context of an application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have an application deployed on Azure Web Apps.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the FTP username has to be with the domain. In
    our case, it can be `Sample9888\m1253966`. Using the username without the web
    app name won't work.
  prefs: []
  type: TYPE_NORMAL
- en: All these different ways of deploying to AWS IaaS, AWS PaaS, Microsoft Azure
    PaaS, and Docker container can be used in the final end-to-end automation.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery in Microsoft Azure App Services Using VSTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio Team Services provides a way to configure continuous integration
    and continuous delivery. We will first go to our VSTS account. Here, we need the
    following things to be accomplished:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure Microsoft Azure Subscription so we can connect to Azure Web Apps from
    VSTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a release definition that achieves the task of application deployment
    in Azure Web Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Recent projects & teams, click on PetClinic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will open a Home page for the project created in VSTS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top menu bar, click on Build & Release, which will open a menu. Click
    on the Releases menu item from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Releases link on the page.
  prefs: []
  type: TYPE_NORMAL
- en: As this is the new account, there is no Release definition created that has
    been created yet, so this section is empty. We can create a New Release definition
    so we can automate application deployment into Azure App Services or the App Service
    Environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that we have built definition for continuous integration, we
    have release definition for continuous release or continuous delivery or continuous
    deployment. Release definition contains different tasks that can be used for application
    deployment in the target environment. Each release definition contains one or
    more environments, and each environment contains one or more tasks to deploy the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's create a new release definition. Each release definition can contain
    one or more environment and each environment can contain one or more tasks to
    deploy an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on New definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once we click on the new release definition, it will open a dialog box with
    deployment templates that can be used for deployment automation.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to deploy the WAR file into Azure App Service / Azure Web Apps,
    so select Azure App Service Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's review a few things from earlier chapters before explaining this deployment
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: We created a build definition PetClinic-Maven that compiles the source code,
    executes unit test cases and creates a WAR file. WAR file is our artifact. This
    artifact is the result of the build definition execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the release definition, we need to select where the artifact will come
    from, and that is from Build.
  prefs: []
  type: TYPE_NORMAL
- en: Select the PetClinic project.
  prefs: []
  type: TYPE_NORMAL
- en: In Source (Build definition), all build definitions related to the PetClinic
    project will be available. We will select PetClinic-Maven.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, we want to achieve continuous integration and continuous delivery
    here. It means that, when a developer checks any new code or bug fix in the repository,
    it will automatically trigger a build definition. Build definition will compile
    source files, execute unit tests, if any, conduct a static code analysis if sonar
    is configured, and create a WAR/package file. That is an artifact. Once build
    definition has completed successfully, it will trigger a release definition to
    deploy an artifact or a **WAR** file into Azure Web Apps that is hosted in an
    ASE or a non-ASE environment.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Continuous deployment (create release and deploy whenever a build
    completes) checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will open a release definition in the edit mode. We selected Deploy Azure
    App Service. The first thing that is required is to configure an Azure subscription
    with VSTS.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the task and see there are two fields named AzureRM Subscription and
    App Service Name. We need to configure Azure subscription here and App Service
    Name will come in the list automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Manage link next to the AzureRM Subscription field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will open a Services page in the VSTS portal. As of now, there is no service
    configured, so the list is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the New Service Endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will open a menu; select the Azure Resource Manager menu item from the menu
    to configure Azure subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we are already logged into VSTS and our Azure account, it will show the subscription
    name in the list. In Connection name, give the name that we will use in the release
    definition task to connect to our Azure Account.
  prefs: []
  type: TYPE_NORMAL
- en: Click on OK.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of adding the Azure subscription here is to get a list of resources
    available in that subscription to VSTS so that we can configure them for deployment.
    In our example, we need a list of Azure Web Apps that are hosted in ASE or non-ASE
    so we can deploy the PetClinic application to Azure Web Apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we close the box to add an Azure RM Endpoint, we can see a list of endpoints
    in services. Hence, we have Azure RM subscription configured successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Roles link to verify the available roles of the Azure subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: Now go to Release Definitions and click on the list box of AzureRM Subscription,
    and now our newly added Endpoint is available in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have configured Azure Subscription Endpoint in VSTS so we can use
    it in Release Definitions to deploy the artifact in Azure App Services hosted
    in ASE and non-ASE environments. We have already configured AzureRM Subscription.
    Once it has completed successfully, we can select App Service Name. Click on the
    down arrow and the Azure Web Apps available in the configured AzureRM subscription
    will show in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Select File Or Folder and click on the three dots (...); go to the PetClinic-Maven
    and select the **WAR** file created after successful execution of build definition.
  prefs: []
  type: TYPE_NORMAL
- en: Our Release Definitions will pick this WAR file and deploy it in Azure Web Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Click on OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are all set to execute the Release Definitions, but before that, we
    need to save the Release Definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Save button and it will open a new dialog box. Provide a Comment
    and click on OK to save the release definition in VSTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Verify that you have saved the release definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Triggers section allows us to schedule when the new release should be created.
    We can set it when a new artifact version is available, or in other words, when
    a build definition execution has successfully completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To check end-to-end automation, we will start build definition execution. So,
    once it is successful, it will trigger a release definition. Save the release
    definition and click on Queue new build....
  prefs: []
  type: TYPE_NORMAL
- en: 'Queue build for PetClinic-Maven build definition will trigger release definition
    if it is completed successfully. Click on OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the build definition has successfully completed, the PetClinic-Release
    release definition will be triggered. Its job is to deploy the `.war` artifact
    into Azure App Services.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment Failed! Let's find out why this deployment has failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Release definition execution has failed. Let''s try to troubleshoot the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify the History first: we can see that release definition was triggered
    but deployment has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out the likely cause of this failure from the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Logs section and verify the release definition execution steps. It
    clearly indicates that it is the final deployment operation that has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the failed step, that is Deploy Azure App Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After closely examining the logs, we can see that it is mentioned that `.war`
    does not have a `.zip` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we selected `petclinic.war` and not `petclinic.zip`, so it is deploying
    the `.war` with this task; we need to have a `.zip` file and not a WAR file.
  prefs: []
  type: TYPE_NORMAL
- en: How to solve this?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can convert the WAR file into a .zip file, then it can be done and it
    should happen automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The best way is to use any task that can convert `.war` in to a `.zip` file.
    So let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Add Task and click on the Marketplace link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It will open a new Marketplace window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find Trackyon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before deployment, we will convert the WAR file into a ZIP file using Trackyon.
    Once that is done, our deployment on Azure Web Apps should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the VSTS account where we want to install Trackyon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Proceed to the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Close:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After installation, our next task is to add that task in the release definition
    so that, before deployment into Azure Web Apps, the WAR file is converted into
    a ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: Select the Trackyon WAR converter task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Close:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the folder where the WAR file is located:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the folder where the ZIP file should be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now our release definition has two tasks to perform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `.war` in to a `.zip` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploy the `.zip` file into Azure Web Apps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go to the PetClinic-Maven build definition and click on Queue new build...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build will start when the hosted agent is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait till build execution has completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: As we have configured our release definition for continuous delivery, the successful
    build definition execution will trigger our release definition to achieve end-to-end
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the Build number Build 20161230.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This build will trigger the release definition if completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at different ways to deploy an application package
    into a local Tomcat server using Jenkins plugins, into a Docker container, into
    AWS Elastic Beanstalk, into Microsoft Azure App Services using FTP, and into Microsoft
    Azure App Services using Visual Studio Team Services.
  prefs: []
  type: TYPE_NORMAL
- en: If we observe the previous automation, it is one of the ways to deploy an application
    in a web server that is available locally or in the cloud using different ways,
    such as script, plugin, and VSTS.
  prefs: []
  type: TYPE_NORMAL
- en: Build definition was all about continuous integration, while release definition
    is all about continuous delivery. Hence, we have covered CI and CD till now, using
    different tools that are open source and commercial.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover automated testing (functional and load testing),
    so that we can consider it as a part of continuous testing.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Selenium and Apache JMeter for functional testing and load testing
    respectively in a local and a cloud environment.
  prefs: []
  type: TYPE_NORMAL
