<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-222"><a id="_idTextAnchor247" class="pcalibre1 pcalibre calibre6"/>10</h1>
<h1 id="_idParaDest-223" class="calibre5"><a id="_idTextAnchor248" class="pcalibre1 pcalibre calibre6"/>Keeping History Clean</h1>
<p class="calibre3">The previous chapter, <em class="italic">Merging Changes Together</em>, described how to join changes developed by different people (as described in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>), or just developed in a separate feature branch (as shown in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>). One of the techniques was rebase, which can help bring a branch to be merged to a better state. However, if we are rewriting history, perhaps it would be possible to also modify the rebased commits to be easier for review, making the development steps of a feature clearer. If rewriting is forbidden, can one make history cleaner without it? How do we fix mistakes if we cannot rewrite project history?</p>
<p class="calibre3">This chapter will answer all those questions. It will explain why one might want to keep a clean history, when it can and should be done, and how it can be done. Here you will find step-by-step instructions on how to reorder, squash, and split commits. This chapter will also describe how to do large-scale history rewriting (for example, the clean-up after imports from other VCS) and what to do if one cannot rewrite history: in other words, using <strong class="bold">reverts</strong>, replacements, and notes.</p>
<p class="calibre3">To really understand some of the topics presented here, and to truly master their use, you need some basics of Git internals. These are presented at the beginning of this chapter.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre16">
<li class="calibre15">The basics of the object model of Git repositories</li>
<li class="calibre15">Why you shouldn’t rewrite published history, and how to recover from doing so</li>
<li class="calibre15">The interactive rebase: reordering, squashing, splitting, and testing commits</li>
<li class="calibre15">Large-scale scripted history rewriting</li>
<li class="calibre15">Reverting a revision, reverting a merge, and re-merging after a reverted merge</li>
<li class="calibre15">Amending history without rewriting with replacements</li>
<li class="calibre15">Appending additional information to objects with notes</li>
</ul>
<h1 id="_idParaDest-224" class="calibre5"><a id="_idTextAnchor249" class="pcalibre1 pcalibre calibre6"/>An introduction to Git internals</h1>
<p class="calibre3">To really understand and<a id="_idIndexMarker820" class="pcalibre1 pcalibre calibre6"/> make good use of at least some of the methods described in this chapter, you will need to understand at least the very basics of Git internals. Among other things, you will need to know how Git stores the information about revisions.</p>
<p class="calibre3">When describing Git internals, it will be useful to create different types of data to later examine. This can be achieved with a set of low-level commands that Git provides as a supplement to user-facing high-level commands. These low-level commands operate on the level of the internal representation instead of using friendly abstractions. That makes those commands very flexible and powerful, though perhaps not user-friendly.</p>
<h2 id="_idParaDest-225" class="calibre7"><a id="_idTextAnchor250" class="pcalibre1 pcalibre calibre6"/>Git objects</h2>
<p class="calibre3">In <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>, you<a id="_idIndexMarker821" class="pcalibre1 pcalibre calibre6"/> learned that Git represents history a<a id="_idIndexMarker822" class="pcalibre1 pcalibre calibre6"/>s the <strong class="bold">Directed Acyclic Graph</strong> (<strong class="bold">DAG</strong>) of revisions, where each revision is a graph node represented as a <strong class="bold">commit object</strong>. Each <a id="_idIndexMarker823" class="pcalibre1 pcalibre calibre6"/>commit is identified<a id="_idTextAnchor251" class="pcalibre1 pcalibre calibre6"/> by the SHA-1 identifier. We can use this identifier (in its full or ambiguous shortened form) to refer to any given version.</p>
<p class="calibre3">The commit object consists of revision metadata, links to zero or more parent commits, and the snapshot of the project’s files at the revision that it represents. The revision metadata includes information about who made changes and when, who created the commit object (who entered changes into the repository) and when, and of course the commit message.</p>
<p class="calibre3">Beyond this fact, it is also useful, in some cases, to know how Git internally represents the snapshot of a project’s files at the given revision. Git <a id="_idIndexMarker824" class="pcalibre1 pcalibre calibre6"/>uses <strong class="bold">tree objects</strong> to represent directories, and <strong class="bold">Binary Large Objects</strong> (<strong class="bold">blobs</strong>) to <a id="_idIndexMarker825" class="pcalibre1 pcalibre calibre6"/>represent the contents of a file.</p>
<p class="calibre3">Aside from the commit, tree, and blobs, there might also<a id="_idIndexMarker826" class="pcalibre1 pcalibre calibre6"/> be <strong class="bold">tag objects</strong> representing annotated and signed tags.</p>
<p class="calibre3">Each object is identified by the SHA-1 hash function over its contents, or to be more exact, over the type and the size of the object plus its contents. Such a content-based identifier does not require a central naming service. Thanks to this fact, each and every distributed repository of the same project will use the same identifiers, and we do not have to worry about name collisions:</p>
<pre class="console">
# calculate SHA-1 identifier of blob object with Git
$ printf "foo" | git hash-object -t blob --stdin
19102815663d23f8b75a47e7a01965dcdc96468c
# calculate SHA-1 identifier of blob object by hand
$ printf "blob 3\0foo" | sha1sum
19102815663d23f8b75a47e7a01965dcdc96468c</pre>
<p class="callout-heading">Object identifier – SHA-1 to SHA-256 transition</p>
<p class="callout">Over time, flaws in the SHA-1 hash function have been discovered. Therefore, Git will transition to using SHA-256 while providing interoperability. At the time of writing this, Git was still using SHA-1 by default.</p>
<p class="calibre3">We can say that the <a id="_idIndexMarker827" class="pcalibre1 pcalibre calibre6"/>Git repository is the content-addressed object database. That is, of course, not all there is; there are also references (branches and tags), various configuration files, and other things.</p>
<p class="calibre3">Let’s describe Git objects in more detail, starting from the bottom up. We can examine objects with the low-level <code>git </code><code>cat-file</code> command:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Blob</strong>: These objects store the contents of the file at the given revision. Such an object can be created using the low-level <strong class="source-inline1">git hash-object -w</strong> command. Note that if different revisions have the same contents of a file, it is stored only once thanks to content-based addressing:<pre class="source-code">
<strong class="bold1">$ git cat-file blob HEAD:COPYRIGHT</strong></pre><pre class="source-code">
<strong class="bold1">Copyright (c) 2014 Company</strong></pre><pre class="source-code">
<strong class="bold1">All Rights Reserved</strong></pre></li>
<li class="calibre15"><strong class="bold">Tree object</strong>: These objects represent directories. Each tree object is a list of entries, sorted by filename. Each entry is composed of combined permissions and type, the name of the file or directory, and the link (that is, SHA-1 identifier) of an object connected with the given path, either the tree object (representing the subdirectory), the blob (representing the file contents), or rarely the commit object (representing the submodule; see <a href="B21194_11.xhtml#_idTextAnchor270" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>, <em class="italic">Managing Subprojects</em>). Note that if different revisions have the same contents of a subdirectory, it will be stored only once thanks to content-based addressing:<pre class="source-code">
<strong class="bold1">$ git cat-file -p HEAD^{tree}</strong></pre><pre class="source-code">
<strong class="bold1">100644 blob 862aafd...</strong></pre><pre class="source-code">
<strong class="bold1">COPYRIGHT</strong></pre><pre class="source-code">
<strong class="bold1">100644 blob 25c3d1b...</strong></pre><pre class="source-code">
<strong class="bold1">Makefile</strong></pre><pre class="source-code">
<strong class="bold1">100644 blob bdf2c76...</strong></pre><pre class="source-code">
<strong class="bold1">README</strong></pre><pre class="source-code">
<strong class="bold1">040000 tree 7e44d2e...</strong></pre><pre class="source-code">
<code>git update-index</code> command) with <code>git write-tree</code>.</p></li>
<li class="calibre15"><strong class="bold">Commit object</strong>: These objects represent revisions. Each commit is composed of a set of headers (key-value data) that includes zero or more <strong class="source-inline1">parent</strong> lines and exactly one tree line with the link to the <strong class="source-inline1">tree</strong> object representing a snapshot of the repository contents (the top directory of a project). You can create a commit with a given tree object as a revision snapshot by using the low-level <strong class="source-inline1">git commit-tree</strong> command, or by simply using <strong class="source-inline1">git commit</strong>:<pre class="source-code">
<strong class="bold1">$ git cat-file -p HEAD</strong></pre><pre class="source-code">
<strong class="bold1">tree 752f12f08996b3c0352a189c5eed7cd7b32f42c7</strong></pre><pre class="source-code">
<strong class="bold1">parent cbb91914f7799cc8aed00baf2983449f2d806686</strong></pre><pre class="source-code">
<strong class="bold1">parent bb71a804f9686c4bada861b3fcd3cfb5600d2a47</strong></pre><pre class="source-code">
<strong class="bold1">author Joe Hacker &lt;joe@example.com&gt; 1401584917 +0200</strong></pre><pre class="source-code">
<strong class="bold1">committer Bob Developer &lt;bob@example.com&gt; 1401584917 +0200</strong></pre><pre class="source-code">
<strong class="bold1">Merge remote branch 'origin/multiple'</strong></pre></li>
<li class="calibre15"><strong class="bold">Tag object</strong>: These objects represent annotated tags, of which signed tags are a special case. Tags (lightweight and annotated) give a permanent name to a commit (such as <strong class="source-inline1">v0.2</strong>) or any object. Tag objects also consist of a series of headers (including links to the tagged object) and the tag message. You can create the tag object <a id="_idIndexMarker829" class="pcalibre1 pcalibre calibre6"/>with a low-level <strong class="source-inline1">git mktag</strong> command, or simply with <strong class="source-inline1">git tag</strong>:<pre class="source-code">
<strong class="bold1">$ git cat-file tag v0.2</strong></pre><pre class="source-code">
<strong class="bold1">object 5d2584867fe4e94ab7d211a206bc0bc3804d37a9</strong></pre><pre class="source-code">
<strong class="bold1">type commit</strong></pre><pre class="source-code">
<strong class="bold1">tag v0.2</strong></pre><pre class="source-code">
<strong class="bold1">tagger John Tagger &lt;john@example.com&gt; 1401585007 +0200</strong></pre><pre class="source-code">
<strong class="bold1">random v0.2</strong></pre></li>
</ul>
<p class="callout-heading">Internal datetime format</p>
<p class="callout">The Git internal format for the author, the committer, and the tagger dates is <strong class="bold">&lt;unix timestamp&gt; &lt;timezone offset&gt;</strong>. The Unix timestamp (POSIX time) is the number of seconds since the Unix epoch, which is 00:00:00 <strong class="bold">Coordinated Universal Time</strong> (<strong class="bold">UTC</strong>), Thursday, January 1st, 1970 (1970-01-01T00:00:00Z), not counting leap seconds. This denotes<a id="_idIndexMarker830" class="pcalibre1 pcalibre calibre6"/> when the event took place. You can print the Unix timestamp with <strong class="source-inline1">date "%s"</strong> and convert it into other formats with <strong class="source-inline1">date --date="@&lt;timestamp&gt;"</strong>.</p>
<p class="callout">The timezone offset is a positive or negative offset from UTC, in the <strong class="bold">HHMM</strong> (hours, minutes) format. For example, CET (the timezone that is 2 hours ahead of UTC) is +0200. This can be used to find the local time for an event.</p>
<p class="calibre3">The relationship between different types of Git objects mentioned here is shown in <em class="italic">Figure 10</em><em class="italic">.1</em>. It represents a typical case, with a tag pointing to a commit and with commits sharing the same <a id="_idIndexMarker831" class="pcalibre1 pcalibre calibre6"/>contents of at least some files.</p>
<div><div><img alt="Figure 10.1 – The Git repository object model" src="img/B21194_10_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The Git repository object model</p>
<p class="calibre3">Some Git commands work on any type of object. For example, you can tag any type of object, not only commits. You can, among other things, tag a blob to keep some unrelated piece of <a id="_idIndexMarker832" class="pcalibre1 pcalibre calibre6"/>data in the repository and have it available in each clone. Public keys can be such data.</p>
<p class="calibre3">Notes and replacements, which will be described later in this chapter, also work on any type of object.</p>
<h2 id="_idParaDest-226" class="calibre7"><a id="_idTextAnchor252" class="pcalibre1 pcalibre calibre6"/>Plumbing and porcelain Git commands</h2>
<p class="calibre3">Git was developed in<a id="_idIndexMarker833" class="pcalibre1 pcalibre calibre6"/> a bottom-up fashion. This means that its development started from basic blocks and built upward. Many of the user-facing commands were once built as shell scripts utilizing these basic low-level blocks to do their work. Thanks to this, we can distinguish between the two types of Git commands.</p>
<p class="calibre3">The better-known<a id="_idIndexMarker834" class="pcalibre1 pcalibre calibre6"/> type is <strong class="bold">porcelain</strong> commands, which are high-level user-facing commands (<em class="italic">porcelain</em> is a play on words on calling engine-level commands <em class="italic">plumbing</em>). The output of these commands is intended for the end user. This means that their output can be changed to be more user-friendly. Therefore, their output can be different in different Git versions. The user is smart enough to understand what happens if they are presented with additional information, changed wording, or changed formatting (for example).</p>
<p class="calibre3">This is not the case for the scripts you may write in this chapter, such as those used for rewriting with <code>git filter-repo</code>. Here, you need unchanging output – well, at least for the scripts that are used more than once (as hooks, as <code>.gitattribute</code> drivers, and as helpers). You can often find a switch, usually named <code>--porcelain</code>, that ensures that the command output is immutable. For other commands, the solution is to specify the format fully. Alternatively, you can use low-level commands intended for scripting: <strong class="bold">plumbing</strong> commands. These<a id="_idIndexMarker835" class="pcalibre1 pcalibre calibre6"/> commands usually do not have user-friendly defaults, not to mention a “do what I mean” quality. Their output also does not depend on the Git configuration; not many of them can be configured via the Git configuration file.</p>
<p class="calibre3">The <code>git(1)</code> manpage includes a list of all the Git commands, separated into porcelain and plumbing. The distinction between plumbing and porcelain commands was mentioned as a tip in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>, when we encountered the first low-level plumbing command without a user-facing and user-friendly porcelain equivalent.</p>
<h1 id="_idParaDest-227" class="calibre5"><a id="_idTextAnchor253" class="pcalibre1 pcalibre calibre6"/>Rewriting history</h1>
<p class="calibre3">Many times, while <a id="_idIndexMarker836" class="pcalibre1 pcalibre calibre6"/>working on a project, you may want to revise your commit history. One reason for this could be to make it easier to review before submitting the changes upstream. Another reason would be to take reviewer comments into account in the next improved version of changes. Or perhaps you’d like to have a clear history while finding regressions using bisection, as described in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring </em><em class="italic">Project History</em>.</p>
<p class="calibre3">One of the great things about Git is that it makes revising and rewriting history possible while providing a wide set of tools to revise history and make it clean.</p>
<p class="callout-heading">Views on rewriting history</p>
<p class="callout">There are two conflicting views among users of the version control system. One states that history is sacred and that you should show the true history of the development, warts, and all. The other states that you should clean up the new history for better readability before publishing it.</p>
<p class="calibre3">An important issue to note is that even though we talk about “rewriting” the history, objects in Git (including commits) are <code>ORIG_HEAD</code>). Well, at least they will be there until they get pruned (that is, deleted) as unreferenced and unreachable objects during garbage collection, though this only happens after the reflog expires.</p>
<h2 id="_idParaDest-228" class="calibre7"><a id="_idTextAnchor254" class="pcalibre1 pcalibre calibre6"/>Amending the last commit</h2>
<p class="calibre3">The simplest case <a id="_idIndexMarker838" class="pcalibre1 pcalibre calibre6"/>of history rewriting is correcting the latest commit on a branch.</p>
<p class="calibre3">Sometimes you might notice a typo (an error) in a commit message, or that you have committed an incomplete change in the last revision. If you have not pushed (published) your changes, you can <code>--amend</code> option to the <code>git </code><code>commit</code> command.</p>
<p class="calibre3">The result of amending a commit is shown in <em class="italic">Figure 6</em> in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>. Note that there is no functional difference between amending the last commit and changing some commits deeper in the history. In both cases, you are creating a new commit, leaving the old version referenced by the reflog. The difference is in what happens to other commits.</p>
<p class="calibre3">Here, the index (that is, the explicit staging area for commits) shows its usefulness again. For example, if you want to simply fix only the commit message and you do not want to make any other changes, you can use <code>git commit --amend</code> (note the lack of an <code>-a</code> or <code>--all</code> option). This works even if you have started work on a new commit – at least, assuming that you didn’t add any changes to the index. If you did, you can put them away temporarily with <code>git stash</code>, fix the commit message of the last commit, and then pop stashed changes and restore the index with <code>git stash </code><code>pop --index</code>.</p>
<p class="calibre3">If, on the other hand, you realize that you have forgotten some changes, you can just edit the files and use <code>git commit --amend --all</code>. If the changes are interleaved, you can use <code>git add</code> or its interactive version (utilizing knowledge from <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>) to create<a id="_idIndexMarker840" class="pcalibre1 pcalibre calibre6"/> the contents you want to have, finalizing it with <code>git </code><code>commit --amend</code>.</p>
<h2 id="_idParaDest-229" class="calibre7"><a id="_idTextAnchor255" class="pcalibre1 pcalibre calibre6"/>The interactive rebase</h2>
<p class="calibre3">Sometimes you might <a id="_idIndexMarker841" class="pcalibre1 pcalibre calibre6"/>want to edit commits deeper in the <a id="_idIndexMarker842" class="pcalibre1 pcalibre calibre6"/>history or reorganize commits into a logical sequence of steps. One of the built-in tools in Git that you can use for this purpose is <code>git </code><code>rebase --interactive</code>.</p>
<p class="calibre3">Here, we will assume that you are working on a feature using a separate topic branch, as well as a topic branch workflow described and recommended in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>. We will also assume that you are doing the work in a series of logical steps rather than in one large commit.</p>
<p class="calibre3">When implementing a new feature, you usually won’t do it perfectly from the very beginning. You would want to introduce it in a series of small self-contained steps (see <a href="B21194_15.xhtml#_idTextAnchor371" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 15</em></a>, <em class="italic">Git Best Practices</em>) to make code review, code audit, and bisection (finding the cause of regressions bugs) easier. Often, you will only see how to split it better after finishing the work. It is also unreasonable to expect that you would not make mistakes while implementing a new feature.</p>
<p class="calibre3">Before submitting the changes (by either pushing them to the central repository, pushing them to your own public repository and sending pull requests, or using some other workflow described in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>), you will often want to update your branch to the up-to-date state of the project to make it easier to merge. By rebasing your changes on top of the current state and having them up-to-date, you will make it easier for the maintainer (the integration manager) to ultimately merge your changes when they are accepted for inclusion into the mainline. <strong class="bold">Interactive rebase</strong> allows you to clean up history, as described earlier, while doing this work.</p>
<p class="calibre3">Aside from tidying up changes before publishing them, there is also additional use for tools such as interactive rebases. While working on a more involved feature, the very first submission is not always accepted into an upstream and added to the project. Often, the process of patch review finds problems with the code, or with the explanation of the changes. Perhaps something is missing (for example, the feature might lack documentation or tests), some commit needs to be fixed, or the submitted series of patches (or the branch submitted in the pull request) should be split into smaller commits for<a id="_idIndexMarker843" class="pcalibre1 pcalibre calibre6"/> easy review. In this case, you would also <a id="_idIndexMarker844" class="pcalibre1 pcalibre calibre6"/>use an interactive rebase (or an equivalent tool) to prepare a new version to submit, taking into account the results of the code inspection.</p>
<h3 class="calibre9">Reordering, removing, and fixing commits</h3>
<p class="calibre3">Rebase, as <a id="_idIndexMarker845" class="pcalibre1 pcalibre calibre6"/>described<a id="_idIndexMarker846" class="pcalibre1 pcalibre calibre6"/> in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>, consists <a id="_idIndexMarker847" class="pcalibre1 pcalibre calibre6"/>of taking a series of changes of the commits being rebased and reapplying them on top of a new base (a new commit). In other words, rebase moves changesets, not snapshots. Git starts the interactive rebase by opening the instructions sheet corresponding to those operations of reapplying changes in the editor.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can configure the text editor used for editing the rebase instruction file separately from the default editor (which is used, for example, to edit commit messages) with the <strong class="source-inline1">sequence.editor</strong> configuration variable, which can in turn be overridden by the <strong class="source-inline1">GIT_SEQUENCE_EDITOR</strong> environment variable.</p>
<p class="calibre3">Like in the case of the template for editing commits, the instruction sheet is accompanied by the comments explaining what you can do with it (note that if you are using older Git, some <a id="_idIndexMarker848" class="pcalibre1 pcalibre calibre6"/>interactive rebase commands might <a id="_idIndexMarker849" class="pcalibre1 pcalibre calibre6"/>be <a id="_idIndexMarker850" class="pcalibre1 pcalibre calibre6"/>missing from this sheet):</p>
<pre class="source-code">
pick 89579c9 first commit in a branch
pick d996b71 second commit in a branch
pick 6c89dee third commit in a branch
# Rebase 89579c9..6c89dee onto b8fffe1 (3 commands)
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#  d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.</pre>
<p class="calibre3">Note that empty commits will be marked with <code># empty</code> at the end of the line. Depending on your version of Git and your configuration, the instruction sheet may include more commands.</p>
<p class="calibre3">As explained in the comments, the instructions are in the order of execution, starting from the instruction on the top to create the first commit (with the new base as its parent) and ending at the bottom with the instruction copying the commit at the tip of the branch being rebased. This means that revisions are listed in an increasing chronological order, with older commits first. This is the reverse order from the <code>git log</code> output, with the most recent commit first (unless you are using <code>git log --reverse</code>). This is quite understandable; the rebase reapplies changesets in the order in which they were<a id="_idIndexMarker851" class="pcalibre1 pcalibre calibre6"/> added<a id="_idIndexMarker852" class="pcalibre1 pcalibre calibre6"/> to the branch, while <a id="_idIndexMarker853" class="pcalibre1 pcalibre calibre6"/>the log operation shows commits in the order of reachability from the tips.</p>
<p class="calibre3">Each line of the instruction sheet consists of three elements, separated by spaces:</p>
<ul class="calibre16">
<li class="calibre15">First, there is a one-word command. By default, the interactive rebase starts with <strong class="source-inline1">pick</strong>. Each command has a one-letter shortcut that you can use instead of the long form, as shown in the comments (for example, you can use <strong class="source-inline1">p</strong> in place of <strong class="source-inline1">pick</strong>).</li>
<li class="calibre15">Next, there is a uniquely shortened SHA-1 identifier of a commit to be used with the command. Strictly speaking, it is the identifier of a commit being rebased, which it had before the rebase process started. This shortened SHA-1 identifier is used to pick the appropriate commit (for example, when reordering lines of the interactive rebase instruction sheet, which effectively<a id="_idIndexMarker854" class="pcalibre1 pcalibre calibre6"/> means <strong class="bold">reordering commits</strong>).</li>
<li class="calibre15">Lastly, there is the description (subject) of a commit. It is taken from the first line of the commit message. More specifically, it is the first paragraph of the commit message with the line breaks removed, where a paragraph is defined as the set of subsequent lines of text, separated from other paragraphs by at least one empty line – that is, two or more end-of-line characters. This is one of the reasons why the first line of the commit message should be a short description of changes (see <a href="B21194_15.xhtml#_idTextAnchor371" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 15</em></a>, <em class="italic">Git Best Practices</em>). This description is for you to help decide what to do with the commit; Git uses its SHA-1 identifier and ignores the rest of the line.</li>
</ul>
<p class="calibre3">Reordering commits with the interactive rebase is as simple as reordering lines in the instruction sheet. Note, however, that if the changes are not independent, you might need to resolve conflicts, even if there would be no merge conflicts without reordering. In such cases, as instructed by Git, you will need to fix conflicts, mark conflicts as resolved (for example, with <code>git add</code>), and then run <code>git rebase --continue</code>. Git will remember that you are in the middle of an interactive rebase, so you don’t need to repeat the <code>--</code><code>interactive</code> option.</p>
<p class="calibre3">The other possibility of dealing with a conflict is skipping a commit, rather than resolving a conflict, by running <code>git rebase --skip</code>. By default, rebase removes changes that are already present in upstream; you might want to use this command in case the rebase didn’t<a id="_idIndexMarker855" class="pcalibre1 pcalibre calibre6"/> detect<a id="_idIndexMarker856" class="pcalibre1 pcalibre calibre6"/> correctly that the <a id="_idIndexMarker857" class="pcalibre1 pcalibre calibre6"/>commit in question is already there in the branch we are transplanting revisions onto. In other words, do skip a commit if you know that the correct resolution of a conflict is an empty changeset.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can also make Git present you with the instruction sheet again at any time when rebase stops for some reason (including an error in the instruction sheet, such as using the <strong class="source-inline1">squash</strong> command with the first commit). You can do this with the <strong class="source-inline1">git rebase --edit-todo command</strong>. After editing it, you can continue the rebase.</p>
<p class="calibre3">To <code>drop</code> command. You can use it to drop failed experiments or to make it easier on the rebase by deleting changesets that you know are already present in the upstream being rebased onto (though perhaps in a different form). Note though that removing the instruction sheet altogether aborts the rebase.</p>
<p class="calibre3">To <code>pick</code> command preceding the relevant commit in the instruction sheet to <code>edit</code> (or just <code>e</code>). This would make the rebase stop at this commit, that is, at this step of reapplying changes, similar to what happens in the case of a conflict. To be precise, the interactive rebase applies the commit in question, making it the <code>HEAD</code> commit, and then stops the process, giving control to the user . You can then fix this commit as if it were the current one with <code>git commit --amend</code>, as described in <em class="italic">Amending the last commit</em>. After changing it to your liking, run <code>git rebase --continue</code>, as explained in the instruction that Git prints.</p>
<p class="callout-heading">Tip</p>
<p class="callout">A proper Git-aware command line prompt, such as the one from the Git <strong class="source-inline1">`contrib/` </strong>directory in the Git source code, would tell you when you are in the middle of the rebase (see <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and Extending Git</em>). If you are not using such a prompt, you can always check what’s happening with <strong class="source-inline1">git status</strong>, which says that there is a rebase in progress in such cases. You can also find instructions on what you can do next there.</p>
<p class="calibre3">Alternatively, you can always go to the state before starting the rebase with the <code>git rebase --</code><code>abort</code> command.</p>
<p class="calibre3">If you only want to change the commit message (for example, to fix a spelling error or to include additional information), you can skip the need to run <code>git commit --amend</code> and then <code>git rebase --continue</code> by using <code>reword</code> (or <code>r</code>) instead of <code>edit</code>. Git will <a id="_idIndexMarker859" class="pcalibre1 pcalibre calibre6"/>then <a id="_idIndexMarker860" class="pcalibre1 pcalibre calibre6"/>automatically<a id="_idIndexMarker861" class="pcalibre1 pcalibre calibre6"/> open the editor with the commit message. Saving changes and exiting the editor will commit the changes, amend the commit, and continue the rebase.</p>
<h3 class="calibre9">Squashing commits</h3>
<p class="calibre3">Sometimes you might <a id="_idIndexMarker862" class="pcalibre1 pcalibre calibre6"/>need to make one commit out of two or more, squashing them together. Maybe you decided that it didn’t make sense to split the changes and that they are better together.</p>
<p class="calibre3">With the interactive rebase you can reorder these commits as needed, so that they are next to each other. Then, keep the <code>pick</code> command for the first of the commits to be concatenated together (or change it to the <code>edit</code> command). For the rest of the commits, replace the <code>pick</code> command with either the <code>squash</code> or the <code>fixup</code> command. Git will then accumulate the changes and create the commit with all of them together. The suggested commit message for the folded commit is the commit message of the first commit, with the messages of the commits with the <code>squash</code> command appended. Commit messages with the <code>fixup</code> command are omitted. This means that the <code>squash</code> command is useful for squashing changes, while <code>fixup</code> is useful for adding fixes. If commits had different authors, the folded commit will be attributed to the author of the first commit. The committer will be you, the person performing the rebase.</p>
<p class="calibre3">Let’s assume that you noticed that you forgot to add some parts of the changes to the commit. Perhaps it is missing tests (or just negative tests) or documentation. The commit is in the past, so you cannot simply add to it by amending it. You could use the interactive rebase or the patch management interface to fix it, but it is often more effective to create the commit with forgotten changes and squash it later.</p>
<p class="calibre3">Similarly, when you notice that the commit you created a while ago has a bug, instead of trying to edit it immediately, you can create a <code>fixup</code> commit with a bug fix to be squashed later.</p>
<p class="calibre3">If you use this technique, there might be some delay between noticing the need to make changes or fix a bug and creating the appropriate commit. This gap includes the time taken for the rebase operation.</p>
<p class="calibre3">How do you then mark the commit being created for squashing or fixup? If you use the commit message beginning with the magic <code>squash! ...</code> or <code>fixup! ...</code> strings, respectively, preceding the description (the first line of the commit message, sometimes called the <code>rebase -i</code>. You can request this on an individual basis with the <code>--autosquash</code> option, or you can enable this behavior by default with the <code>rebase.autoSquash</code> configuration variable. To create an appropriate “magic” commit message, you can use <code>git commit --squash/--fixup</code> (when<a id="_idIndexMarker865" class="pcalibre1 pcalibre calibre6"/> creating the commit to be squashed into or the bugfix commit).</p>
<h3 class="calibre9">Splitting commits</h3>
<p class="calibre3">Sometimes, you<a id="_idIndexMarker866" class="pcalibre1 pcalibre calibre6"/> might want to make two commits or more out of one commit, splitting it into two or more parts. You may have noticed that the commit is too large, perhaps because it tries to do too much, and should be split into smaller pieces. Or perhaps you have decided that some part of a changeset should be moved from one commit to another, and extracting it into a separate commit is a first step toward accomplishing that.</p>
<p class="calibre3">Git does not provide a one-step built-in command for this operation. Nevertheless, splitting commits is possible with the clever use of the interactive rebase.</p>
<p class="calibre3">To split a given commit, first mark it with the <code>edit</code> action. As described earlier, Git will stop at the specified commit and give the control back to the user. In the case of splitting a commit, when returning control to Git with <code>git rebase --continue</code>, you would want to have two commits in place of one.</p>
<p class="calibre3">The problem of splitting a commit is comparable to the problem of having different changes tangled together in the working directory from <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing With Git</em> (the section about the interactive commit), and <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>. The difference is that in the case of splitting a commit with the interactive rebase, when the rebase stops for editing, the commit is already created and copied from the branch being rebased. This is simple to fix with <code>git reset HEAD^</code>; as described in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>, this command will keep the working area at the (entangled) state of the commit to be split while moving the <code>HEAD</code> pointer and the staging area for the commit to the state before this revision. Then you can interactively add those changes that you want to have in the first commit to the index, by composing the intermediate step in the staging area. Next, you should check whether you have what you want in the index, then create a commit from it using <code>git commit</code> without the <code>-a</code> or <code>--all</code> option. Repeat these last two steps as often as necessary.</p>
<p class="calibre3">For the last commit in the series (which would be the second one, if you are splitting the commit in two), you can do one of two things. The first option is to add everything to the index, making the working copy clean, and create a commit from the index. The other option is to create a commit from the state of the working area (<code>git commit --all</code>). If you want to keep or start from the commit message of the original commit to be split, you can provide it with the <code>--reuse-message=&lt;commit&gt;</code> or the <code>--reedit-message=&lt;commit&gt;</code> option while creating a commit. I think the simplest way of naming a commit that was split (or that is being split) is to use reflog – it will be the <code>HEAD@{n}</code> entry just before <code>reset: moving to HEAD^</code> in the <code>git </code><code>reflog</code> output.</p>
<p class="calibre3">Instead of crafting the commit in the staging area (the index) starting from the parent of the commit to be split and adding changes, perhaps interactively, you could start directly from the final state—the commit to be split—and remove the changes intended for the second step. This can be done, for example, with <code>git reset --patch HEAD^</code>. Frankly, you can use any combination of techniques from <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>. I find graphical commit tools such as <code>git gui</code> quite useful for this purpose (you can find out about graphical commit tools, including some examples, in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and </em><em class="italic">Extending Git</em>).</p>
<p class="calibre3">If you are not absolutely sure that the intermediate revisions you are creating in the index are consistent (they compile, pass the test suite, and so on), you should use <code>git stash save --keep-index</code> to stash away the not-yet-committed changes, bringing the working area to the state composed in the index. You can then test the changes and amend the staging area if fixes are necessary.</p>
<p class="calibre3">Alternatively, you can create the commit from the index and use a plain <code>git stash</code> command to save the state of <a id="_idIndexMarker867" class="pcalibre1 pcalibre calibre6"/>the working area after each commit. You can then test and amend the created intermediate commit if fixes are necessary. In both cases, you need to restore the changes with <code>git stash pop</code> before working on a new commit in the split.</p>
<h3 class="calibre9">Testing each rebased commit</h3>
<p class="calibre3">A good software <a id="_idIndexMarker868" class="pcalibre1 pcalibre calibre6"/>development practice is to test each change before committing it. However, this practice is not always followed. Let’s assume that you forgot to test some commit or skipped it because the change seemed trivial and you were pressed for time. The interactive rebase allows you to <code>exec</code> (or <code>x</code>) action. It is run between steps of rebasing commits. The <code>exec</code> command itself is formatted in a different way from the commands described earlier in this chapter: instead of SHA-1 and a summary of a commit, you provide the command to run.</p>
<p class="calibre3">The <code>exec</code> command launches the provided command (given by the rest of the line) in a shell: the one specified in the <code>SHELL</code> environment variable, or the default shell if <code>SHELL</code> is not set. This means that you can use shell feature. For the POSIX shell, this would mean using <code>cd</code> to change directories, <code>&gt;</code> to redirect command output, <code>;</code> and <code>&amp;&amp;</code> to sequence multiple commands, and so on. It is important to remember that the command to be executed is run from the root of the working tree, not from the current directory (i.e., not from the subdirectory you were in when starting the interactive rebase).</p>
<p class="calibre3">If you are strict about not publishing untested changes, you might have worried about the fact that rewritten commits rebased on top of the new changes might not pass tests, even if the original commits did. You can, however, make the interactive rebase test each commit <a id="_idIndexMarker869" class="pcalibre1 pcalibre calibre6"/>with the <code>--exec</code> option. Here is an example:</p>
<pre class="console">
$ git rebase --interactive --exec "make test"</pre>
<p class="calibre3">This would modify the starting instruction sheet, inserting <code>exec make test</code> after each entry:</p>
<pre class="source-code">
pick 89579c9 first commit in a branch
exec make test
pick d996b71 second commit in a branch
exec make test
pick 6c89dee third commit in a branch
exec make test</pre>
<h2 id="_idParaDest-230" class="calibre7"><a id="_idTextAnchor256" class="pcalibre1 pcalibre calibre6"/>External tools – patching management interfaces</h2>
<p class="calibre3">You might prefer to<a id="_idIndexMarker870" class="pcalibre1 pcalibre calibre6"/> fix the old commit immediately at the time when you notice the bug, instead of postponing it until the time when the branch is rebased. The latter is usually done just before the branch is sent for review (to publish it). This might be quite some time after realizing the need to edit the past commit.</p>
<p class="calibre3">Git itself doesn’t make it easy to fix the found bug straight away, or at least, not with built-in tools. You can, however, find third-party external tools that implement the patch management interface on the top of Git. Examples of such tools include <strong class="bold">Stacked Git</strong> (<strong class="bold">StGit</strong>) and <strong class="bold">Git Quilt</strong> (<strong class="bold">Guilt</strong>) – the<a id="_idIndexMarker871" class="pcalibre1 pcalibre calibre6"/> latter<a id="_idIndexMarker872" class="pcalibre1 pcalibre calibre6"/> is unmaintained, but still usable.</p>
<p class="calibre3">These tools provide similar functionality<a id="_idIndexMarker873" class="pcalibre1 pcalibre calibre6"/> to <strong class="bold">Quilt</strong> (that is, pushing or popping patches to and from a stack). With such tools, you have a set of work-in-progress “floating” patches in the Quilt-like stack. You also have accepted changes in the form of proper Git commits. You can convert <a id="_idIndexMarker874" class="pcalibre1 pcalibre calibre6"/>between <strong class="bold">patch</strong> and commit and vice-versa, move and edit patches around, move and edit commits (which is done by turning the commit and its children into patches, reordering or editing patches, and then turning patches back into commits again), squash patches, and so on.</p>
<p class="calibre3">This is, however, an additional tool to install, an additional set of operations to learn (even if they make your work easier), and an additional set of complications coming from the boundary <a id="_idIndexMarker875" class="pcalibre1 pcalibre calibre6"/>between Git and the tool in question. An interactive rebase is powerful enough nowadays, and, with autosquash, the need for another layer on top of Git is lessened.</p>
<h2 id="_idParaDest-231" class="calibre7"><a id="_idTextAnchor257" class="pcalibre1 pcalibre calibre6"/>Rewriting project history with Git filter-repo</h2>
<p class="calibre3">In some use <a id="_idIndexMarker876" class="pcalibre1 pcalibre calibre6"/>cases, you might need to use a more powerful tool for rewriting and cleaning up history than the interactive rebase. You might want something that would rewrite full history non-interactively when given some specified algorithm for doing the rewrite. Such a situation is a task for the <code>git </code><code>filter-repo</code> command.</p>
<p class="calibre3">This is an external project that needs to be installed in addition to Git. However, as it is a single-file Python script, installing it is trivial in most cases. It is now recommended by the Git project to use <code>git filter-repo</code> project instead of the built-in <code>git filter-branch</code> command (which is now deprecated).</p>
<p class="calibre3">The calling convention of this command is rather different than the convention for the interactive rebase. By default, it operates on the whole history of the project, changing the full graph of revisions, though you can limit the operation to a selected branch or set of branches with the <code>--</code><code>refs</code> option.</p>
<p class="calibre3">This command rewrites the Git revision history by applying custom filters on each revision to be rewritten. That’s another difference: rebase works by reapplying changesets, while <code>filter-branch</code> works with snapshots. One of the consequences of this is that for <code>git filter-repo</code>, a merge is simply a kind of a commit object, while the rebase drops merges and puts commits into a line, at least unless you use the <code>--</code><code>rebase-merges</code> option.</p>
<p class="calibre3">Of course, with <code>git filter-repo</code>, you describe how to do the rewrite with appropriate options instead of doing the rewriting interactively. This means that the speed of the operation is not limited by the speed of user <a id="_idIndexMarker877" class="pcalibre1 pcalibre calibre6"/>interaction but by I/O.</p>
<p class="callout-heading">Safety check</p>
<p class="callout">Since <strong class="source-inline1">git filter-repo</strong> is usually used for massive rewrites and does irreversible rewriting of the project’s history, it needs to be run from the fresh clone. This means that the user would always have a good backup in the form of a separate clone. If anything goes wrong, you can simply delete your clone and restart.</p>
<p class="callout">You can make <strong class="source-inline1">git filter-repo</strong> ignore the fresh clone check with the <strong class="source-inline1">--</strong><strong class="source-inline1">force</strong> option.</p>
<h3 class="calibre9">Running filter-repo without filters</h3>
<p class="calibre3">If you specify<a id="_idIndexMarker878" class="pcalibre1 pcalibre calibre6"/> no filters, <code>filter-repo</code> will error out unless you specify <code>--force</code>. In this case, the commits will be recommitted without any changes. Such usage would normally have no effect, but it is permitted to allow you to compensate for some Git bugs in the future.</p>
<p class="calibre3">This means that <code>git filter-repo --force</code>, without other options, can be used to make effects implemented by replacement refs permanent. This way, you can use the following technique: use <code>git replace</code> on specified commits to alter history, ensure that it looks correct, and then make the modification permanent. This is the simplest way to do commit<a id="_idIndexMarker879" class="pcalibre1 pcalibre calibre6"/> parent rewriting.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">The <strong class="source-inline1">git filter-repo</strong> command command respects <strong class="bold">replacements</strong> (refs in the <strong class="source-inline1">refs/replace/</strong> namespace).  Replacements is a technique to affect the history (or rather, a view of it) without rewriting any revisions. It will be explained later in the <em class="italic">Replacements </em><em class="italic">mechanism</em> section.</p>
<h3 class="calibre9">Available filter types for filter-repo</h3>
<p class="calibre3">There is a large <a id="_idIndexMarker880" class="pcalibre1 pcalibre calibre6"/>set of different filtering options to specify how to rewrite history. You can specify more than one option; they are applied in the order in which they are presented.</p>
<p class="calibre3">You can run the command multiple times to achieve your desired results. The <code>--analyze</code> option can be used to analyze repository history, creating a directory of reports, which (among other things) mention renames and list object sizes. This information may be useful in choosing how to filter your repo and to verify the changes.</p>
<p class="calibre3">The <code>git filter-repo</code> command supports the following types of filters:</p>
<ul class="calibre16">
<li class="calibre15">Filtering based on paths, which specifies the paths to select or exclude. Note that renames are not followed, so you may need to specify both the old and new names of the path.</li>
<li class="calibre15">Renaming paths, which may be combined with path filtering.</li>
<li class="calibre15">Content editing filters, which involve replacing text in a project’s files, removing large blobs (files), or removing specified blobs (versions of file contents).</li>
<li class="calibre15">Filtering commit messages with special support for filtering author names and emails with the help of <strong class="source-inline1">.mailmap</strong> or a mailmap-like file.</li>
<li class="calibre15">Renaming tags, which involves replacing one tag prefix with another.</li>
</ul>
<p class="calibre3">For flexibility, <code>filter-repo</code> also allows you to specify functions in Python to further filter all changes using custom API, with various <code>--&lt;something&gt;-callback</code> options, such as (for example) <code>--filename-callback</code> or <code>--commit-callback</code>.</p>
<p class="calibre3">You can also configure how commits are rewritten and pruned. For example, you can decide whether to re-encode commit message into UTF-8, or whether to prune commits that have become<a id="_idIndexMarker881" class="pcalibre1 pcalibre calibre6"/> empty (that is, ones that bring no changes to the project).</p>
<h3 class="calibre9">Examples of using filter-repo</h3>
<p class="calibre3">Let’s assume that you<a id="_idIndexMarker882" class="pcalibre1 pcalibre calibre6"/> committed the wrong file to the repository by mistake, and you want to <code>git add .</code>, you included a generated file that was not properly ignored (such as perhaps a large binary file). Alternatively, it might have turned out that you don’t have the distribution rights to a file and you need to have it removed to avoid copyright violations. Using <code>git rm --cached</code> would only remove it from future commits. You can also quite easily remove the file from the latest version by amending the commit (as described earlier in this chapter).</p>
<p class="calibre3">Let’s assume that the file is called <code>passwords.txt</code>. To excise it from the entire history, you can use the following command:</p>
<pre class="console">
$ git filter-repo --path 'passwords.txt' --invert-paths</pre>
<p class="calibre3">If you want to delete all <code>.DS_Store</code> files in any directory (and not only from the top directory of the project), you can use one of two commands. Here is the first option:</p>
<pre class="console">
$ git filter-repo --invert-paths --path '.DS_Store' --use-base-name</pre>
<p class="calibre3">You can also use the following option:</p>
<pre class="console">
$ git filter-repo --invert-paths --path-glob '*/.DS_Store' --path '.DS_Store'</pre>
<p class="calibre3">You can use <code>filter-repo</code> to <code>***REMOVED***</code> if the replacement is not specified). For example, to remove accidentally committed GitHub Personal Access Tokens, you can use the file specifying the list of expressions, one per line. Let’s say that you create an <code>expressions.txt</code> file with the following contents:</p>
<pre class="source-code">
regex:ghp_ua[A-Za-z0-9]{20,}==&gt;&lt;access_token&gt;</pre>
<p class="calibre3">Then you need to run the following command:</p>
<pre class="console">
$ git filter-repo --replace-text expressions.txt</pre>
<p class="calibre3">You can use <code>filter-repo</code> to permanently <code>v1.0</code> tag, you can use the following:</p>
<pre class="console">
$ git replace --graft v1.0^{commit}
$ git filter-repo --force</pre>
<p class="calibre3">Another common case is to <code>git config</code> to set your name and email address before you started working and Git guessed them incorrectly (if it couldn’t guess, it would ask before allowing a commit). Maybe you want to open the sources of a formerly proprietary closed source program and need to change your internal corporate email to your personal<a id="_idIndexMarker883" class="pcalibre1 pcalibre calibre6"/> address. We’ll say that you want the change to be permanent instead of relying on the <code>.</code><code>mailmap</code> file.</p>
<p class="calibre3">In any case, you can change email addresses in a whole history with <code>filter-repo</code>:</p>
<pre class="console">
$ git filter-repo --use-mailmap</pre>
<p class="calibre3">If you are open-sourcing a project, you could also want to add the <code>Signed-off-by:</code> lines for the Digital Certificate of Origin (see <a href="B21194_15.xhtml#_idTextAnchor371" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 15</em></a>, <em class="italic">Git Best Practices</em>), and add the trailer to the commit message if one is not already present:</p>
<pre class="console">
$ git filter-repo --message-callback '
  if b"Signed-off-by:" not in message:
    message += "\n\nSigned-off-by: Joe Hacker &lt;joe@h.com&gt;"
  return message</pre>
<p class="calibre3">Suppose that you have noticed a typo in the name of a subdirectory, such as <code>inlude/</code> instead of <code>include/</code>. This can be fixed simply by running the following:</p>
<pre class="console">
$ git filter-repo --path-rename inlude/:include/</pre>
<p class="calibre3">Often, some part of a larger project will take on a life on its own. In those instances, it begins to make sense to separate the part from the project it started in. We would want to extract the history of this part to make its <strong class="bold">subdirectory the new root</strong>. To rewrite history in this way and discard all other history, you can run the following:</p>
<pre class="console">
$ git filter-repo --subdirectory-filter lib/foo</pre>
<p class="calibre3">However, perhaps a better <a id="_idIndexMarker884" class="pcalibre1 pcalibre calibre6"/>solution would be to use a specialized third-party tool, namely <code>git subtree</code>. This tool (and its alternatives) will be discussed in <a href="B21194_11.xhtml#_idTextAnchor270" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>, <em class="italic">Managing Subprojects</em>.</p>
<h2 id="_idParaDest-232" class="calibre7"><a id="_idTextAnchor258" class="pcalibre1 pcalibre calibre6"/>External tools for large-scale history rewriting</h2>
<p class="calibre3">The <code>git filter-repo</code> project is<a id="_idIndexMarker885" class="pcalibre1 pcalibre calibre6"/> not the only solution for a large-scale rewriting of the project’s history. There are other tools that are more specialized, perhaps including lots of predefined clean-up operations or providing some level of interactivity with the ability for scripted <a id="_idIndexMarker886" class="pcalibre1 pcalibre calibre6"/>rewrites (with a <strong class="bold">Read–Evaluate–Print Loop</strong> (<strong class="bold">REPL</strong>), similar to interactive shells in some interpreted programming languages).</p>
<h3 class="calibre9">Removing files from the history with the BFG Repo Cleaner</h3>
<p class="calibre3">The BFG Repo<a id="_idIndexMarker887" class="pcalibre1 pcalibre calibre6"/> Cleaner is<a id="_idIndexMarker888" class="pcalibre1 pcalibre calibre6"/> a specialized alternative to using <code>git filter-repo</code>. It is specialized for the purpose of cleaning bad data out of your Git repository history by removing files and directories and replacing text in files (for example, accidentally committed passwords or API keys with their placeholders). It can use multiple cores with parallel processing – BFG is written in Scala and uses JGit as a Git implementation.</p>
<p class="calibre3">BFG provides a set of command-line parameters that are specialized for removing files and fixing them, such as <code>--delete-files</code> or <code>--replace-text</code>, a “query language” of sorts. It lacks the flexibility of other tools. Nowadays, <code>filter-repo</code> can do everything it can. There is <a id="_idIndexMarker889" class="pcalibre1 pcalibre calibre6"/>even <code>filter-repo</code>.</p>
<p class="calibre3">One issue you need to remember is that BFG assumes that you have fixed the contents of your<a id="_idIndexMarker890" class="pcalibre1 pcalibre calibre6"/> current <a id="_idIndexMarker891" class="pcalibre1 pcalibre calibre6"/>commit.</p>
<h3 class="calibre9">Editing the repository history with reposurgeon</h3>
<p class="calibre3">The <code>git fast-import</code> format, which is a common export and import format among source control systems nowadays thanks to it being version control-agnostic. The <code>git filter-repo</code> tool, which was described earlier in this chapter, is also based on processing fast-import streams.</p>
<p class="calibre3">It can be used for history rewriting, including editing past commits and metadata, excising commits, squashing (coalescing) and splitting commits, removing files and directories from history, and splitting and joining history.</p>
<p class="calibre3">The advantage that <code>reposurgeon</code> has over <code>git filter-repo</code> is that it can be run in two modes: either as an interactive interpreter, a kind of debugger or editor for history, with command history and tab completion; or in a batch mode to execute commands given as arguments. This allows users to interactively inspect history and test changes, and then batch run them for all the revisions.</p>
<p class="calibre3">The disadvantage is in having to install and then learn to use a separate tool.</p>
<h2 id="_idParaDest-233" class="calibre7"><a id="_idTextAnchor259" class="pcalibre1 pcalibre calibre6"/>The perils of rewriting published history</h2>
<p class="calibre3">There is, however, a very <a id="_idIndexMarker894" class="pcalibre1 pcalibre calibre6"/>important principle to know about: you should never (or at least not without a very, very good reason) rewrite <em class="italic">published</em> history, especially when it comes to those commits that were pushed to the public repository or were otherwise made public. What you can do is change the parts of the graph of revisions that are private.</p>
<p class="calibre3">The reason behind this rule is that rewriting published history could cause trouble for downstream developers if they have based their changes on revisions that were rewritten.</p>
<p class="calibre3">This means that it is safe to rewrite and rebuild those public branches that are explicitly stated and documented to be in flux, for example, as a way of showing work in progress (such as <code>'</code><code>proposed-updates</code><code>'</code> type of branch, that is used to test merge all feature branches – see the <em class="italic">Visibility without integration</em> and <em class="italic">Progressive-stability branches</em> sections in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a><em class="italic">, Advanced Branching Techniques</em>). Another possibility for the safe rewriting of a public<a id="_idIndexMarker895" class="pcalibre1 pcalibre calibre6"/> branch is to do it at specific stages of the project’s life, namely after creating a new release; again, this needs to be documented.</p>
</div>


<div><h3 class="calibre9">The consequences of upstream rewrites</h3>
<p class="calibre3">Now you will see, in <a id="_idIndexMarker896" class="pcalibre1 pcalibre calibre6"/>a simple example, the perils of rewriting published history (for example, rebasing) and how it causes trouble. Let’s assume that there are two public branches that are of interest: <code>master</code> and <code>subsys</code>. The latter is based on (forked from) the former. Let’s also assume that a downstream developer (who might be you) created a new <code>topic</code> branch based on the <code>subsys</code> branch for their own work, but did not publish it yet; it is only present in their local repository. This situation is shown in <em class="italic">Figure 10</em><em class="italic">.2</em> (the revisions below the dashed lines, denoted by darker color, are present only in the local repository of the downstream developer).</p>
<div><div><img alt="Figure 10.2 – The state of the local repository of a downstream developer before the rewrite of the published history, with the new local work that was put on a topic branch" src="img/B21194_10_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The state of the local repository of a downstream developer before the rewrite of the published history, with the new local work that was put on a topic branch</p>
<p class="calibre3">Then, the upstream developer rewrites the <code>subsys</code> branch to start from the current (topmost) revision in the <code>master</code> branch. This operation is called rebase and was described in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em> (the previous chapter). Let’s assume that during the rewrite, one of the commits was dropped; perhaps the same change was already present in <code>master</code> and was skipped, perhaps it was dropped for some other reason, or perhaps it was or squashed into the previous commit with the interactive rebase. The public repository now looks as follows:</p>
<div><div><img alt="Figure 10.3 – The state of a public upstream repository after rewrite, with an emphasized old base of the rebased branch, plus a new base and rewritten commits (after the rebase)" src="img/B21194_10_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.3 – The state of a public upstream repository after rewrite, with an emphasized old base of the rebased branch, plus a new base and rewritten commits (after the rebase)</p>
<p class="calibre3">Note that in the default configuration, Git would refuse to push rewritten history (it would deny a non-fast-forward push). You would need to force the push.</p>
<p class="calibre3">The problem is with<a id="_idIndexMarker897" class="pcalibre1 pcalibre calibre6"/> merging changes based on the pre-rewrite versions of revisions, such as the <code>topic</code> branch in this example.</p>
<div><div><img alt="Figure 10.4 – The situation after merging the changes that were based on pre-rewrite revisions into post-rewrite branches" src="img/B21194_10_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.4 – The situation after merging the changes that were based on pre-rewrite revisions into post-rewrite branches</p>
<p class="calibre3">Notice that the merge brings the pre-rewrite version of revisions, including commits that were dropped during the rebase.</p>
<p class="calibre3">If neither the downstream developer nor the upstream one notices that the published history has been rewritten, and one of them merges changes from the <code>topic</code> branch into, for example, the <code>subsys</code> branch it was based on, the merge would bring about duplicated commits. As we can see in the example in <em class="italic">Figure 10</em><em class="italic">.3</em>, after such a merge (denoted by <strong class="bold">M13</strong> here), we have both the <strong class="bold">C3</strong>, <strong class="bold">C4</strong>, and <strong class="bold">C5</strong> pre-rewrite commits brought by the topic branch and the <strong class="bold">C3’</strong> and <strong class="bold">C5’</strong> post-rewrite commits (see <em class="italic">Figure 10</em><em class="italic">.4</em>). Note that the <strong class="bold">C4</strong> commit that<a id="_idIndexMarker898" class="pcalibre1 pcalibre calibre6"/> was removed in the rewrite is back – it might have been a security bug!</p>
<h3 class="calibre9">Recovering from an upstream history rewrite</h3>
<p class="calibre3">However, what<a id="_idIndexMarker899" class="pcalibre1 pcalibre calibre6"/> can we do if the upstream has rewritten the published history (for example, rebased it)? Can we avoid bringing the abandoned commits back and merging a duplicate or near-duplicate of the rewritten revisions? After all, if the rewrite is published, changing it would be yet another rewrite.</p>
<p class="calibre3">The solution is to rebase your work to fit with the new version from the upstream, moving it from the pre-rewrite upstream revisions to the post-rewrite ones.</p>
<div><div><img alt="Figure 10.5 – The situation after a downstream rebase of a topic branch" src="img/B21194_10_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.5 – The situation after a downstream rebase of a topic branch</p>
<p class="calibre3">In the case of our example, it would mean rebasing the <code>topic</code> branch onto a new (post-rewrite) version of <code>subsys</code>, as shown in <em class="italic">Figure 10</em><em class="italic">.5</em>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You might not have a local copy of the <strong class="source-inline1">subsys</strong> branch; in this case, do substitute <strong class="source-inline1">subsys</strong> with the respective remote-tracking branch, for example, <strong class="source-inline1">origin/subsys</strong>.</p>
<p class="calibre3">Depending on whether the <code>topic</code> branch is public or not, it might mean that you are now breaking the promise of unaltered public history for your downstream. Recovering from an upstream rewrite might then result in a ripple of rebases following the rewrite down the river of downstreams (dependent repositories).</p>
<p class="calibre3">An easy case is when <code>subsys</code> is simply rebased and the changes remain the same (which means that <code>topic</code> on top of its upstream, that is, <code>subsys</code>, with the following:</p>
<pre class="console">
$ git rebase subsys topic</pre>
<p class="calibre3">The <code>topic</code> part is not necessary if you are currently on it (if <code>topic</code> is the current branch). This rebases everything: the old version of <code>subsys</code> and your commits in <code>topic</code>. This solution, however, relies on the fact that <code>git rebase</code> would skip repeated commits (removing <strong class="bold">C3</strong>, <strong class="bold">C4</strong>, and <strong class="bold">C5</strong>, leaving only <strong class="bold">C10’</strong> and <strong class="bold">C12’</strong>). It might be better and less error-prone to assume the more difficult case.</p>
<p class="calibre3">The hard case is when rewriting <code>subsys</code> involved some changes and was not a pure rebase, or when an interactive rebase was used. In this case, it is better to explicitly move just your changes, namely <code>subsys@{1}..topic</code> (assuming that the <code>subsys@{1}</code> entry in the <code>subsys</code> reflog comes from before rewrite), stating that they are moved on top of the new <code>subsys</code>. This can be done with the <code>--</code><code>onto</code> option:</p>
<pre class="console">
$ git rebase --onto subsys subsys@{1} topic</pre>
<p class="calibre3">You can make Git <a id="_idIndexMarker900" class="pcalibre1 pcalibre calibre6"/>use the reflog to find a better common ancestor with the <code>--fork-point</code> option with the <code>git rebase</code> command, such as in the following example:</p>
<pre class="console">
$ git rebase --fork-point subsys topic</pre>
<p class="calibre3">The rebase would then move the changes to <code>topic</code>, starting with the result of the <code>git merge-base --fork-point subsys topic</code> command. However, if the reflog of the <code>subsys</code> branch does not contain necessary information, Git would fall back upstream, here to <code>subsys</code>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can use the interactive rebase instead of an ordinary rebase like in the narration mentioned earlier for better control at the cost of more work (for example, to drop commits that are already present, but are not detected by the rebase machinery as such).</p>
<h1 id="_idParaDest-234" class="calibre5"><a id="_idTextAnchor260" class="pcalibre1 pcalibre calibre6"/>Amending history without rewriting</h1>
<p class="calibre3">What should you<a id="_idIndexMarker901" class="pcalibre1 pcalibre calibre6"/> do if what you need to fix is in the published part of the history? As described in <em class="italic">The perils of rewriting published history</em>, changing those parts of the history that were made public can cause problems for downstream developers. You had better not touch this part of the graph of revisions.</p>
<p class="calibre3">There are a few solutions to this problem. The most commonly used one is to put in a new fixup commit with appropriate changes (for example, a typo fix in documentation). If what you need is to remove the changes, deciding that they turned out to be bad to have in the history, you can create a commit to revert the changes.</p>
<p class="calibre3">If you fix a commit or revert one, it would be nice to annotate that commit with the information that it was buggy, as well as which commit fixed (or reverted) it. Even though you cannot (and should not) edit the fixed commit to add this information if the commit is public, Git provides <a id="_idIndexMarker902" class="pcalibre1 pcalibre calibre6"/>the <strong class="bold">notes</strong> mechanism to append extra information to existing commits, which is a bit like publishing an addendum, errata, or amendment. However, remember that notes are not published by default; nonetheless, it is easy to publish them (you just need to remember to do it).</p>
<h2 id="_idParaDest-235" class="calibre7"><a id="_idTextAnchor261" class="pcalibre1 pcalibre calibre6"/>Reverting a commit</h2>
<p class="calibre3">If you need to <a id="_idIndexMarker903" class="pcalibre1 pcalibre calibre6"/>back out an existing commit, undoing the changes it brought, you can use <code>git revert</code>. As described in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em> (see, for example, <em class="italic">Figure 9</em><em class="italic">.5</em> in that chapter), the <code>revert</code> operation creates a commit with the reverse of any changes. For example, where the original adds a line, reversion removes it; where the original commit removes the line, reversion adds it.</p>
<p class="callout-heading">Trivia</p>
<p class="callout">Note that different version control systems use the name revert for different operations. In particular, it is often used to mean resetting the changes to a file back to the latest committed version, throwing away uncommitted changes. It is something that <strong class="source-inline1">git reset -- &lt;file&gt;</strong> does in Git.</p>
<p class="calibre3">This is best shown in an example. Let’s assume that the last commit on the <code>multiple</code> branch has the following summary of its changes:</p>
<pre class="console">
$ git show --stat multiple
commit bb71a804f9686c4bada861b3fcd3cfb5600d2a47
Author: Alice Developer &lt;alice@company.com&gt;
Date:   Sun Jun 1 03:02:09 2014 +0200
    Support optional &lt;count&gt; parameter
 src/rand.c | 26 +++++++++++++++++++++-----
 1 file changed, 21 insertions(+), 5 deletions(-)</pre>
<p class="calibre3">Reverting this commit (which requires a clean working directory) would create a new revision. This<a id="_idIndexMarker904" class="pcalibre1 pcalibre calibre6"/> revision undoes the changes that the reverted commit brought:</p>
<pre class="console">
$ git revert bb71a80
[master 76d9e25] Revert "Support optional &lt;count&gt; parameter"
 1 file changed, 5 insertions(+), 21 deletions(-)</pre>
<p class="calibre3">Git would ask for a commit message, which should explain why you reverted the given revision: how it was faulty, and why it needed to be reverted rather than fixed. The default is to give the SHA-1 of the reverted commit:</p>
<pre class="console">
$ git show --stat
commit 76d9e259db23d67982c50ec3e6f371db3ec9efc2
Author: Alice Developer &lt;alice@example.com&gt;
Date:   Tue Jun 16 02:33:54 2015 +0200
    Revert "Support optional &lt;count&gt; parameter"
    This reverts commit bb71a804f9686c4bada861b3fcd3cfb5600d2a47.
 src/rand.c | 26 +++++---------------------
 1 file changed, 5 insertions(+), 21 deletions(-)</pre>
<p class="calibre3">Compare the summary of changes for the commit and its revert. In the preceding example, the commit has 21 insertions and 5 deletions, while the revert has 5 insertions and 21 deletions (where line that changed from one version to the other counts as deletion of the old version and insertion of the new).</p>
<p class="calibre3">A common practice is<a id="_idIndexMarker905" class="pcalibre1 pcalibre calibre6"/> to leave the subject alone (which allows you to easily find reverts) but replace the content with a description of the reasoning behind the revert.</p>
<h3 class="calibre9">Reverting a faulty merge</h3>
<p class="calibre3">Sometimes, you <a id="_idIndexMarker906" class="pcalibre1 pcalibre calibre6"/>might need to undo the effect of a merge. Suppose that you have merged changes, but it turned out that they were merged prematurely and that the merge brings regressions.</p>
<p class="calibre3">Let’s say that the branch that was merged is named <code>topic</code>, and that you were merging it into the <code>master</code> branch. This situation is shown in <em class="italic">Figure 10</em><em class="italic">.6</em>.</p>
<div><div><img alt="Figure 10.6 – An accidental or premature merge commit, a starting point for reverting merges and redoing reverted merges." src="img/B21194_10_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.6 – An accidental or premature merge commit, a starting point for reverting merges and redoing reverted merges.</p>
<p class="calibre3">If you didn’t publish this merge commit before you noticed the mistake, and the unwanted merge exists only in your local repository, the e<a id="_idTextAnchor262" class="pcalibre1 pcalibre calibre6"/>asiest solution is to drop this commit with <code>git reset --hard HEAD^</code> (see <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>, for an explanation of the hard mode of <code>git reset</code>).</p>
<p class="calibre3">What do you do if you realize only later that the merge was incorrect, for example after one more commit was created on the <code>master</code> branch and published? One possibility is to revert the merge.</p>
<p class="calibre3">However, a merge <a id="_idIndexMarker907" class="pcalibre1 pcalibre calibre6"/>commit has more than one parent, which means more than one delta (or, more than one changeset). To run <code>revert</code> on a merge commit, you need to specify which patch you are reverting, or, in other words, which parent is the mainline. In this particular scenario, assuming that there was one more commit after the merge (and that the merge was two commits back in the history), the command to revert the merge would look like this:</p>
<pre class="console">
$ git revert -m 1 HEAD^^
[master b2d820c] Revert "Merge branch 'topic'"</pre>
<p class="calibre3">The situation after reverting a merge is shown in <em class="italic">Figure 10</em><em class="italic">.7</em>.</p>
<div><div><img alt="Figure 10.7  The history from the previous figure after reverting merge; the square boxes attached to selected commits symbolize their changesets in a diff-like format" src="img/B21194_10_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.7  The history from the previous figure after reverting merge; the square boxes attached to selected commits symbolize their changesets in a diff-like format</p>
<p class="calibre3">Starting with the new <strong class="bold">!M1</strong> commit (the <strong class="bold">!M1</strong> symbol is used to represent negation or reversal of the <strong class="bold">M1</strong> commit), it’s <a id="_idIndexMarker908" class="pcalibre1 pcalibre calibre6"/>as if the merge never happened, at least with regards to the changes.</p>
<h3 class="calibre9">Recovering from a reverted merge</h3>
<p class="calibre3">Let’s assume that <a id="_idIndexMarker909" class="pcalibre1 pcalibre calibre6"/>you continued work on a branch whose merge was reverted. Perhaps it was prematurely merged, but it doesn’t mean that the development on it has stopped. If you continue to work on the same branch, perhaps by creating commits with fixes, they will get ready in some time, and then you will need to be able to merge them correctly into the mainline again. Or perhaps the mainline will mature enough to be able to accept a merge. Trouble lies ahead if you simply try to merge your branch again the same way as last time.</p>
<div><div><img alt="Figure 10.8 – The unexpectedly erroneous result of trying to simply redo a reverted merge" src="img/B21194_10_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.8 – The unexpectedly erroneous result of trying to simply redo a reverted merge</p>
<p class="calibre3">The unexpected result, as shown in <em class="italic">Figure 10</em><em class="italic">.8</em>, is that Git has only brought the changes since the reverted merge. The changes brought by the commits on a side branch, whose merge got reverted, are not here. In other words, you would get a strange result: the new merge would not include the changes that were created on your branch (the side branch) before the merge that got reverted.</p>
<p class="calibre3">This is caused by the fact that <code>git revert</code> undoes changes (the data), but does not undo the history (the DAG of revisions). This means that the new merge sees <strong class="bold">C4</strong>, the commit on the side branch just before the reverted merge, as a common ancestor. Since the default three-way merge<a id="_idIndexMarker910" class="pcalibre1 pcalibre calibre6"/> strategy looks only at the state of the <em class="italic">ours</em>, <em class="italic">theirs</em>, and <em class="italic">base</em> snapshots, it doesn’t search through the history to find that there was a revert there. It sees that both the common ancestor <strong class="bold">C4</strong> and the merged branch (that is, <em class="italic">theirs</em>) <strong class="bold">C6</strong> do include features brought by the <strong class="bold">C3</strong> and <strong class="bold">C4</strong> commits, namely <strong class="bold">f3</strong> and <strong class="bold">f4</strong>, while the branch that we are merging into (that is, <em class="italic">ours</em>) doesn’t have them because of the revert.</p>
<p class="calibre3">For the merge strategy, it looks exactly like the case where one branch deleted something, which means that this change (the removal) is the result of the merge (it looks like the case where there was change on only one side). In particular, it looks like the base and the side branch have the feature, but the current branch doesn’t (because of the revert) – so the result doesn’t have it either. You can find an explanation of the merging mechanism in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging </em><em class="italic">Changes Together</em>.</p>
<p class="calibre3">There is more than one option to fix this issue and make Git re-merge the <code>topic</code> branch correctly, which means including the <code>proposed-updates</code> branch with all the topic branches merged in, it is with the understanding that they can and probably will be rewritten.</p>
<div><div><img alt="Figure 10.9  The history after re-merging (as M2) a reverted M1 merge, with revering revert !!M1 (replay)" src="img/B21194_10_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.9  The history after re-merging (as M2) a reverted M1 merge, with revering revert !!M1 (replay)</p>
<p class="calibre3">One option is to bring<a id="_idIndexMarker911" class="pcalibre1 pcalibre calibre6"/> back deleted changes by reverting the revert. The result is shown in <em class="italic">Figure 10</em><em class="italic">.9</em>. In this case, you have brought changes to match the recorded history.</p>
<p class="calibre3">Another option would be to change the view of the history (perhaps temporarily), for example, by amending it with <code>git replace</code>, or by changing the <code>topic</code>, were published.</p>
<p class="calibre3">If the problem was some bugs in the commits being merged (on the <code>topic</code> branch), and the branch being merged was not published, you can fix these commits with the interactive rebase, as described earlier. Rebasing changes the history anyway. Therefore, if you additionally ensure that the new history you are creating with the rebase does not have any revision in common with the old history that includes the failed and reverted merge, re-merging the topic branch would pose no challenges.</p>
<div><div><img alt="Figure 10.10 – The history after re-merging the rebased branch, which had its merge reverted" src="img/B21194_10_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.10 – The history after re-merging the rebased branch, which had its merge reverted</p>
<p class="calibre3">Usually you would rebase a topic branch, <code>topic</code> in this case, on top of the current state of the branch it was forked from, which is the <code>master</code> branch here. This way, your changes are kept up to date with the current work, which makes a later merge easier. Now that the <code>topic</code> branch has a new history, merging it into <code>master</code> “again”, like in <em class="italic">Figure 10</em><em class="italic">.10</em>, is easy and doesn’t give us any surprises or trouble.</p>
<p class="calibre3">A more difficult case<a id="_idIndexMarker912" class="pcalibre1 pcalibre calibre6"/> would be if the <code>topic</code> branch is for some reason required to keep its base (such as being able to merge it into the <code>maint</code> branch too). This is not more difficult in the sense that there would be problems with re-merging the <code>topic</code> branch after the rebase, but in that we need to ensure that the branch doesn’t share history with the reverted merge arc after the rebase. The goal is to have history in the same shape as is shown in <em class="italic">Figure 10</em>. By default, a rebase tries to fast-forward revisions if they didn’t change (for example, leaving <code>-f</code> or <code>--force-rebase</code> to force rebasing of unchanged skippable commits (or of <code>--no-ff</code>, which is equivalent) as well. The result is shown in <em class="italic">Figure 10</em><em class="italic">.11</em>.</p>
<div><div><img alt="Figure 10.11  The history after re-merging an in-place-rebased topic branch, where a pre-rebase merge was reverted" src="img/B21194_10_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.11  The history after re-merging an in-place-rebased topic branch, where a pre-rebase merge was reverted</p>
<p class="calibre3">So, you should not be blindly reverting the revert of a merge. What to do with the problem of re-merging after a reverted merge depends on how you want to handle the branch being merged. If the branch is being rewritten (for example, using an interactive rebase), then <a id="_idIndexMarker913" class="pcalibre1 pcalibre calibre6"/>reverting the revert would be an actively wrong thing to do because you could bring back errors that were fixed in the rewrite.</p>
<h2 id="_idParaDest-236" class="calibre7"><a id="_idTextAnchor263" class="pcalibre1 pcalibre calibre6"/>Storing additional information with notes</h2>
<p class="calibre3">The notes mechanism <a id="_idIndexMarker914" class="pcalibre1 pcalibre calibre6"/>is a way to<a id="_idIndexMarker915" class="pcalibre1 pcalibre calibre6"/> store additional information for an object, usually a commit, without touching the object itself. You can think of it as an attachment, or an appendix, that is “stapled” to an object. Each note belongs to some category of notes so that notes used for different purposes can be kept separate.</p>
<h3 class="calibre9">Adding notes to a commit</h3>
<p class="calibre3">Sometimes you<a id="_idIndexMarker916" class="pcalibre1 pcalibre calibre6"/> want <a id="_idIndexMarker917" class="pcalibre1 pcalibre calibre6"/>to add extra information to a commit, particularly information that is available only some time after its creation. It might be, for example, a note that there was a bug found in the commit, and perhaps even that it was fixed in some specified future commit (in case of regression). Perhaps we realized after the commit got published that we forgot to add some important information to the commit message, for example, to explain why it was done. Or maybe we realized after the fact that there is another way of doing it and we want to create a note to ensure that we do not forget about it, and for other developers to share the idea.</p>
<p class="calibre3">Since history is immutable in Git, you cannot do this without rewriting the history (creating a modified copy and forgetting the old version of the history). The immutability of history is important; it allows people to sign revisions and trust that, once inspected, history cannot change. What you can do instead is add the extra message as a note.</p>
<p class="calibre3">Let’s assume that codevelopers have switched from <code>atoi()</code> to <code>strtol()</code> because the former is deprecated. The change was made public since then. However, the commit message didn’t include an explanation of why it was deprecated and why it is worth it to switch, even if the code after the change is longer. Let’s add the information as a note:</p>
<pre class="console">
$ git notes add \
  -m 'atoi() invokes undefined behaviour upon error' v0.2~3</pre>
<p class="calibre3">We have added the <a id="_idIndexMarker918" class="pcalibre1 pcalibre calibre6"/>note directly from the command line <a id="_idIndexMarker919" class="pcalibre1 pcalibre calibre6"/>without invoking the editor by using the <code>-m</code> flag (the same flag as for <code>git commit</code>) to simplify the explanation of this example. The note will be visible when running <code>git log</code> or <code>git show</code>:</p>
<pre class="console">
$ git show --no-patch v0.2~3
commit 8c4ceca59d7402fb24a672c624b7ad816cf04e08
Author: Bob Hacker &lt;bob@company.com&gt;
Date:   Sun Jun 1 01:46:19 2014 +0200
    Use strtol(), atoi() is deprecated
Notes:
    atoi() invokes undefined behaviour upon error</pre>
<p class="calibre3">As you can see from the preceding output, our note is shown after the commit message in the <code>Notes:</code> section. Displaying notes can be disabled <a id="_idIndexMarker920" class="pcalibre1 pcalibre calibre6"/>with the <code>--no-notes</code> option, and (re)enabled<a id="_idIndexMarker921" class="pcalibre1 pcalibre calibre6"/> with <code>--show-notes</code>.</p>
<h3 class="calibre9">How notes are stored</h3>
<p class="calibre3">In Git, notes are<a id="_idIndexMarker922" class="pcalibre1 pcalibre calibre6"/> stored using extra references in the <code>refs/notes/</code> namespace. By<a id="_idIndexMarker923" class="pcalibre1 pcalibre calibre6"/> default, commit notes are stored using the <code>refs/notes/commits</code> ref. This can be changed using the <code>core.notesRef</code> configuration variable, which can in turn be overridden with the <code>GIT_NOTES_REF</code> environment variable.</p>
<p class="calibre3">If the given ref does not exist, it is not an error, but it means that no notes should be printed. These variables decide both which type of notes are displayed with the commit after the <code>Notes:</code> line and where to write the note created with <code>git </code><code>notes add</code>.</p>
<p class="calibre3">You can see that the new type of has reference appeared in the repository:</p>
<pre class="console">
$ git show-ref --abbrev commits
fcac4a6 refs/notes/commits</pre>
<p class="calibre3">If you examine the new reference, you will see that each note is stored in a file named after the SHA-1 identifier of the annotated object. This means that you can have only one note of the given type for one object. You can always edit the note, append to it (with <code>git notes append</code>), or replace its content (with <code>git notes </code><code>add --force</code>).</p>
<p class="calibre3">In interactive mode, Git opens the editor with the contents of the note, so edit, append, and replace operations work almost the same interactively. As opposed to commits, notes are mutable, or to be more exact, only the latest version of each note is used:</p>
<pre class="console">
$ git show refs/notes/commits
commit fcac4a649d2458ba8417a6bbb845da4000bbfa10
Author: Alice Developer &lt;alice@example.com&gt;
Date:   Tue Jun 16 19:48:37 2015 +0200
    Notes added by 'git notes add'
diff --git a/8c4ceca59d7402fb24a672c624b7ad816cf04e08 b/8c4ceca59d7402fb24a672c624b7ad816cf04e08
new file mode 100644
index 0000000..a033550
--- /dev/null
+++ b/8c4ceca59d7402fb24a672c624b7ad816cf04e08
@@ -0,0 +1 @@
+atoi() invokes undefined behaviour upon error
$ git log -1 --oneline \
  8c4ceca59d7402fb24a672c624b7ad816cf04e08
8c4ceca Use strtol(), atoi() is deprecated</pre>
<p class="calibre3">Notes for commits are stored in a separate line of (meta) history, but this need not be the case for the other categories of notes. The notes reference can point directly to the <code>tree</code> object instead of the <code>commit</code> object such as for <code>refs/notes/commits</code>.</p>
<p class="calibre3">One important issue that is often overlooked in books and articles is that it is the full path to a file with the note’s contents, not the base name of the file, that identifies the object that the note<a id="_idIndexMarker924" class="pcalibre1 pcalibre calibre6"/> is attached to. If there are many notes, Git <a id="_idIndexMarker925" class="pcalibre1 pcalibre calibre6"/>can and will use a fan-out directory hierarchy, for example, storing the preceding note at the <code>8c/4c/eca59d7402fb24a672c624b7ad816cf04e08</code> path (note the slashes).</p>
<h3 class="calibre9">Other categories and uses of notes</h3>
<p class="calibre3">Notes are <a id="_idIndexMarker926" class="pcalibre1 pcalibre calibre6"/>usually <a id="_idIndexMarker927" class="pcalibre1 pcalibre calibre6"/>added to commits. However, even for those notes that are attached to commits, it makes sense, at least in some cases, to store different pieces of information using different categories of notes. This makes it possible to decide which parts of information to display on an individual basis, and which parts to push to the public repository. It also allows us to query for specific parts of information individually.</p>
<p class="calibre3">To create a note in a namespace (category) that is different from the default one (where the default means <code>notes/commits</code>, or the value of the configuration variable <code>core.notesRef</code> if it is set), you need to specify the category of notes while adding it:</p>
<pre class="console">
$ git notes --ref=issues add -m '#2' v0.2~3</pre>
<p class="calibre3">Now, by default, Git will only display the <code>core.notesRef</code> category of notes after the commit message. To include other types of notes, you must either select the category to display with <code>git log --notes=&lt;category&gt;</code> (where <code>&lt;category&gt;</code> is either the unqualified or qualified reference name, or a glob; you can therefore use <code>--notes=*</code> to show all categories) or configure which notes to display in addition to the default with the <code>display.notesRef</code> configuration variable (or the <code>GIT_NOTES_DISPLAY_REF</code> environment variable). You can either specify the configuration variable value multiple times, just like for <code>remote.&lt;remote-name&gt;.push</code> (or specify a colon-separated list of pathnames if you are using the environment variable), or<a id="_idIndexMarker928" class="pcalibre1 pcalibre calibre6"/> you can specify a globing<a id="_idIndexMarker929" class="pcalibre1 pcalibre calibre6"/> pattern:</p>
<pre class="console">
$ git config notes.displayRef 'refs/notes/*'
$ git log -1 v0.2~3
commit 8c4ceca59d7402fb24a672c624b7ad816cf04e08
Author: Bob Hacker &lt;bob@company.com&gt;
Date:   Sun Jun 1 01:46:19 2014 +0200
    Use strtol(), atoi() is deprecated
Notes:
    atoi() invokes undefined behaviour upon error
Notes (issues):
    #2</pre>
<p class="calibre3">There are many possible uses of notes. You can, for example, use notes to reliably mark which patches (which commits) were <strong class="bold">upstreamed</strong> (<strong class="bold">forward-ported</strong> to<a id="_idIndexMarker930" class="pcalibre1 pcalibre calibre6"/> the development branch) or <strong class="bold">downstreamed</strong> (<strong class="bold">back-ported</strong> to the <a id="_idIndexMarker931" class="pcalibre1 pcalibre calibre6"/>more stable branch or the stable repository), even if the upstreamed or downstreamed version is not identical, and mark a patch as being <strong class="bold">deferred</strong> if it is not ready for either upstream or downstream.</p>
<p class="calibre3">If you require manual input, this is a bit more reliable than relying on the <code>git patch-id</code> mechanism to detect when the changeset is already present (which you can do by rebasing, by using <code>git cherry-pick</code>, or with the <code>--cherry</code>, <code>--cherry-pick</code>, or <code>--cherry-mark</code> option of <code>git log</code>). This is, of course, in case we are not using topic branches from the start, but rather cherry-picking commits.</p>
<p class="calibre3">Notes can also be used to store the results of the post-commit (but pre-merge) <strong class="bold">code audit</strong> and to notify other developers of the reason(s) why this version of the patch was used.</p>
<p class="calibre3">Notes can also be used to handle <strong class="bold">marking bugs and bug fixes</strong>, as well as <strong class="bold">verifying</strong> fixes. You will often find bugs in commits long after they get published; that is why you need notes for this purpose. If you find a bug before publishing, you would rewrite the buggy commit instead.</p>
<p class="calibre3">In this case, when <a id="_idIndexMarker932" class="pcalibre1 pcalibre calibre6"/>the bug gets reported, and<a id="_idIndexMarker933" class="pcalibre1 pcalibre calibre6"/> if it was a regression, you would first find which revision introduced the bug (for example, with <code>git bisect</code>, as described in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>). Then you would want to mark this commit, putting the identifier of a bug entry in the issue tracker for the project (which is usually a number, or number preceded by some specific prefix such as <code>bugs</code>, <code>defects</code>, or <code>issues</code> category of notes. Perhaps you would also want to include the description of a bug. If the bug affects security, it might be assigned a vulnerability identifier, for <a id="_idIndexMarker934" class="pcalibre1 pcalibre calibre6"/>example, a <code>CVE-IDs</code> category.</p>
<p class="calibre3">Then, after some time, the bug will hopefully get fixed. Just like we marked the commit with the information that it contains the bug, we can additionally annotate it with the information on which commit fixes it, such as in a note in the <code>fixes</code> category. Unfortunately, it might happen that the first attempt at fixing it doesn’t handle the bug entirely correctly and you have to amend a fix, or perhaps even create a fix for a fix. If you are using bugfix or hotfix branches (topic branches for bugfixes), as described in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>, it will be easy to find and apply them together by merging the aforementioned bugfix branch. If you are not using this workflow, then it would be a good idea to use notes to annotate fixes that should be cherry-picked together with a supplementary commit, for example by adding a note in the <code>alsoCherryPick</code> or <code>seeAlso</code> category, or whatever you want to name this category of notes. Perhaps the original submitter, or a Q&amp;A group, would also get to the fix and test that it works correctly. It would be better if the commit was tested before publishing, but it is not always possible, so <code>refs/notes/tests</code> it is.</p>
<p class="calibre3">Third-party tools use (or could use) notes to <a id="_idIndexMarker935" class="pcalibre1 pcalibre calibre6"/>store additional <code>refs/notes/reviews</code>. This includes the name and email address of the Gerrit user that submitted the change, the time the commit was submitted, the URL to the change review in the Gerrit instance, review labels and <a id="_idIndexMarker937" class="pcalibre1 pcalibre calibre6"/>scores (including the identity of the <a id="_idIndexMarker938" class="pcalibre1 pcalibre calibre6"/>reviewer), the name of project and branch, and so on:</p>
<pre class="source-code">
Notes (review):
    Code-Review+2: John Reviewer &lt;john@company.com&gt;
    Verified+1: Jenkins
    Submitted-by: Bob Developer &lt;bob@company.com&gt;
    Submitted-at: Thu, 20 Oct 2014 20:11:16 +0100
    Reviewed-on: http://localhost:9080/7
    Project: common/random
    Branch: refs/heads/master</pre>
<h3 class="calibre9">Notes as cache</h3>
<p class="calibre3">Going to a more <a id="_idIndexMarker939" class="pcalibre1 pcalibre calibre6"/>exotic<a id="_idIndexMarker940" class="pcalibre1 pcalibre calibre6"/> example, you can use the notes mechanism to store <strong class="bold">the result of a build</strong> (either the archive, the installation package, or just the executable), attaching it to a commit or a tag. Theoretically, you could store a build result in a tag, but you would usually expect a tag to contain a <strong class="bold">Pretty Good Privacy</strong> (<strong class="bold">PGP</strong>) signature <a id="_idIndexMarker941" class="pcalibre1 pcalibre calibre6"/>and perhaps also the release highlights. Also, you would, in almost all cases, want to fetch all the tags, while not everyone wants to pay for the cost of disk space for the convenience of pre-build executables. You can select whether you want to fetch the given category of notes (for example to skip pre-built binaries) or not from case to case while you autofollow tags. That is why notes are better than tags for this purpose.</p>
<p class="calibre3">Here, the trouble is to correctly generate a binary note. You can binary-safely create a note with the following trick:</p>
<pre class="console">
# store binary note as a blob object in the repository
$ blob_sha=$(git hash-object -w ./a.out)
# take the given blob object as the note message
$ git notes --ref=built add --allow-empty –C "$blob_sha" HEAD</pre>
<p class="calibre3">You cannot <a id="_idIndexMarker942" class="pcalibre1 pcalibre calibre6"/>simply use <code>-F ./a.out</code>, as this is not binary-safe – comments (or rather what was misdetected as comments, that is, lines starting with <code>#</code>) would be stripped.</p>
<p class="calibre3">The notes mechanism is also used as a mechanism to enable storing cache for the <code>textconv</code> filter (see the section on gitattributes in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>). All you need to do is <a id="_idIndexMarker943" class="pcalibre1 pcalibre calibre6"/>configure the filter in question, setting its <code>true</code>:</p>
<pre class="source-code">
<strong class="bold1">[diff "jpeg"]</strong>
    <strong class="bold1">textconv = exif</strong>
    <strong class="bold1">cachetextconv = true</strong></pre>
<p class="calibre3">Here, notes in the <code>refs/notes/textconv/jpeg</code> namespace (named after the filter) are used to <a id="_idIndexMarker944" class="pcalibre1 pcalibre calibre6"/>attach the text of the conversion to a blob.</p>
<h3 class="calibre9">Notes and rewriting history</h3>
<p class="calibre3">Notes are attached<a id="_idIndexMarker945" class="pcalibre1 pcalibre calibre6"/> to objects they annotate (usually commits) by their SHA-1 identifier. What happens with notes when we are rewriting history then? In the new, rewritten history, SHA-1 identifiers of objects are different in most cases.</p>
<p class="calibre3">It turns out that you can configure this quite extensively. First, you can select which categories of notes should be copied along with the annotated object during the rewrite with the <code>notes.rewriteRef</code> multi-value configuration variable. This setting can be overridden with the <code>GIT_NOTES_REWRITE_REF</code> environment variable with a colon-separated list of fully qualified notes references and globs (denoting reference patterns to match). There is no default value for this setting; you must configure this variable to enable rewriting.</p>
<p class="calibre3">Second, you can also configure whether to copy a note during rewriting depending on the exact type of the command doing the rewriting (<code>rebase</code> and <code>amend</code> are currently supported as the value of the command). This can be done with the boolean-valued <code>notes.rewrite.&lt;command&gt;</code> configuration variable.</p>
<p class="calibre3">In addition, you can decide what to do if the target commit already has a note while copying notes during a rewrite, for example, while squashing commits using an interactive rebase. You have to decide between <code>overwrite</code> (taking the note from the appended commit), <code>concatenate</code> (which is the default value), <code>cat_sort_uniq</code> (like <code>concatenate</code>, but sorting lines and removing duplicates), and <code>ignore</code> (using the note from the original commit being appended to) for the <code>notes.rewriteMode</code> configuration variable or the <code>GIT_NOTES_REWRITE_MODE</code> environment variable.</p>
<h3 class="calibre9">Publishing and retrieving notes</h3>
<p class="calibre3">So, we have notes<a id="_idIndexMarker946" class="pcalibre1 pcalibre calibre6"/> in our own local repository. What <a id="_idIndexMarker947" class="pcalibre1 pcalibre calibre6"/>do we do if we want to share these notes? How do we make them public? How can we, and other developers, get notes from other public repositories?</p>
<p class="calibre3">We can employ our knowledge of Git here. The <em class="italic">How notes are stored</em> section explained that notes are stored in the object database of the repository using special references in the <code>refs/notes/</code> namespace. The contents of the note is stored as a blob, referenced through this special ref. Commit notes (notes in <code>refs/notes/commits</code>) store the history of notes, though Git allows you to store notes without history as well. So, what you need to do is get this special ref. The contents of the notes will follow. This is the usual mechanism of repository synchronization (object transfer).</p>
<p class="calibre3">This means that to publish your notes, you need to configure appropriate <code>push</code> lines in the appropriate remote repository configuration (see <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>). Assuming that you are using a separate <code>public</code> remote (if you are the maintainer, you will probably simply use <code>origin</code>), which is perhaps set as <code>remote.pushDefault</code>, and that you would like to publish notes in any category, you can run the following:</p>
<pre class="console">
$ git config --add remote.public.push '+refs/notes/*:refs/notes/*'</pre>
<p class="calibre3">If <code>push.default</code> is set to <code>matching</code> (or Git is old enough to have this as the default behavior), or the <code>push</code> lines use special refspecs such as <code>:</code> or <code>+:</code>, it is enough to push notes refs the first time, as they would be pushed automatically each time after:</p>
<pre class="console">
$ git push origin 'refs/notes/*'</pre>
<p class="calibre3">The process of <strong class="bold">fetching notes</strong> is only <a id="_idIndexMarker948" class="pcalibre1 pcalibre calibre6"/>slightly more involved. If you don’t produce specified types <a id="_idIndexMarker949" class="pcalibre1 pcalibre calibre6"/>of notes yourself, you can fetch notes<a id="_idIndexMarker950" class="pcalibre1 pcalibre calibre6"/> in the “mirror-like” mode to the ref with the same name:</p>
<pre class="console">
$ git config --add remote.origin.fetch '+refs/notes/*:refs/notes/*'</pre>
<p class="calibre3">However, if there is a possibility of conflict, you would need to fetch notes from the remote into the remote-tracking notes reference, and then use <code>git notes merge</code> to join them into your notes. Please see the documentation for details.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you want to make it easy to merge Git notes, perhaps even automatically, then following the convention of the <strong class="bold">Key: Value</strong> entries on separate lines for the content of notes, with duplicates removed, will help.</p>
<p class="calibre3">There is no standard naming convention for remote-tracking notes references, but you can use either <code>refs/notes/origin/*</code> (so that the shortened <code>commits</code> notes category from the <code>origin</code> remote is <code>origin/commits</code>, and so on), or go whole works and fetch <code>refs/*</code> from the <code>origin</code> remote into <code>refs/remotes/origin/refs/*</code> (so that<a id="_idIndexMarker951" class="pcalibre1 pcalibre calibre6"/> the <code>commits</code> category<a id="_idIndexMarker952" class="pcalibre1 pcalibre calibre6"/> lands in <code>refs/remotes/origin/refs/notes/commits</code>).</p>
<h2 id="_idParaDest-237" class="calibre7"><a id="_idTextAnchor264" class="pcalibre1 pcalibre calibre6"/>Using git replace</h2>
<p class="calibre3">The original idea for<a id="_idIndexMarker953" class="pcalibre1 pcalibre calibre6"/> the replace- or replacement-like mechanism was to make it possible to join the history of two different repositories.</p>
<p class="calibre3">The original impulse was to be able to switch from the other version control system to Git by creating two repositories: the first one for the current work, starting with the most recent version in the empty repository, and the second one for the historical data, storing the conversion from the original system. That way, it would be possible to take time doing the faithful conversion of the historical data, and even fix it if the conversion were incorrect, without affecting the current work.</p>
<p class="calibre3">What was needed was some mechanism to connect the histories of those two repositories, to have a full history for inspection going back to the creation of a project (for example, for blame, that is, line-history annotation).</p>
<h3 class="calibre9">The replacements mechanism</h3>
<p class="calibre3">The modern incarnation <a id="_idIndexMarker954" class="pcalibre1 pcalibre calibre6"/>of such a tool is a replace (or replacements) mechanism. With it, you can replace any object with any object, or rather create a virtual history (virtual object database of a repository) by creating an overlay, so that most Git commands return a replacement in place of the original object.</p>
<p class="calibre3">However, the original object is still there, and Git’s behavior with respect to the replacement mechanism was done in such a way as to eliminate the possibility of losing data. You can get the original view with the <code>--no-replace-objects</code> option passed to the <code>git</code> wrapper, added before the command. You can also use the <code>GIT_NO_REPLACE_OBJECTS</code> environment variable, instead. For example, to view the original history, you can use <code>git --</code><code>no-replace-objects log</code>.</p>
<p class="calibre3">The information about replacements is saved in the repository by storing the ref named after the SHA-1 of the replaced object in the <code>refs/replace/</code> namespace, with the SHA-1 of replacement as its sole content. However, there is no need to edit it by hand or with low-level plumbing commands –  you can use the <code>git </code><code>replace</code> command.</p>
<p class="calibre3">Almost all the commands use replacements unless they are told not to, as explained previously. The exception is reachability analysis commands. This means that Git would not remove the replaced objects because they are no longer reachable if we take replacement into account. Of course, replacement objects are reachable from the replace refs.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Currently, some of the mechanisms that are used to make Git faster for very large repositories (see <a href="B21194_12.xhtml#_idTextAnchor302" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing Large Repositories</em>) don’t work if <strong class="source-inline1">git replace</strong> is used.</p>
<p class="calibre3">You can replace any object with any other object, though changing the type of an object requires telling Git that you know what you are doing with <code>git replace -f &lt;object&gt; &lt;replacement&gt;</code>. This is because such a change might lead to troubles with Git, since it was expecting one type of object, and getting another.</p>
<p class="calibre3">With <code>git replace --edit &lt;object&gt;</code>, you can edit its contents interactively. What really happens is that Git opens the editor with the object contents, and after editing, Git creates a new object and a replacement ref. The object format (in particular, the commit object<a id="_idIndexMarker955" class="pcalibre1 pcalibre calibre6"/> format, as one would almost always edit commits) was described at the beginning of this chapter. You can change the commit message, commit parents and authorship, and so on.</p>
<h3 class="calibre9">Example – joining histories with git replace</h3>
<p class="calibre3">Let’s assume that <a id="_idIndexMarker956" class="pcalibre1 pcalibre calibre6"/>you have split the repository into two, as described in an earlier section about <code>filter-repo</code>, perhaps for performance reasons. However, let’s say that you want to be able to treat the joined history as if it were one.</p>
<p class="calibre3">Or perhaps there was a natural history split after changing the version control system to Git, with the fresh repository with the current work (started after switching from the current state of a project, with an empty history) and the converted historical repository kept separate. This could be done to make the switch faster. This technique has the advantage of allowing you to improve the conversion after the split.</p>
<p class="calibre3">This situation is shown in <em class="italic">Figure 10</em><em class="italic">.12</em>, with the historical repository added as a remote to the current work repository (one with new commits).</p>
<div><div><img alt="Figure 10.12 – The view of a split history, with the replacements turned off (git --no-replace-objects). The shortened SHA-1 in the left upper corner of a commit denotes its identifier." src="img/B21194_10_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.12 – The view of a split history, with the replacements turned off (git --no-replace-objects). The shortened SHA-1 in the left upper corner of a commit denotes its identifier.</p>
<p class="calibre3">In many cases, you might want to create a kind of informational commit on top of the “historical” repository (the one with the older part of the history), for example, adding the notification where one can find the <code>current work</code> repository to the <code>README</code> file. Such a commit is, for simplicity, not shown in <em class="italic">Figure 10</em><em class="italic">.12</em>.</p>
<p class="calibre3">How to join history depends somewhat on whether the history was originally split or joined. If it was originally joined, then split, just tell Git to replace the post-split version with the pre-split version using <code>git replace &lt;post-split&gt; &lt;pre-split&gt;</code>. If the repository was split from beginning, use the <code>--edit</code> or <code>--graft</code> option of <code>git replace</code>.</p>
<div><div><img alt="Figure 10.13 – The view of a split history, joined using replacements" src="img/B21194_10_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.13 – The view of a split history, joined using replacements</p>
<p class="calibre3">The split history is there, it is just hidden from view. For all Git commands, the history looks like in <em class="italic">Figure 10</em><em class="italic">.13</em>. You can, as described earlier, turn it off using replacements; in this case, you<a id="_idIndexMarker957" class="pcalibre1 pcalibre calibre6"/> would see the history as in <em class="italic">Figure 10</em><em class="italic">.12</em>.</p>
<h3 class="calibre9">Historical note – grafts</h3>
<p class="calibre3">The first attempt to<a id="_idIndexMarker958" class="pcalibre1 pcalibre calibre6"/> create a mechanism to make it possible to join lines of <a id="_idIndexMarker959" class="pcalibre1 pcalibre calibre6"/>history came about in the form of <code>.git/info/grafts</code> file with the SHA-1 identifier of the affected commit and its replacement parents in line, separated by spaces.</p>
<p class="calibre3">This mechanism was only for commits, and allowed only to change the parentage of the commit. There was no support for transport, that is, for propagating this information from inside of Git. You could not turn the grafts mechanism off temporarily, at least not easily. Moreover, it was inherently unsafe because there were no exceptions for reachability-checking commands, making it possible for Git to remove needed objects by accident during pruning (garbage collecting).</p>
<p class="calibre3">However, you can find its use in examples. Nowadays, it is obsolete, especially with the existence of the <code>git replace --graft</code> option. If you use grafts, consider replacing them with replacements objects; the <code>contrib/convert-grafts-to-replace-refs.sh</code> script <a id="_idIndexMarker960" class="pcalibre1 pcalibre calibre6"/>can help with this in the Git sources.</p>
<p class="callout-heading">Other graft-like files in Git</p>
<p class="callout">The <strong class="bold">shallow clone</strong> (the<a id="_idIndexMarker961" class="pcalibre1 pcalibre calibre6"/> result of <strong class="source-inline1">git clone --depth=&lt;N&gt;</strong>, a clone with the shortened history) is managed with a graft-like <strong class="source-inline1">.git/shallow</strong> file. This file is managed by Git, however, not by the user.</p>
<h3 class="calibre9">Publishing and retrieving replacements</h3>
<p class="calibre3">How can you <a id="_idIndexMarker962" class="pcalibre1 pcalibre calibre6"/>publish replacements, and how do you get them from the remote repository? Since replacements use references, this is quite simple.</p>
<p class="calibre3">Each replacement is a separate reference in the <code>refs/replaces/</code> namespace. Therefore, you can get all the replacements with the globing <code>fetch</code> or <code>push</code> line:</p>
<pre class="source-code">
+refs/replace/*:refs/replace/*</pre>
<p class="calibre3">There can be only one replacement for an object, so there are no problems with merging replacements. You can only choose between one replacement or the other.</p>
<p class="calibre3">Theoretically, you could also request individual replacements by fetching (and pushing) individual replacement references instead of using the '*' wildcard.</p>
<h1 id="_idParaDest-238" class="calibre5"><a id="_idTextAnchor265" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter, along with <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>, provided all the tools required to manage a clean, readable, and easy-to-review history of a project.</p>
<p class="calibre3">You learned how to make history cleaner by rewriting it in this chapter. You also learned what rewriting history means in Git, when and why to avoid it, and how to recover from an untimely upstream rewrite. You have learned to use an interactive rebase to delete, reorder, squash and split commits, and how to test each commit during the rebase. You know how to do a large-scale scripted rewrite with <code>filter-repo</code>, as well as how to edit commits and commit metadata and how to permanently change history, such as by splitting it in two. You also got to know some third-party external tools, which can help with these tasks.</p>
<p class="calibre3">You learned what to do if you cannot rewrite history: how to fix mistakes by creating commits with appropriate changes (for example, with <code>git revert</code>), how to add extra information to the existing commits with notes, and how to change the virtual view of the history with replacements. You learned to handle reverting a faulty merge and how to re-merge after a reverted merge. You learned how to fetch and publish both notes and replacements.</p>
<p class="calibre3">To really understand advanced history rewriting and the mechanism behind notes and replacements, this chapter explained the basics of Git internals and low-level commands that are usable for scripting (including scripted rewrite).</p>
<p class="calibre3">The following chapter, <a href="B21194_11.xhtml#_idTextAnchor270" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>, <em class="italic">Managing Subprojects</em>, will explain and show different ways to connect different subprojects in one repository, from submodules to subtrees.</p>
<p class="calibre3">In the subsequent chapter, <a href="B21194_12.xhtml#_idTextAnchor302" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing Large Repositories</em>, you will also learn techniques to manage (or mitigate managing) large-size assets inside a repository, or large numbers of files in a repository. Splitting a large project into submodules is one, but not the only, way to handle this issue.</p>
<h1 id="_idParaDest-239" class="calibre5"><a id="_idTextAnchor266" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">When working on a series of commits to implement a feature, how can you mark a bugfix commit for later squashing into the original commit before publishing the series?</li>
<li class="calibre15">Why should you not rewrite (rebase or amend) published history if you are using merging to integrate changes?</li>
<li class="calibre15">How can you recover from the upstream rebase?</li>
<li class="calibre15">What can you do when you notice that you accidentally included some large file that should not be put in version control in a commit?</li>
<li class="calibre15">How can you undo the effect of the commit if you cannot rewrite history?</li>
<li class="calibre15">What mechanisms exist to amend history, or a view of history, without rewriting it?</li>
</ol>
<h1 id="_idParaDest-240" class="calibre5"><a id="_idTextAnchor267" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li class="calibre15">You can use <strong class="source-inline1">git commit --fixup</strong> when creating a bugfix, and then later <strong class="source-inline1">git rebase --interactive --autosquash</strong> before publishing the series.</li>
<li class="calibre15">You should not rewrite published history because other developers can do their work based on the version before the changes, and then merging would bring older versions (from before the rewrite) back into existence.</li>
<li class="calibre15">Rebase your own changes on top of the new, rebased version of the upstream.</li>
<li class="calibre15">If the problem is in the most recent commit, you can amend it with <strong class="source-inline1">git commit --amend</strong>. If you need to rewrite the whole history of the project, you can use the <strong class="source-inline1">git filter-repo</strong> tool. Note, however, the caveat that comes with rewriting published history, namely that it can cause problems for other developers when they will try to integrate their changes.</li>
<li class="calibre15">You can use <strong class="source-inline1">git revert</strong> to create the commit that undoes changes brought by an unwanted commit.</li>
<li class="calibre15">You can use <strong class="source-inline1">git notes</strong> to add extra information to commit objects after the fact, and you can use <strong class="source-inline1">git replace</strong> to change the effective shape of the history.</li>
</ol>
<h1 id="_idParaDest-241" class="calibre5"><a id="_idTextAnchor268" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Scott Chacon and Ben Straub: <em class="italic">Pro Git, 2nd Edition</em> (2014) <a href="https://git-scm.com/book/en/v2" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2</a>.<ul class="calibre18"><li class="calibre15"><em class="italic">Chapter 7.6</em>, <em class="italic">Git Tools - </em><em class="italic">Rewriting History</em></li><li class="calibre15"><em class="italic">Chapter 7.13</em>, <em class="italic">Git Tools - </em><em class="italic">Replace</em></li></ul></li>
<li class="calibre15">Aske Olsson and Rasmus Voss: <em class="italic">Git Version Control Cookbook (2014)</em>, Packt Publishing Ltd<ul class="calibre18"><li class="calibre15"><em class="italic">Chapter 5</em>, <em class="italic">Storing Additional Information in </em><em class="italic">Your Repository</em></li><li class="calibre15"><em class="italic">Chapter 8</em>, <em class="italic">Recovering </em><em class="italic">From Mistakes</em></li></ul></li>
<li class="calibre15">Git Documentation HOWTOs<ul class="calibre18"><li class="calibre15"><em class="italic">How to revert a faulty </em><em class="italic">merge </em><a href="https://github.com/git/git/blob/master/Documentation/howto/revert-a-faulty-merge.txt" class="pcalibre1 pcalibre calibre6">https://github.com/git/git/blob/master/Documentation/howto/revert-a-faulty-merge.txt</a></li><li class="calibre15"><em class="italic">How to revert an existing </em><em class="italic">commit </em><a href="https://github.com/git/git/blob/master/Documentation/howto/revert-branch-rebase.txt" class="pcalibre1 pcalibre calibre6">https://github.com/git/git/blob/master/Documentation/howto/revert-branch-rebase.txt</a></li></ul></li>
<li class="calibre15">Tyler Cipriani: <em class="italic">Git Notes: Git’s Coolest, Most Unloved Feature</em> (2022) <a href="https://tylercipriani.com/blog/2022/11/19/git-notes-gits-coolest-most-unloved-feature/" class="pcalibre1 pcalibre calibre6">https://tylercipriani.com/blog/2022/11/19/git-notes-gits-coolest-most-unloved-feature/</a></li>
<li class="calibre15">Elijah Newren: <em class="italic">git </em><em class="italic">filter-repo </em><a href="https://github.com/newren/git-filter-repo" class="pcalibre1 pcalibre calibre6">https://github.com/newren/git-filter-repo</a></li>
<li class="calibre15">Stacked Git: <em class="italic">StGit </em><em class="italic">Tutorial </em><a href="https://stacked-git.github.io/guides/tutorial/" class="pcalibre1 pcalibre calibre6">https://stacked-git.github.io/guides/tutorial/</a></li>
<li class="calibre15">Jackson Gabbard: <em class="italic">Stacked Diffs Versus Pull Requests</em> (2018) <a href="https://jg.gg/2018/09/29/stacked-diffs-versus-pull-requests/" class="pcalibre1 pcalibre calibre6">https://jg.gg/2018/09/29/stacked-diffs-versus-pull-requests/</a></li>
</ul>
</div>
</body></html>