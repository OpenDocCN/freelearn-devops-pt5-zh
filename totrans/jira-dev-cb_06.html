<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. The Power of JIRA Searching</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing a JQL function</li><li class="listitem" style="list-style-type: disc">Sanitizing JQL functions</li><li class="listitem" style="list-style-type: disc">Adding a search request view</li><li class="listitem" style="list-style-type: disc">Smart querying using quick search</li><li class="listitem" style="list-style-type: disc">Searching in plugins</li><li class="listitem" style="list-style-type: disc">Parsing a JQL query in plugins</li><li class="listitem" style="list-style-type: disc">Linking directly to search queries</li><li class="listitem" style="list-style-type: disc">Index and de-index programmatically</li><li class="listitem" style="list-style-type: disc">Managing filters programmatically</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Introduction</h1></div></div></div><p>JIRA<a id="id1036" class="indexterm"/> is known for its search capabilities<a id="id1037" class="indexterm"/>. It allows us to extend them in a way that impresses its users! In this chapter, we will look at customizing the various searching aspects of JIRA such as JQL<a id="id1038" class="indexterm"/>, searching in plugins, managing filters, and so on.</p><p>Before we start, it would make sense to look at one of the major enhancements in JIRA 4<a id="id1039" class="indexterm"/>, that is, <strong>JQL</strong> – <a id="id1040" class="indexterm"/>
<strong>JIRA Query Language</strong>. JQL brings to the table advanced searching capabilities, using which the users can search for issues in their JIRA instance and then exploit all the capabilities of issue navigator.</p><p>In addition to the previous searching capabilities, now called <strong>Simple Searching</strong><a id="id1041" class="indexterm"/>, JQL or the <strong>Advanced Searching</strong><a id="id1042" class="indexterm"/> introduces support for logical operations, including AND, OR, NOT, NULL, and EMPTY. It also introduces a set of JQL functions, which can be used effectively to search based on predefined criteria.</p><p>JQL<a id="id1043" class="indexterm"/> is a structured query language that lets us find issues using a simple SQL-like syntax. It is simple because of its auto-complete features and maintains a query history to navigate easily to the recent searches. As Atlassian puts it:</p><div><blockquote class="blockquote"><p>"JQL allows you to use standard boolean operators and wild cards to perform complex searches, including fuzzy, proximity, and empty field searches. It even supports extensible functions, allowing you to define custom expressions like "CurrentUser" or "LastSprint" for dynamic searches."</p></blockquote></div><a id="id1044" class="indexterm"/><p>A query in <a id="id1045" class="indexterm"/> <em>Advanced Search</em> consists of a <strong>field</strong><a id="id1046" class="indexterm"/>, followed by an <strong>operator</strong><a id="id1047" class="indexterm"/>, followed by a <strong>value</strong><a id="id1048" class="indexterm"/> or <strong>function</strong><a id="id1049" class="indexterm"/>. To find out all issues in a project, we can use:</p><div><pre class="programlisting">project = "TEST"</pre></div><p><code class="literal">project</code> is the field, <code class="literal">=</code> is the operator, and <code class="literal">TEST</code> is the value.</p><p>Similarly, we can find all issues assigned to the current user using:</p><div><pre class="programlisting">assignee = currentUser()</pre></div><p><code class="literal">assignee</code> is the field, <code class="literal">=</code> is the operator, and <code class="literal">currentUser()</code><a id="id1050" class="indexterm"/> is a JQL function.</p><p>At this point of time, JQL doesn't support comparison of two fields or two functions in a single query. But we can use logical operators and keywords to introduce more control as follows:</p><div><pre class="programlisting">project = "TEST" AND assignee = currentUser()</pre></div><p>This query will display issues that are in the project <code class="literal">TEST</code> and that have the current user as the <code class="literal">assignee</code>. A more detailed explanation on Advanced Searching, along with the full reference to the Keywords, Operators, Fields, and Functions used can be found at<a class="ulink" href="http:// http://confluence.atlassian.com/display/JIRA/Advanced+Searching"> http://confluence.atlassian.com/display/JIRA/Advanced+Searching</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Writing a JQL function</h1></div></div></div><a id="id1051" class="indexterm"/><p>As we have seen, a <strong>JQL function</strong> allows us to define custom expressions or searchers<a id="id1052" class="indexterm"/>. <a id="id1053" class="indexterm"/>JIRA has a set of built-in JQL functions, the details of which can be found at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Advanced+Searching#AdvancedSearching-FunctionsReference">http://confluence.atlassian.com/display/JIRA/Advanced+Searching#AdvancedSearching-FunctionsReference</a>. In this recipe, we will look at writing a new JQL function.</p><p>JQL functions provide a way for values within a JQL query to be calculated at runtime. It takes optional arguments and produces results based on the arguments at runtime.</p><p>In our example, let us consider creating a function <code class="literal">projects()</code><a id="id1054" class="indexterm"/>, which can take a list of project keys and return all issues in the supplied projects. For example,</p><div><pre class="programlisting">project in projects("TEST", "DEMO")</pre></div><p>It will be equivalent to:</p><div><pre class="programlisting">project in ("TEST","DEMO") and also to project = "TEST" OR project = "DEMO"</pre></div><p>We are introducing this new function just for the sake of this recipe.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec191"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using the Atlassian plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec192"/>How to do it...</h2></div></div></div><a id="id1055" class="indexterm"/><a id="id1056" class="indexterm"/><p>JIRA uses the <strong>JQL Function Module</strong><a id="id1057" class="indexterm"/> to add new JQL functions to the Advanced Search. The following is the step-by-step process for our example:</p><div><ol class="orderedlist arabic"><li class="listitem">Modify the plugin descriptor to include the JQL function module:<div><pre class="programlisting">&lt;jql-function key="jql-projects" name="Projects Function" class="com.jtricks.ProjectsFunction"&gt;
  &lt;!--The name of the function--&gt;
  &lt;fname&gt;projects&lt;/fname&gt;

  &lt;!--Whether this function returns a list or a single value--&gt;
  &lt;list&gt;true&lt;/list&gt;
&lt;/jql-function&gt;</pre></div><p>As with any other plugin modules, a JQL function module also has a unique <strong>key</strong><a id="id1058" class="indexterm"/>. The other major attribute of the function module is the function <strong>class</strong><a id="id1059" class="indexterm"/>. In this example, <code class="literal">ProjectsFunction</code> is the function class. The root element, <code class="literal">jql-function</code><a id="id1060" class="indexterm"/>, has two other elements—<code class="literal">fname</code> and <code class="literal">list</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fname</code> holds the JQL function name that is visible to the user. This will be used in the JQL query.</li><li class="listitem" style="list-style-type: disc"><code class="literal">list</code> indicates whether the function returns a list or not. In our example, we return a list of projects, and hence we use the value <code class="literal">true</code> to indicate that it is a list. A list can be used along with operators <code class="literal">IN</code> and <code class="literal">NOT</code> <code class="literal">IN</code>, whereas a scalar can be used with operators <code class="literal">=</code>, <code class="literal">!=</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>, <code class="literal">IS</code>, and <code class="literal">IS</code> <code class="literal">NOT</code>.</li></ul></div></li><li class="listitem">Implement the function class:<p>The class name here is the name used in the module description, <code class="literal">ProjectsFunction</code> in this case. The class should extend the <code class="literal">AbstractJqlFunction</code> class<a id="id1061" class="indexterm"/>. We now need to implement the major methods detailed next:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getDataType</code><a id="id1062" class="indexterm"/> – This method defines the return type of the function. In our example, we take a list of project keys and return valid projects, and hence we will implement the method to return the <code class="literal">PROJECT</code> datatype as follows:<div><pre class="programlisting">public JiraDataType getDataType() {
  return JiraDataTypes.PROJECT;
}</pre></div><p>Check out the <code class="literal">JiraDataTypes</code> class to see other supported data types.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">getMinimumNumberOfExpectedArguments</code><a id="id1063" class="indexterm"/> – It returns the smallest number of arguments that the function may accept. The auto-population of the method in the issue navigator takes this into consideration and puts sufficient double quotes within brackets when the function is selected.<p>For example, in our case, we need at least one project key in the function name and hence we <code class="literal">return 1</code> as follows:</p><div><pre class="programlisting">public int getMinimumNumberOfExpectedArguments() {
  return 1;
}</pre></div><a id="id1064" class="indexterm"/><a id="id1065" class="indexterm"/><p>The pre-populated function will then look like <code class="literal">projects("")</code>.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">validate</code> –<a id="id1066" class="indexterm"/> This method is used to do validation of the arguments we have passed. In our example, we need to check if the method has at least one argument or not and make sure all the arguments passed are valid project keys. The validate method looks like the following:<div><pre class="programlisting">public MessageSet validate(User searcher, FunctionOperand operand, TerminalClauseterminalClause) {
  List&lt;String&gt; projectKeys = operand.getArgs();
  MessageSet messages = new MessageSetImpl();
  if (projectKeys.isEmpty()) {
    messages.addErrorMessage("Atleast one project key needed");
  } else {
    for (String projectKey : projectKeys) {
      if (projectManager.getProjectObjByKey(projectKey) == null){
        messages.addErrorMessage("Invalid Project Key:" + projectKey);
      }
    }
  }
  return messages;
}</pre></div></li></ul></div><p>Here we instantiate a new <code class="literal">MessageSet</code> and add error messages to it, if the validation fails. We must always return a <code class="literal">MessageSet</code>, even if it is empty. Returning <code class="literal">null</code> is not permitted. We can also add warning messages which doesn't prevent the JQL execution, but warns the user about something.</p><p>The most important argument in the <code class="literal">validate</code> method<a id="id1067" class="indexterm"/> is <code class="literal">FunctionOperand</code>, as it holds the arguments of the function which can be retrieved as <code class="literal">operand.getArgs()</code>. The other argument <code class="literal">terminalClause</code> is JIRA's representation of the JQL condition we are validating for. We can extract the name, operator, and function from the argument using <code class="literal">terminalClause.getName</code>, <code class="literal">terminalClause.getOperator</code>, and <code class="literal">terminalClause.getOperand</code> respectively.</p><a id="id1068" class="indexterm"/><a id="id1069" class="indexterm"/><p>The <code class="literal">AbstractJqlFunction</code> has a validation method in it to check the number of arguments. So if we know the expected number of arguments (which is not the case in our example as we can have any number of projects passed in the example), we can validate it using:</p><div><pre class="programlisting">
MessageSet messages = validateNumberOfArgs(operand, 1);</pre></div><p>This code adds an error if the number of arguments is not 1.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getValues</code><a id="id1070" class="indexterm"/> – This is the method that takes the arguments and returns the date type as a list or scalar depending on the function. In our example, the <code class="literal">getValues</code> method returns a list of literals that has the project ID.<p>The method is implemented as follows in our example:</p><div><pre class="programlisting">public List&lt;QueryLiteral&gt; getValues(QueryCreationContext context, FunctionOperand operand,   TerminalClauseterminalClause) {
  notNull("queryCreationContext", context);
  List&lt;QueryLiteral&gt; literals = new LinkedList&lt;QueryLiteral&gt;();
  List&lt;String&gt; projectKeys = operand.getArgs();
  for (String projectKey : projectKeys) {
    Project project = projectManager.getProjectObjByKey(projectKey);
    if (project != null) {
      literals.add(new QueryLiteral(operand, project.getId()));
    }
  }
  return literals;
}</pre></div><p><code class="literal">notnull()</code><a id="id1071" class="indexterm"/> is a predefined method from the <code class="literal">Asserions</code> class that checks whether the query creation context is null or not and throws an error if null. This is not mandatory and can be handled in some other way if needed.</p><p>The arguments <code class="literal">operand</code> and <code class="literal">terminalClause</code> are the same as what we have seen in the validate method. The <code class="literal">QueryCreationContext</code> argument<a id="id1072" class="indexterm"/> holds the context in which the query is executed. <code class="literal">QueryCreationContext.getUser</code> will retrieve the user who executed the query, and the <code class="literal">QueryCreationContext.isSecurityOverriden</code> method indicates whether or not this function should actually perform security checks.</p><p>The function should always return a list of <code class="literal">QueryLiteral</code> objects<a id="id1073" class="indexterm"/>. Even when the function returns a scalar instead of list, it should return a list of <code class="literal">QueryLiteral</code>, which can be created like the following:</p><div><pre class="programlisting">Collections.singletonList(new QueryLiteral(operand, some_value))</pre></div><a id="id1074" class="indexterm"/><a id="id1075" class="indexterm"/><p>A <code class="literal">QueryLiteral</code> represents either a <code class="literal">String</code>, <code class="literal">Long</code>, or <code class="literal">EMPTY</code> value. These three represent JQL's distinguishable types. Construct it with no value and it will represent EMPTY, construct it with a String and it represents a String, or construct it with a Long and it represents a Long.</p><p>In our example, we use the project ID (LONG) which is unique across projects. For projects, we can even use the key (STRING) or name (STRING), as they are also unique. However, it may not work with fields such as Fix For Version as you might find two Fix Versions with the same name. It is recommended to return the ID wherever possible to avoid such unambiguous search results.</p><p>To summarize, we find out the project objects using the project keys supplied by the user and return a list of <code class="literal">QueryLiterals</code>, created using the project IDs.</p></li></ul></div></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec193"/>How it works...</h2></div></div></div><p>Once the plugin is deployed, we can go to the Issue Navigator and open the advanced search to start using our brand new function! When you start typing <strong>project in</strong> <strong>p</strong>, JIRA auto-populates the available options including our new function, as shown:</p><div><img src="img/1803-06-01.jpg" alt="How it works..."/></div><p>Once the function with appropriate arguments is added, the search is executed and results are shown as follows:</p><div><img src="img/1803-06-02.jpg" alt="How it works..."/></div><a id="id1076" class="indexterm"/><a id="id1077" class="indexterm"/><p>When an invalid project key is given as the argument, our <code class="literal">validate</code> method populates the error message, as shown in the following screenshot:</p><div><img src="img/1803-06-03.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec194"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a skeleton plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a>, <em>Plugin Development Process</em></li><li class="listitem" style="list-style-type: disc"><em>Deploying your plugin</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Sanitizing JQL functions</h1></div></div></div><p>If you don't want to make your JQL function violate the strict security aspects of your JIRA instance, sanitizing the JQL functions is a must! So, what does this actually mean?</p><p>Imagine a filter created by you to find out issues in a pre-defined set of projects. What will happen if you share the filter with a friend of yours who is not supposed to see the project or know that the project existed? The person with whom you shared it won't be able to modify the issues in the protected project due to JIRA's permission schemes but he/she will surely see the name of the project in the JQL query that is used in the filter!</p><a id="id1078" class="indexterm"/><a id="id1079" class="indexterm"/><p>This is where sanitizing of the JQL function will help. In essence, we just modify the JQL query to protect the arguments in line with the permission schemes. Let us see an example of doing that by sanitizing the JQL function we created in the previous recipe.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec195"/>Getting ready</h2></div></div></div><p>Develop the JQL function, as explained in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec196"/>How to do it...</h2></div></div></div><p>In our JQL function, we use the project keys as the arguments. To explain the Function Sanitization, we will look to replace the keys with project IDs whenever the user doesn't have the permission to browse a project. The following is the step-by-step process showing you how to do it:</p><div><ol class="orderedlist arabic"><li class="listitem">Modify the JQL function class to implement the <a id="id1080" class="indexterm"/><code class="literal">ClauseSanitisingJqlFunction</code> interface:<div><pre class="programlisting">public class ProjectsFunction extends AbstractJqlFunction implements ClauseSanitisingJqlFunction{</pre></div></li><li class="listitem">Implement the<a id="id1081" class="indexterm"/> <code class="literal">sanitiseOperand</code> method:<div><pre class="programlisting">@NotNull FunctionOperand santiseOperand(User searcher, @NotNullFunctionOperand operand);</pre></div><p>Here we read all the existing arguments of the JQL function, from the <code class="literal">FunctionOperand</code> argument<a id="id1082" class="indexterm"/>, and modify it to include project IDs instead of keys, wherever the user doesn't have Browse permissions:</p><div><pre class="programlisting">public FunctionOperand sanitiseOperand(User user, FunctionOperand functionOperand) {
  final List&lt;String&gt; pKeys = functionOperand.getArgs();
  boolean argChanged = false;
  final List&lt;String&gt; newArgs = new ArrayList&lt;String&gt;(pKeys.size());
  for (final String pKey : pKeys) {
    Project project = projectManager.getProjectObjByKey(pKey);
    if (project != null &amp;&amp; !permissionManager.hasPermission(Permissions.BROWSE, project, user)) {
      newArgs.add(project.getId().toString());
      argChanged = true;
    } else {
      newArgs.add(pKey);
    }
  }

  if (argChanged) {
    return new FunctionOperand(functionOperand.getName(),
newArgs);
  } else {
    return functionOperand;
  }
}</pre></div></li><li class="listitem">Package and deploy the modified plugin.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec197"/>How it works...</h2></div></div></div><a id="id1083" class="indexterm"/><a id="id1084" class="indexterm"/><p>Once the plugin is deployed, if a user doesn't have the permission to browse a project, he/she will see the project ID instead of the key that was originally entered when the filter was created. Following is a sample screenshot of how the query will look in that case. In this case, I just removed myself from the Browse permission of the <code class="literal">TEST</code> project, and you can see that the query is modified to replace the key <code class="literal">TEST</code> with its unique ID, which doesn't reveal much information!</p><div><img src="img/1803-06-04.jpg" alt="How it works..."/></div><p>What if you try to edit the filter now? Our validation will now kick in as it is not able to find a project with the ID, as shown next! Nice, eh?</p><div><img src="img/1803-06-05.jpg" alt="How it works..."/></div><a id="id1085" class="indexterm"/><a id="id1086" class="indexterm"/><p>This is only an example, and we can sanitize the query in a similar way in every other case.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec198"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing a JQL function</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Adding a search request view</h1></div></div></div><p>One of the customizable features in JIRA is its <strong>Issue Navigator</strong><a id="id1087" class="indexterm"/>. It lets us search based on numerous criteria, choose the fields that need to be shown, in a way we want to see them!</p><p>The normal or the default view in the issue navigator is the tabular view to display the issues and the fields we have chosen by configuring the issue navigator. JIRA also gives us a few other options to see the search results in different formats, to export them into Excel, Word, or XML, and so on with the help of the pre-defined search request views.</p><p>In this recipe, we will see how we can add more search views in to JIRA that enables us to see the search results in a format we like. To achieve this we need to use the <a id="id1088" class="indexterm"/> <strong>Search Request View Plugin</strong> module.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec199"/>Getting ready</h2></div></div></div><a id="id1089" class="indexterm"/><a id="id1090" class="indexterm"/><p>Create a plugin skeleton using Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec200"/>How to do it...</h2></div></div></div><p>As mentioned before, we use the Search Request View Plugin module to create custom search views. In our example, let us create a simple HTML view that just displays the issue key and summary.</p><p>The following is the step-by-step process:</p><div><ol class="orderedlist arabic"><li class="listitem">Define the plugin descriptor with the search request view module:<div><pre class="programlisting">&lt;search-request-view key="simple-searchrequest-html" name="Simple HTML View" class="com.jtricks.SimpleSearchRequestHTMLView" state='enabled'                        fileExtension="html" contentType="text/html"&gt;
  &lt;resource type="velocity" name="header" location="templates/searchrequest-html-header.vm"/&gt;
  &lt;resource type="velocity" name="body" location="templates/searchrequest-html-body.vm"/&gt;
  &lt;resource type="velocity" name="footer" location="templates/searchrequest-html-footer.vm"/&gt;

  &lt;order&gt;200&lt;/order&gt;
&lt;/search-request-view&gt;</pre></div><p>As usual, the module has a unique key. Following are the other attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: The name that will appear in the Issue Navigator for the View</li><li class="listitem" style="list-style-type: disc"><code class="literal">class</code>: The search request view class. This is where we populate the velocity contexts with the necessary information</li><li class="listitem" style="list-style-type: disc"><code class="literal">contentType</code>: The <code class="literal">contentType</code> of the file that is generated. <code class="literal">text/html</code>, <code class="literal">text/xml</code>, <code class="literal">application/rss+xml</code>, <code class="literal">application/vnd.ms-word</code>, <code class="literal">application/vnd.ms-excel</code>, and so on</li><li class="listitem" style="list-style-type: disc"><code class="literal">fileExtension</code>: The extension of the file generated. <code class="literal">html</code>, <code class="literal">xml</code>, <code class="literal">xml</code>, <code class="literal">doc</code>, <code class="literal">xls</code>, and so on</li><li class="listitem" style="list-style-type: disc"><code class="literal">state</code>: Enabled or disabled. Determines whether the module is enabled at startup</li></ul></div><a id="id1091" class="indexterm"/><a id="id1092" class="indexterm"/><p>The Search-Request-View element also has few child elements to define the velocity templates required for the various views and to determine the <code class="literal">order</code> in which the views will appear. Modules with lower <code class="literal">order</code> values are shown first. JIRA uses an order of 10 for the built-in views. A lower value will put the new view above the built-in views and a higher value will put the new view at the bottom.</p></li><li class="listitem">Implement the Search Request View class.<p>The Search Request View class must implement the <code class="literal">SearchRequestView</code> interface<a id="id1093" class="indexterm"/>. To make things easier, we can extend the <code class="literal">AbstractSearchRequestView</code> class<a id="id1094" class="indexterm"/> that already implements this interface. When we do that, we have one method, <code class="literal">writeSearchResults</code>, to be implemented!</p><p>This method takes a writer argument using which we can generate the output using the various template views we define. For example:</p><div><pre class="programlisting">writer.write(descriptor.getHtml("header", headerParams));</pre></div><p>It will identify the velocity template with the view named as <code class="literal">header</code> and will use the variables on the map – <code class="literal">headerParams</code> to render the template. We can similarly define as many templates as we want and write them to create the view that we need.</p><p>In our example, we have three views defined – header, body, and footer. These views can be named in any way we want, but the same names that we define in the <code class="literal">atlassian-plugin.xml</code> should be used in the Search Request View class.</p><p>In our class implementation, we use the three views to generate the simple HTML view. We use the header and footer views in the beginning and end and will use the body view to generate the issue view for each individual issue in search results. The following is how we do it:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generate a map with the default velocity context parameters:<div><pre class="programlisting">final Map defaultParams = JiraVelocityUtils.getDefaultVelocityParams(authenticationContext);</pre></div></li><li class="listitem" style="list-style-type: disc">Populate the map with the variables that we need in the context to render the header template and write the header. In our example, let us keep the header fairly simple and just use the filter name and the current user:<div><pre class="programlisting">final Map headerParams = new HashMap(defaultParams);        headerParams.put("filtername", searchRequest.getName());        headerParams.put("user", authenticationContext.getUser());
writer.write(descriptor.getHtml("header", headerParams));</pre></div></li><li class="listitem" style="list-style-type: disc"><a id="id1095" class="indexterm"/><a id="id1096" class="indexterm"/>Now we need to write the search results. We should iterate over each issue in the search results and write it to the writer using the format we defined. To ensure that this doesn't result in huge memory consumption, only one issue should be loaded into memory at a time. This can be guaranteed by using a <strong>Hitcollector</strong>. This collector<a id="id1097" class="indexterm"/> is responsible for writing out each issue as it is encountered in the search results. It will be called for each search result by the underlying Lucene search code:<div><pre class="programlisting">final Searcher searcher = searchProviderFactory.getSearcher(SearchProviderFactory.ISSUE_INDEX);
final Map issueParams = new HashMap(defaultParams);
final DocumentHitCollectorhitCollector = new IssueWriterHitCollector(searcher, writer, issueFactory){
  protected void writeIssue(Issue issue, Writer writer) throws IOException{
    //put the current issue into the velocity context and render the //single issue view
    issueParams.put("issue", issue  writer.write(descriptor.getHtml("body", issueParams));
  }
};
searchProvider.searchAndSort(searchRequest.getQuery(), user, hitCollector, searchRequestParams.getPagerFilter());</pre></div></li></ul></div><p>All we do here is define the <code class="literal">HitCollector</code> and invoke the <code class="literal">searchAndSort</code> method<a id="id1098" class="indexterm"/>, which will then use the <code class="literal">HitCollector</code> to generate the view for each issue. Here we can add more variables if we need them in the view.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id1099" class="indexterm"/><a id="id1100" class="indexterm"/>We can now write the footer before we finish. Let us again put the user just for educational purpose:<div><pre class="programlisting">writer.write(descriptor.getHtml("footer", EasyMap.build("user", user)));</pre></div></li></ul></div><p>Here we created a simple map just to show that we need only the variables we use in the view.</p><p>The method will now look as follows:</p><div><pre class="programlisting">@Override
public void writeSearchResults(final SearchRequestsearchRequest, final SearchRequestParams searchRequestParams, final Writer writer) throws SearchException{
  final Map defaultParams = JiraVelocityUtils.getDefaultVelocityParams(authenticationContext);
  final Map headerParams = newHashMap(defaultParams);          headerParams.put("filtername", searchRequest.getName());      headerParams.put("user", authenticationContext.getUser());  
  try{
    //Header
    writer.write(descriptor.getHtml("header", headerParams));  

    //Body
    final Searcher searcher =searchProviderFactory.getSearcher(SearchProviderFactory.ISSUE_INDEX);
    final Map issueParams = new HashMap(defaultParams); 
    final DocumentHitCollector hitCollector = new IssueWriterHitCollector(searcher, writer, issueFactory) {
      protected void writeIssue(Issue issue, Writer writer) throws IOException{
        //put the current issue into the velocity context and render the single issue view
        issueParams.put("issue", issue);      writer.write(descriptor.getHtml("body", issueParams));
      }
    };
    searchProvider.searchAndSort(searchRequest.getQuery(), authenticationContext.getUser(),hitCollector, searchRequestParams.getPagerFilter());

    //Footer
    writer.write(descriptor.getHtml("footer", EasyMap.build("user", authenticationContext.getUser())));
  }catch (IOException e){
    throw new RuntimeException(e);
  }catch (SearchException e){
    throw new RuntimeException(e);
  }
}</pre></div></li><li class="listitem"><a id="id1101" class="indexterm"/><a id="id1102" class="indexterm"/>Write the velocity templates. As we saw, we are using three views:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Header</strong> – The velocity template is <code class="literal">templates/searchrequest-html-header.vm</code>. The following is how it looks:<div><pre class="programlisting">Hello $user.fullName , have a look at the search results!&lt;br&gt;&lt;br&gt;
#set($displayName = 'Anonymous')
#if($filtername)
  #set($displayName = $textutils.htmlEncode($filtername))
#end
&lt;b&gt;Filter&lt;/b&gt; : $displayName&lt;br&gt;&lt;br&gt;
&lt;table&gt;</pre></div></li></ul></div><p>We just greet the user and display the filter name here. It also has a <code class="literal">&lt;table&gt;</code> tag which is used at the beginning of the issue table. The table will be closed in the footer.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Body</strong> – The velocity template is <code class="literal">templates/searchrequest-html-body.vm</code>. The following is how it looks:<div><pre class="programlisting">&lt;tr&gt;
  &lt;td&gt;&lt;font color="green"&gt;$!issue.key&lt;/font&gt;&lt;/td&gt;
  &lt;td&gt;$!issue.summary&lt;/td&gt;
&lt;/tr&gt;</pre></div><p>Whatever appears here is common to all the issues. Here we create a table row for each issue and display the key and summary appropriately.</p></li><li class="listitem" style="list-style-type: disc"><strong>Footer</strong> – The velocity template is <code class="literal">templates/searchrequest-html-footer.vm</code>. The following code shows how it looks:<div><pre class="programlisting">&lt;/table&gt;
&lt;br&gt;&lt;br&gt;...And that's all we have got now , $user.fullName !</pre></div><p>We just close the table and wind up with a message!</p></li></ul></div></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec201"/>How it works...</h2></div></div></div><a id="id1103" class="indexterm"/><a id="id1104" class="indexterm"/><p>Once the plugin is deployed, we will find a new view in the issue navigator named <strong>Simple HTML View</strong>:</p><div><img src="img/1803-06-06.jpg" alt="How it works..."/></div><p>On selecting the view, the current search results will appear as follows:</p><div><img src="img/1803-06-07.jpg" alt="How it works..."/></div><a id="id1105" class="indexterm"/><a id="id1106" class="indexterm"/><p>If the results belong to a filter, it will display the filter name instead of Anonymous:</p><div><img src="img/1803-06-08.jpg" alt="How it works..."/></div><p>It is now left to our creativity to make it more beautiful or use an entirely different content type instead of HTML. An example of how an XML view is generated can be found in the JIRA documentation at <a class="ulink" href="https://developer.atlassian.com/display/JIRADEV/Search+Request+View+Plugin+Module">https://developer.atlassian.com/display/JIRADEV/Search+Request+View+Plugin+Module</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec202"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a skeleton plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a>, <em>Plugin Development Process</em></li><li class="listitem" style="list-style-type: disc"><em>Deploying your plugin</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Smart querying using quick search</h1></div></div></div><a id="id1107" class="indexterm"/><a id="id1108" class="indexterm"/><a id="id1109" class="indexterm"/><p>The name says it all! JIRA allows smart querying using its Quick Search functionality and it enables the users to find critical information with ease. There is a pre-defined set of search keywords that JIRA recognizes and we can use them to search smart and fast!</p><p>In this recipe, we will look at how we can do smart querying on some of the JIRA fields.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec203"/>How to do it...</h2></div></div></div><p>Before we start, the <strong>Quick Search</strong> box is located at the right-hand top corner of JIRA, as shown:</p><div><img src="img/1803-06-09.jpg" alt="How to do it..."/></div><p>The following is how we can search on some of the fields as of JIRA 4.4. Don't forget to check how many of them are supported in your version of JIRA!</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Issue key</strong>:<a id="id1110" class="indexterm"/> If you already know the issue key that you want to see, it doesn't get any better! Just type the issue key in the <strong>Quick Search</strong> box and JIRA will take you to the view issue page.<p>And there's more! If you are browsing a project or viewing an issue and if you want to see another issue for which the key is known, all you need to type is the number in the unique key (just the numerical part). There isn't even a need to type in the full key.</p><p>For example, <strong>TEST-123</strong> will take you to that issue directly. Typing <strong>125</strong> will then take you to <strong>TEST-125</strong>!</p></li><li class="listitem" style="list-style-type: disc"><strong>Project</strong>: If you type in the project key<a id="id1111" class="indexterm"/>, the quick search will show you all the issues in that particular project. The project name can also be used as long as there are no spaces in it.<p>For example, <strong>TEST</strong> will return all issues in the project <code class="literal">TEST</code> or a project with the key <strong>TEST</strong>. 'TEST Project' will not display issues in the project with the name 'Test Project', as the quick search interprets it as two different keywords.</p></li><li class="listitem" style="list-style-type: disc"><strong>Assignee</strong>:<a id="id1112" class="indexterm"/> The keyword <strong>my</strong> can be used to find all issues assigned to me.</li><li class="listitem" style="list-style-type: disc"><strong>Reporter</strong>:<a id="id1113" class="indexterm"/> The keyword <strong>r:</strong> is followed by <strong>me</strong>, or the <em>reporter name</em> can find all issues reported by me or the user respectively For example, <strong>r:none</strong> is also supported and it returns issues without any reporter.<p><strong>r:me</strong> will retrieve all issues reported by me, whereas <strong>r:admin</strong> will retrieve all issues reported by the user – admin.</p></li><li class="listitem" style="list-style-type: disc"><strong>Date</strong> <strong>fields</strong>: <a id="id1114" class="indexterm"/>Quick Search can be done based on the three major date fields on the issue – <strong>created</strong>, <strong>updated</strong>, and <strong>due</strong> <strong>date</strong>. The keywords used are <strong>created</strong>, <strong>updated</strong>, and <strong>due</strong> respectively. The keyword should be followed by <strong>:</strong> and the date range without any spaces.<p>The date range can use one of the following keywords – <strong>today</strong>, <strong>tomorrow</strong>, <strong>yesterday</strong>, or a single date range (for example,. '-5d') or two date ranges (for example,. '-2w,1w'). The date ranges cannot have spaces in them. Valid date/time abbreviations are: 'w' (week), 'd' (day), 'h' (hour), and 'm' (minute). For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>created:today</strong> will retrieve all issues created on the date.</li><li class="listitem" style="list-style-type: disc"><strong>updated:-5d</strong> will retrieve all issues updated in the last five days.</li><li class="listitem" style="list-style-type: disc"><strong>due:-2w,1w</strong> will retrieve all issues due in the last two weeks and in the next week.</li></ul></div><p>You can also use the keyword <strong>overdue</strong> to retrieve all issues that are overdue (has a past due date).</p></li><li class="listitem" style="list-style-type: disc"><a id="id1115" class="indexterm"/><a id="id1116" class="indexterm"/><a id="id1117" class="indexterm"/><strong>Priority</strong>: <a id="id1118" class="indexterm"/>The quick search can be done using the priority values <strong>blocker</strong>, <strong>critical</strong>, <strong>major</strong>, <strong>minor</strong>, and <strong>trivial</strong>. Just typing the value will retrieve all the issues that have the given priority value.<p>For example, all issues with the priority <strong>major</strong> can be retrieved by searching with <strong>major</strong>.</p></li><li class="listitem" style="list-style-type: disc"><strong>IssueType</strong>: <a id="id1119" class="indexterm"/>Issue type names can be used in the Quick search as long as it doesn't have any spaces in it. Even plurals will work.<p>For example, typing <strong>bug</strong> or <strong>bugs</strong> will retrieve all the issues with the issue type of bug.</p></li><li class="listitem" style="list-style-type: disc"><strong>Versions</strong>:<a id="id1120" class="indexterm"/> Quick Search can find issues with known Affected Versions or Fix for versions using the keywords <strong>v:</strong> or <strong>ff:</strong> followed by the value without any space. There shouldn't be any spaces between <strong>v:</strong> and the version name. It can also use wild card search. The search will also find all issues with version values that contain the string you specify, followed immediately by a space. For example:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>v:2.0</strong> will find issues in versions – 2.0, 2.0 one, 2.0 beta, and so on. But it wouldn't find issues in version 2.0.1</li><li class="listitem" style="list-style-type: disc"><strong>v:2.*</strong> will find issues in versions – 2.0, 2.0 one, 2.0.1, 2.2, and so on.</li></ul></div><p>The same applies to fixes for versions. The prefix only changes to ff:</p></li><li class="listitem" style="list-style-type: disc"><a id="id1121" class="indexterm"/><a id="id1122" class="indexterm"/><a id="id1123" class="indexterm"/><strong>Components</strong>: Quick search can find issues with component names using the prefix <strong>c:</strong> followed by the component name. It will retrieve all issues where the component has the value somewhere in its name, not necessarily starting with it.<p>For example, <strong>c:jql</strong> will find all issues in components that have the word 'jql' in it. It will work for the components jql, jql performance, advanced jql, and so on.</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec204"/>There's more...</h2></div></div></div><p>Quick Search can also be used to search for any word within the issue(s) you are looking for, provided the word is in the summary, description, or comments of the issue. It is called <strong>Smart</strong> <strong>Search</strong><a id="id1124" class="indexterm"/>.</p><p>If you think you want to use any of these keywords without using Smart search, the query can be run without smart search when the results are displayed.</p><a id="id1125" class="indexterm"/><p>Smart Querying can have multiple keywords combined to narrow down the search. It can even be combined with Free Text Search<a id="id1126" class="indexterm"/>.</p><p>For example, <strong>my open bugs</strong> will retrieve all bugs that are opened and assigned to me. It is equivalent to the JQL:</p><div><pre class="programlisting">issuetype = Bug AND assignee = currentUser() AND status = Open</pre></div><p><strong>my open bugs jql</strong> will retrieve all bugs that are opened and assigned to me and has the word 'jql' in its summary, description, or comments. It is equivalent to:</p><div><pre class="programlisting">(summary ~ jql OR description ~ jql OR comment ~ jql) AND issuetype = Bug AND assignee = currentUser() AND status = Open</pre></div><p><strong>my open bugs jql performance</strong> is equivalent to:</p><div><pre class="programlisting">(summary ~ "jql performance" OR description ~ "jql performance" OR comment ~ "jql performance") AND issuetype = Bug AND assignee = currentUser() AND status = Open.</pre></div><p>More on advanced searching<a id="id1127" class="indexterm"/>
<a id="id1128" class="indexterm"/> or JQL can be found at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Advanced+Searching">http://confluence.atlassian.com/display/JIRA/Advanced+Searching</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Searching in plugins</h1></div></div></div><p>With the invention of JQL, JIRA Search APIs have changed drastically from 3.x versions. Searching in plugins is now done using APIs supporting JQL. In this recipe, we will see how to search for issues within our plugins using those APIs.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec205"/>How to do it...</h2></div></div></div><a id="id1129" class="indexterm"/><a id="id1130" class="indexterm"/><p>For the sake of concentrating on the search APIs, we will look at writing a simple method, <code class="literal">getIssues()</code><a id="id1131" class="indexterm"/>, that returns a list of issue objects based on some search criteria.</p><p>The essence of searching is to build a <code class="literal">Query</code> object using <code class="literal">JqlQueryBuilder</code>. A <code class="literal">Query</code> object will have a <code class="literal">where</code> clause and an <code class="literal">order by</code> clause, which are built using the <code class="literal">JqlClauseBuilder</code>. We can also incorporate conditions in between clauses using <code class="literal">ConditionBuilders</code>.</p><p>For now, let us assume we want to find all the issues in a particular project (project ID: 10000, Key: DEMO) and assigned to the current user within our plugin. The JQL equivalent for this is:</p><div><pre class="programlisting">project = "DEMO" and assignee = currentUser()</pre></div><p>The following are the steps to do this programmatically:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a JqlQueryBuilder (<a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlQueryBuilder.html">http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlQueryBuilder.html</a>) object.<p><code class="literal">JqlQueryBuilder</code> is used to build the query that is used to perform issue searching. The following is how a <code class="literal">JqlQueryObject</code> is created:</p><div><pre class="programlisting">JqlQueryBuilder builder = JqlQueryBuilder.newBuilder();</pre></div></li><li class="listitem">Create a <code class="literal">where</code> clause that returns a JqlClauseBuilder (<a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlClauseBuilder.html">http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlClauseBuilder.html</a>). A query is constructed with one or more JQL clauses with different conditions added in between.<p><code class="literal">builder.where()</code> returns a <code class="literal">JqlClauseBuilder</code> object for our <code class="literal">QueryBuilder</code> on which we can then add multiple clauses.</p></li><li class="listitem"><a id="id1132" class="indexterm"/><a id="id1133" class="indexterm"/>Add the project clause to search for a project with its ID as argument. The project clause will return a <code class="literal">ConditionBuilder</code>:<div><pre class="programlisting">builder.where().project(10000L)</pre></div></li><li class="listitem">Add the <code class="literal">assignee</code> clause using the <code class="literal">AND</code> condition on the <code class="literal">ConditionBuilder</code>:<div><pre class="programlisting">builder.where().project(10000L).and().assigneeIsCurrentUser();</pre></div><p>We can have numerous clauses added like this using the different conditions. Let us see some examples in the 'There's More...' section.</p></li><li class="listitem">Add ordering, if you have any, using the <code class="literal">Order By</code> clause. We can sort based on assignee as follows:<div><pre class="programlisting">builder.orderBy().assignee(SortOrder.ASC);</pre></div><p><code class="literal">SortOrder.DESC</code> can be used for descending orders.</p></li><li class="listitem">Build the <code class="literal">Query</code> (<code class="literal">com.atlassian.query.Query</code>) object:<div><pre class="programlisting">Query query = builder.buildQuery();</pre></div><p>The <code class="literal">Query</code> object is immutable; once it is created it cannot be changed. The <code class="literal">JqlQueryBuilder</code> represents the mutable version of a <code class="literal">Query</code> object. We can create a Query from an already existing Query by calling <code class="literal">JqlQueryBuilder.newBuilder(existingQuery)</code>.</p></li><li class="listitem">Get an instance of the <code class="literal">SearchService</code>. It could be injected in the constructor of your plugin using dependency injection or can be retrieved from the <code class="literal">ComponentManager</code> class as follows:<div><pre class="programlisting">SearchService searchService = ComponentManager.getInstance().getSearchService();</pre></div></li><li class="listitem">Search using the query to retrieve the SearchResults (<a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/search/SearchResults.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/search/SearchResults.html</a>):<div><pre class="programlisting">SearchResults results = searchService.search(user, query, PagerFilter.getUnlimitedFilter());</pre></div><p>Here we used <code class="literal">PagerFilter.getUnlimitedFilter()</code> to retrieve all the results. It is possible to limit the results to a particular range, say from 20 to 80 results, using the method <code class="literal">PagerFilter.newPageAlignedFilter(index, max)</code>. This will be useful when Pagination is done, such as in the case of issue navigator.</p></li><li class="listitem">Retrieve the issues from the search results:<div><pre class="programlisting">List&lt;Issue&gt; issues = results.getIssues();</pre></div></li></ol></div><p>The entire method will look as follows:</p><div><pre class="programlisting">  private List&lt;Issue&gt;getIssues(User user) {
    JqlQueryBuilder builder = JqlQueryBuilder.newBuilder();
    builder.where().project(10000L).and().assigneeIsCurrentUser();
    builder.orderBy().assignee(SortOrder.ASC);
    Query query = builder.buildQuery();
    SearchService searchService = ComponentManager.getInstance().getSearchService();
    SearchResults results = searchService.search(user, query, PagerFilter.getUnlimitedFilter());
    returnresults.getIssues();
  }</pre></div><p>Hopefully, that is a good starting point from which to write more complex queries!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec206"/>There's more...</h2></div></div></div><p>As promised earlier, let us look at writing complex queries with a couple of examples.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id1134" class="indexterm"/><a id="id1135" class="indexterm"/>We can extend the aforementioned search to include multiple projects, assignees, and a custom field. The JQL representation of the query will be:<div><pre class="programlisting">project in ("TEST", "DEMO") and assignee in ("jobinkk", "admin") and "Customer Name" = "Jobin"</pre></div><p>The <code class="literal">where</code> clause<a id="id1136" class="indexterm"/> is written as:</p><div><pre class="programlisting">builder.where().project("TEST", "DEMO").and().assignee().in("jobinkk", "admin").and().customField(10000L).eq("Jobin");</pre></div><p>10000L is the ID of the custom field Customer Name.</p></li><li class="listitem" style="list-style-type: disc">We can group the conditions using <code class="literal">sub()</code> and <code class="literal">endsub()</code> to write even more complex queries:<div><pre class="programlisting">project in ("TEST", "DEMO") and (assignee is EMPTY or reporter is EMPTY)</pre></div><p>It can be written as:</p><div><pre class="programlisting">builder.where().project("TEST", "DEMO").and().sub().assigneeIsEmpty().or().reporterIsEmpty().endsub();</pre></div></li></ul></div><p>Similarly, we can write more complex queries.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec207"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing a JQL funcion</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec70"/>Parsing a JQL query in plugins</h1></div></div></div><p>In the previous recipe, we saw how to build a Query to search within JIRA. In this recipe, we will see searching again, but without building a Query using the APIs. We will use the JQL Query as it is written in the Issue Navigator in advanced mode and search using the same.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec208"/>How to do it...</h2></div></div></div><a id="id1137" class="indexterm"/><a id="id1138" class="indexterm"/><a id="id1139" class="indexterm"/><p>Suppose we know the query that we want to execute. Let us assume it is the same we saw in the previous recipe: <code class="literal">project = "DEMO" and assignee = currentUser()</code>.</p><p>The following is how we do it:</p><div><ol class="orderedlist arabic"><li class="listitem">Parse the JQL query:<div><pre class="programlisting">String jqlQuery = "project = \"DEMO\" and assignee = currentUser()";
SearchService.ParseResult parseResult = searchService.parseQuery(user, jqlQuery);</pre></div></li><li class="listitem">Check if the parsed result is valid or not:<div><pre class="programlisting">if (parseResult.isValid()){
   // Carry On
} else {
  // Log the error and exit!
}</pre></div></li><li class="listitem">If the result is valid, get the <code class="literal">Query</code> object from the <code class="literal">ParseResult</code>:<div><pre class="programlisting">Query query = parseResult.getQuery()</pre></div></li><li class="listitem">Search for the issues and retrieve the <code class="literal">SearchResults</code>, as we have seen in the previous recipe:<div><pre class="programlisting">SearchResults results = searchService.search(user, query, PagerFilter.getUnlimitedFilter());</pre></div></li><li class="listitem">Retrieve the list of issues from the search results:<div><pre class="programlisting">List&lt;Issue&gt; issues = results.getIssues();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec209"/>How it works...</h2></div></div></div><a id="id1140" class="indexterm"/><a id="id1141" class="indexterm"/><a id="id1142" class="indexterm"/><p>Here the <code class="literal">parseQuery</code> operation in <code class="literal">SearchService</code> converts the <code class="literal">String</code> JQL query in to the <code class="literal">Query</code> object we normally construct using <code class="literal">JqlQueryBuilder</code>. The actual parse operation is done by <code class="literal">JqlQueryParser</code> behind the scenes.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec210"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Searching in plugins</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Linking directly to search queries</h1></div></div></div><p>Haven't you wondered how we can link to a query from a template or JSP from a custom page or plugin page? In this recipe, we will see how we can create a link programmatically and otherwise to use in various places.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec211"/>How to do it...</h2></div></div></div><a id="id1143" class="indexterm"/><a id="id1144" class="indexterm"/><p>Let us first look at creating a search link programmatically. Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">Query</code> object using <code class="literal">JqlQueryBuilder</code>, as we have seen in the previous recipe.</li><li class="listitem">Get an instance of the <code class="literal">SearchService</code>. It could be injected in the constructor of your plugin using dependency injection or can be retrieved from the <code class="literal">ComponentManager</code> class as follows:<div><pre class="programlisting">SearchService searchService = ComponentManager.getInstance().getSearchService();</pre></div></li><li class="listitem">Retrieve the query string from the <code class="literal">Query</code> object using <code class="literal">SearchService</code>, as shown:<div><pre class="programlisting">String queryString = searchService.getQueryString(user, query);</pre></div></li><li class="listitem">Construct the link using the context path. In JSPs, you can do it as shown next:<div><pre class="programlisting">&lt;a href="&lt;%= request.getContextPath() %&gt;/secure/IssueNavigator.jspa?reset=true&lt;ww:property value="/queryString" /&gt;&amp;amp;mode=hide" title=""&gt;Show in Navigator&lt;/a&gt;</pre></div><p>Here, <code class="literal">getQueryString()</code> in the <code class="literal">Action</code> class returns the preceding <code class="literal">queryString</code>.</p><p>And in velocity templates:</p><div><pre class="programlisting">&lt;a href="$requestContext.baseUrl/secure/IssueNavigator.jspa?reset=true$queryString&amp;amp;mode=hide" title=""&gt;Show in Navigator&lt;/a&gt;</pre></div><p>Here, <code class="literal">$queryString</code> is the preceding <code class="literal">queryString</code> in context!</p><p>The <code class="literal">mode</code> parameter can have the values <code class="literal">hide</code> or <code class="literal">show</code> depending on whether you want to open the issue navigator in view or edit mode!</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec212"/>How it works...</h2></div></div></div><a id="id1145" class="indexterm"/><p>The <code class="literal">getQueryString</code> method in <code class="literal">SearchService</code> returns the <code class="literal">queryString</code> in a manner in which it can be used in a URL. It starts with <code class="literal">&amp;jqlQuery=</code>, followed by the actual query as a web URL:</p><div><pre class="programlisting">reset=true&lt;ww:property value="/queryString" /&gt;&amp;amp;mode=hide will be then reset=true&amp;amp;jqlQuery=someQuery&amp;amp;mode=hide</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec213"/>There's more...</h2></div></div></div><a id="id1146" class="indexterm"/><a id="id1147" class="indexterm"/><a id="id1148" class="indexterm"/><p>Linking to a Quick Search is also pretty easy and useful. We can even store such searches in our browser favorites. All we need to do is find out the URL by replacing <code class="literal">%s</code> in JIRA's URL as follows:</p><p><code class="literal">http://&lt;Context_Path&gt;/secure/QuickSearch.jspa?searchString=%s</code></p><p>For example, if your JIRA instance is <code class="literal">http://localhost:8080/</code> and you want to Quick Search for all the issues where you are the assignee, the relevant quick search string will be: <strong>my open</strong>.</p><p>And the URL will then be:</p><p><code class="literal">http://localhost:8080/secure/QuickSearch.jspa?searchString=my+open</code></p><p>Please note that the spaces in Quick Search are replaced by <code class="literal">+</code> while substituting <code class="literal">%s</code>.</p><p>Other examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">http://localhost:8080/secure/QuickSearch.jspa?searchString=my+open+critical</code> retrieves all open critical issues assigned to you</li><li class="listitem" style="list-style-type: disc"><code class="literal">http://localhost:8080/secure/QuickSearch.jspa?searchString=created:-1w+my</code> retrieves all the issues assigned to you, created in the past week</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Index and de-index programmatically</h1></div></div></div><p>As we have seen in the JIRA architecture explained in <a class="link" href="ch02.html" title="Chapter 2. Understanding Plugin Framework">Chapter 2</a>, <em>Understanding Plugin Framework</em>, searching in JIRA is based on Apache Lucene. The Lucene indexes<a id="id1149" class="indexterm"/> are stored in the File System and are used as the basis for the search queries executed in JIRA. Whenever an issue is updated, more records are created or existing records are updated for that particular issue in the filesystem.</p><p>It is possible to programmatically index selected or all issues or de-index an issue. Also, we can switch OFF or ON indexing selectively in our plugins if needed. In this recipe, we will see both of these.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec214"/>How to do it...</h2></div></div></div><a id="id1150" class="indexterm"/><a id="id1151" class="indexterm"/><a id="id1152" class="indexterm"/><a id="id1153" class="indexterm"/><p>Most of the indexing operations can be done with the help of <code class="literal">IssueIndexManager</code>. An instance of <code class="literal">IssueIndexManager</code> can be created either by injecting in the constructor or as follows:</p><div><pre class="programlisting">IssueIndexManager indexManager = ComponentManager.getInstance().getIndexManager();</pre></div><p>The following are the important operations supported by <code class="literal">IssueIndexManager</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reIndexAll()</code><a id="id1154" class="indexterm"/> – Indexes all the issues in JIRA. A good method if you want a custom admin operation to do indexing as well!</li><li class="listitem" style="list-style-type: disc"><code class="literal">reIndex(GenericValue issue)</code>or <a id="id1155" class="indexterm"/><code class="literal">reIndex(Issue issue)</code> – To selectively index an issue by passing the <code class="literal">Issue</code> object or its <code class="literal">GenericValue</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">deIndex(GenericValue issue)</code> –<a id="id1156" class="indexterm"/> Method to de-index an issue. Once this is done, the issue won't appear in the search results.<p>Be aware that when the issue is later updated or a comment is added on the issue, JIRA automatically indexes again. So don't rely on calling this just once to permanently hide your issue from searches. To do so, the <code class="literal">IssueIndexer</code> should be overridden so that it won't index the issue again.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">reIndexIssues(final Collection&lt;GenericValue&gt; issues)or reIndexIssueObjects(final Collection&lt;? extends Issue&gt;issueObjects)</code> – <a id="id1157" class="indexterm"/>Indexes a Collection of issues.</li></ul></div><p>Checkout the Java Docs at <a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/issue/index/IssueIndexManager.html">http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/issue/index/IssueIndexManager.html</a> for more available methods on the <code class="literal">IssueIndexManager</code>.</p><p>If we want to make sure that indexing is turned ON when we make a major update on an issue, we can do the following:</p><div><pre class="programlisting">  // Store the current state of indexingboolean wasIndexing = ImportUtils.isIndexIssues();
  // Set indexing to trueImportUtils.setIndexIssues(true);
  // Update the issue or issues
  ...................
  // Reset indexingImportUtils.setIndexIssues(wasIndexing);</pre></div><a id="id1158" class="indexterm"/><a id="id1159" class="indexterm"/><a id="id1160" class="indexterm"/><a id="id1161" class="indexterm"/><p>Here we use <code class="literal">ImportUtils</code> to save the current indexing state and turn it ON. After the update to issue(s) is done, indexing is turned back to whatever it was!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec215"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Searching in plugins</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec73"/>Managing filters programmatically</h1></div></div></div><p>Be it a beginner in JIRA or a pro, one of the features used often is creating and managing filters. The fact that we can save the searches, share them, and subscribe to it adds a lot of value to JIRA. So, how do we programmatically create and manage filters?</p><p>In this recipe, we will learn how to manage filters programmatically.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec216"/>How to do it...</h2></div></div></div><a id="id1162" class="indexterm"/><a id="id1163" class="indexterm"/><p>We will see the various aspects of managing the filters one-by-one:</p><p><strong>Creating a filter</strong></p><a id="id1164" class="indexterm"/><p>Most of the operations on managing filters are done using <code class="literal">SearchRequestService</code>. For creating a filter, following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the Query to be saved as filter. The Query can be created using <code class="literal">JqlQueryBuilder</code>, as we have seen in the previous recipes.</li><li class="listitem">Create a <code class="literal">SearchRequest</code> object from the Query<div><pre class="programlisting">SearchRequest searchRequest = new SearchRequest(query);</pre></div></li><li class="listitem">Create a JIRA Service Context. If you are in an action class, you can get the service context by calling <code class="literal">getJiraServiceContext()</code> and if not, an instance can be created as:<div><pre class="programlisting">JiraServiceContext ctx = new JiraServiceContextImpl(user);</pre></div><p>Where user is the user for which the filter should be created.</p></li><li class="listitem">Get an instance of <code class="literal">SearchRequestService</code>. It can be either injected in the constructor or as follows:<div><pre class="programlisting">SearchRequestService searchRequestService = ComponentManager.getInstance().getSearchRequestService();</pre></div></li><li class="listitem">Create the filter:<div><pre class="programlisting">final SearchRequest newSearchRequest = searchRequestService.createFilter(ctx, searchRequest, favourite);</pre></div><p>Where <code class="literal">favourite</code> is a boolean which can be set to true, if you want the filter to be made a favorite.</p></li></ol></div><p><strong>Updating a filter</strong></p><a id="id1165" class="indexterm"/><p>Updating a filter is much similar to creating a filter. Once the <code class="literal">SearchRequest</code> is updated and context is created, we need to invoke the following method to update and persist in the database the filter with the new search parameters, that is, the new query:</p><div><pre class="programlisting">SearchRequest updatedSearchRequest = searchRequestService.updateSearchParameters(JiraServiceContextserviceCtx, SearchRequest request);</pre></div><p>To update the attributes such as name, description, and so on, one of the following methods is invoked, depending on whether we want to make the filter favorite or not:</p><div><pre class="programlisting">SearchRequest updatedFilter = searchRequestService.updateFilter(JiraServiceContextserviceCtx, SearchRequest request);</pre></div><p>Alternatively, we can use:</p><div><pre class="programlisting">SearchRequest updatedFilter = searchRequestService.updateFilter(JiraServiceContextserviceCtx, SearchRequest request, booleanisFavourite);</pre></div><p><strong>Deleting a filter</strong></p><a id="id1166" class="indexterm"/><a id="id1167" class="indexterm"/><a id="id1168" class="indexterm"/><p>JIRA takes the filter ID as the input for deleting a filter. Before we actually delete the filter, we need to validate the deletion as follows:</p><div><pre class="programlisting">searchRequestService.validateForDelete(ctx, filterId);</pre></div><p>If there are any errors, it will be added into the Action's error collection. We can then check for the errors and delete the filter, if there are no errors.</p><div><pre class="programlisting">if(!ctx.getErrorCollection().hasAnyErrors())){
  searchRequestService.deleteFilter(ctx, filterId);
}</pre></div><p>We can also delete all the filters of a user using:</p><div><pre class="programlisting">deleteAllFiltersForUser(JiraServiceContextserviceCtx, User user);</pre></div><p><strong>Retrieving filters</strong></p><a id="id1169" class="indexterm"/><p>The <code class="literal">SearchRequestService</code> also has few methods to retrieve favorite filters, filters owned by a user, non-private filters, and so on. Key methods are listed as follows:</p><div><pre class="programlisting">Collection&lt;SearchRequest&gt;getFavouriteFilters(User user);
Collection&lt;SearchRequest&gt;getOwnedFilters(User user);
Collection&lt;SearchRequest&gt;getNonPrivateFilters(User user);
Collection&lt;SearchRequest&gt;getFiltersFavouritedByOthers(User user);</pre></div><p>The method names are self explanatory.</p><p><strong>Sharing a filter</strong></p><a id="id1170" class="indexterm"/><a id="id1171" class="indexterm"/><a id="id1172" class="indexterm"/><p>In order to share a filter, we need to retrieve the relevant filter and set the permissions on it using:</p><div><pre class="programlisting">searchRequest.setPermissions(permissions);</pre></div><p>Where permissions is a set of <code class="literal">SharePermission</code> objects. The <code class="literal">SharePermission</code> objects can be created from a JSONArray using the <code class="literal">SharePermissionUtils utility</code> class. The JSONObject can have three keys – <code class="literal">Type</code>, <code class="literal">Param1</code>, and <code class="literal">Param2</code>.</p><p>The <code class="literal">Type</code> can have the following values: <code class="literal">global</code>, <code class="literal">group</code>, or <code class="literal">project</code>.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When <code class="literal">Type</code> is <code class="literal">global</code>, <code class="literal">Param1</code> and <code class="literal">Param2</code> are not required.</li><li class="listitem" style="list-style-type: disc">When it is <code class="literal">group</code>, <code class="literal">Param1</code> is populated with the <code class="literal">groupname</code>.</li><li class="listitem" style="list-style-type: disc">When it is <code class="literal">project</code>, <code class="literal">Param1</code> is the ID of the project and <code class="literal">Param2</code> is the ID of the project role</li></ul></div><p>Example of JSON arrays is as follows:</p><div><pre class="programlisting">[{"type":"global"}]
[{"type":"group","param1":"jira-administrators"},{"type":"project","param1":"10000","param2":"10010"}]</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec217"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Searching in plugins</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Subscribing to a filter</h1></div></div></div><a id="id1173" class="indexterm"/><a id="id1174" class="indexterm"/><p>We have seen various methods of managing filters. While filters are a great way to save searches and access them quickly at a later point of time, filter subscriptions are even better! The subscriptions help us to see the issues of interest at regular intervals without even logging in to JIRA.</p><p>How do we subscribe to a filter programmatically? In this recipe, we will focus on subscribing to a filter in our plugins.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec218"/>How to do it...</h2></div></div></div><p>For the subscription of filters, JIRA provides a manager class implementing the <code class="literal">FilterSubscriptionService</code> interface<a id="id1175" class="indexterm"/>. This class provides the important methods needed for managing filter subscriptions.</p><p>There are three important parameters for Filter Subscriptions:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Cron Expression</strong>: This is the most important part of a subscription. It tells us when the subscription has to run, or in other words, it defines the schedule of a subscription.<p>Cron expressions<a id="id1176" class="indexterm"/> consist of the following fields separated by spaces.</p><a id="id1177" class="indexterm"/><a id="id1178" class="indexterm"/><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Field</p>
</th><th style="text-align: left" valign="bottom">
<p>Allowed Values</p>
</th><th style="text-align: left" valign="bottom">
<p>Allowed Special Characters</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Second</code></p>
</td><td style="text-align: left" valign="top">
<p>0-59</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">, - * /</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Minute</code></p>
</td><td style="text-align: left" valign="top">
<p>0-59</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">, - * /</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Hour</code></p>
</td><td style="text-align: left" valign="top">
<p>0-23</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">, - * /</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Day-of-Month</code></p>
</td><td style="text-align: left" valign="top">
<p>1-31</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">, - * / ? L W C</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Month</code></p>
</td><td style="text-align: left" valign="top">
<p>1-12 Or JAN-DEC</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">, - * /</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Day-of-week</code></p>
</td><td style="text-align: left" valign="top">
<p>1-7 Or SUN-SAT</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">, - * / ? L C #</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Year (Optional)</code></p>
</td><td style="text-align: left" valign="top">
<p>1970-2099</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">, - * /</code></p>
</td></tr></tbody></table></div><p>The special characters denote the following:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Special Character</p>
</th><th style="text-align: left" valign="bottom">
<p>Usage</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">,</code></p>
</td><td style="text-align: left" valign="top">
<p>List of values. For example, 'MON,WED,FRI' means 'every Monday, Wednesday, and Friday'.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">-</code></p>
</td><td style="text-align: left" valign="top">
<p>Range of Values. For example, 'MON-WED' means 'every Monday, Tuesday, Wednesday'.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">*</code></p>
</td><td style="text-align: left" valign="top">
<p>All possible values. For example, * in the <code class="literal">Hour</code> field means 'every hour of the day'.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">/</code></p>
</td><td style="text-align: left" valign="top">
<p>Increments to the give value. For example, 1/3 in <code class="literal">Hour</code> field means ' every 3 hours during the day, starting from 1.00 AM'.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">?</code></p>
</td><td style="text-align: left" valign="top">
<p>No particular value. This is useful when you need to specify a value for only one of the two fields, <code class="literal">Day-of-month</code> or <code class="literal">Day-of-week</code>, but not the other.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">L</code></p>
</td><td style="text-align: left" valign="top">
<p>Last possible value. It has different meanings based on the context. For example:</p>
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">L in <code class="literal">Day-of-week</code> means 'Last day of every week'</li><li class="listitem" style="list-style-type: disc">7L means 'last Saturday of the month'</li><li class="listitem" style="list-style-type: disc">L in <code class="literal">Day-of-month</code> means 'last day of the month'</li><li class="listitem" style="list-style-type: disc">LW means 'last weekday of the month'<a id="id11758" class="indexterm"/><a id="id1179" class="indexterm"/></li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">W</code></p>
</td><td style="text-align: left" valign="top">
<p>Weekday (MON-FRI) nearest to the given day of the month.</p>
<p>For example, 1W means 'nearest working day to the 1st of the month' – useful when you want to get the first working day of the month!</p>
<p>It cannot be used with a range of days.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#</code></p>
</td><td style="text-align: left" valign="top">
<p>N'th occurance of a given day of the week.</p>
<p>For example, MON#3 means '3rd Monday of the month'</p>
</td></tr></tbody></table></div><p>We need to create a valid Cron expression based on the subscription we want to set up. The following are some examples based on these rules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0 7 30 * * ?</code> – 7:30 AM Every Day</li><li class="listitem" style="list-style-type: disc"><code class="literal">0 0/15 15 * * ?</code> – Every 15 minutes starting at 3.00PM ending at 3:59 PM</li></ul></div><p>You can find more examples in the Atlassian documentation for filter subscriptions at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Receiving+Search+Results+via+Email">http://confluence.atlassian.com/display/JIRA/Receiving+Search+Results+via+Email</a>.</p></li><li class="listitem"><strong>Group Name</strong>: This is the group that we want to subscribe the filter. If the value is null, it will be considered as a personal subscription and the user in the context will be used.</li><li class="listitem"><strong>Email On Empty</strong>: It is a boolean value which is <code class="literal">true</code> if you want the subscription to send an e-mail, even when it has no results.</li></ol></div><a id="id1181" class="indexterm"/><a id="id1182" class="indexterm"/><p>Now let us see the steps to subscribe to a known filter:</p><div><ol class="orderedlist arabic"><li class="listitem">Get an instance of the <code class="literal">FilterSubscriptionService</code>. You can either inject the class in the constructor or get it using the <code class="literal">ComponentManger</code> class as follows:<div><pre class="programlisting">FilterSubscriptionService filterSubscriptionService = ComponentManager.getInstance().getComponentInstanceOfType(FilterSubscriptionService.class)</pre></div></li><li class="listitem">Define the cron expression based on the aforementioned rules:<div><pre class="programlisting">String cronExpression = "0 0/15 * * * ? *"; // Denotes every 15 minutes</pre></div></li><li class="listitem">Define the group name. Use <code class="literal">null</code> if it is a personal subscription:<div><pre class="programlisting">String groupName = "jira-administrators";</pre></div></li><li class="listitem">Create a JIRA Service Context. If you are in an action class, you can get the service context by calling <code class="literal">getJiraServiceContext()</code>, and if not, an instance can be created as:<div><pre class="programlisting">JiraServiceContext ctx = new JiraServiceContextImpl(user);</pre></div><p>Where <code class="literal">user</code> is the user for whom the filter is subscribed, in case it is a personal subscription.</p></li><li class="listitem">Define whether an e-mail should be sent, even when the number of results is zero or not:<div><pre class="programlisting">booleane mailOnEmpty = true;</pre></div></li><li class="listitem">Validate the cron expression:<div><pre class="programlisting">filterSubscriptionService.validateCronExpression(ctx, cronExpression);</pre></div><p>If there are any errors, the Error Collection in <code class="literal">JiraServiceContext</code> will be populated with an error message.</p></li><li class="listitem">If there are no errors, use the <code class="literal">FilterSubscriptionService</code> class to store the subscription:<div><pre class="programlisting">if (!ctx.getErrorCollection().hasAnyErrors()){
  filterSubscriptionService.storeSubscription(ctx, filterId, groupName, cronExpression, emailOnEmpty);
}</pre></div><p>Here <code class="literal">filterId</code> is the ID of the filter we want to subscribe to and can be obtained as <code class="literal">searchRequest.getId()</code>!</p></li></ol></div><p>The subscription should now be saved and the mails will be sent based on the schedule defined by the cron expression.</p><p>We can also update an existing subscription using <code class="literal">FilterSubscriptionService</code> using the following method:</p><div><pre class="programlisting">filterSubscriptionService.updateSubscription(ctx, subId, groupName, cronExpression, emailOnEmpty);</pre></div><p>Where <code class="literal">subId</code> is the existing subscription ID!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec219"/>How it works...</h2></div></div></div><p>Each subscription we create is stored as <strong>Quartz</strong><a id="id1183" class="indexterm"/> scheduled jobs in the system, which runs based on the cron expression we have defined while storing the subscription.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec220"/>There's more...</h2></div></div></div><p>If you want to use a Web Form, like the one used in JIRA, to create filter subscriptions and you don't want to write the cron expression, you can create a <code class="literal">CronEditorBean</code> using the parameters from the Web Form.</p><p>The various attributes supported in the form can be found from the <code class="literal">CronEditorBean</code> class. The Java Docs can be found at <a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/web/component/cron/CronEditorBean.html">http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/web/component/cron/CronEditorBean.html</a>.</p><p>Once the <code class="literal">CronEditorBean</code> is created, it can be parsed into a cron expression as follows:</p><div><pre class="programlisting">String cronExpression = new CronExpressionGenerator().getCronExpressionFromInput(cronEditorBean);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec221"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id1184" class="indexterm"/><a id="id1185" class="indexterm"/><em>Searching in plugins</em></li></ul></div></div></div></body></html>