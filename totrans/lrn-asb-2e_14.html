<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-204"><a id="_idTextAnchor609"/>14</h1>
<h1 id="_idParaDest-205"><a id="_idTextAnchor610"/>Hardening Your Servers Using Ansible</h1>
<p>One of the advantages of using an orchestration and configuration tool such as Ansible is that it can be utilized to generate and deploy a complex set of configurations in a repeatable task across many hosts. In this chapter, we will look at a tool that scans your hosts using Ansible, dynamically generates a remediation playbook, and then runs it for you.</p>
<p>We will also look at running two different security tools that scan the WordPress installation we have used throughout the previous chapters.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>The scanning tools</li>
<li>The playbook</li>
</ul>
<h1 id="_idParaDest-206"><a id="_idTextAnchor611"/>Technical requirements</h1>
<p>Following our excursion into the cloud, we will return to our local machine and launch a<a id="_idTextAnchor612"/>n Ubuntu 22.04 <a id="_idTextAnchor613"/>virtual machine using Multipass; as we will be running a workload that requires a bit more disk space than we have been used to so far, we will be altering the specs of the virtual machine when we launch it to increase the disk space and RAM.</p>
<p>As we will be installing a lot of different software on the virtual machine, your Multipass virtual machine will need to be able to download packages from the internet; there will be around 3 GB of various packages and configuration files to download.</p>
<p>You can find a complete copy of the playbook accompanying this chapter in the repository at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14</a>.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor614"/>The scanning tools</h1>
<p>Before we dive into<a id="_idIndexMarker774"/> the Playbook, let’s quickly look at the three tools we will be running, starting with the one that does the most, <strong class="bold">OpenSCAP</strong>.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor615"/>OpenSCAP</h2>
<p>First, we will <a id="_idIndexMarker775"/>be looking at one of Red Hat’s tools, called OpenSCAP. Before<a id="_idIndexMarker776"/> we continue, the next section will contain many abbreviations.</p>
<p>So, what is SCAP? The <strong class="bold">Security Content Automation Protocol</strong> (<strong class="bold">SCAP</strong>) is an open standard that <a id="_idIndexMarker777"/>encompasses several components, all of which are open standards themselves, to build a framework that allows you to<a id="_idIndexMarker778"/> automatically assess and remediate your hosts against the <strong class="bold">National Institute of Standards and Technology</strong> (<strong class="bold">NIST</strong>) <em class="italic">Special </em><em class="italic">Publication 800-53</em>.</p>
<p>This publication is a catalog of controls applied to all U.S. federal IT systems, apart from those maintained <a id="_idIndexMarker779"/>by the <strong class="bold">National Security Agency</strong> (<strong class="bold">NSA</strong>). These controls have been effected to help implement the <strong class="bold">Federal Information Security Management Act</strong> (<strong class="bold">FISMA</strong>) of <a id="_idIndexMarker780"/>2002 across U.S. federal departments.</p>
<p>SCAP is made up of the following components:</p>
<ul>
<li><strong class="bold">Asset Identification</strong> (<strong class="bold">AID</strong>) is a data<a id="_idIndexMarker781"/> model<a id="_idIndexMarker782"/> used for asset identification.</li>
<li><strong class="bold">Asset Reporting Format</strong> (<strong class="bold">ARF</strong>) is a <a id="_idIndexMarker783"/>vendor-neutral and technology-agnostic data model for transporting information on assets between different reporting applications and services.</li>
<li><strong class="bold">Common Configuration Enumeration</strong> (<strong class="bold">CCE</strong>) is a standard database of recommended <a id="_idIndexMarker784"/>configurations for common software. Each recommendation has a unique identifier. At the time of writing, the database hadn’t been updated for over a decade.</li>
<li><strong class="bold">Common Configuration Scoring System</strong> (<strong class="bold">CCSS</strong>) is the continuation of CCE. It is<a id="_idIndexMarker785"/> used for generating a score for various software and hardware configurations across all types of deployments.</li>
<li><strong class="bold">Common Platform Enumeration</strong> (<strong class="bold">CPE</strong>) identifies hardware assets, operating <a id="_idIndexMarker786"/>systems, and software in an organization’s infrastructure. Once identified, this data can then be used to search other databases to threat-assess the asset.</li>
<li><strong class="bold">Common Weakness Enumeration</strong> (<strong class="bold">CWE</strong>) is a common language for dealing with <a id="_idIndexMarker787"/>and discussing the causes of weaknesses in system architecture, design, and code that may lead to vulnerabilities.</li>
<li><strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVE</strong>) is a database of publicly acknowledged <a id="_idIndexMarker788"/>vulnerabilities. Most system administrators and IT professionals will have encountered the CVE database at some point. Each vulnerability receives a unique ID; for example, most people will know CVE-2014-0160, also known as <strong class="bold">Heartbleed</strong>. The <a id="_idIndexMarker789"/>Heartbleed vulnerability was a severe s<a id="_idTextAnchor616"/>ecurity flaw in OpenSSL (a cryptographic software library) that allowed attackers to steal sensitive information, such <a id="_idIndexMarker790"/>as passwords and private keys, from the memory of affected systems by exploiting a bug in <a id="_idIndexMarker791"/>the OpenSSL’s implementation of the <strong class="bold">transport layer security</strong> (<strong class="bold">TLS</strong>)/<strong class="bold">datagram transport layer security</strong> (<strong class="bold">DTLS</strong>) heartbeat <a id="_idIndexMarker792"/>extension.</li>
<li><strong class="bold">Common Vulnerability Scoring System</strong> (<strong class="bold">CVSS</strong>) is a method that helps capture the <a id="_idIndexMarker793"/>characteristics of a vulnerability to produce a normalized numerical score, which can then be used to describe the impact of a vulnerability, for example, low, medium, high, and critical.</li>
<li><strong class="bold">Extensible Configuration Checklist Description Format</strong> (<strong class="bold">XCCDF</strong>) is an XML format<a id="_idIndexMarker794"/> for describing security checklists. It can also be used for configuration and <a id="_idIndexMarker795"/>benchmarks and provides a common language for all the parts of SCAP.</li>
<li><strong class="bold">Open Checklist Interactive Language</strong> (<strong class="bold">OCIL</strong>) is a framework for expressing<a id="_idIndexMarker796"/> questions to an end user and the procedures to process the responses in a standardized way.</li>
<li><strong class="bold">Open Vulnerability and Assessment Language</strong> (<strong class="bold">OVAL</strong>) is defined in XML and<a id="_idIndexMarker797"/> aims to standardize the transfer of security content across all of the tools and services offered by NIST, the MITRE Corporation, the <strong class="bold">United States Computer Emergency Readiness Team</strong> (<strong class="bold">US-CERT</strong>), and <a id="_idIndexMarker798"/>the United <a id="_idIndexMarker799"/>States <strong class="bold">Department of Homeland </strong><strong class="bold">Security</strong> (<strong class="bold">DHS</strong>).</li>
<li><strong class="bold">Trust Model for Security Automation Data</strong> (<strong class="bold">TMSAD</strong>) is an XML document that aims to <a id="_idIndexMarker800"/>define a <a id="_idIndexMarker801"/>common trust model that can be applied to the data being exchanged by all components that make up SCAP.</li>
</ul>
<p>As you can imagine, thousands of man-years have gone into producing SCAP and its components to make its foundation. Some of the projects have been around in one form or another since<a id="_idIndexMarker802"/> the mid-90s, so they are well-established and considered the de facto standard when it comes to security best practices; however, I am sure you think that it all sounds very complicated – after all, these are standards that have been defined and are being maintained by scholars, security professionals, and government departments.</p>
<p>This is where OpenSCAP comes in. The OpenSCAP project, maintained by Red Hat and certified by NIST for supporting the SCAP standard, allows you to apply all the best practices we have discussed using a command-line client.</p>
<p class="callout-heading">Note</p>
<p class="callout">The automatic remediation scripts in OpenSCAP are a work in progress, and there are known issues that we will address toward the end of the chapter. Because of this, your output may differ from that covered in this chapter.</p>
<p>OpenSCAP, like many Red Hat projects, has support for Ansible, and the current release introduces support for automatically generating Ansible playbooks to remediate non-conformance <a id="_idIndexMarker803"/>discovered during an OpenSCAP scan.</p>
<p>The next two tools we will be looking at will be scanning our WordPress site, starting with WPScan.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor617"/>WPScan</h2>
<p>The second <a id="_idIndexMarker804"/>tool we will be running is called <strong class="bold">WPScan</strong> and we will use it to <a id="_idIndexMarker805"/>scan our WordPress site. WPScan is a command-line tool that can perform various security assessments and vulnerability tests on WordPress installations. It can detect common configuration errors, outdated themes, weak passwords, and other potential risks. WPScan is easy to install – especially as we will be using the container version and running it using Docker, which we will also be going for the t<a id="_idTextAnchor618"/>hird and final tool, OWASP ZAP.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor619"/>OWASP ZAP</h2>
<p>Web vulnerabilities <a id="_idIndexMarker806"/>such as SQL injection, cross-site scripting, broken <a id="_idIndexMarker807"/>authentication, and insecure deserialization can threaten our WordPress site’s security and quality. To help identify and prioritize such vulnerabilities, we can use <strong class="bold">OWASP ZAP</strong>. This tool, the third and final one we will cover in the chapter, generates reports, alerts, and graphs that assist us in visualizing and addressing the findings. Moreover, OWASP ZAP is user-friendly and easy to install, making it a valuable resource for enhancing our site’s security and overall quality.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor620"/>The playbook</h1>
<p>We will split the<a id="_idIndexMarker808"/> playbook into a few different roles to run the various scanning tools that will be running in the chapter – as you can see from the <code>site.yml</code> file, we are adding some conditions to the roles containing our tasks. The start of the file looks like all of the other playbook files we have been running:</p>
<pre class="source-code">
- name: "Scan our WordPress Ansible Playbook and stack"
  hosts: ansible_hosts
  gather_facts: true
  become: true
  become_method: "ansible.builtin.sudo"
  vars_files:
    - 'group_vars/common.yml'</pre> <p>As mentioned, roles are where this playbook starts to differ from the previous playbooks we have been running up to this point in the book.</p>
<p>As you can see from the following source, we are defining tags alongside the roles themselves:</p>
<pre class="source-code">
  roles:
    - { role: 'common', tags: ['openscap','scan'] }
    - { role: 'docker', tags: ['docker','scan'] }</pre> <p>As you can see, we are<a id="_idIndexMarker809"/> using the <code>openscap</code>, <code>scan</code>, and <code>docker</code> tags followed by <code>wordpress</code>, which used the roles directly from <a href="B21620_05.xhtml#_idTextAnchor253"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying WordPress</em>:</p>
<pre class="source-code">
    - { role: 'stack_install', tags: ['wordpress'] }
    - { role: 'stack_config', tags: ['wordpress'] }
    - { role: 'wordpress', tags: ['wordpress'] }</pre> <p>Finally, we have roles that run <code>scans</code> and <code>openscap</code>:</p>
<pre class="source-code">
    - { role: 'scan', tags: ['scan'] }
    - { role: 'openscap', tags: ['openscap'] }</pre> <p>So, what does this mean? Well, later in the chapter, when it comes to running the playbook, we will only be running specific roles; for example, to run OpenSCAP, we will use the following commands:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "openscap" --extra-vars "scap_options_remediation=true"
$ ansible-playbook -i hosts site.yml --tags "openscap"</pre> <p>When running the first command, it will run just the <code>common</code> and <code>openscap</code> roles and run the remediation Ansible Playbook and bash script, both of which will be automatically generated during the initial scan – it will also download a copy of the results, an implementation guide, a copy of the playbook, and a copy of the bash scripts.</p>
<p>The second of the two commands will rerun the scan host and download a copy of the results again.</p>
<p>Once we have finished running OpenSCAP, we will then redep<a id="_idTextAnchor621"/>loy our host and run the following:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "wordpress"</pre> <p>This, as I am sure you will have guessed, will run the three <code>wordpress</code> roles. Then, with WordPress installed, we can run the following:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "scan"</pre> <p>This will execute the <code>common</code>, <code>docker</code>, and <code>scan</code> roles.</p>
<p>We can also run these commands to run just one of the two scanning tools that the <code>scan</code> role runs:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "scan" --extra-vars "scan_types=zap"
$ ansible-playbook -i hosts site.yml --tags "scan" --extra-vars "scan_types=wpscan"</pre> <p>But we are getting <a id="_idIndexMarker810"/>ahead of ourselves; let’s work our way through the preceding roles before we think about running the playbook.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor622"/>The common role</h2>
<p>This role <a id="_idIndexMarker811"/>contains a single task in <code>roles/common/tasks/main.yml</code>, and its only job is to set a fact containing the current date and time:</p>
<pre class="source-code">
- name: "Set a fact for the date"
  ansible.builtin.set_fact:
    the_date: "{{ lookup('pipe', 'date +%Y-%m-%d-%H%M') }}"</pre> <p>You might think, <em class="italic">“That seems a little basic.”</em> However, as we will be using the <code>the_date</code> variable several times throughout the roles in this playbook, we only want it to be generated once as it will be used to create file and folder names that are then called later in tasks.</p>
<p>If we use <code>{{ lookup('pipe', 'date +%Y-%m-%d-%H%M') }}</code> to insert the date dynamically as part of other variables and tasks, we need to be cautious. This is because some parts of the playbook can take several minutes to finish running.</p>
<p>For instance, we may create a file called <code>myfile-2024-02-16-1300.yml</code> at one point in the playbook. However, if we dynamically set the date and time, and several tasks later, it takes five minutes for the playbook to get to that task, we could reference a file called <code>myfile-2024-02-16-1305.yml</code>. This would result in an error as the file does not exist. Therefore, we<a id="_idIndexMarker812"/> should only use the date and time lookup once during the playbook run.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor623"/>The Docker role</h2>
<p>This role<a id="_idIndexMarker813"/> contains<a id="_idIndexMarker814"/> all of the tasks and variables needed to install and configure Docker on our target host, much like the roles discussed in <a href="B21620_04.xhtml#_idTextAnchor202"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying a LAMP Stack</em>, and <a href="B21620_05.xhtml#_idTextAnchor253"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying WordPress</em>; this role uses the <code>ansible.builtin.apt</code>, <code>ansible.builtin.apt_key</code>, and <code>ansible.builtin.apt_repository</code> modules to do the following:</p>
<ol>
<li>Download and install the prerequisites required for Docker to run.</li>
<li>Add the <strong class="bold">GNU Privacy Guard</strong> (<strong class="bold">GPG</strong>) key for the official Docker <strong class="bold">advanced packaging tool</strong> (<strong class="bold">APT</strong>) repository.</li>
<li>Configure the official Docker APT repository.</li>
<li>Install Docker itself along with the Docker command-line tool.</li>
<li>Ensure that Docker is running and set to start on boot.</li>
</ol>
<p>To review the full list of tasks and variables for this role, see the following:</p>
<ul>
<li><a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/defaults/main.yml">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/defaults/main.yml</a></li>
<li><a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/tasks/main.yml">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/tasks/main.yml</a></li>
</ul>
<p>Next, we have <a id="_idIndexMarker815"/>the<a id="_idIndexMarker816"/> roles that install WordPress.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor624"/>The WordPress roles</h2>
<p>As you have already<a id="_idIndexMarker817"/> seen from the <code>site.yml</code> file at the start of the<a id="_idIndexMarker818"/> Playbook section of this chapter, here, we are just reusing the roles that we discussed at length in <a href="B21620_05.xhtml#_idTextAnchor253"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying WordPress</em>. If you want to review these, you can see them at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05/roles">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05/roles</a>.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor625"/>The scan role</h2>
<p>As already <a id="_idIndexMarker819"/>mentioned, we will be using Docker to run WPScan and OWASP ZAP; this allows us to reuse the same tasks. Let’s look at <code>roles/scan/tasks/main.yml</code>; first, we need to pull the Docker image or images:</p>
<pre class="source-code">
- name: "Pull the Docker image for the scanning tool"
  community.docker.docker_image:
    name: "{{ item.image }}"
    source: "{{ item.source }}"
  loop: "{{ scan }}"
  when: "item.name in scan_types"
  loop_control:
    label: "{{ item.name }}"</pre> <p>We are switching it up slightly in that we are using <code>loop</code> rather than <code>with_items</code>; this gives more control over what happens when looping through. In this task, we are using <code>label</code> to show which of the scanning tools is currently processing.</p>
<p>You may also notice that we have a <code>when</code> condition; this allows us to run both of the scans or just one of the two by passing in the name of the scan in the <code>scan_types</code> variable. When we look at the variables in a moment, you will see that by default, we are passing in the names of both scanning tools.</p>
<p>This pattern of <code>loop</code>, <code>loop_control</code>, and <code>when</code> will be repeated throughout all the tasks in this role. We have a task that will create a folder on the virtual machine; we will be mounting this folder into the container at runtime so that we can keep a copy of the scan output:</p>
<pre class="source-code">
- name: "Create the folder which we will mount inside the container"
  ansible.builtin.file:
    path: "{{ item.log.remote_folder }}"
    state: "directory"
    mode: "0777"
  loop: "{{ scan }}"
  when: "item.name in scan_types"
  loop_control:
    label: "{{ item.name }}"</pre> <p>Now, with the<a id="_idIndexMarker820"/> container image and folder created, we can run the scan:</p>
<pre class="source-code">
- name: "Run the scan"
  community.docker.docker_container:
    detach: "{{ item.detach }}"
    auto_remove: "{{ item.auto_remove }}"
    name: "{{ item.name }}"
    volumes: "{{ item.log.remote_folder }}:{{ item.container_folder }}"
    image: "{{ item.image }}"
    command: "{{ item.command }}"
  register: docker_scan
  ignore_errors: true
  no_log: true
  loop: "{{ scan }}"
  when: "item.name in scan_types"
  loop_control:
    label: "{{ item.name }}"</pre> <p>As you can see, everything is being passed to the container as variables; this is how we can run two very different tools with a single common task, and more so later when we look at the variables.</p>
<p>You will have <a id="_idIndexMarker821"/>also noted that we are adding a few options to the end of this task; these are as follows:</p>
<ul>
<li><code>register</code>: Here, we are just registering the output of the task – nothing special here</li>
<li><code>ignore_errors</code>: This tells Ansible to continue running should it detect an error; in our case, the containers we are running will purposely trigger an error code as they have been designed to halt and not proceed with any further tasks until the scan does not fail</li>
<li><code>no_log</code>: This suppresses the output – as we save the output when running the scan, we do not need the output printed to the terminal when we run the task</li>
</ul>
<p>As we are registering an output, the next task is a debug line. This follows the same pattern as debug tasks in other chapters, so we will be moving to the task that downloads a copy of the reports:</p>
<pre class="source-code">
- name: "Download the report"
  ansible.builtin.fetch:
    src: "{{ item.log.remote_folder }}{{ item.log.file }}"
    dest: "{{ item.log.local_folder }}"
    flat: true
    mode: "0644"
  loop: "{{ scan }}"
  when: "item.name in scan_types"
  loop_control:
    label: "{{ item.name }}"</pre> <p>This uses the <code>ansible.<a id="_idTextAnchor626"/>builtin.fetch</code> module setting the <code>flat</code> option to <code>true</code>. This option copies the file rather than the full directory path. The final task removes the container, meaning that when we next run a scan, it will start from scratch and spawn a new container rather than reusing the one we have just finished using:</p>
<pre class="source-code">
- name: "Remove the scan container"
  community.docker.docker_container:
    name: "{{ item.name }}"
    state: "absent"
  loop: "{{ scan }}"
  when: "item.name in scan_types"
  loop_control:
    label: "{{ item.name }}"</pre> <p>Now that we <a id="_idIndexMarker822"/>know what the tasks look like, <a id="_idTextAnchor627"/>let us look at the variables, which can be found in <code>roles/scan/defaults/main.yml</code>. The first variable sets the scan we want to run, and as already mentioned, this gives the name of the two scans:</p>
<pre class="source-code">
scan_types:
  - "{{ common_scan_settings.dict.wpscan }}"
  - "{{ common_scan_settings.dict.zap }}"</pre> <p>Next up in <code>roles/scan/defaults/main.yml</code>, we have a block of variables that could be commonly used across both scanning tools:</p>
<pre class="source-code">
common_scan_settings:
  detach: false
  auto_remove: false
  source: "pull"
  local_folder: "output/"
  report_name: "{{ the_date }}-results-"
  dict:
    wpscan: "wpscan"
    zap: "zap"</pre> <p>Finally, we have the primary <code>scan</code> variable, which is the one we have been looping over; it starts<a id="_idIndexMarker823"/> with WPScan:</p>
<pre class="source-code">
scan:
  - name: "{{ common_scan_settings.dict.wpscan }}"
    image: "wpscanteam/wpscan:latest"
    source: "{{ common_scan_settings.source }}"
    detach: "{{ common_scan_settings.detach }}"
    auto_remove: "{{ common_scan_settings.auto_remove }}"
    container_folder: "/tmp/{{ common_scan_settings.dict.wpscan }}/"
    command: "--url http://{{ ansible_host }} --enumerate u --plugins-detection mixed --format cli-no-color --output /tmp/{{ common_scan_settings.dict.wpscan }}/{{ common_scan_settings.report_name }}{{ common_scan_settings.dict.wpscan }}.txt"
    log:
      remote_folder: "/tmp/{{ common_scan_settings.dict.wpscan }}/"
      local_folder: "{{ common_scan_settings.local_folder }}"
      file: "{{ common_scan_settings.report_name }}{{ common_scan_settings.dict.wpscan }}.txt"</pre> <p>The block that follows is the one for OSWAP ZAP:</p>
<pre class="source-code">
  - name: "{{ common_scan_settings.dict.zap}}"
    image: "ghcr.io/zaproxy/zaproxy:stable"
    source: "{{ common_scan_settings.source }}"
    detach: "{{ common_scan_settings.detach }}"
    auto_remove: "{{ common_scan_settings.auto_remove }}"
    container_folder: "/zap/wrk/"
    command: "zap-baseline.py -t http://{{ ansible_host }} -g gen.conf -r {{ common_scan_settings.report_name }}{{ common_scan_settings.dict.zap }}.html"
    log:
      remote_folder: "/tmp/{{ common_scan_settings.dict.zap }}/"
      local_folder: "{{ common_scan_settings.local_folder }}"
      file: "{{ common_scan_settings.report_name }}{{ common_scan_settings.dict.zap }}.html"</pre> <p>As you can see, we pass in the different container images and commands to run the scan while using the same variables. Because of this, we could keep the tasks used in the role completely neutral, meaning that we didn’t have to consider anything custom to the tool we were running.</p>
<p>That concludes <a id="_idIndexMarker824"/>the scan role, leaving us with, as I am sure you will have already guessed from how long the tool explanation was at the start of the chapter, the most complex role in the playbook: OpenSCAP.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor628"/>The OpenSCAP role</h2>
<p>When writing <a id="_idIndexMarker825"/>a playbook, it is essential to know how the tool you are <a id="_idIndexMarker826"/>automating works; given that OpenSCAP is a little complex, let’s review the steps needed to manually run a scan and remediate the problems it finds using an automatically generated Ansible playbook and a shell script.</p>
<p class="callout-heading">Note</p>
<p class="callout">While the commands to run OpenSCAP follow, you do not need to follow along; these are provided to illustrate the process we need to follow in our Playbook role.</p>
<p>First, we need to download and install OpenSCAP itself, along with a few tools we will also need:</p>
<pre class="console">
$ sudo apt-get install unzip curl libopenscap8</pre> <p>Next up, we need to download the actual content – these definitions cover several different operating systems and various levels of compliance. The GitHub repository for this content can be found at <a href="https://github.com/ComplianceAsCode/content">https://github.com/ComplianceAsCode/content</a>, and at the time of writing, the current release is 0.1.71.</p>
<p>Get the release URL for the zip file, which contains the files we need from the releas<a id="_idTextAnchor629"/>es page, then download and unzip on the host:</p>
<pre class="console">
$ wget https://github.com/ComplianceAsCode/content/releases/download/v0.1.71/scap-security-guide-0.1.71.zip
unzip scap-security-guide-0.1.71.zip</pre> <p>Now that we have OpenSCAP and the definition files installed, we can get some information on what is available for our Ubuntu 22.04 operating system:</p>
<pre class="console">
$ sudo oscap info --fetch-remote-resources scap-security-guide-0.1.71/ssg-ubuntu2204-ds.xml</pre> <p>This will give us the name of the profile we want to use; in our case, it is <code>xccdf_org.ssgproject.content_profile_cis_level1_server</code>. Once we have <a id="_idIndexMarker827"/>this, we <a id="_idIndexMarker828"/>can run the scan itself:</p>
<pre class="console">
$ oscap xccdf eval --profile xccdf_org.ssgpr<a id="_idTextAnchor630"/><a id="_idTextAnchor631"/>oject.content_profile_cis_level1_server  --results-arf result.xml --report report.html scap-security-guide-0.1.71/ssg-ubuntu2204-ds.xml</pre> <p>This will generate two output files: an HTML copy of a report containing everything that needs fixing in a nicely digestible format we can read, and a second XML file containing the same information in a format OpenSCAP can read.</p>
<p>We can then take the XML file and generate a more detailed guide on how we could resolve the issues found by running the following:</p>
<pre class="console">
$ sudo oscap xccdf generate guide  --profile xccdf_org.ssgproject.content_profile_cis_level1_server scap-security-guide-0.1.71/ssg-ubuntu2204-ds.xml  &gt; guide.html</pre> <p>However, as this book is about Ansible, it would be better to have a Playbook to fix as many of the issues as possible, and running the following command will give us just that:</p>
<pre class="console">
$ sudo oscap xccdf generate fix --fetch-remote-resources --fix-type ansible --result-id "" result.xml &gt; playbook.yml</pre> <p>Finally, not everything can be resolved using the Playbook method, so having a bash script to fix any issues that can’t be resolved by running the playbook is also a great idea as it will mean less manual work for us to do:</p>
<pre class="console">
$ sudo oscap xccdf generate fix --fetch-remote-resources --fix-type bash --result-id "" result.xml &gt; bash.sh</pre> <p>Now we have the Playbook and bash script; we need to run them, copy the playbook to our local machine, and run it using the following:</p>
<pre class="console">
$ ansible-playbook -i hosts --become -become-method=sudo output/ansiblevm-playbook.yml</pre> <p>Then we go back to the virtual machine, and run the bash script using the following:</p>
<pre class="console">
$ sudo bash bash.sh</pre> <p>You will have<a id="_idIndexMarker829"/> seen<a id="_idIndexMarker830"/> a lot of output, but if everything goes as planned when you rerun the scan, you should see a lot of issues being reported.</p>
<p class="callout-heading">Note</p>
<p class="callout">The code in the repo contains the variables and tasks for a feature we will not cover here, as the content we are downloading from GitHub can take up a lot of space on your drive. These tasks are included to remove any unneeded files.</p>
<p>So, now that we have an idea of the steps we need to automate, let’s dive straight in.</p>
<p>First, let’s look at the variables, which can be found in <code>roles/openscap/default/main.yml</code>, and that we will be using within our tasks.</p>
<p>Start with the option that, if set to <code>true</code>, will execute the remediation Playbook and Bash script:</p>
<pre class="source-code">
scap_options_remediation: false</pre> <p>Next, we have the packages needed to run OpenSCAP and OpenSCAP itself:</p>
<pre class="source-code">
scap_packages:
  - "unzip"
  - "curl"
  - "libopenscap8"</pre> <p>Then we have information to download the content from GitHub; note that we are passing the API URL and not the direct download link (more on why later in the chapter):</p>
<pre class="source-code">
openscap_download:
  openscap_github_release_api_url: "https://api.github.com/repos/ComplianceAsCode/content/releases/latest"
  dest: "/tmp/scap-security-guide"</pre> <p>Now we have a<a id="_idIndexMarker831"/> long<a id="_idIndexMarker832"/> list of filenames and details on the profile we need to use:</p>
<pre class="source-code">
opens<a id="_idTextAnchor632"/>cap_scan:
  ssg_file_name: "{{openscap_download.dest}}/ssg-{{ ansible_facts.distribution | lower }}{{ ansible_facts.distribution_version | replace('.','') }}-ds.xml"
  profile_search: "cis_level1_server"
  output_dir: "/tmp/"
  output_file_xml: "{{ inventory_hostname }}-result.xml"
  output_file_html: "{{ inventory_hostname }}-report.html"
  output_file_guide: "{{ inventory_hostname }}-guide.html"
  output_file_playbook: "{{ inventory_hostname }}-playbook.yml"
  output_file_bash: "{{ inventory_hostname }}-bash.sh"
  local_output_dir: "output/{{ the_date }}-openscap-results"</pre> <p>Notice that we are trying not to hardcode any values; for example, when referring to the operating system, we use <code>{{ ansible_facts.distribution | lower }}{{ ansible_facts.distribution_version | replace('.','') }}</code>, which, in our case, gives us <code>ubuntu2204</code>. This means that if OpenSCAP supports it, we can run our Playbook on other Ubuntu distributions without making any changes.</p>
<p>The tasks that use these variables can be found in <code>roles/openscap/tasks/main.yml</code>; we begin with two tasks that install OpenSCAP, the first of which makes sure that the APT cache and our operating system are both up to date:</p>
<pre class="source-code">
- name: "Update apt cache and upgrade packages"
  ansible.builtin.apt:
    name: "*"
    state: "latest"
    update_cache: "yes"</pre> <p>The tasks immediately after installing OpenSCAP itself and the other packages we need:</p>
<pre class="source-code">
- name: "Install common packages"
  ansible.builtin.apt:
    state: "present"
    pkg: "{{ scap_packages }}"</pre> <p>Now, we <a id="_idIndexMarker833"/>create<a id="_idIndexMarker834"/> the directory where we will be storing the OpenSCAP content we will be downloading from GitHub:</p>
<pre class="source-code">
- name: "Create the directory to store the scap security guide content"
  ansible.builtin.file:
    path: "{{ openscap_download.dest }}"
    state: "directory"
    mode: "0755"</pre> <p>With our destination folder in place, we can now download the content and unarchive it:</p>
<pre class="source-code">
- name: "Download the latest scap security guide content"
  ansible.builtin.unarchive:
    src: "{{ lookup('url', '{{ openscap_download.openscap_github_release_api_url }}', split_lines=false) | from_json | json_query('assets[?content_type==`application/zip`].browser_download_url') | last }}"
    dest: "{{ openscap_download.dest }}"
    creates: "{{ openscap_download.dest }}/README.md"
    list_files: true
    remote_src: true
  register: scap_download_result</pre> <p>On the face of it, while it looks a little complicated, there is quite a bit going on; let’s break down how we are getting the value to populate into the <code>src</code> key.</p>
<p>We use Ansible’s <code>lookup</code> plugin to fetch and process data from the GitHub API, giving us the latest release information for the OpenSCAP Content GitHub repository:</p>
<ul>
<li><code>{{ lookup('url', '{{ openscap_download.openscap_github_release_api_url }}', split_lines=false) }}</code>: The <code>lookup</code> plugin is being used here with the <code>url</code> lookup type, which fetches data from the given URL that is specified by the <code>openscap_download.openscap_github_release_api_url</code> variable, which<a id="_idIndexMarker835"/> points to t<a id="_idTextAnchor633"/>he API endpoint for the latest<a id="_idIndexMarker836"/> release of a GitHub repository (<a href="https://api.github.com/repos/ComplianceAsCode/content/releases/latest">https://api.github.com/repos/ComplianceAsCode/content/releases/latest</a>). The <code>split_lines=false</code> parameter ensures that the fetched content is not split into lines, preserving its JSON structure.</li>
<li><code>| from_json</code>: This part of the code takes the output from the <code>lookup</code> plugin, which is expected to be a JSON string, and converts it into an Ansible data structure (such as a dictionary or a list) that can be further processed.</li>
<li><code>| json_query('assets[?content_type==`application/zip`].browser_download_url')</code>: This uses the <code>json_query</code> filter with a JMESPath expression to query the converted JSON data. The <code>'assets[?content_type==`application/zip`].browser_download_url'</code> query looks for items in the <code>assets</code> array where <code>content_type</code> is <code>application/zip</code>, and then extracts <code>browser_download_url</code>. This URL is typically used to directly download the asset from a browser.</li>
<li><code>| last</code>: Finally, the <code>last</code> filter is used to get the last URL from the list of URLs returned by the <code>json_query</code> filter. We are doing this as there might be multiple assets with the <code>application/zip</code> content type, but we are only interested in the most recent or last one listed.</li>
</ul>
<p>This means that we do not have to hardcode the version number of the latest release into our Playbook, which is helpful as the OpenSCAP <code>content</code> repo is updated at least once every few weeks.</p>
<p>The other <a id="_idIndexMarker837"/>options <a id="_idIndexMarker838"/>we are passing to the <code>ansible.builtin.unarchive</code> module are as follows:</p>
<ul>
<li><code>dest</code>: The destination directory on the target machine where the archive will be extracted is specified</li>
<li><code>creates</code>: This parameter is used as a conditional check to prevent re-downloading and extracting the archive if a particular file exists</li>
<li><code>list_files</code>: When set to <code>true</code>, this option lists all the files in the archive file; we will use this list to copy the files to our destination folder</li>
<li><code>remote_src</code>: Setting this to <code>true</code> indicates that the source archive is located on a remote server, not on the control machine running Ansible; this is needed to download content directly from a URL</li>
</ul>
<p>The following two tasks move the files to the root of <code>openscap_download.dest</code> as they would have been unarchived to a folder containing the version number – which we don’t want to use, as it could change between runs:</p>
<pre class="source-code">
- name: "Move scap security guide content to the correct location"
  ansible.builtin.shell: "mv {{ openscap_download.dest }}/{{ scap_download_result.files[0] }}/* {{ openscap_download.dest }}"
  when: scap_download_result.changed
- name: "Remove the downloaded scap security guide content"
  ansible.builtin.file:
    path: "{{ openscap_download.dest }}/{{ scap_download_result.files[0] }}"
    state: "absent"
  when: scap_download_result.changed</pre> <p>Note that we are only running these tasks when the task that downloads the files has changed.</p>
<p>The final bit of information we need before we can run the OpenSCAP scan is which profile to use. To get this, we need to run the command to print information on the profiles available for our operating system:</p>
<pre class="source-code">
- name: "Get information of the SCAP profiles available for the target system"
  ansible.builtin.command: "oscap info –profiles –fetch-remote-resources {{ openscap_scan.ssg_file_name }}"
  register: scap_info</pre> <p>Now that<a id="_idIndexMarker839"/> we <a id="_idIndexMarker840"/>have the information on the available profiles registered as <code>scap_info</code>, we can filter this list based on the contents of <code>openscap_scan.profile_search</code> and set a fact:</p>
<pre class="source-code">
- name: "Extract profile name based on our selection criteria"
  ansible.builtin.set_fact:
    profile_name: "{{ scap_info.stdout_lines | select('search', openscap_scan.profile_search) | map('regex_replace', '^(.*?):.*$', '\\1') | first }}"</pre> <p>With the fact set, we can run the scan itself:</p>
<pre class="source-code">
- name: "Run OpenSCAP scan"
  ansible.builtin.command: "oscap xccdf eval --profile {{ profile_name }} --results-arf {{ openscap_scan.output_dir }}{{ openscap_scan.output_file_xml }} --report {{ openscap_scan.output_dir }}{{ openscap_scan.output_file_<a id="_idTextAnchor634"/>html }} {{ openscap_scan.ssg_file_name }}"
  ignore_errors: true
  no_log: true
  register: scap_scan</pre> <p>As you can see, we are suppressing the output by using <code>no_log: true</code>; this is because we don’t really need to see the output at this stage and can ignore errors, like in the previous role where we ran WPScan and OSWAP ZAP.</p>
<p>Now that we have the output of the scan, we need to create a folder on our Ansible host to copy the output files to the following:</p>
<pre class="source-code">
- name: "Ensure the local output directory exists"
  ansible.builtin.file:
    path: "{{ openscap_scan.local_output_dir }}"
    state: directory
    mode: "0755"
  delegate_to: "localhost"
  become: false</pre> <p>As you can<a id="_idIndexMarker841"/> see, we <a id="_idIndexMarker842"/>are using <code>delegate_to</code> to ensure that Ansible runs the task on <code>localhost</code>, and we are telling it not to become a privileged user.</p>
<p>Now we can <code>fetch</code> the <code>output.xml</code> and <code>report.html</code> files:</p>
<pre class="source-code">
- name: "Copy the SCAP report and results file to local machine"
  ansible.builtin.fetch:
    src: "{{ item }}"
    dest: "{{ openscap_scan.local_output_dir }}/"
    flat: true
    mode: "0644"
  with_items:
    - "{{ openscap_scan.output_dir }}{{ openscap_scan.output_file_xml }}"
    - "{{ openscap_scan.output_dir }}{{ openscap_scan.output_file_html }}"</pre> <p>Next, we need to generate the guide and remediation files:</p>
<pre class="source-code">
- name: "generate SCAP guide"
  ansible.builtin.command: "oscap xccdf generate guide --profile {{ profile_name }} {{ openscap_scan.ssg_file_name }}"
  ignore_errors: true
  register: scap_guide</pre> <p>You may have noticed we are not saving a file here; we are just registering the output. That is because all of the content for the guide is output to the screen when the command is run, so rather than direct the output to a file on the virtual machine and copy it, we<a id="_idIndexMarker843"/> can capture the output and then create a file on our local <a id="_idIndexMarker844"/>machine that contains this content, essentially a fancy <em class="italic">copy</em> + <em class="italic">paste</em> from the remote host to our local one:</p>
<pre class="source-code">
- name: "Copy SCAP guide to local machine"
  ansible.builtin.copy:
    content: "{{ scap_guide.stdout }}"
    dest: "{{ openscap_scan.local_output_dir }}/{{ openscap_scan.output_file_guide }}"
    mode: "0644"
  when: scap_guide is defined
  <a id="_idTextAnchor635"/>delegate_to: "localhost"
  become: false</pre> <p>This is then repeated for the remediation Ansible Playbook:</p>
<pre class="source-code">
- name: "Generate SCAP fix playbook"
  ansible.builtin.command: "oscap xccdf generate fix --fetch-remote-resources --fix-type ansible --result-id '' {{ openscap_scan.output_dir }}{{ openscap_scan.output_file_xml }}"
  ignore_errors: true
  register: scap_playbook
- name: "Copy SCAP playbook to local machine"
  ansible.builtin.copy:
    content: "{{ scap_playbook.stdout }}"
    dest: "{{ openscap_scan.local_output_dir }}/{{ openscap_scan.output_file_playbook }}"
    mode: "0644"
  when: scap_playbook is defined
  delegate_to: "localhost"
  become: false</pre> <p>Then <a id="_idIndexMarker845"/>again, for<a id="_idIndexMarker846"/> the remediation Bash script:</p>
<pre class="source-code">
- name: "Generate SCAP fix bash script"
  ansible.builtin.command: "oscap xccdf generate fix --fetch-remote-resources --fix-type bash --result-id '' {{ openscap_scan.output_dir }}{{ openscap_scan.output_file_xml }}"
  ignore_errors: true
  register: scap_bash_script
- name: "Copy SCAP bash script to local machine"
  ansible.builtin.copy:
    content: "{{ scap_bash_script.stdout }}"
    dest: "{{ openscap_scan.local_output_dir }}/{{ openscap_scan.output_file_bash }}"
    mode: "0644"
  when: scap_bash_script is defined
  delegate_to: "localhost"
  become: false</pre> <p>The remaining tasks in the role deal with the remediation work, starting with the playbook:</p>
<pre class="source-code">
- name: "Run the remediation playbook"
  ansible.builtin.command: "ansible-playbook -i {{ inventory_file }} --become --become-method sudo {{ openscap_scan.local_output_dir }}/{{ openscap_scan.output_file_playbook }}"
  when: scap_options_remediation
  delegate_to: "localhost"
  become: false
  register: remediation_playbook</pre> <p>Then, as we<a id="_idIndexMarker847"/> never kept a copy of the bash script on the target virtual<a id="_idIndexMarker848"/> machine, we need to copy it back there:</p>
<pre class="source-code">
- name: "Copy the remediation bash script to the target machine"
  ansible.builtin.copy:
    src: "{{ openscap_scan.local_output_dir }}/{{ openscap_scan.output_file_bash }}"
    dest: "{{ openscap_scan.output_dir }}"
    mode: "0755"
  when: scap_options_remediation</pre> <p>Once copied, we can run the script:</p>
<pre class="source-code">
- name: "Run the remediation bash script"
  ansible.builtin.command: "bash {{ openscap_scan.output_dir }}{{ openscap_scan.output_file_bash }}"
  when: scap_options_remediation
  register: remediation_bash_script</pre> <p>With that task, the <a id="_idIndexMarker849"/>role is complete, and we now have all the pieces in place to run our playbook.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor636"/>Running the playbook</h2>
<p>In <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing and Running Ansible</em>, we covered the installation and usage of Multipass; since <a id="_idIndexMarker850"/>then, we have been launching our local virtual machines using the same commands. In this chapter, as we need a little more disk space and RAM, we are going to be adding a few extra options when we launch the virtual machine:</p>
<pre class="console">
$ multipass launch -n ansiblevm --cloud-init cloud-init.yaml --disk 10G --memory 4G</pre> <p>Once the virtual machine has launched, you can get the IP address of the host by running the following:</p>
<pre class="console">
$ multipass info ansiblevm</pre> <p>Once you have the IP address, create a copy of <code>hosts.example</code>, calling its <code>hosts</code> and updating the IP address as we have done in previous chapters. Once your <code>hosts</code> inv<a id="_idTextAnchor637"/>entory file is in place, we can start to run the playbook, starting with the OpenSCA<a id="_idTextAnchor638"/>P scan:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "openscap" --extra-vars "scap_options_remediation=true"</pre> <p>As you can see, we are running using the <code>openscap</code> tag and setting the <code>scap_options_remediation</code> variable to <code>true</code>; if you recall, the default for this variable is <code>false</code>, meaning the remediation tasks will be executed during this playbook run.</p>
<p>Once completed, you will find several files in the output folder on your local machine; if you are not following along, then you can find a copy of the output at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/01-scap_options_remediation_true">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/01-scap_options_remediation_true</a>.</p>
<p>As you can see<a id="_idTextAnchor639"/> from the following screen, on the initial run, we had 98 failed results:</p>
<div><div><img alt="Figure 14.1 – The initial results" src="img/B21620_14_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The initial results</p>
<p>As we ran the remediation tasks as part of the playbook run, we know that the score should now<a id="_idIndexMarker851"/> be improved, so let’s rerun the playbook – this time skipping the remediation tasks altogether:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "openscap"</pre> <p>Once completed, you should have another folder of results; again, you can view the results at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/02-scap_options_remediation_false">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/02-scap_options_remediation_false</a>:</p>
<div><div><img alt="Figure 14.2 – The updated results" src="img/B21620_14_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – The updated results</p>
<p>As you can see, this has dramatically improved the score, and we only have six failures this time.</p>
<p>Next, we need to install WordPress; let’s start afresh with that. To make a fresh start, run the following commands to terminate the virtual machine and replace it with a new one:</p>
<pre class="console">
$ multipass stop ansiblevm
$ multipass delete --purge ansiblevm
$ multipass launch -n ansiblevm --cloud-init cloud-init.yaml --disk 10G --memory 4G
$ multipass info ansiblevm</pre> <p>Update the <code>hosts</code> file with the new IP address and then run the following command to install WordPress:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "wordpress"</pre> <p>With WordPress installed, you can run the WPScan and OSWAP ZAP scans with the following command:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "scan"</pre> <p>Once completed, you <a id="_idIndexMarker852"/>will have the scan results in the output folder; you can find examples of the results at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples</a>. The folder also contains the entire output from each of the playbook runs so far up to this point in the chapter.</p>
<p>Also, as mentioned at the start of the chapter, you can run each of the scans independently of each other using the following commands:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --tags "scan" --extra-vars "scan_types=zap"
$ ansible-playbook -i hosts site.yml --tags "scan" --extra-vars "scan_types=wpscan"</pre> <p>Once you have finished running the playbooks, you can remove the virtual machine by running the following:</p>
<pre class="console">
$ multipass stop ansiblevm
$ multipass delete --purge ansiblevm</pre> <p>With the virtual machine cleaned up, that concludes our look at using Ansible to scan and harden our server.</p>
<p>Before we move on to the next chapter, I recommend you look at the remediation playbook, which was generated when we first ran OpenSCAP.</p>
<p>It can be found at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/examples/01-scap_options_remediation_true/ansiblevm-playbook.yml">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/examples/01-scap_options_remediation_true/ansiblevm-playbook.yml</a>, and as you can see, it contains <a id="_idIndexMarker853"/>over 4,600 lines of code!</p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor640"/>Summary</h1>
<p>In this chapter, we generated a playbook to remediate any CIS level-1 non-compliance errors found during a scan. As well as being cool, it is also convenient if you imagine you are running a few dozen servers that all need to be compliant and that all need an entire audit history.</p>
<p>You now have the foundations of a playbook that you can use to target those hosts daily, audit them, and store the results away from the host itself. Also, if you need to, depending on your configuration, you have a way of automatically resolving any non-conformance found during the scan.</p>
<p>We also ran scans against our WordPress installation and again stored the results away from the host itself – while the WPScan and OSWAP ZAP scans didn’t include any remediation, you could quickly review the results and update your WordPress deployment script to remediate the issues raised at deployment time.</p>
<p>So far, we have been running our Ansible Playbooks from our local machine; in the next chapter, it is time to move from running our Ansible code from our local machines into the cloud and look at how we can use Azure DevOps Pipelines and GitHub Actions to execute our playbooks.</p>
</div>
</body></html>