- en: Chapter 9. Complex Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen how you can develop playbooks and test them. The final
    aspect is how to release playbooks into production. In most cases, you will have
    multiple environments to deal with before the playbook is released into production.
    This is similar to software that your developers have written. Many companies
    have multiple environments and usually your playbook will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staging environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some companies name these environments in different ways, and some companies
    have additional environments such as certification where all software has to be
    certified before it can go to production.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your playbooks and set up roles, we strongly recommend that you
    keep in mind the notion of the environments right from the start. It might be
    worthwhile to talk to your software and operations teams to figure out exactly
    how many environments your setup has to cater to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll list down a couple of approaches with examples that you can follow in
    your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Code based on the Git branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume you have four environments to take care of, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Git branch-based method, you will have one environment per branch. You
    will always make changes to **Development** first, and then promote those changes
    to **Testing** (merge or cherry-pick, and tag commits in Git), **Stage**, and
    **Production**. In this approach, you will hold one single inventory file, one
    set of variable files, and finally, a bunch of folders dedicated to roles and
    playbooks per branch.
  prefs: []
  type: TYPE_NORMAL
- en: A single stable branch with multiple folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this approach, you will always maintain the dev and master branches. The
    initial code is committed to the dev branch, and once stable, you will promote
    it to the master branch. The same roles and playbooks that exist in the master
    branch will run across all environments. On the other hand, you will have separate
    folders for each of your environments. Let''s look at an example. We''ll show
    how you can have a separate configuration and an inventory for two environments:
    stage and production. You can extend it for your scenario to fit all the environments
    you use. Let''s first look at the playbook in `playbooks/variables.yaml` that
    will run across these multiple environments and has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are two sets of tasks in this plays:'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks that run against DB servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks that run against web servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an extra task to print the environment name that is common to
    all servers in a particular environment. We will also have two different inventory
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one will be called `inventory/production` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one will be called `inventory/staging` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have two machines for the `web` section and one for the `db`
    in each environment. Further, we have a different set of machines for stage and
    production environments. The additional section, `[ENVIRONMENT:children]`, allows
    you to create a group of groups. This would mean that any variables that are defined
    in the `ENVIRONMENT` section will apply to both the `db` and `web` groups, unless
    they're overridden in the individual sections, respectively. The next interesting
    part would be to look at variable values for each of the environments and see
    how they are separated out in each environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the variables that will be the same for all our environments,
    located in `inventory/group_vars/all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The only variable that is the same for both our environments is the `db_user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now look at the production-specific variables, located in `inventory/group_vars/production`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now look at the stage-specific variables located in `inventory/group_vars/staging`,
    we will find the same variables we had in the production one, but with different
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now validate that we receive the expected results. First we are going
    to run against the staging environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should receive an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run against the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the Ansible run picked up all the relevant variables defined
    for the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using this approach to gain a stable master branch for multiple environments,
    it's best to use an amalgamation of environment-specific directories, `group_vars`,
    and inventory groups to tackle the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Software distribution strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications is probably one of the most complex tasks in the **Information
    and Communication Technology** (**ICT**) field. This is mainly caused by the fact
    that it often requires changing the state of the majority of machines that are
    somehow part of that application. In fact, often you find yourself having to change
    the state of load balancers, distribution servers, application servers, and database
    servers all at the same time during a deployment. New technologies, like containers,
    are trying to make those operations simpler, but often is not easy or possible
    to just move a legacy application to a container.
  prefs: []
  type: TYPE_NORMAL
- en: What we are now going to see are the various software distribution strategies
    and how Ansible can help with each one.
  prefs: []
  type: TYPE_NORMAL
- en: Copying files from the local machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably the oldest strategy to distribute software. The idea is to
    have the files on the local machine (often used to develop the code) and as soon
    as the change is made, a copy of the file is put on the server (usually via FTP).
    This way of deploying code was often used for web development, where the code
    (usually in PHP) does not need any compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This distribution strategy should be avoided due to its multiple problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Very hard to rollback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Impossible to track changes to the various deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No deployment history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to make errors during the deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this distribution strategy can be very easily automated with Ansible,
    I strongly suggest you move immediately to a different strategy that allows you
    to have a safer distribution strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Revision control system with branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many companies are using this technique to distribute their software, mainly
    for uncompiled software. The idea behind this technique is to set up your server
    to use a local copy of your code repository. With SVN this was possible but not
    very easy to manage properly, while Git allowed a simplification of this technique,
    making it very popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique has many advantages over the one we have just seen, the main
    ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy rollbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy to obtain the history of changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy deployments (mainly if Git is used)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, this technique, still has multiple disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: No deployment history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard for compiled software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible security problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'd like to discuss the possible security problems you can encounter with this
    technique a little bit more. What can be very tempting, is to download your Git
    repository directly in the folder that you use to distribute the content, so if
    it's a web server, the `/var/www/` folder. This has obvious advantages since to
    deploy you'll only need to perform a `git pull`. The disadvantage is that Git
    will create the `/var/www/.git` folder which will contain your entire Git repository
    (history included) and, if not properly protected, will be freely downloadable
    by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: About 1% of Alexa's top 1 million websites have the Git folder publicly accessible,
    so be very careful if you want to use this distribution strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Revision control system with tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way of using revision control systems that is a little bit more complex
    but have some advantages, is leveraging the tagging system. This method requires
    to tag every time a new deployment has to be done and then checkout the specific
    tag on the server.
  prefs: []
  type: TYPE_NORMAL
- en: This has all the advantages of the previous method, with the addition of the
    deployment history. The compiled software problem and possible security problems
    are the same as in the previous method.
  prefs: []
  type: TYPE_NORMAL
- en: RPM packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very common way to deploy software (mainly for compiled applications, but
    also advantageous for non-compiled applications) is using some kind of packaging
    system. Some languages, like Java, have an included system (the WAR, in Java case),
    but there are also packaging systems that can be used for any kind of applications,
    such as RPM. The disadvantage of these systems is that they are a little bit more
    complex than the previous methods, but those systems can grant a higher level
    of security as well as versioning. Also, these systems are easily injectable in
    a CI/CD pipeline, so the real complexity is much lower than what it could seem
    at first sight, since the CI/CD pipeline will take care of the building itself.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see how we can deploy the code in the various ways we talked about in the
    previous pages, we will need an environment, and obviously we are going to create
    it using Ansible. First of all, to ensure that our roles are properly loaded,
    we need the `ansible.cfg` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need the `playbooks/firstrun.yaml` to ensure that we can configure
    our machines with a basic configuration, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `playbooks/groups/web.yaml` will also need to be created to allow us to
    properly bootstrap our web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can imagine from the previous file content, we will need to create the
    roles: `common` and `webserver` which are very similar to the ones we created
    in [Chapter 4](ch04.html "Chapter 4.  Handling Complex Deployment"), *Handling
    Complex Deployment*. We start with the `roles/common/tasks/main.yaml` file with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s `motd` template is in `roles/common/templates/motd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move to the `webserver` role, more specifically to the `roles/webserver/tasks/main.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create the handler in `roles/webserver/handlers/main.yaml`
    with the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we need to touch the `roles/webserver/files/website.conf` file, leaving
    it empty for now, but it needs to exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now provision a couple of CentOS machines (I provisioned `ws01.fale.io`
    and `ws02.fale.io`) and ensure that the inventory is right. We can also run the
    `firstrun.yaml` playbook to ensure that the Ansible user is present and properly
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output you should receive is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now configure those machines running their group playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can now point our browser to our nodes on port `80` to check that the HTTPd
    page is displayed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a web app with revision control systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this example, we are going to deploy a simple PHP application that will
    be composed of only a single PHP page. The source is available on the following
    repository: https://github.com/Fale/demo-php-app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy it, we will need the following code placed in `playbooks/manual/rcs_deploy.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the **deployer** with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At the moment, our application is not yet reachable since we have no HTTPd
    rule for that folder. To achieve this, we will need to change the `roles/webserver/files/website.conf`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are just displaying this application to the users reaching
    our server with the `app.fale.io` URL and not to everyone. This will ensure that
    all your users will have a consistent experience. Also, you can see that we are
    blocking all access to the `.git` folder (and all its content). This is needed
    for security reasons we mentioned earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now re-run the web playbook to ensure that our HTTPd configuration gets
    propagated with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result we are going to receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can now check and see that everything works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a web app with RPM packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to deploy an RPM package, we will need to create it in the first place.
    To do so, the first thing we need is a Spec file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spec file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is to create a **Specifics** (**Spec**) file, which is
    a recipe for instructing `rpmbuild` on how to actually create the RPM package.
    We are going to locate the Spec file in `spec/demo-php-app.spec` and put the following
    content into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the various parts do and mean before moving forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These first three lines are variables declarations.
  prefs: []
  type: TYPE_NORMAL
- en: The first one will disable the generation of a debug package. By default, `rpmbuild`
    will create a debug package every time and include all debugging symbols, but
    in this case, we don't have any debugging symbols since we are not making any
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second puts the **hash** of the commit in the variable `commit0`. The third
    one calculates the value of `shortcommit0`, that is calculated as the first eight
    characters of the `commit0` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we declare the name, version, release number, and summary.
    The difference between version and release, is that the version is the upstream
    version, while the release is the Spec version for that upstream release.
  prefs: []
  type: TYPE_NORMAL
- en: The license is the source license, not the Spec license. The URL is used to
    track the upstream website. The `source0` field is used by `rpmbuild` to know
    how the source file is called (in case more than one file is present, we can user
    `source1`, `source2`, and so on). Also, if the source fields are valid URI, we
    can use `spectool` to download them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is the `description` of the software packaged in RPM package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prep` phase is the one where the source(s) get uncompressed and eventual
    patch(es) and applied. The `%autosetup` will `uncompress` the first source, as
    well as apply all patches. In this part, you can also perform other operations
    that need to be executed before the building phase and have the goal to prepare
    the environment for the build phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we would put all actions of the `build` phase. In our case, our sources
    do not need to be compiled and therefore it is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the `install` phase, we put the files in the folder `%{buildroot}` that will
    mimic the target filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `files` section is needed to declare which files are to be put in the package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `changelog` is needed to track who released a new version when and with
    which changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the Spec file, we need to build it. To do so, we could use
    a production machine, but this would increase the attack surface to that machine,
    so it''s better to avoid one. There are multiple ways to build your RPM software.
    The four main ways are:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate the manual way with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Koji
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the differences very briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Building RPMs manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to build an RPM package is doing so in a manual way.
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage is that you need very few and easy to install packages and
    for this reason many people that are starting with RPM, start from here. The disadvantage
    is that the process will be manual, and therefore human errors can spoil the result
    and the procedure is not easy to audit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build RPM packages, you will need a Fedora or an EL (Red Hat Enterprise
    Linux, CentOS, Scientific Linux, Oracle Enterprise Linux) system. If you are using
    Fedora, you will need to execute the following command to install all needed software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running an EL system, the command you''ll need to execute is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In either case, you''ll need to add the user you''ll use to the `mock` group,
    to do so, you need to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux loads the users at login, so to apply a group change, you need to restart
    your session.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can copy the Spec file in folder (usually `$HOME` is a good
    one) and perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will create the `$HOME/rpmbuild/SOURCES` folder that is needed in the process.
    The `-p` option will automatically create all folders in the path that are eventually
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We used `spectool` to download the source file and place it in the appropriate
    directory. The `spectool` will automatically get the URL from the Spec file so
    that we don't have to remember it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to create an `src.rpm` file, to do so we can use `rpmbuild`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will output something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Some small differences in the name could be present, for instance you will
    probably have a different `$HOME` folder and you could have something other than
    `fc24`, if you are using something different than Fedora 24 to build the package.
    At this point, we can create the binary file with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Mock allows us to build RPM packages in a clean environment and also, thanks
    to the `-r` option, it allows us to build for different versions of Fedora, EL,
    and Mageia. This command will give you a very long output, that I''ll not report
    here, but in the last few lines there is useful information. If everything built
    properly, this is the last few lines you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The second to last line contains the path where you can find the results. If
    you look in that folder, you should find the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The three log files are very useful in case of problems during the compilation.
    The `src.rpm` file will be a copy of the `src.rpm` file we created with the first
    command, while the `x86_64.rpm` file is the one mock created and the one we will
    need to install on our machines.
  prefs: []
  type: TYPE_NORMAL
- en: Building RPMs with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since doing all those steps manually can be long, boring, and error prone, we
    can automatize them with Ansible. The resulting playbook will probably not be
    the cleanest one, but will be able to execute all operations in a repeatable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we are going to build a new machine from scratch. I''ll call
    this machine `builder01.fale.io` and we are also going to change the inventory/production
    file to match this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Before diving in the `builders` role, we will need to do a couple of changes
    to the `webserver` roles to enable a new repository. The first is adding a task
    in `roles/webserver/tasks/main.yaml` at the end of the file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second change is actually creating the `roles/webserver/files/privaterepo.repo`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute the `webserver` group playbook to make the changes effective
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following output should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the only change has been the deployment of our newly generated
    repository file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a role for `builders` with a `tasks` file located in
    `roles/builder/tasks/main.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as part of the `builders` role, we need the `roles/builder/handlers/main.yaml`
    handler file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can guess from the tasks file, we will also need the `roles/builder/files/repo.conf`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a new `group` playbook in `playbooks/groups/builders.yaml` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute the `firstrun` playbook against it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move to create the host itself with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And we are expecting a result similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the parts of the infrastructure ready, we can create the
    `playbooks/manual/rpm_deploy.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As discussed, this playbook has a lot of commands and shells which are not very
    clean. Probably, in the future it will be possible to write a playbook with the
    same features but with modules. Most actions are the same as we discussed in the
    previous section. The new actions are toward the end, in fact in this case we
    copy the generated RPM file to a specific folder, we invoke `createrepo` to generate
    a repository in that folder, and then we force all web servers to update the generated
    package to the last version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To grant the security of your application, is important that the repository
    is only accessible internally and not publicly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the playbook with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And we expect a result like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Building RPMs with CI/CD pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although this is not covered by this book, in more complex cases you may want
    to use a CI/CD pipeline to create and manage RPM packages. The two main pipelines
    are based on two different software: Jenkins and Koji.'
  prefs: []
  type: TYPE_NORMAL
- en: The Koji software has been developed by the Fedora community and Red Hat. It
    is released under the terms of the LGPL 2.1 license. This is the pipeline that
    currently gets used by Fedora, CentOS, as well as many other companies and communities
    to create all their RPMs (both for official and testing-aka **scratch builds**-builds).
    Koji - by default is not triggered by commit, but needs to be called "manually"
    from a user (through web interface or CLI). Koji will automatically download the
    last version of the Spec Git, download the source from a side-cache (this is optional,
    but suggested) or from the original location, and trigger the mock build. Koji
    does support only mock due to the fact that is the only system that allows consistent
    and repeatable builds. Koji can store all output artifacts forever or for a limited
    amount of time, based on the configuration. This is to ensure a very high level
    of auditability.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is one of the most used CI/CD managers and can also be used for RPM
    pipelines. The big disadvantage is that it needs to be configured from scratch
    with the consequence that more time is required, but this means it has more flexibility.
    Also, a big advantage of Jenkins is that many companies already have an instance
    of Jenkins, and this makes it easier to set up and maintain the infrastructure,
    since you can reuse an installation you already have, having to manage less systems
    overall.
  prefs: []
  type: TYPE_NORMAL
- en: Building compiled software with RPM packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RPM packaging is very useful for non-binary applications and close to a necessity
    for binary applications. This is also true because the difference in complexity
    is pretty low between a non-binary and a binary case. In fact, the build and the
    installation will work in exactly the same way. The only thing that will change
    is the Spec file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see for example the Spec file needed to compile and package a simple
    Hello World! application written in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's very similar to the one we saw for the PHP demo application.
    Let's see the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we don't have the line to disable the debug package. Every time
    you package a compiled application, you should let `rpm` create the debug symbols
    package so that in case of crashes, it will be easier to debug and understand
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the changes in this section are only due to the fact that the
    new package has a different name and `URL`, but are not linked to the fact that
    is a compliable application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the non-compiled application we did not need any packages present at build
    time, while in this case we will need the make and the `gcc` (compiler) applications.
    Different applications could require different tools and or libraries to be present
    on the system at build time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `description` is package-specific and is not influenced by the compilation
    of the package. In the same way, the `%prep` phase works.
  prefs: []
  type: TYPE_NORMAL
- en: In the `%build` phase we now have make `%{?_smp_mflags}`. This is needed to
    tell `rpmbuild` to actually run make to build our application. The `_smp_mflags`
    variable will include a set of parameters to optimize the compilation to be multi-thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: During the `%install` phase, we will issue the `%make_install` command. This
    macro will call `%make_install` with a set of additional parameters to ensure
    that the **libraries** are located in the right folder, as well as the binaries
    and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we only need to place the `hello` binary that was located in the
    right folder of the `buildroot` during the `%install` phase as well as add the
    `LICENSE` file containing the license.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `%changelog` is very similar to the other Spec file we saw, since it is
    not influenced by the involvement of a compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you completed this, you can place it in `spec/hello-world.spec` and tweak
    `playbooks/manual/rpm_deploy.yaml` saving it into `playbooks/manual/hello_deploy.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the only thing that we changes is that all references to `demo-php-app`
    got replaced with `hello-world`. Running it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could eventually create a playbook that accepts the name of the package
    to build as a parameter, so that you don't need a different playbook for every
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to distribute software in your environment, let's now speak
    about deployment strategies; that is how to upgrade your application without your
    service suffering from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different problems you might incur during an update:'
  prefs: []
  type: TYPE_NORMAL
- en: Downtime during the update rollout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new version has problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new version seems to work, until it fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first problem is known to every system administrator. During the update,
    you are probably going to restart some services, and for the time between the
    stop and the start of the service, your application will not be available on that
    machine. To avoid this also means that your application is not available at all;
    you will need to have at least some machines with the application available and
    a smart load balancer in front that will remove (and add them back when is the
    case) all nonfunctioning nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem can be prevented in multiple ways. The cleanest one would
    be testing in the CI/CD pipeline. In fact, those kinds of problems are pretty
    easy to find with simple tests. This can also be prevented with the methods we
    are going to see soon.
  prefs: []
  type: TYPE_NORMAL
- en: The third problem is by far the most complex. Many big down have been generated
    by these kinds of problems. Usually the problem is that the new version has some
    performance problems or memory leaks. Since the majority of deployments are done
    in the period of least load of the servers, as soon as the load increases, a performance
    problem or memory leak could kill your servers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be able to use those methods in a proper way, you have to be able to ensure
    that your software can accept rollbacks. There are cases where this is not possible
    (that is, a database table gets removed in an update) but should be avoided. We
    will not speak how to avoid it since is part of the development strategy, and
    is not related to Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The canary deployment is a technique that involves updating a small percentage
    of your machines (often 5%) to the new version and instruct the load balancers
    to send only an equivalent amount of traffic to it. This has several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: During the update, you never have less than 95% of the capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the new version completely fails, you lose the 5% of capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the load-balancer divides the traffic between your new and old version,
    if the new version has problems, only 5% of your users will see the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to have 5% capacity more than your expected load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canary deployment is able to prevent all three problems we mentioned with a
    very small overhead (5%) and with a low cost in case of rollback (5%). For those
    reasons, this technique is used a lot by huge companies; progressive rollout.
    Often to ensure a similar user experience to users that live close to each other,
    geography is used to choose if the user is going to hit the old or the new version.
  prefs: []
  type: TYPE_NORMAL
- en: When the test seems to be a success, the percentage can be increased progressively
    until 100% is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to implement a canary deployment in multiple ways in Ansible.
    The way I suggest is the cleanest one; using the inventory files, more specifically,
    to have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can set all variables on the web group (the variables are going
    to be the same no matter the version, or at least they should be) but you can
    run a playbook easily against the canary group, the main group, or both groups
    at the same time. Another option would be to create two different inventory files,
    one for the canary group and the other for the main group with the groups having
    the same name so that variables are shared.
  prefs: []
  type: TYPE_NORMAL
- en: Blue/Green deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Blue/Green** deployment is very different from canary deployment and has
    some advantages and some disadvantages. The main advantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows quicker iterations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All users get moved at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollbacks have no performance degradation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among the disadvantages, the main ones are the fact that you need to have double
    the machines available than what your application requires. This disadvantage
    can be easily mitigated if the application is running on a cloud (either private,
    public, or hybrid) scaling up the application resources for the deployment and
    then scale them back down.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Blue/Green deployment in Ansible is very easy. The simplest way
    is to create two different inventories (one for blue and one for green) and then
    simply manage your infrastructure as if they are different environments such as
    production, staging, dev, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, Ansible feels slow, mainly if you have a very long list of tasks
    to execute and/or if you have huge amount of machines. This feeling is actually
    more than just a feeling. There are multiple reasons for this, and ways to avoid
    it, we are going to look at three of those.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the reason why Ansible is slow by default is that for every module execution
    and for every host, Ansible will perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: SSH handshake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the SSH connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this means that if you have 10 tasks to be executed on a single
    remote server, Ansible will open (and close) the connection 10 times. Since the
    SSH protocol is an encrypted protocol, this makes the SSH handshake an even longer
    process, since the two parts have to negotiate the ciphers every single time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible allows us to reduce the execution time drastically by initiating the
    connections at the beginning of the playbook and keeping them alive for the whole
    execution so that it does not need to reopen the connection at every task. Over
    the course of Ansible life, this feature has changed name multiple times, as well
    as the way it''s enabled. From version 1.5, it''s been called **pipelining** and
    the way to enable it is by adding the following line to your `ansible.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The reason why this feature is not enabled by default, is that many distributions
    ship with the `requiretty` option in `sudo`. The pipelining mode in Ansible and
    the `requiretty` option in `sudo` conflict and will make your playbooks fail.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to enable the pipelining mode, ensure that the `sudo requiretty`
    mode is disabled on your target machines.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing with_items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to execute similar operations multiple times, it''s possible to
    repeat the same task multiple times with different parameters or use the `with_items`
    option. Aside from the fact that `with_items` makes your code easier to read and
    to follow, it could also improve your performance. An example is with the installation
    of packages (that is: `apt`, `dnf`, `yum`, `package` modules) where Ansible will
    perform a single command if you use `with_items` against a single command for
    each package if you don''t. As you can imagine, this can help boosting your performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what happens when your tasks are executed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even after you implement the methods we just talked about to speed up the playbook
    execution, you may still find some tasks take a very long time. This is very common
    with some tasks, even if it''s possible with many other modules. The modules that
    usually give you this problem are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Packaging management (that is: `apt`, `dnf`, `yum`, `package`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud machine creation (that is: DigitalOcean, EC2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason for this slowness is often non-Ansible specific. An example case
    could be if you used a packaging management module to update your machines. This
    requires downloading tens or hundreds of megabytes on every machine and installing
    a high quantity of software. A way to speed up this kind of operation is to have
    a local repository in your datacenter and have all your machines pointing to it
    instead of your distribution repositories. This will allow your machines to download
    at higher speed and without using the public connection that is often limited
    in bandwidth or metered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's often important to understand what the modules do in the background to
    optimize the playbook execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the cloud machine creation case, Ansible just performs an API call to the
    chosen cloud provider and waits for the machine to be ready. DigitalOcean machines
    can take up to one minute to be created (and other clouds much longer) so Ansible
    will wait for that amount of time. Some modules have an asynchronous mode to avoid
    this wait period, but you'll have to ensure that the machine is ready before using
    it otherwise the modules that use the created machine will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how you can deploy an application with Ansible,
    as well as the various distribution and deployment strategies you can use. We
    also saw how to create RPM packages with Ansible and how to optimize the performance
    of Ansible using different methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the last and final chapter, we will discuss Ansible on Windows, networking
    devices. Additionally, some Ansible Tower concepts will be discussed.
  prefs: []
  type: TYPE_NORMAL
