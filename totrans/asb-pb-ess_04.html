<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Separating Code and Data – Variables, Facts, and Templates</h1></div></div></div><p>In the previous chapter, we looked at how to write a role to provide modularity and abstraction. While doing so, we created the configuration file and copied the file over to the destination host using Ansible's copy module.</p><p>In this chapter, we will cover the following concepts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How do you separate data from code?</li><li class="listitem" style="list-style-type: disc">What are Jinja2 templates? How are these created?</li><li class="listitem" style="list-style-type: disc">What are variables? How and where are they used?</li><li class="listitem" style="list-style-type: disc">What are system facts? How are they discovered?</li><li class="listitem" style="list-style-type: disc">What are the different types of variables?</li><li class="listitem" style="list-style-type: disc">What is a variable merge order? What are its precedence rules?</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Static content explosion</h1></div></div></div><p>Let's imagine that we are <a id="id70" class="indexterm"/>managing a cluster of hundreds of web servers spanning across multiple data centers. Since we have the <code class="literal">server_name</code> parameter hardcoded in to the <code class="literal">config</code> file, we will have to create one file per server. This also means that we will manage hundreds of static files, which will quickly get out of control. Our infrastructure is dynamic, and managing change is one of the most common aspects of a DevOps engineer's routine tasks. If tomorrow, our company policy states that we should run web servers on the port 8080 instead of the port 80, only in a production environment, imagine the headache you'd get having to change all these files individually. Wouldn't it be better to have a single file that takes dynamic inputs, which are specific to the host it's running on? This is exactly what templates are for and, as depicted in the following <a id="id71" class="indexterm"/>diagram, a single template could replace a multitude of static files:</p><div><img src="img/B03800_03_01.jpg" alt="Static content explosion"/></div><p>Before we define what a template is, let's begin by understanding how to separate code from data and how this would help us solve the problem of static content explosion.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Separating code and data</h1></div></div></div><p>The real magic of <a id="id72" class="indexterm"/>infrastructure as code tools, such as Ansible, lies in its ability to separate data and code. In our example, the <code class="literal">default.conf</code> file is a configuration file that is specific to an Nginx web server. The configuration parameters, such as ports, users, paths, and so on, remain generic and constant at all times, no matter who installs and configures them. What is not constant are the values those parameters take. That's what is specific to our organization. So, for this, we would decide the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Which port should Nginx run on?</li><li class="listitem" style="list-style-type: disc">Which user should own the web server process?</li><li class="listitem" style="list-style-type: disc">Where should the log files go?</li><li class="listitem" style="list-style-type: disc">How many worker processes should be run?</li></ul></div><p>Our organization-specific policies may also require us to pass different values to these parameters based on the environment or geography the hosts run in.</p><p>Ansible splits these in to two parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code that is generic</li><li class="listitem" style="list-style-type: disc">The data that is specific to an organization</li></ul></div><p>This has two advantages; one advantage is that it solves our problem of static data explosion. Now that we have separated the code and data, we can create <code class="literal">config</code> files flexibly and dynamically. The second advantage, you may realize, is now that the code and data are split, there is nothing in the code that is specific to a particular organization. This makes it easy to share the site with the world for anyone who finds it useful. That's exactly what you would <a id="id73" class="indexterm"/>find on Ansible-Galaxy or even on GitHub, fueling the growth of tools, such as Ansible. Instead of reinventing the wheel, you can download the code that someone else has written, customize it, fill in the data specific to the code, and get the work done.</p><p>Now, how is this code separate from the data? The answer is that Ansible has two primitives:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Jinja templates (code)</li><li class="listitem" style="list-style-type: disc">The variables (data)</li></ul></div><p>The following diagram explains how the resulting file is generated from templates and variables:</p><div><img src="img/B03800_03_02.jpg" alt="Separating code and data"/></div><p>Templates provide <a id="id74" class="indexterm"/>placeholders in place of parameter values, which are then defined in variables. Variables can then be fed in from various places, including roles, playbooks, inventories, and even from the command line when you launch Ansible. Let's <a id="id75" class="indexterm"/>now understand templates and variables in detail.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Jinja2 templates</h1></div></div></div><p>What is <strong>Jinja</strong> all about? <strong>Jinja2</strong> is <a id="id76" class="indexterm"/>a very popular and powerful Python-based template engine. Since Ansible is written in Python, it becomes the default choice for most users, just like other Python-based configuration management systems, such as <strong>Fabric</strong> and <strong>SaltStack</strong>. The name Jinja originated from the Japanese word for temple, which is similar in phonetics to the word template.</p><p>Some of the important features of Jinja2 are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is fast and compiled just in time with the Python byte code</li><li class="listitem" style="list-style-type: disc">It has an optional sandboxed environment</li><li class="listitem" style="list-style-type: disc">It is easy to debug</li><li class="listitem" style="list-style-type: disc">It supports template inheritance</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>The template formation</h2></div></div></div><p>Templates look very similar to <a id="id77" class="indexterm"/>normal text-based files except for the occasional variables or code that surrounds the special tags. These get evaluated and are mostly replaced by values at runtime, creating a text file, which is then copied to the destination host. The following are the two types of tags that Jinja2 templates accept:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">{{  }}</code> embeds variables inside a template and prints its value in the resulting file. This is the most common use of a template.<p>For example:</p><div><pre class="programlisting">    {{ nginx_port }}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">{%   %}</code> embeds statements of code inside a template, for example, for a loop, it embeds the if-else statements, which are evaluated at runtime but are not printed.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Facts and variables</h1></div></div></div><p>Now that we have looked <a id="id78" class="indexterm"/>at the code that Jinja2 templates provide, let's understand where this data comes from, which is then embedded in the template at runtime. Data can come from either facts or variables. When it comes to a Jinja2 template, the same rules apply to the usage of facts and variables. Facts are a type of variable; the differentiating factor here is the origin of the two. Facts are automatically available and discovered at runtime, and variables are user-defined.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Automatic variables – facts</h2></div></div></div><p>A lot of data in our systems is <a id="id79" class="indexterm"/>automatically discovered and made available to Ansible by the managed hosts during the handshake process. This data is very useful and tells us everything about that system, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The hostname, network interface, and IP address</li><li class="listitem" style="list-style-type: disc">The system architecture</li><li class="listitem" style="list-style-type: disc">The operating system</li><li class="listitem" style="list-style-type: disc">The disk drives</li><li class="listitem" style="list-style-type: disc">The processor used and amount of memory</li><li class="listitem" style="list-style-type: disc">Whether it is a VM; if yes, is it a virtualization/cloud provider?</li></ul></div><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>Facts are collected at the very beginning of an Ansible run. Remember the line in the output that says <strong>GATHERING FACTS *******</strong>? That's exactly when this happens.</p></div></div><p>You can find facts about any system by running the following command followed by a shortened output:</p><div><pre class="programlisting">
<strong>$ ansible -i customhosts www -m setup | less</strong>
192.168.61.12 | success &gt;&gt; {
  "ansible_facts": {
    "ansible_all_ipv4_addresses": [
      "10.0.2.15",
      "192.168.61.12"
    ],
    "ansible_architecture": "i386",
    "ansible_bios_date": "12/01/2006",
    "ansible_cmdline": {
      "BOOT_IMAGE": "/vmlinuz-3.5.0-23-generic",
      "quiet": true,
      "ro": true,
      "root": "/dev/mapper/vagrant-root"
    },
    "ansible_distribution": "Ubuntu",
    "ansible_distribution_major_version": "12",
    "ansible_distribution_version": "12.04",
    "ansible_domain": "vm",
    "ansible_fqdn": "vagrant.vm",
    "ansible_hostname": "vagrant",
    "ansible_nodename": "vagrant",
    "ansible_os_family": "Debian",
    "ansible_pkg_mgr": "apt",
    "ansible_processor": [
      "GenuineIntel",
      "Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz"
    ],
    "ansible_processor_cores": 1,
    "ansible_processor_count": 2,
    "ansible_processor_threads_per_core": 1,
    "ansible_processor_vcpus": 2,
    "ansible_product_name": "VirtualBox",
  }
}</pre></div><p>The preceding output is in Ansible's own format and uses its core setup module. Akin to the setup module, there is <a id="id80" class="indexterm"/>another module by the name <code class="literal">facter</code>, which discovers and displays facts in the format discovered with Puppet, another configuration management system. The following is an example of how to use the <code class="literal">facter</code> module to discover facts for the same host:</p><div><pre class="programlisting">
<strong>$ ansible -i customhosts www -m facter | less</strong>
</pre></div><p>While using the <code class="literal">facter</code> module, a point that you need to note is that this module is not a core module and comes as part of extra modules. Extras modules are a subset of the Ansible module, which is used less frequently and is less popular in comparison with the core modules. Moreover, to use the <code class="literal">facter</code> module, you require the "<code class="literal">facter</code>" and "<code class="literal">ruby-json</code>" packages preinstalled on the target host.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>User-defined variables</h2></div></div></div><p>We looked at facts, which <a id="id81" class="indexterm"/>are automatically available, and the amount of data that is discovered is overwhelming. However, it does not provide us with every attribute of our infrastructure that we need. For example, Ansible can not discover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Which port we want our web server to listen to</li><li class="listitem" style="list-style-type: disc">Which user should own a process</li><li class="listitem" style="list-style-type: disc">Which system the users need to create, with which authorization rules</li></ul></div><p>All this data is external to a system profile and is to be provided by us, the users. It's user-defined for sure, but how and where should we define it? That's what we are going to look at next.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Where to define a variable</h3></div></div></div><p>Where a variable can be <a id="id82" class="indexterm"/>defined from is a complex phenomenon, as Ansible offers abundant choices in this regard. This also offers a lot of flexibility to users to configure portions of their infrastructures divergently. For example, all Linux hosts in a production environment should use local package repositories or web servers in staging and should run on the port 8080. All this without changing the code, and driven by data alone is done, by variables.</p><p>The following are the places from where Ansible accepts variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">default</code> directory inside a role</li><li class="listitem" style="list-style-type: disc">Inventory variables<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">host_vars</code> and <code class="literal">group_vars</code> parameters defined in separate directories</li><li class="listitem" style="list-style-type: disc">The <code class="literal">host/group vars</code> parameter defined in an inventory file</li></ul></div></li><li class="listitem" style="list-style-type: disc">Variables in playbooks and role parameters</li><li class="listitem" style="list-style-type: disc">The <code class="literal">vars</code> directory inside a role and variables defined inside a play</li><li class="listitem" style="list-style-type: disc">Extra variables provided with the <code class="literal">-e</code> option at runtime</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec04"/>How to define a variable</h3></div></div></div><p>After looking at <a id="id83" class="indexterm"/>where to define the variable from, we will start looking at how to define it at various places.</p><p>Here are some simple rules you can use to form a valid Ansible variable:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A variable should always start with a letter</li><li class="listitem" style="list-style-type: disc">It can contain:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Letters</li><li class="listitem" style="list-style-type: disc">Numbers</li><li class="listitem" style="list-style-type: disc">Underscores</li></ul></div></li></ul></div><p>Let's take a look at the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Valid variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Invalid variable</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">app_port</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">app-port</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">userid_5</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">5userid</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">logdir</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">log.dir</code>
</p>
</td></tr></tbody></table></div><p>We looked at the precedence rules and now we know that there are multiple places where you can define variables. Irrespective of the precedence levels, all use the same syntax to define a variable.</p><p>To define a simple variable in a key-value pair format, use, <code class="literal">var: value</code>, for example:</p><div><pre class="programlisting">      nginx_port: 80</pre></div><p>A dictionary or hash can be defined as Nginx:</p><div><pre class="programlisting">       port: 80
       user: www-data</pre></div><p>An array could be defined as:</p><div><pre class="programlisting">    nginx_listners:
      - '127.0.0.1:80'
      - '192.168.4.5:80'</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Templating the Nginx configurations</h1></div></div></div><p>You have learnt a lot about <a id="id84" class="indexterm"/>facts, variables, and templates. Now, lets transform our Nginx role to be data driven. We will start templating the <code class="literal">default.conf</code> file for Nginx that we created earlier. The approach toward converting a file into a template would be as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the directories required to hold templates and default variables inside a role:<div><pre class="programlisting">
<strong>$ mkdir roles/nginx/templates</strong>
<strong>$ mkdir roles/nginx/defaults</strong>
</pre></div></li><li class="listitem">Always start with the actual configuration file, our end result of this process, to know all of the parameters it would take. Then, work backwards. For example, the configuration for the <code class="literal">default.conf</code> file on our system is as follows:<div><pre class="programlisting">        server {
                 listen       80;
                 server_name  localhost; 
                 location / {
                    root   /usr/share/nginx/html;
                    index  index.html;
               }
         }</pre></div></li><li class="listitem">Identify the configuration parameters that you would like to generate dynamically, remove the values for those parameters, note them down separately, and replace them with template variables:<div><pre class="programlisting">    Template Snippets:
      listen {{ nginx_port }} ;
      root   {{ nginx_root }};
      index  {{ nginx_index }};

    Variables:
      nginx_port: 80
      nginx_root: /usr/share/nginx/html
      nginx_index: index.html</pre></div></li><li class="listitem">If the values for any of the configuration parameters are supposed to be sourced from facts, typically system parameters or topology information, such as the hostname, IP address, and so on, then find out the relevant facts with the help <a id="id85" class="indexterm"/>of the following command:<p>For example:</p><div><pre class="programlisting">
<strong>$ ansible -i customhosts www -m setup | less</strong>
</pre></div><p>To find out the hostname of the system:</p><div><pre class="programlisting">
<strong>$ ansible -i customhosts www -m setup | grep -i hostname</strong>

  "ansible_hostname": "vagrant",
  "ohai_hostname": "vagrant",</pre></div></li><li class="listitem">Use the discovered fact inside the template instead of a user-defined variable. For example:<div><pre class="programlisting">  server_name  {{ ansible_hostname }},</pre></div></li><li class="listitem">Save the resulting file inside the template's directory, ideally with the <code class="literal">.j2</code> extension. For example, for <code class="literal">roles/nginx/templates/default.conf.j2</code>, the resulting file becomes:<div><pre class="programlisting">#roles/nginx/templates/default.conf.j2
server {
    listen       {{ nginx_port }};
    server_name  {{ ansible_hostname }};

    location / {
        root   {{ nginx_root }};
        index  {{ nginx_index }};
    }
}</pre></div></li><li class="listitem">Create <code class="literal">roles/nginx/defaults/main.yml</code> and store the sane defaults as follows:<div><pre class="programlisting">---
#file: roles/nginx/defaults/main.yml
nginx_port: 80
nginx_root: /usr/share/nginx/html
nginx_index: index.html</pre></div></li><li class="listitem">Once the template has been created, change the task in the <code class="literal">configure.yml</code> file to use the template instead of the copy module:<div><img src="img/B03800_03_04.jpg" alt="Templating the Nginx configurations"/></div></li><li class="listitem">Finally, it's time to remove the static file we used earlier with the copy module:<div><pre class="programlisting">
<strong>$ rm roles/nginx/files/default.conf</strong>
</pre></div><p>Then it's time to run the Ansible playbook:</p><div><pre class="programlisting">
<strong>$ ansible-playbook -i customhosts site.yml</strong>
</pre></div></li></ol></div><p>Let's take a look at <a id="id86" class="indexterm"/>the following screenshot:</p><div><img src="img/B03800_03_05.jpg" alt="Templating the Nginx configurations"/></div><p>Let's analyze what happened during this run:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We changed the configuration task to use the template instead of the copy module, which is reflected in the screenshot when a task shows its changed status</li><li class="listitem" style="list-style-type: disc">Since the task has been updated, a notification gets triggered, which calls the handler to restart the service</li></ul></div><p>Our code tree for the <a id="id87" class="indexterm"/>Nginx role looks like the following after we make this change:</p><div><img src="img/B03800_03_06.jpg" alt="Templating the Nginx configurations"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Adding another layer – the MySQL role</h1></div></div></div><p>So far, we have been <a id="id88" class="indexterm"/>focusing on the single tier of our infrastructure, that is, the web server layer. Writing code for just one tier is not a lot of fun. Being a cool DevOps team, we will create a multi-tier infrastructure with database, web server, and then, a load balancer. We will start creating the MySQL role next, apply everything that we have learnt so far, and extend that knowledge with a few new concepts.</p><p>Here is our specification for the MySQL role:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It should install the MySQL server package</li><li class="listitem" style="list-style-type: disc">It should configure '<code class="literal">my.cnf</code>', which is the main configuration for the MySQL server</li><li class="listitem" style="list-style-type: disc">It should start the MySQL server daemon</li><li class="listitem" style="list-style-type: disc">It should support <a id="id89" class="indexterm"/>Ubuntu 12.04 as well as CentOS/RedHat Enterprise 6.x</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Creating the scaffolding for the roles with Ansible-Galaxy</h2></div></div></div><p>So far, we <a id="id90" class="indexterm"/>have been doing all the hard work to understand and create the directory structure required by the roles. However, to make our lives easier, Ansible ships with a tool called <strong>Ansible-Galaxy</strong>, which should help us initialize a role by creating the scaffolding automatically and could help us follow the best practices. Ansible-Galaxy actually does more than that. It's a utility to connect to the <a id="id91" class="indexterm"/>repository of the freely available Ansible roles hosted at <a class="ulink" href="http://galaxy.ansible.com">http://galaxy.ansible.com</a>. This is similar to the way we use <strong>CPAN</strong> or <strong>RubyGems</strong>.</p><p>Let's start by <a id="id92" class="indexterm"/>initializing the MySQL role with Ansible-Galaxy using the following command:</p><div><pre class="programlisting">
<strong>$ ansible-galaxy init --init-path roles/ mysql</strong>
</pre></div><p>Here, the following is the analysis of the preceding command:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">init</code>: This is the subcommand given to Ansible-Galaxy to create the scaffolding</li><li class="listitem" style="list-style-type: disc"><code class="literal">--init-path</code> or <code class="literal">-p</code>: These provide the path to the roles directory, under which the directory structure is created</li><li class="listitem" style="list-style-type: disc"><code class="literal">mysql</code>: This is the name of the role</li></ul></div><p>Let's take a look at the following screenshot:</p><div><img src="img/B03800_03_07.jpg" alt="Creating the scaffolding for the roles with Ansible-Galaxy"/></div><p>The preceding <a id="id93" class="indexterm"/>diagram shows the directory layout created after you initialize the role with Ansible-Galaxy, which creates an <a id="id94" class="indexterm"/>empty role with a structure suitable for upload on to Galaxy. It also initializes the necessary components, including tasks, handlers, vars, and meta files with placeholders.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Adding metadata to the role</h2></div></div></div><p>We used the <code class="literal">meta</code> file <a id="id95" class="indexterm"/>earlier to specify the dependency on <a id="id96" class="indexterm"/>another role. In addition to specifying the dependencies, meta files can specify much more data for the roles, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The author and company information</li><li class="listitem" style="list-style-type: disc">The supported OS and platforms</li><li class="listitem" style="list-style-type: disc">A brief description of what a role does</li><li class="listitem" style="list-style-type: disc">The Ansible versions supported</li><li class="listitem" style="list-style-type: disc">The category of software that this role attempts to automate</li><li class="listitem" style="list-style-type: disc">The licensing information</li></ul></div><p>Let's update all this data by editing <code class="literal">roles/meta/main.yml</code>:</p><div><pre class="programlisting">---
galaxy_info:
  author: Gourav Shah
  description: MySQL Database Role
  company: PACKT
  min_ansible_version: 1.4
  platforms:
  - name: EL
    versions:
      - all
  - name: Ubuntu
    versions:
      - all
  categories:
  - database:sql</pre></div><p>In the preceding <a id="id97" class="indexterm"/>snippet, we added metadata to the role, such as the <a id="id98" class="indexterm"/>author and company details, a brief description of what a role does, its compatibility with Ansible versions, the supported platforms, the category the role belongs to, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Using variables in tasks and handlers</h2></div></div></div><p>You have learnt how to <a id="id99" class="indexterm"/>use variables in templates. That's <a id="id100" class="indexterm"/>not all the code there is used to define the variables. In addition to templates, we can also use variables inside tasks, plays, and so <a id="id101" class="indexterm"/>on. This time around, we have also committed to provide a <a id="id102" class="indexterm"/>multiplatform role, supporting Ubuntu and RedHat both. Unlike <strong>Chef</strong> and <strong>Puppet</strong>, Ansible uses OS-specific modules (for example, <code class="literal">apt</code> and <code class="literal">yum</code>) and not platform-independent resources (package). We will have to create OS-specific task files and call them selectively based on the OS they are going to run on. Here's how we do so:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will find a fact that will determine the OS platform/family. We have a couple of options here:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ansible_distribution</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ansible_os_family</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">RedHat, CentOS, and Amazon Linux are all based on <code class="literal">rpm</code> and have similar behavior. The same goes for Ubuntu and Debian operating systems, which are part of the same platform family. Hence, we choose to use the <code class="literal">ansible_os_family</code> fact, which will give us wider support.</li><li class="listitem" style="list-style-type: disc">We will define variables from two places in the roles:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">From the default <code class="literal">vars</code> file with the sane defaults for Debian.</li><li class="listitem" style="list-style-type: disc">From the variables specific to <code class="literal">os_family</code> if not Debian.</li></ul></div></li><li class="listitem" style="list-style-type: disc">We will also <a id="id103" class="indexterm"/>create OS-specific task <a id="id104" class="indexterm"/>files, since we may need to call different modules (<code class="literal">apt</code> versus <code class="literal">yum</code>) and additional tasks that are specific to that OS.</li><li class="listitem" style="list-style-type: disc">For handlers and <a id="id105" class="indexterm"/>tasks, we will use variables to provide <a id="id106" class="indexterm"/>OS-specific names (for example, MySQL versus mysqld, for service).</li><li class="listitem" style="list-style-type: disc">Finally, we will create the <code class="literal">main.yml</code> file, which will selectively include host-specific vars as well as task files by checking the value of this fact.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Creating variables</h3></div></div></div><p>We will begin <a id="id107" class="indexterm"/>with the creation of variables. Let's set up the sane defaults for Debian/Ubuntu inside the <code class="literal">/mysql/defaults/main.yml</code> file:</p><div><pre class="programlisting">---
#roles/mysql/defaults/main.yml
mysql_user: mysql
mysql_port: 3306
mysql_datadir: /var/lib/mysql
mysql_bind: 127.0.0.1
mysql_pkg: mysql-server
mysql_pid: /var/run/mysqld/mysqld.pid
mysql_socket: /var/run/mysqld/mysqld.sock
mysql_cnfpath: /etc/mysql/my.cnf
mysql_service: mysql</pre></div><p>Then it will run on RedHat/CentOS machines, however, we will need to override a few of these variables to configure the RedHat-specific parameters.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Note that the filename should match the exact name (RedHat) that is returned by the <code class="literal">ansible_os_family</code> fact with the correct case.</p></div></div><p>We will create and edit the <code class="literal">roles/mysql/vars/RedHat.yml</code> file, as follows:</p><div><pre class="programlisting">---
# RedHat Specific Configs.
# roles/mysql/vars/RedHat.yml
mysql_socket: /var/lib/mysql/mysql.sock
mysql_cnfpath: /etc/my.cnf
mysql_service: mysqld
mysql_bind: 0.0.0.0</pre></div><p>Finally, we will create the <code class="literal">group_vars</code> fact with one variable to override our default settings. You have learnt that you can specify variables in the <code class="literal">inventory</code> files, the <code class="literal">group_vars</code> and the <code class="literal">host_vars</code> facts. We will start using the <code class="literal">group_vars</code> fact for now. You could either create <a id="id108" class="indexterm"/>these in your inventory file or create a separate directory for it with the name <code class="literal">group_vars</code>. We are going to take the second approach, which is recommended:</p><div><pre class="programlisting">
<strong># From our top level dir, which also holds site.yml</strong>
<strong>$ mkdir group_vars</strong>
<strong>$ touch group_vars/all</strong>
</pre></div><p>Edit the <code class="literal">group_vars</code>/<code class="literal">all</code> file and add the following line:</p><div><pre class="programlisting">mysql_bind: "{{ ansible_eth0.ipv4.address }}"</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Creating tasks</h3></div></div></div><p>It's now time to create <a id="id109" class="indexterm"/>tasks. Following the best practices, we will split tasks into multiple files and use include statements, just like we did for Nginx. Let's start by creating the default <code class="literal">main.yml</code> file inside <code class="literal">roles/mysql/tasks</code>, as follows:</p><div><pre class="programlisting">---
# This is main tasks file for mysql role
# filename: roles/mysql/tasks/main.yml
# Load vars specific to OS Family. 
- include_vars: "{{ ansible_os_family }}.yml"
  when: ansible_os_family != 'Debian'

- include: install_RedHat.yml
  when: ansible_os_family == 'RedHat'

- include: install_Debian.yml
  when: ansible_os_family == 'Debian'

- include: configure.yml
- include: service.yml</pre></div><p>We saw the <code class="literal">include</code> statements earlier. What's new here is the <code class="literal">include_vars</code> fact and the use of the <code class="literal">ansible_os_family</code> fact. If you notice:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are using the <code class="literal">ansible_os_family</code> fact here with the <code class="literal">include_vars</code> fact to determine whether to include OS-specific variables when the OS family is not Debian. Why not for the Debian system? That's because we are already specifying Debian-specific configurations in the <code class="literal">default</code> file. The <code class="literal">include_vars</code> fact works well with the preceding conditionals.</li><li class="listitem" style="list-style-type: disc">We are also calling OS-specific installation scripts using the <code class="literal">when</code> condition. We have included two scripts for now to support the Debian and RedHat families. However, later on, we could just extend the scripts by adding more <code class="literal">install_&lt;os_family&gt;.yml</code> scripts to support additional platforms.</li></ul></div><p>Now, let's create the install <a id="id110" class="indexterm"/>tasks for Debian and RedHat:</p><div><pre class="programlisting">
<strong>$ vim roles/mysql/tasks/install_Debian.yml</strong>
</pre></div><p>Then edit the file, as follows:</p><div><pre class="programlisting">---
# filename: roles/mysql/tasks/install_Debian.yml
  - name: install mysql server
    apt:
      name:"{{ mysql_pkg }}"
      update_cache:yes

<strong>$ vim roles/mysql/tasks/install_Redhat.yml</strong>
</pre></div><p>After running the preceding command, edit the file as follows:</p><div><pre class="programlisting">---
# filename: roles/mysql/tasks/install_RedHat.yml
- name: install mysql server
   yum:
     name:"{{ mysql_pkg }}"
     update_cache:yes</pre></div><p>In the preceding example, we used the <code class="literal">apt</code> and <code class="literal">yum</code> modules, respectively, for Debian- and RedHat-based systems. Following the best practices, we will write a data-driven role by providing the package name using a variable <code class="literal">mysql_pkg</code>. This variable is set based on the platform it runs on. Let's take a look at the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The next step is to create a task to configure MySQL. Since we know that every configuration file should be a template, we will create one for the <code class="literal">my.cnf</code> file, the <a id="id111" class="indexterm"/>default configuration file for the MySQL server:<div><pre class="programlisting">
<strong>$ touch roles/mysql/templates/my.cnf.j2</strong>
</pre></div><p>Then edit the file, as follows:</p><div><pre class="programlisting"># Notice:This file is being managed by Ansible
# Any manual updates will be overwritten
# filename: roles/mysql/templates/my.cnf.j2
[mysqld]
user = {{ mysql_user | default("mysql") }}
pid-file	 = {{ mysql_pid }}
socket = {{ mysql_socket }}
port = {{ mysql_port }}
datadir = {{ mysql_datadir }}
bind-address = {{ mysql_bind }}</pre></div></li><li class="listitem">We created a template with the <code class="literal">.j2</code> extension since it's a Jinja2 template. It's not a must, but a recommended practice.</li><li class="listitem">All configuration parameters come from variables in the <code class="literal">{{var}}</code> format. This is a recommended practice for managing a configuration file. We could let the attribute precedence decide where the values comes from.</li></ol></div><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>It's good practice to add a notice to every file being managed by Ansible. This will avoid possible manual updates or ad hoc changes.</p></div></div><p>We will write a task that will manage this template, and copy over the resulting file to the desired path on the host:</p><div><pre class="programlisting">---
# filename: roles/mysql/tasks/configure.yml
 - name: create mysql config
   template: src="img/my.cnf" dest="{{ mysql_cnfpath }}" mode=0644
   notify:
    - restart mysql service</pre></div><p>We have a common configuration file template; however, the path to copy this varies from platform to platform, also based on the flavor of MySQL that you plan to use. Here, we are using a MySQL distribution that comes with the Ubuntu and CentOS repositories by default, and we will set the <code class="literal">mysql_cnfpath</code> path from the role variables, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On Ubuntu/Debian, use the command: <code class="literal">mysql_cnfpath = /etc/mysql/my.cnf</code></li><li class="listitem" style="list-style-type: disc">On RedHat/CentOS, use the command: <code class="literal">mysql_cnfpath = /etc/my.cnf</code></li></ul></div><p>Also, we are sending the <a id="id112" class="indexterm"/>notification to the MySQL service restart handler. This will make sure that if there are any changes to the configuration file, the service will automatically be restarted.</p><p>To manage a service, we will create a service task and handler:</p><p>The task:</p><div><pre class="programlisting">
<strong>$ touch roles/mysql/tasks/service.yml</strong>
</pre></div><p>Then edit the file, as follows:</p><div><pre class="programlisting">---
# filename: roles/mysql/tasks/service.yml
 - name: start mysql server
   service: name="{{ mysql_service }}" state=started</pre></div><p>The handler:</p><div><pre class="programlisting">
<strong>$ touch roles/mysql/handlers/main.yml</strong>
</pre></div><p>After running the preceding commands, edit the file as follows:</p><div><pre class="programlisting">---
# handlers file for mysql
# filename: roles/mysql/handlers/main.yml
- name: restart mysql service
  service: name="{{ mysql_service }}" state=restarted</pre></div><p>Here, the task and handler are similar to the Nginx service, so nothing much needs to be described. The only change is that we are using the <code class="literal">mysql_service</code> variable to decide the service name to start, or restart, the service.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Using variables in playbooks</h2></div></div></div><p>Variables can also be <a id="id113" class="indexterm"/>specified in playbooks. The preferred method of doing so would be to pass them as role parameters, an example of which is shown as follows. This is typically useful when you have <a id="id114" class="indexterm"/>defaults in the role and you'd like to override some configuration parameters specific to your setup. That way, roles are still generic and sharable, and do not contain organization-specific data.</p><p>We are going to create a playbook to manage our databases and then we will include it in the site-wide playbook, as follows:</p><div><pre class="programlisting">
<strong>$ touch db.yml</strong>
</pre></div><p>Then edit the file, as follows:</p><div><pre class="programlisting">---
# Playbook for Database Servers
# filename: db.yml
- hosts: db
  remote_user: vagrant
  sudo: yes
  roles:
    - { role: mysql, mysql_bind: "{{ ansible_eth1.ipv4.address }}" }</pre></div><p>Here, we assume that the host's inventory contains a host group by the name <code class="literal">db</code>. In our example, we have two <code class="literal">db</code> servers, one running on Ubuntu, the other running on CentOS. This is added as:</p><div><pre class="programlisting">[db]
192.168.61.11 ansible_ssh_user=vagrant ansible_ssh_private_key_file=/vagrant/insecure_private_key
192.168.61.14 ansible_ssh_user=vagrant ansible_ssh_private_key_file=/vagrant/insecure_private_key</pre></div><p>In the preceding playbook, we used a parameterized role, which overrides one variable, that is, <code class="literal">mysql_bind</code>. The value is set from a multilevel fact.</p><p>Let's take a look at the following screenshot:</p><div><img src="img/B03800_03_08.jpg" alt="Using variables in playbooks"/></div><p>A multilevel fact can also be specified as <code class="literal">ansible_eth1["ipv4"]["address"]</code> and both the formats are valid. Parameterized roles are also useful when we want to create multiple instances of the role, for example, virtual hosts and WordPress instances running on different ports.</p><p>Let's now include this <a id="id115" class="indexterm"/>playbook in the top-level <code class="literal">site.yml</code> file using the <code class="literal">include</code> <a id="id116" class="indexterm"/>statement:</p><p>Edit the <code class="literal">site.yml</code> file as follows:</p><div><pre class="programlisting">---
# This is a sitewide playbook
# filename: site.yml
- include: www.yml 
- include: db.yml</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Applying a MySQL role to the DB servers</h2></div></div></div><p>We are all set to <a id="id117" class="indexterm"/>configure our database servers. Let's go ahead <a id="id118" class="indexterm"/>and apply the newly created role to all the <code class="literal">db</code> servers we have in the inventory:</p><div><pre class="programlisting">
<strong>$ ansible-playbook -i customhosts site.yml</strong>
</pre></div><p>The following image contains the snippet of the output which is only relevant to the database play:</p><div><img src="img/B03800_03_09.jpg" alt="Applying a MySQL role to the DB servers"/></div><p>We have explained the Ansible run in the previous chapters, when we created our first playbook as well as <a id="id119" class="indexterm"/>when we applied the Nginx role. The only <a id="id120" class="indexterm"/>new concept here is the <code class="literal">include_var</code> part. Ansible will check our condition based on the <code class="literal">ansible_os_family</code> fact and call variables specific to the OS. In our case, we have one Ubuntu and CentOS host each, and both of them call for the <code class="literal">RedHat.yml</code> file when it runs on the CentOS host alone.</p><p>What will be really interesting here is to find out what happened to our configuration files on each platform and which variables took precedence.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Variable precedence</h1></div></div></div><p>We specified <a id="id121" class="indexterm"/>variable defaults, used them in inventory files, and defined the same variable from different places (for example, defaults, vars, and inventory). Let's now analyze the output of the templates to understand what happened with all those variables.</p><p>The following is the figure showing the <code class="literal">my.cnf</code> file on Ubuntu:</p><div><img src="img/B03800_03_11.jpg" alt="Variable precedence"/></div><p>The following is the analysis of the screenshot:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The file has a notice in the comments section. This can deter admins from making manual changes to the file.</li><li class="listitem" style="list-style-type: disc">Most of the variables come from the defaults in a role. This is because Debian is our <a id="id122" class="indexterm"/>default family of operating systems and we already have sane defaults set for it. Similarly, for other operating system platforms, we are setting variable defaults from the <code class="literal">vars</code> directory in a role.</li><li class="listitem" style="list-style-type: disc">Even though the <code class="literal">bind_address</code> parameter is specified in the defaults and <code class="literal">group_vars</code>, it takes a value from the playbook's role parameter, which has a higher precedence over the other two levels.</li></ul></div><p>The following diagram explains what happens when there are variables defined at various levels. All of them are merged at runtime. If the same variables are defined in more than one place, the precedence rules apply:</p><div><img src="img/B03800_03_10.jpg" alt="Variable precedence"/></div><p>To understand the <a id="id123" class="indexterm"/>precedence rules, let's look at what happened on our CentOS host. The following is the <code class="literal">my.cnf</code> file created on CentOS:</p><div><img src="img/B03800_03_12.jpg" alt="Variable precedence"/></div><p>As seen in the preceding figure, in the case of CentOS, we see some interesting results:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The values for <strong>user</strong>, <strong>pid</strong>, <strong>datadir</strong>, and <strong>port</strong> come from the defaults. We have looked at the merge order. If the variables are not identical, they are merged to create the final configuration.</li><li class="listitem" style="list-style-type: disc">The value for a socket comes from vars as that's the only place it has been defined. Nevertheless, we want this socket to be constant for the RedHat-based system, hence, we specified it in the vars directory of the role.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">bind_address</code> parameter comes from the vars directory again. This is interesting as we <a id="id124" class="indexterm"/>have the <code class="literal">mysql_bind</code> variable defined at the following locations:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Default</code> in a role</li><li class="listitem" style="list-style-type: disc"><code class="literal">group_vars</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">playbook</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">vars</code> in a role</li></ul></div></li></ul></div><p>The following figure depicts the precedence rules when we define the same variable more than once:</p><div><img src="img/B03800_03_03.jpg" alt="Variable precedence"/></div><p>Since our role defines the <code class="literal">bind_address</code> parameter in the <code class="literal">vars</code> directory, it takes precedence over the rest.</p><p>There is a way to override a role parameter using extra variables or the <code class="literal">-e</code> switch while running Ansible. This is <a id="id125" class="indexterm"/>the supreme level of precedence for a variable that Ansible manages.</p><p>For example:</p><div><pre class="programlisting">
<strong>ansible-playbook -i customhosts db.yml  -e mysql_bind=127.0.0.1</strong>
</pre></div><p>In the preceding launch command, we used the <code class="literal">-e</code> switch, which will override all the other variable levels and make sure that the MySQL server is bound to <code class="literal">127.0.0.1</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>The best practices for variable usage</h1></div></div></div><p>Overwhelming, eh? Do not worry. We will give you the recommendations on the best practices while <a id="id126" class="indexterm"/>using variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Start with defaults in a role. This has the lowest precedence of all. This is also a good place to provide the sane defaults of your application, which can be later overridden from various places.</li><li class="listitem" style="list-style-type: disc">Group variables are very useful. A lot of the time we will do region-specific or environment-specific configurations. We would also apply certain roles to a certain group of servers, for example, for all web servers in Asia, we apply the Nginx role. There is also a default group by the name "<code class="literal">all</code>", which will contain all the hosts for all groups. It's a good practice to put the variables common for all groups in "<code class="literal">all</code>" (<code class="literal">group_vars/all</code>), which can then be overridden by more specific groups.</li><li class="listitem" style="list-style-type: disc">If there are host-specific exceptions, use <code class="literal">hosts_vars</code>, for example, <code class="literal">host_vars/specialhost.example.org</code>.</li><li class="listitem" style="list-style-type: disc">If you would like to separate variables in different files, create directories named after the hosts and put the variable files inside it. All files inside those directories will be evaluated:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">group_vars/asia/web</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">host_vars/specialhost/nginx</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">host_vars/specialhost/mysql</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">If you would like to keep your roles generic and sharable, use defaults in the roles and then specify organization-specific variables from playbooks. These can be specified as role parameters.</li><li class="listitem" style="list-style-type: disc">If you would like role variables to always take precedence over inventory variables and playbooks, specify them in the <code class="literal">vars</code> directory inside a role. This is useful for providing role constants for specific platforms.</li><li class="listitem" style="list-style-type: disc">Finally, if you would like to override any of the preceding variables and provide some data during runtime, provide an extra variable with Ansible commands using the <code class="literal">-e</code> option.</li></ul></div><p>By now, our tree for <a id="id127" class="indexterm"/>the MySQL role and DB playbook should look like the following figure:</p><div><img src="img/B03800_03_13.jpg" alt="The best practices for variable usage"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Review questions</h1></div></div></div><p>Do you think you've understood the chapter well enough? Try answering the following questions to test your understanding:</p><div><ol class="orderedlist arabic"><li class="listitem">How are Jinja2 templates different from static files?</li><li class="listitem">What are facts? How are they discovered?</li><li class="listitem">What is the difference between <code class="literal">{{ }}</code> and <code class="literal">{%  %}</code> in the context of Jinja2 templates?</li><li class="listitem">Can you use a variable anywhere apart from templates? If yes, where?</li><li class="listitem">If you define a variable <code class="literal">foo</code> in the <code class="literal">vars</code> directory in a role and the same variable in the <code class="literal">hosts_var</code> file, which of these will take precedence?</li><li class="listitem">How do you write Ansible roles that are supported on multiple platforms?</li><li class="listitem">Where can you specify the author and licensing information in a role?</li><li class="listitem">How do you provide variables while launching an Ansible-playbook command?</li><li class="listitem">Which command would you use to create a directory structure required by the roles automatically?</li><li class="listitem">How do you override a variable specified in the <code class="literal">vars</code> directory of a role?</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Summary</h1></div></div></div><p>We started this chapter by learning about why and how to separate data from code using Ansible variables, facts, and Jinja2 templates. You learnt how to create data-driven roles by providing variables and facts in templates, tasks, handlers, and playbooks. Additionally, we created a new role for the database tier, which supports both the Debian and RedHat families of operating systems. You learnt what system facts are and how they are discovered and used. You learnt how variables can be specified from more than one place, how they are merged, and the precedence rules. Finally, you learnt about the best practices for using variables.</p><p>In the next chapter, we will work with custom commands and scripts, understand what registered variables are, and deploy a sample WordPress application using all this information.</p></div></body></html>