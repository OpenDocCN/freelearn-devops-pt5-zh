- en: Security Automation with the CI Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reviewed white box testing tips and security testing toolsets. This
    chapter will focus on security practices in the development phases, as well as
    how to integrate tools such as Jenkins into continuous integration. In the development
    phases, we explored the techniques of using IDE plugins to secure code scanning,
    and suggested some static code analysis tools. For the build and package delivery,
    secure compiler configurations and dependency vulnerability checks will also be
    introduced. Finally, web security automation testing approaches and tips will
    also be discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Security in continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security practices in development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web testing in proactive/proxy mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web automation testing tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security automation in Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security in continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the development team's daily activities include coding, compiling/building,
    testing, and deployment. Our goal is to build security automation practices into
    these activities. In the coding stage, the development team can use IDE plugins
    to do security source code analysis. In the build stage, we scan for the secure
    hardened compiling options and the known vulnerabilities of the dependency components,
    as well as the secure source code for the whole project.
  prefs: []
  type: TYPE_NORMAL
- en: Once the build is ready and installed on the staging environment, more comprehensive
    security scanning will be performed, such as dynamic web security testing by OWASP
    ZAP, infrastructure configuration security, and secure communication protocols.
    In the production deployment, security scanning will also be performed regularly,
    and will be more focused on security monitoring instead of the source code or
    dynamic web security testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the security practices in each phase, namely, coding,
    build, testing, and production deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Security practices in development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The security practices of the development team consist of secure coding and
    secure build delivery. For the secure coding, we can have an IDE plugin do the
    code scanning, or we can also require security unit testing and run a static code
    scan of the whole project. For the secure build delivery, we need to ensure that
    the compiler options are configured properly and review all the dependency components
    for known vulnerabilities. The following diagram shows the overall security practices
    we can plan into the development stage. We will introduce some of the open source
    security tools and practices for these security activities in the upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: IDE plugins to automate the code review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key advantages of using the IDE plugins to perform the automated security
    code review is that the tools can provide informative suggestions for fixes during
    the coding stage. It works in a similar way to a spellchecker. This will reduce
    lots of code review efforts and security defects that can't be detected by blackbox
    testing. The disadvantage is that this kind of static code scanning may introduce
    some annoying false positives, and the developer team may ignore or forget to
    use the IDE plugins to do static secure code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows some of the open source IDE plugins that can help
    developers to detect security and coding errors. Only open source tools are listed
    here, although there are also many good commercial tools that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'DevSkim is recommended not only because it can support multiple languages,
    but also because it supports a wide range of IDEs, such as VS, VS Code, Sublime
    Text, and so on. In addition, writing scanning rules for DevSkim is also simple
    in JSON format. Refer to  [https://github.com/Microsoft/DevSkim/wiki/Sample-Rule](https://github.com/Microsoft/DevSkim/wiki/Sample-Rule) for
    more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tools** | **Supported programming language** | **Reference** |'
  prefs: []
  type: TYPE_TB
- en: '| FindSecBugs | Java |'
  prefs: []
  type: TYPE_TB
- en: '[https://find-sec-bugs.github.io/](https://find-sec-bugs.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| PMD | Java |'
  prefs: []
  type: TYPE_TB
- en: '[https://pmd.github.io/](https://pmd.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| DevSkim | All |'
  prefs: []
  type: TYPE_TB
- en: '[https://github.com/Microsoft/DevSkim](https://github.com/Microsoft/DevSkim)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we would like the code review to be done automatically by the tools,
    there may be an occasion where we want to execute a team peer code review and
    require a team collaboration portal to comment on or discuss the code quality.
    For a team code review platform, the following open source tools are recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gerrit:** It provided a web-based UI code review for the GIT source code. [www.gerritcodereview.com](http://www.gerritcodereview.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phabricator:** Phabricator is an open source tool which integrates not only
    code review tools but also bug tracking.  [www.phacility.com](http://www.phacility.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the peer code review practices, consider creating a code review checklist
    or refer to the OWASP cheat sheet or OWASP SCP (secure coding practices):'
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static code scanning analysis is an effective source-level security inspection
    in CI frameworks, such as Jenkins or Travis. The development team may not fully
    apply IDE code-scanning plugins to do the secure code analysis. In that case,
    the static code analysis adoption into the CI framework will help to enforce the
    secure code scanning for all projects. In other words, the integration with the
    static security code analysis tools and Jenkins is a must in the development stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists some of the static code analysis tools. You can also
    refer to [Chapter 8](part0145.html#4A91I0-993778ed0b7e4894800dd46a3f389a65), *Secure
    Coding Best Practices*, for other suggested tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tools** | **Supported Programming language** | **Characteristics** |'
  prefs: []
  type: TYPE_TB
- en: '| Grep Rough Audit | All | It''s a simple script to detect security flaws in
    the source code by using GREP and regular expression for common security patterns. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| Flawfinder | C/C+ | It''s a simple tool to scan for the security issue in
    C/C++ security issue in C/C++ source code.   |'
  prefs: []
  type: TYPE_TB
- en: '| Brakeman | Ruby on Rails | Brakeman is mainly focused on the security issue
    in Ruby code. |'
  prefs: []
  type: TYPE_TB
- en: '| SonarQube | All | The SonarQube is a source code quality analysis tool. |'
  prefs: []
  type: TYPE_TB
- en: '| GREP IT | All | It''s one Linux shell script which can do the code scanning.
    No other dependencies required.  |'
  prefs: []
  type: TYPE_TB
- en: '| NodeJsScan | NodeJS | It''s mainly used to scan NodeJS security issue. |'
  prefs: []
  type: TYPE_TB
- en: '| ScanJS | JavaScript | The ScanJS can identify the uses of high-risk JavaScript
    API such as eval, execScript, document.write and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Bandit | Python | It scans the security issue for Python source code. |'
  prefs: []
  type: TYPE_TB
- en: Secure compiler configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The secure compiler configuration means that you can enable the compile-time
    defenses against memory corruption issues to execute unexpected exploit code.
    These mitigations may include RELRO, **address space layout randomization** (**ASLR**),
    **NoExecute** (**NX**), stack canaries, and **position-independent executables**
    (**PIE**). These secure compiler configurations should be done during the development
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of the available mitigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mitigation** | **Visual Studio compiler options** |'
  prefs: []
  type: TYPE_TB
- en: '| Stack randomization | /DyNAMICBASE |'
  prefs: []
  type: TYPE_TB
- en: '| Buffer overrun defenses | /GS |'
  prefs: []
  type: TYPE_TB
- en: '| NoExecute (NX) | /NXCOMPAT |'
  prefs: []
  type: TYPE_TB
- en: '| Exception handler protection | /SAFESEH |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows the common build flags for GCC and G++ compiler drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mitigation** | **Compiler and linker flags for GCC** |'
  prefs: []
  type: TYPE_TB
- en: '| Address | -fPIC |'
  prefs: []
  type: TYPE_TB
- en: '| NoExecute stack | -Wl, -z, noexecstack |'
  prefs: []
  type: TYPE_TB
- en: '| GOT protection | -Wl, -z, relro |'
  prefs: []
  type: TYPE_TB
- en: '| Stack protector | -fstack-protector |'
  prefs: []
  type: TYPE_TB
- en: '| ASLR | Echo 1 > /proc/sys/kernel/randomize_va_space |'
  prefs: []
  type: TYPE_TB
- en: 'The following tools can be used to verify the correct secure compiler configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CheckSEC for Linux**: [www.trapkit.de/tools/checksec.html](http://www.trapkit.de/tools/checksec.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft BinScope**: [https://www.microsoft.com/en-us/download/details.aspx?id=44995](https://www.microsoft.com/en-us/download/details.aspx?id=44995)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The secure compiler configurations are low-hanging fruits for the buffer overflow
    security mitigations. This security practice is often neglected by the development
    team. Make sure that the security configurations are done at compile time, and
    also verify the binary packages in the testing stage.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Known vulnerabilities in third-party components or dependencies are considered
    to be parts of the OWASP Top 10 List of Using Components with Known Vulnerabilities.
    These known vulnerable components should be identified at an early development
    stage. It is also suggested that you perform the vulnerability scanning of the
    dependency components not only in the development stage but also in the production
    stage on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools will help you scan for vulnerable components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Supported languages** |'
  prefs: []
  type: TYPE_TB
- en: '| OWASP Dependency Check | The OWASP Dependency Check scans for dependency
    vulnerabilities in Java, Ruby, PHP, JavaScript, Python, and .NET.  |'
  prefs: []
  type: TYPE_TB
- en: '| Retire.JS  | Retire.JS scans for vulnerable JavaScript libraries. |'
  prefs: []
  type: TYPE_TB
- en: '| Snyk | Snyk scans for the JS, Ruby, Python, Java vulnerabilities. |'
  prefs: []
  type: TYPE_TB
- en: Web testing in proactive/proxy mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic web testing tools, such as OWASP ZAP, Arachni, Wapiti and W3af, normally
    provide two modes of security testing: proactive mode and proxy mode. The proactive
    mode means that you launch the testing tools and perform security testing directly
    on the web services. The tester may decide on the types of security testing (such
    as XSS or SQLi) of the target web service. However, the key disadvantage of this
    kind of testing is that you could miss certain permission-required web pages,
    or web pages that may require the right order of page visits. The following diagram
    shows the approach of proactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The proactive mode
  prefs: []
  type: TYPE_NORMAL
- en: The proxy mode, which can also be understood as MITM, means that the security
    testing tool is running as a proxy and intercepting traffic between the browser
    client and the target web services. In the proxy mode, the security testing tool
    OWASP ZAP will detect potential security vulnerability issues based on the intercepted
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take OWASP ZAP as an example. Say that we want OWASP ZAP to be executed in
    proxy mode. This will require the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the OWASP ZAP as proxy mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the client-side proxy to the OWASP ZAP proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the CA certificate in the OWASP ZAP proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Proxy mode works best for the project team if they have set up functional automation,
    such as Selenium or Robot Framework. Selenium or Robot Framework will help to
    guide the OWASP ZAP to walk through the web pages, especially those required permission
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The proxy mode
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, it''s recommended that you execute the web security testing in
    both modes with more than one tool. This is because every security tool may have
    its own strength and weakness of security attacks and detection engines. For example,
    OWASP ZAP and Arachni may be running in proactive scanning and spider mode. Furthermore,
    you can also use the Selenium automation client to guide the Vega or OWASP ZAP
    to visit authenticated pages, and to do deeper fuzz testing on the specified web
    service. Refer to the following diagram for the testing scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Web automation testing tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply install and launch OWASP ZAP. Active and passive scanning can only give
    us a preliminary testing result for public web services. The following table contains
    some suggested tips to improve the testing efficiency and effectiveness for uses
    of web automation testing tools, such as ZAP or Arachni:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Testing tips** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Integration | To do automated integration, try to understand that the web
    security tools provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Headless execution mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins plugin (this may be optional as long as one of te preceding tools is
    provided)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the OWASP ZAP ([https://github.com/Grunny/zap-cli/](https://github.com/Grunny/zap-cli/))
    provides the ZAP CLI interface, which also helps make the integration easier.
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| Authorization testing | To test the guest, user, and admin permissions for
    every web service''s URL or resources will require proper predefined navigation
    workflows. The testing scenario may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Session fixation, reuses, expiration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User, role, guest, administration permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login, logout, and reauthentication behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two main approaches for the security testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Selenium or Robot Framework to do the authentication and use OWASP ZAP to
    detect the security issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preconfigure the pages or URLs that require authentication in OWASP ZAP or Arachni
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Scanning scope | Dynamic web testing may take a very long period of time.
    Properly configure the scanning scope to include or exclude the URLs that are
    being tested. Only apply a complete full scan when the application passes the
    smoke testing. A complete scan can be scheduled to be done on a nightly basis.
    |'
  prefs: []
  type: TYPE_TB
- en: '| API fuzz | The web service may provide several REST JSON or SOAP XML APIs.
    It''s suggested that you get a complete API list and specifications. Do the fuzz
    testing on the parameters of each API. Once this has been done, run the OWASP
    ZAP or the Arachni in proxy mode to intercept all the API calls. Then, investigate
    these API calls for further fuzz testing with the parameters in the payload.For
    the fuzz security payload test, consider replacing the value of the parameters
    with the following data in the fuzzDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/fuzzdb-project/fuzzdb/](https://github.com/fuzzdb-project/fuzzdb/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/minimaxir/big-list-of-naughty-strings/](https://github.com/minimaxir/big-list-of-naughty-strings/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Radamsa can be used to automatically generate fuzzing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/aoh/radamsa](https://github.com/aoh/radamsa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Business logic | Some web UI workflows need to be operated in order, such
    as shopping for items, ordering the items, and payment. Here are some approaches
    to help you handle this kind of security testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Use existing functional Selenium automation UI testing and run the OWASP ZAP
    or Arachni in proxy attack mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the script provided by OWASP ZAP to integrate with Selenium. Refer to the
    Zap webdriver ([https:/github.com/continuumsecurity/zap-webdriver](https://github.com/continuumsecurity/zap-webdriver))
    as an example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the BDD Security framework ([https://github.com/continuumsecurity/bdd-security/](https://github.com/continuumsecurity/bdd-security/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually operate the web pages to navigate the flow and save the ZAP sessions
    for further security scanning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Security automation in Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how to configure Jenkins to trigger the automated
    testing, and also introduce some of the security plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows an example of how to configure the command-line ZAP,
    which can be triggered periodically and remotely by a predefined URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Steps** | **Configuration steps** |'
  prefs: []
  type: TYPE_TB
- en: '| New item | New Item &#124; Enter an Item Name &#124; *"Security Testing"*
    &#124; Freestyle Project &#124; OK |'
  prefs: []
  type: TYPE_TB
- en: '| General | Project Name: *"Security Testing"* |'
  prefs: []
  type: TYPE_TB
- en: '| Build Trigger | The automation testing can be triggered by the schedule in
    the following ways. The Build Trigger defines how the tasks can be triggered.
    There are two modes supported: one is the scheduled mode and the other is the
    remote trigger by the REST API:                 Build Periodically: *45  9-17/2 
    *  *  1-5*The automation testing can also be triggered remotely by sending the
    HTTP request:                 Trigger builds remotely:  *ZAP*Once it''s defined,
    this will be the URL that can be triggered remotely to kick off the automation
    execution:`https://<JenkinsHost:8080>/job/Security Testing/build?token=ZAP` |'
  prefs: []
  type: TYPE_TB
- en: '| Build | Build &#124; Add Build StepExecute the Windows batch command: `echo
    ---- the execution of OWASP ZAP for Active Scan----``           zap cli   active-scan   
    http://targetWeb/``     echo ---- The end of OWASP ZAP active Scan ----` |'
  prefs: []
  type: TYPE_TB
- en: 'There are some open source security scanning tools that also provide Jenkins
    plugins. In practice, these Jenkins plugins are optional. If you have few projects
    and would like to manage the security scanning status in the Jenkins dashboard,
    these Jenkins plugins will be good choices. However, if you have a lot of projects
    with various kinds of security testing scans, it''s still suggested that you build
    your integrated security testing framework. Please also refer to the [Chapter
    12](part0206.html#64EJS0-993778ed0b7e4894800dd46a3f389a65), *Security Testing
    Toolkits*, for details. The following table lists the common Jenkins plugins that
    are related to software security assessment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Jenkins Security plugins** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| ZAP | ZAP is a dynamic web scanning tool. |'
  prefs: []
  type: TYPE_TB
- en: '| Arachni Scanner | Arachni Scanner is a dynamic web scanning tool. |'
  prefs: []
  type: TYPE_TB
- en: '| Dependency Check plugin | The Dependency Check plugin detects vulnerable
    dependency components. |'
  prefs: []
  type: TYPE_TB
- en: '| FindBugs | FindBugs is a static code analysis tool for Java. |'
  prefs: []
  type: TYPE_TB
- en: '| SonarQube  | SonarQube is a code quality analysis tool. |'
  prefs: []
  type: TYPE_TB
- en: '| 360 FireLine | 360 FireLine is a static code scanner for Java. |'
  prefs: []
  type: TYPE_TB
- en: '| HTML Publisher Plugin | The HTML Publisher plugin generates the testing results
    in HTML. |'
  prefs: []
  type: TYPE_TB
- en: '| Log Parser Plugin | The Log Parser plugin parses the testing results of the
    security testing tools, such as the number of XSS detected or the number of errors.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static Analysis Collector  | The Static Analysis Collector plugin can consolidate
    the results from all other static code analysis plugins, such as Checkstyle, Dry,
    FindBugs, PMD, and Android Lin. |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the security practices that take place during
    the continuous integration cycle in the coding, building, testing, and production
    deployment phases. For the development stage, we perform secure code scanning,
    secure compiling checks, and also vulnerable third-party component review. For
    the static code analysis, we also introduced some of the open source scanning
    tools for different programming languages. We have also learned how to enable
    compile-time defenses against buffer overflows, such as ASLR and NX.
  prefs: []
  type: TYPE_NORMAL
- en: For web security testing, we introduced  testing approaches in proactive and
    proxy modes and discussed  web automation testing tips to improve the testing
    effectiveness in terms of business logic, API fuzz, scanning scope, authorization,
    and integration. We also looked at  Jenkins configurations and  security automation
    plugins in Jenkins, such as ZAP, Arachni, Dependency Check, FindBugs, and SonarQube.
    In the next chapter, we will learn about incident response.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What security practices are related to secure coding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security scanning using IDE plugins
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security unit testing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Static code scanning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the tool DevSkim do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reverse engineering
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is an IDE plugin for static code scanning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Web security scanning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Network security
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What techniques are used to defend against memory overflow attacks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stack randomization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Nonexecution
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Exception handler protection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the main purpose of using dependency check tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Software integrity
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Implements access control
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scans for known vulnerabilities
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Data encryption
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What security testing can Radamsa be used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: API fuzz testing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrity monitoring
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic analysis
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mobile application
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub automated testing resources**: [https://github.com/atinfo/awesome-test-automation](https://github.com/atinfo/awesome-test-automation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardening compiler and linker flags**: [https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/](https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated security testing for REST APIs**: [https://github.com/flipkart-incubator/Astra](https://github.com/flipkart-incubator/Astra)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
