- en: Rebasing Regularly and Interactively, and Other Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing commits to another branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing a rebase with merge conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebasing selected commits interactively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squashing commits using an interactive rebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the author of commits using a rebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autosquashing commits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rebase is an incredibly strong Git feature. Hopefully, you have used it before;
    if not, you might have heard about it. Rebasing is exactly what the word implies.
    So, if you have a certain commit, `A`, which is based on commit `B`, then rebasing
    `A` to `C` would result in commit `A` being based on commit `C`.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in the different examples in this chapter, it is not always
    as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing commits to another branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, we are going to perform a very simple rebase, where we will introduce
    a new file, commit that file, make a change to it, and then commit it again so
    that we end up with two new commits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, we need a repository to work in. You can use a previous clone
    of `jgit`, but to get a close-to-identical output from the example, you can clone
    the `jgit` repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jgit` repository can be cloned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating a local branch and then make two commits by performing
    the following steps; these are the commits that we want to rebase onto another
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out a new branch, `rebaseExample`, which tracks `origin/stable-3.1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Make two commits on the `rebaseExample` branch, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we rebase the change on top of the `origin/stable-3.2` branch instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you execute `git rebase`, Git starts by finding the common ancestor of
    the current `HEAD` branch and the branch you want to rebase to. When Git finds
    `merge-base`, it will find the commits that are not available in the branch you
    are rebasing onto. Git will simply try to apply those commits one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing a rebase with merge conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you rebase a commit or a branch on top of a different `HEAD`, you may eventually
    see a conflict.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a conflict, you will be asked to solve the merge conflict and continue
    with the rebase using `git rebase --continue`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be creating a commit that adds the same `fishtank.txt` file on top
    of the `origin/stable-3.1` branch; then, we will try to rebase this on top of
    the `rebaseExample` branch we created in the *Rebasing commits to another branch*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the branch named `rebaseExample2`, which tracks `origin/stable-3.1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a commit on the branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to rebase the branch on top of the `rebaseExample` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can solve the conflict in your preferred editor. Then, add the file to the
    index using `git add` and continue with the rebase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now check with `gitk` to see whether our change is rebased on top of
    the `rebaseExample` branch, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a936be88-0c44-4f1c-987a-563944183fa7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned from the first example, Git will apply the commits that are not
    available in the branch you are rebasing onto. In our example, it is only our
    commit, as we made it, that is available on the `rebaseExample2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed in the output of the failing rebase that you have two
    extra options for the commit.
  prefs: []
  type: TYPE_NORMAL
- en: When you have resolved this problem, run `git rebase --continue`. If you prefer
    to skip this patch, run `git rebase --skip` instead. To check out the original
    branch and stop rebasing, run `git rebase --abort`.
  prefs: []
  type: TYPE_NORMAL
- en: The first extra option we have is to totally ignore this patch by skipping it;
    you can do this using `git rebase --skip`. In our example, this will cause our
    branch to be fast-forwarded to the `rebaseExample` branch. So, both our branches
    will point to the same commit hash.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is to abort the rebasing. If we choose to do this, then we
    will go back to the branch as it was prior to starting the rebase. This can be
    done using `git rebase --abort`.
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing selected commits interactively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are working on a new feature and have branched from an old release
    into a feature branch, you might want to rebase this branch onto the latest release.
    When looking into the list of commits on the feature branch, you may realize that
    some of the commits are not suitable for the new release. In that case, when you
    want to rebase the branch onto a new release, you will need to remove some commits.
    This can be achieved with interactive rebasing, where Git gives you the option
    to pick the commits you wish to rebase.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with this example, you need to check the previously created
    branch, `rebaseExample`; if you don''t have this branch, follow the steps from
    the *Rebasing commits to another branch* section and use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, because we are tracking `origin/stable-3.1`, the Git checkout will
    tell us how far ahead we are in comparison with that branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will try to rebase our current branch, `rebaseExample`, on top of the `origin/stable-3.1`
    branch by performing the following steps. Remember that Git will apply the commits
    that are not available on the branch we are rebasing to; so, in this case, there
    will be a lot of commits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebase the branch onto `origin/stable-3.1` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What you will see now is a list of all the commits you will be rebasing onto
    the `origin/stable-3.1` branch. These commits are all the commits between the
    `origin/stable-3.1` and `rebaseExample` branches. The commits will be applied
    from top to bottom, hence, the commits will be listed in reverse order—at least
    compared to what you would normally see in Git. This actually makes good sense.
    The commits have the keyword `pick` to the left and then the abbreviated commit
    hash, and finally the title of the commit subject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you scroll down to the bottom, you will see a list along the lines of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, if we only want our `fishtank` commits to be based on top of the `origin/stable-3.1`
    branch, we should remove all the commits except for our two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove all the lines except for the two commits at the bottom; for now, leave
    `pick` as the keyword. Save the file and close the editor, and you will get the
    following message from Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with `gitk`, check whether we accomplished what we predicted. The next
    screenshot shows our two `fishtank` commits on top of the `origin/stable-3.1`
    branch. The following screenshot is what we expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2fa6ba1e-496b-4bc2-8814-ed2f55c70ce5.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same thing could actually be achieved with a single short Git command.
    We have been rebasing commits from the `origin/stable-3.2` branch to the `rebaseExample`
    branch onto the `origin/stable-3.2` branch. This can also be achieved in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--onto origin/stable-3.2` flag tells Git to rebase onto `origin/stable-3.2`,
    and it has to be from `origin/stable-3.1` to the `rebaseExample` branch. So, we
    end up having the `rebaseExample` branch to the branch of the `origin/stable-3.1`
    and so on. The next diagram illustrates both before the rebase example, where
    we have our two commits on top of `origin/stable-3.2`, and after the rebase, where
    our commits are on top of `origin/stable-3.1`, as we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49a5c6d8-ec59-4496-8d7b-8864d0d28c6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Squashing commits using an interactive rebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I work on a local branch, I prefer to commit in small increments with a
    few comments on what I did in the commits; however, as these commits do not build
    or pass any test requirements, I cannot submit them for review and verification
    one by one. I have to merge them in my branch, but still, cherry-picking my fix
    would require me to cherry-pick twice the number of commits, which is not very
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: What we can do is rebase and squash the commits into a single commit, or at
    least fewer commits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with this example, we need a new branch, namely `rebaseExample3`,
    which tracks `origin/stable-3.1`. Create the branch with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To really showcase this Git feature, we will start off six commits ahead of
    the `origin/stable-3.1` branch. This is to simulate the fact that we have just
    created six commits on top of the `rebaseExample3` branch; to do this, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find a commit that is between `origin/stable-3.1` and `origin/stable-3.2`,
    and list the commits in reverse order. Alternatively, you can scroll down to the
    bottom of the output and find the commit we will use, as shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Reset the `rebaseExample3` branch to the `5218f7b` commit; this will simulate
    having six commits on top of the `origin/stable-3.1` branch. This can be tested
    by running the status of Git as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have these six commits on top of the `origin/stable-3.1` branch, and
    we want to squash these commits into two different commits. This can be done by
    simply running `git rebase --interactive`. Note that we are not specifying which
    branch we want to rebase to, since we have already set up a tracking branch when
    we created the branch using `--track`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To continue, let''s execute the rebase command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The editor will open, and you will see four commits, not six as you would expect.
    This is because the rebase, in general, refuses to take merged commits as part
    of the rebase scenario. Although you can use the `--preserve-merges` flag, as
    per the Git Help section, this is not recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to the Git Help section, instead of ignoring merges, `--preserve-merges` tries
    to recreate them. The `--preserve-merges` flag uses the `--interactive` machinery
    internally, but combining it with the `--interactive` option explicitly is generally
    not a good idea, unless you know what you are doing (see the bugs in the following
    snippet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the file so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember that commits are listed in reverse order compared to the Git log. So,
    when squashing commits, we squash up into the commits we have marked with the
    `pick`. When you close the editor, Git will start the rebase from top to bottom.
    First, apply `8a51c44` and then squash `f045a68` into the commit `8a51c44`. This
    will open the commit message editor, which contains both of the commit messages.
    You can edit the commit messages, but for now, let's just close the editor to
    finish with the rebase and the squashing of these two commits. The editor will
    open one more time to complete the squashing of `5218f7b` into `7995d87`. Use
    `gitk` to verify the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot is as expected; now, we only have two commits on top
    of the `origin/stable-3.1` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5490c91-8648-43ec-b575-50a267630a57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you check the commit message of the `HEAD` commit, you will see that it
    has the information of two commits, as shown in the following command. This is
    because we decided not to change the commit message when we made the change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have squashed two commits, but we could have used other keywords when
    editing the rebase's to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try the fixup functionality, which works like the squash functionality,
    by performing the following steps; the exception is that Git will select the commit
    message of the commits using the `pick` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by resetting back to our starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are back at the starting point, that is, we''re six commits
    ahead of the `origin/stable-3.1` branch. Now we can try the fixup functionality.
    Start the interactive rebase and change the file according to the following output.
    Notice that you can use `f` instead of `fixup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you close the editor, you will see rebase''s progress through Git. As
    predicted, the commit message editor will not open. Git will just rebase the changes
    into two commits on top of the `origin/stable-3.1` branch. Using `git status`,
    you can confirm that you have just two commits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another difference is that the commit message from the two commits we marked
    with fixup has disappeared. So, if you compare this with the previous example,
    it''s very clear what the difference is; it''s shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can also confirm that we still have the same source code, but with
    different commits. This can be done by comparing this commit with the commit we
    created via `5218f7b`, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As predicted, there is no output from `git diff`, so we still have the same
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: This check can also be performed on the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the author of commits using a rebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When starting to work on a new project, it is common to forget to set the author
    name and author email address for the specified project. Therefore, you will often
    have commits in your local branch that have been committed with the wrong username
    and/or email ID.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin this exercise, we need a branch, as always with Git. Name the
    branch `resetAuthorRebase` and make it track `origin/master`. Use the following
    command to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we want to change the author of all the commits from `origin/stable-3.2` to
    our `HEAD`, which is `master`. This is just an example; you will rarely have to
    change the author of commits that have already been published to a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the author of the `HEAD` commit by using `git commit --amend
    --reset-author`; however, this will only change the author of `HEAD` and leave
    the rest of the commits as they were. We will start by changing the author of
    the `HEAD` commit and then verify why that is wrong by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the author of the `HEAD` commit as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that you have changed it using the Git log command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will list all the commits from `origin/stable-3.2` to `HEAD` and we will
    define a format with `%h` as the abbreviated commit hash, `%an` for the author''s
    name, and `%ae` for the author''s email address. From the output, you can see
    that I am now the author of the `HEAD` commit, but what we really wanted was to
    change the author of all the commits. To do this, we will rebase onto the `origin/stable-3.2`
    branch; then, for each commit, we will stop to amend and reset the author. Git
    can do most of that work with `--exec option` for the `git` rebase, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Git has opened the rebase's to-do list for you, and between
    every commit, you have the `exec` keyword and the command we specified on the
    command line. You can have more `exec` lines between commits if you have a use
    case for them. Closing the editor will start the rebase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you will see, this process is not very good, as the commit message editor
    opens every time and you have to close the editor to allow Git to continue with
    the rebase. To stop the rebase, clear the commit message editor and Git will return
    to the command line; then, you can use `git rebase --abort` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve what we really want, you can add the `--reuse-message` option for
    `git commit`; this will reuse the commit message for the commit you will specify.
    We want to use the message of `HEAD`, as we are going to amend it to the `HEAD`
    commit. So, try again, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Git provides an output indicating that the action was a success; however, to
    verify this, you can execute the previous Git log command and you should see that
    the email address has changed on all the commits, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It works as you would expect! There is one thing to remember: when using the
    `exec` option, Git will check the work area for unstaged and staged changes. Consider
    the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you were to have a line as illustrated in the preceding command, the first
    `exec` would be executed and you would then have an unstaged change in your work
    area. Git would complain and you would have to solve that before continuing with
    the next `exec`.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to do something like this, you must create a single exec line
    that executes all the things you want. Besides this, the rebase functionality
    is fairly simple; it just tries to apply the changes in the order specified in
    the rebase's to-do list. Git will only apply the changes specified in the list,
    so if you remove some of them, they will not be applied. This is a way to clean
    up a feature branch for unwanted commits, for instance, commits that enable you
    to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Autosquashing commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I work with Git, I often create a lot of commits for a single bug fix,
    but when making the delivery to the remote repository, I prefer—and recommend—delivering
    the bug fix as one commit. This can be achieved with an interactive rebase, but
    since this should be a common workflow, Git has a built-in feature called autosquash,
    which will help you squash the commits together.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin with this exercise, we will create a branch from `origin/master`
    so we are ready to add commits to our fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After checking the branch, we will create the first commit that we want to
    squash other commits to. We need to use the abbreviated commit hash from this
    commit to automatically create other commits that will squash to this commit by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by echoing some text into `README.md`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will append more information to `README.md` for developers; verify that
    the file has changed using the Git status as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to add and commit this. We can do this with the `commit` command
    using the `-a` flag, which will add any unstaged changes to the commit, as shown
    in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After you create the commit, remember the abbreviated commit hash; we have highlighted
    it in bold in the command output. The abbreviation will be different in your environment,
    and you should have your own abbreviation once you finish the exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To continue, we will add three commits to the branch, and we would like to
    squash two of these with the first commit, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first commit. Pay attention to why we needed to store the abbreviated
    hash of the first commit—we used it with the `--squash` option for `git commit`.
    This option will create the commit with the subject of the commit specified. It
    will also add `squash!` to the start of the subject. This is to indicate that
    Git should squash this commit when performing a rebase. Now, create the second
    commit, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added two commits that we would like to squash with the first commit.
    When committing, I also used the `--no-edit` option; this skips the opening of
    the commit''s message editor. If you leave the flag out, the editor will open
    as it usually does when committing. The difference is that the commit subject
    has already been set, and you only need to write the commit message. Now, we will
    create the last commit; we don''t want to squash this commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the final commit, which does not have anything to do with the first
    three commits we added. This is why we did not use the `--squash` option. We can
    now squash the commits together using `git rebase -i`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the rebase''s to-do list up in the configured commit editor. What
    we would have expected was to have Git configure a squash for the commits we wanted
    to squash, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'What you can see is that Git inserted `squash` to the subject of two of the
    commits, but besides this, we did not get what we had expected. Git requires you
    to specify `--autosquash` to the `git rebase -i` command. Close the editor and
    Git will perform the rebase and give the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try again with `--autosquash` and see what happens with the rebase''s
    to-do list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, the rebase's to-do list looks much more as we expected. Git has preconfigured
    the to-do list to show which commits it will squash and which commits it will
    keep.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Closing the to-do list now will start the rebase, and we don''t want that (the
    next step will show what we really want). If you clear the to-do list (deleting
    all lines), save and close the editor, the rebase will be aborted. This is what
    we want. The output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What we really want to do is just run `git rebase -i` and Git will use `--autosquash`
    as the default. This can be achieved with `git config rebase.autosquash true`;
    try it and then run `git rebase -i`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The rebase''s to-do list pops up, and we have the expected result as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now close the editor and allow the rebase to start. The editor opens and you
    can change the commit message for the combined message, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the message and close the editor; Git continues with the rebase and
    ends with the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we now have two commits on top of the `origin/master` commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hopefully, this will assist you when you are just making changes and committing
    them, but want to deliver the code as one commit.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to avoid opening the commit message editor, as in step 17 of the
    *Autosquashing commits* recipe, you can use `--fixup=d539645`. This will use the
    commit message from the first commit and totally disregard any message written
    in the commits.
  prefs: []
  type: TYPE_NORMAL
