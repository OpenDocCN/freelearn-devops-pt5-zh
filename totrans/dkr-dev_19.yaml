- en: '*Chapter 16*: Conclusion – End of the Road, but not the Journey'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：结论 – 终点站，但不是旅程的结束'
- en: You have now reached the final chapter of this book. Over the previous 15 chapters,
    a variety of topics have been covered. As you may have noticed, the book was grouped
    into three areas—development, DevOps with monitoring, and finally security. So,
    let's take the time to recap what we studied in each area and where we can go
    next.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经到达了本书的最后一章。在前面的15章中，我们讨论了各种话题。正如你可能已经注意到的，书中的内容被分为三个领域——开发、带有监控的DevOps，最后是安全性。那么，让我们花些时间回顾一下我们在每个领域所学到的内容，以及接下来我们可以去哪里。
- en: First, we will run through an overview of what we learned in the book. Next,
    a summary of the skills we acquired on the development front will be presented.
    After this, we will explore where we can go next to learn more about DevOps with
    containers and expand our newly learned skills. Our penultimate review will consider
    what we learned about security and how we can stay on top of it. Then, we will
    finish up with a general conclusion on everything we've studied.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回顾一下本书中学到的内容。接着，将呈现我们在开发方面所获得的技能总结。然后，我们将探索下一步可以去哪里，学习更多关于容器化DevOps的知识，并扩展我们新学到的技能。我们的倒数第二次回顾将考虑我们在安全方面学到的内容，以及我们如何保持对安全的关注。最后，我们将以对我们所学内容的总体总结结束。
- en: 'In order to review these items, we''ve broken them down into the following
    topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复习这些内容，我们将它们分解为本章中的以下主题：
- en: Wrapping up – let's get started
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结 – 让我们开始吧
- en: What we learned about development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学到的开发内容
- en: Next steps for taking your DevOps knowledge further
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推进DevOps知识的下一步
- en: A summary on security and where to go next
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于安全性的总结以及接下来的步骤
- en: Grab your containerized environment and get ready for our last foray together
    into the world of Docker.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好你的容器化环境，准备好和我们一起进入Docker世界的最后一探。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to have access to a Linux machine running Docker.
    We recommend that you use the setup you have been using so far in this book. This
    is so you can follow up with some of the tools and techniques recommended in this
    chapter if you wish.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要有一台运行Docker的Linux机器。我们建议你使用本书中到目前为止一直使用的设置。这样，你就可以按照本章推荐的一些工具和技术继续进行，如果你愿意的话。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码在实际中的表现：
- en: '[https://bit.ly/2CpGTfZ](https://bit.ly/2CpGTfZ)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/2CpGTfZ](https://bit.ly/2CpGTfZ)'
- en: Wrapping up – let's get started
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结 – 让我们开始吧
- en: Over the course of this book, we have explored the world of containerization.
    As the technology becomes ever more ubiquitous in companies and projects across
    the world, having a solid handle on the basics and the toolsets supporting containers
    becomes ever more useful.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们探讨了容器化的世界。随着这项技术在全球公司和项目中变得越来越普及，掌握容器基础知识以及支持容器的工具集变得愈发有用。
- en: Before we close the book, we are going to wrap up by reviewing what we have
    learned on the development front. After this, we will discuss what steps can be
    taken next to build on your DevOps skills and finally do a quick tour of some
    security projects that may be of interest.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本书之前，我们将通过回顾我们在开发方面所学到的内容来做一个总结。之后，我们将讨论可以采取哪些步骤来提升你的DevOps技能，最后，我们将快速浏览一些可能感兴趣的安全项目。
- en: You may wish to have your project from [*Chapter 9*](B11641_09_Final_NM_ePub.xhtml#_idTextAnchor191),
    *Cloud-Native Continuous Deployment Using Spinnaker*, ready in order to augment
    it with some of the recommended projects in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望准备好[*第9章*](B11641_09_Final_NM_ePub.xhtml#_idTextAnchor191)中的项目，*使用Spinnaker进行云原生持续部署*，以便将本章推荐的一些项目与之结合。
- en: 'Remember you can revisit the source code for setting up this project here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以在这里回顾设置该项目的源代码：
- en: '[https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter9](https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter9)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter9](https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter9)'
- en: With that said, let's look at what we have learned about developing in a Docker-based
    environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来回顾一下在基于Docker的环境中开发时所学到的内容。
- en: What we learned about development
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们学到的开发内容
- en: In the first section of this book, *An Introduction to Docker – Containers and
    Local Development*, we got into the basics of Docker and containers, and how they
    are used for development purposes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，《Docker 入门——容器与本地开发》中，我们介绍了 Docker 和容器的基础知识，以及它们如何用于开发。
- en: First, we introduced the topic of containerization and related technologies
    such as virtualization. Following this, we sized up the differences between Docker
    containers and virtual machines to see how they compared for development purposes.
    In [*Chapter 3*](B11641_03_Final_NM_ePub.xhtml#_idTextAnchor044), *Sharing Containers
    using Docker Hub*, we got our first taste of using Docker Hub to store and retrieve
    images from a third-party location. Finally, having looked at pre-built containers
    and container images, we explored the scenario where multiple containers must
    work together to form a more complex system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们介绍了容器化和相关技术，如虚拟化。接下来，我们评估了 Docker 容器和虚拟机之间的差异，以了解它们在开发中的对比。在[*第3章*](B11641_03_Final_NM_ePub.xhtml#_idTextAnchor044)《通过
    Docker Hub 分享容器》中，我们首次体验了如何使用 Docker Hub 从第三方位置存储和检索镜像。最后，在了解了预构建的容器和容器镜像之后，我们探索了多个容器必须协同工作以构建更复杂系统的场景。
- en: These four chapters in this section, taken together, provide the basics for
    local development and understanding the tooling required to make you a successful
    engineer in this area. To build upon this knowledge, understanding design patterns
    for container-based systems would be a logical next step for you to explore.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的这四章内容，共同提供了本地开发的基础知识，并帮助你理解在该领域成为成功工程师所需的工具。为了进一步拓展这部分知识，理解基于容器的系统的设计模式将是你接下来应当探索的合乎逻辑的步骤。
- en: Going deeper – design patterns
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探讨——设计模式
- en: The first section of this book provided a guide to hands-on development. Just
    because you are using containers does not mean that architectural patterns for
    software development have to be abandoned!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分提供了实践开发的指南。使用容器并不意味着软件开发的架构模式必须被放弃！
- en: So, you may be asking what a design pattern is if you are new to the subject.
    In short, patterns are reusable blueprints for solving common architectural problems.
    Much as engineers and architects in the construction industry reuse workable models
    for constructing buildings, we can use a similar approach for building software
    systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你是这个领域的新手，你可能会问什么是设计模式。简而言之，设计模式是解决常见架构问题的可重用蓝图。就像建筑行业的工程师和建筑师重复使用可行的建筑模型一样，我们也可以采用类似的方法来构建软件系统。
- en: The following container-oriented patterns provide a great jumping-off point
    for you to explore the subject further once you have finished this book. In fact,
    you may recognize some of them from earlier chapters, which is why we have included
    them here. Let's now take a brief tour of five of them and look at which services
    and projects in this book have implemented them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这些面向容器的模式为你在完成本书后进一步探索这一主题提供了一个良好的起点。事实上，你可能会从前面的章节中认识到其中一些模式，这也是我们在此包含它们的原因。现在，让我们简要浏览其中五个模式，并看看本书中哪些服务和项目实现了它们。
- en: A single container – keeping it simple
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一容器——保持简单
- en: When we first embarked on the projects in this book, we kept things simple and
    used a **single container** pattern. This is the simplest pattern you can adopt
    in a container-based environment and the ShipIt Clicker application uses it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始本书中的项目时，我们保持简单，使用了**单一容器**模式。这是你在基于容器的环境中可以采用的最简单模式，ShipIt Clicker 应用就采用了这一模式。
- en: The sidecar design pattern – useful for logging
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边车设计模式——用于日志记录
- en: We've looked at logging throughout this book and log-monitoring systems are
    common implementors of something known as a **sidecar** pattern. In its simplest
    form, we have a container such as the ShipIt Clicker one, and then a second container
    with a log monitoring tool. This could be Grafana, Datadog, or one of the other
    tools we experimented with. As you start to build out your own projects, this
    simple pattern makes a great starting point. Deploy your application on a container,
    and then use a second container to handle log processing. You will also remember
    from our exploration of Envoy that the sidecar pattern is used here to allow us
    to create a service mesh without having to directly edit our applications to handle
    complex networking problems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中都提到过日志记录，而日志监控系统通常会实现一种被称为**边车**模式的方式。在最简单的形式中，我们有一个像 ShipIt Clicker
    这样的容器，接着是一个带有日志监控工具的第二个容器。这个工具可能是 Grafana、Datadog，或者我们实验过的其他工具。当你开始构建自己的项目时，这种简单的模式是一个很好的起点。将你的应用部署到一个容器中，然后用第二个容器处理日志处理。你还记得我们在探讨
    Envoy 时提到的，边车模式在这里被用来创建服务网格，而不需要直接编辑应用来处理复杂的网络问题。
- en: Leader and elections – adding redundancy
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领导者与选举 – 增加冗余
- en: We've seen how highly available systems are desirable, and how tools such as
    Kubernetes can help us achieve this goal through orchestrating multiple containers
    across pods. A common design pattern used in conjunction with Kubernetes is the
    **leader and election** approach. Here, data can be split across multiple nodes
    to provide redundancy; for example, the data may be replicated across containers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了高可用系统的需求，以及像 Kubernetes 这样的工具如何通过在各个 Pod 之间协调多个容器来帮助我们实现这一目标。与 Kubernetes
    配合使用的一种常见设计模式是**领导者和选举**方法。在这种方法中，数据可以分布到多个节点上以提供冗余；例如，数据可能会在容器之间进行复制。
- en: If, for some reason, our container crashes, the other containers will elect
    a new leader and Kubernetes will spin up a new node to plug the gap.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，我们的容器崩溃，其他容器将选举一个新的领导者，Kubernetes 会启动一个新的节点来填补空缺。
- en: The ambassador design pattern – an approach to proxying
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使者设计模式 – 一种代理方法
- en: Proxying is an important part of many systems, especially in microservice architectures.
    As you have seen, in Docker-based environments, we can have multiple containers
    residing on the same virtual network. Each of these containers is assigned a name,
    which allows containers to communicate with one another.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是许多系统中的一个重要组成部分，尤其是在微服务架构中。正如你所看到的，在基于 Docker 的环境中，我们可以让多个容器驻留在同一虚拟网络上。每个容器都会分配一个名称，这使得容器之间可以相互通信。
- en: An example of where we can use the **ambassador** pattern is in communicating
    between a backend caching service, such as Redis, and a set of applications. In
    this instance, the applications communicate with a single Redis proxy node, believing
    it to be Redis itself. However, the proxy node then distributes the traffic across
    multiple other Redis nodes on the network.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以使用**使者**模式的例子是，在后端缓存服务（如 Redis）与一组应用程序之间进行通信。在这个例子中，应用程序与一个 Redis 代理节点进行通信，认为它就是
    Redis 本身。然而，这个代理节点随后会将流量分发到网络上的其他多个 Redis 节点。
- en: Redis
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Redis
- en: Redis ([redis.io](http://redis.io)), as you may remember from earlier chapters,
    is an in-memory, open source caching and message brokering system. It allows you
    to store a variety of data structures in memory such as lists, sets, and hashes,
    and can additionally be used as a primary database if you wish ([https://redislabs.com/blog/goodbye-cache-redis-as-a-primary-database/](https://redislabs.com/blog/goodbye-cache-redis-as-a-primary-database/)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Redis ([redis.io](http://redis.io))，正如你从早期的章节中可能记得的，它是一个基于内存的开源缓存和消息代理系统。它允许你在内存中存储多种数据结构，例如列表、集合和哈希，并且如果你愿意，还可以将其用作主要数据库（[https://redislabs.com/blog/goodbye-cache-redis-as-a-primary-database/](https://redislabs.com/blog/goodbye-cache-redis-as-a-primary-database/)）。
- en: The tool Envoy, which we examined in [*Chapter 11*](B11641_11_Final_NM_ePub.xhtml#_idTextAnchor261),
    *Scaling and Load Testing Docker Applications*, is very useful for deploying an
    ambassador-style approach. If you are interested in trying it out with Redis,
    then check out Dmitry Polyakovsky's article, *Envoy Proxy with Redis* ([http://dmitrypol.github.io/redis/2019/03/18/envoy-proxy.html](http://dmitrypol.github.io/redis/2019/03/18/envoy-proxy.html)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第11章*](B11641_11_Final_NM_ePub.xhtml#_idTextAnchor261)《Docker 应用的扩展和负载测试》中分析的工具
    Envoy，对于部署使者风格的方法非常有用。如果你有兴趣与 Redis 一起尝试，查看 Dmitry Polyakovsky 的文章《*Envoy Proxy
    与 Redis*》([http://dmitrypol.github.io/redis/2019/03/18/envoy-proxy.html](http://dmitrypol.github.io/redis/2019/03/18/envoy-proxy.html))。
- en: Redis can be obtained from Docker Hub as a container ([https://hub.docker.com/_/redis/](https://hub.docker.com/_/redis/)).
    Let's now look at our final design pattern before moving on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 可以从 Docker Hub 获取作为容器 ([https://hub.docker.com/_/redis/](https://hub.docker.com/_/redis/))。在继续之前，让我们看一下最后一个设计模式。
- en: The adapter design pattern – solution reuse
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器设计模式——解决方案重用
- en: Having a consistent way to communicate information between containers is important,
    and this is especially the case when aggregating metrics. For example, if different
    containers produce logs in different formats, we need to be able to ingest this
    data in a common format. This is where the **adapter** pattern comes in. We can
    use this pattern to develop a uniform interface and subsequently receive log files
    from multiple containers, standardize them, and then store the data in a centralized
    monitoring service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器之间有一致的方式来传递信息是非常重要的，尤其是在聚合指标时。例如，如果不同的容器生成不同格式的日志，我们需要能够以统一的格式获取这些数据。这时，**适配器**模式就派上用场了。我们可以使用这种模式开发统一接口，随后接收来自多个容器的日志文件，对其进行标准化处理，然后将数据存储在集中式监控服务中。
- en: We saw in [*Chapter 10*](B11641_10_Final_AM_ePub.xhtml#_idTextAnchor226), *Monitoring
    Docker Using Prometheus, Grafana, and Jaeger*, that Prometheus is a useful tool
    for container monitoring. However, Prometheus requires a uniform interface from
    which to pull metrics, that being the metrics API. Where an application does not
    expose endpoints that are compatible with Prometheus, we can deploy an interface
    using the adapter pattern that wraps the target service containers with a Prometheus-compatible
    set of endpoints. This then allows Prometheus to pull data from the containers
    we are interested in seamlessly via the intermediate interface container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第10章*](B11641_10_Final_AM_ePub.xhtml#_idTextAnchor226)《使用 Prometheus、Grafana
    和 Jaeger 监控 Docker》中看到，Prometheus 是一个有用的容器监控工具。然而，Prometheus 需要一个统一的接口来拉取指标，这个接口就是指标
    API。当一个应用程序没有暴露与 Prometheus 兼容的端点时，我们可以使用适配器模式部署一个接口，将目标服务容器包装在一组 Prometheus 兼容的端点中。这样，Prometheus
    就可以通过中间接口容器无缝地从我们感兴趣的容器中拉取数据。
- en: Reading more on design patterns
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读更多关于设计模式的内容
- en: Using container-based design patterns helps to ensure that the right model is
    being used for your system, only introducing as much complexity is as needed,
    while ensuring the system is resilient and easier to manage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于容器的设计模式有助于确保为你的系统使用正确的模型，仅在需要时引入适当的复杂性，同时确保系统具有弹性并且更容易管理。
- en: If you would like to learn more about container patterns in Kubernetes and Docker,
    be sure to check out the book, *Kubernetes Design Patterns and Extensions*, by
    Packt.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Kubernetes 和 Docker 中容器模式的内容，记得查看 Packt 出版的《Kubernetes 设计模式与扩展》一书。
- en: Next steps for taking your DevOps knowledge further
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是进一步提升你的 DevOps 知识的步骤
- en: The second section, *Running Containers in Production*, was geared toward DevOps
    practices such as **continuous integration** and **continuous deployment** (**CI/CD**),
    container orchestration with Kubernetes, and monitoring with tools such as Jaeger.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分，*在生产环境中运行容器*，针对的是 DevOps 实践，如**持续集成**和**持续部署**（**CI/CD**）、使用 Kubernetes
    进行容器编排以及使用 Jaeger 等工具进行监控。
- en: To start with, we looked at options around hosting containers in cloud-based
    systems and hybrid environments. Next up, we explored the simple option of serving
    up our application on a single host with Docker Compose. After this, experimenting
    with Jenkins provided us with our first introduction to CI/CD tools and how these
    can be used with Docker. With the concept of CD under our belt, it was then on
    to [*Chapter 8*](B11641_08_Final_AM_ePub.xhtml#_idTextAnchor157), *Deploying Docker
    Apps to Kubernetes*, which gave us our first taste of Kubernetes for container
    orchestration. Subsequently, the topic of special container-native cloud deployment
    options in the form of Spinnaker was then trialed, including understanding what
    deployment methodologies are useful for production environments. The penultimate
    chapter of section two of this book explored monitoring tools for performance,
    such as Jaeger, Prometheus, and Grafana. Finally, we closed this section with
    a discussion looking at Envoy service meshes, proxying, and scaling and load testing
    projects in a production environment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们考察了在云环境和混合环境中托管容器的选项。接下来，我们探索了一个简单的选项，即通过 Docker Compose 在单一主机上部署应用程序。之后，通过实验
    Jenkins，我们第一次接触了 CI/CD 工具，以及这些工具如何与 Docker 配合使用。在掌握了 CD 的概念后，我们进入了 [*第八章*](B11641_08_Final_AM_ePub.xhtml#_idTextAnchor157)，*将
    Docker 应用部署到 Kubernetes*，这让我们第一次体验了 Kubernetes 容器编排。随后，我们尝试了 Spinnaker 这种容器原生云部署选项，并理解了哪些部署方法对生产环境有用。本书第二部分的倒数第二章探讨了性能监控工具，如
    Jaeger、Prometheus 和 Grafana。最后，我们以讨论 Envoy 服务网格、代理和在生产环境中的扩展与负载测试项目结束了这一部分。
- en: The seven chapters in this section provided a wealth of projects that gave you
    an understanding of some of the core concepts companies face when hosting and
    serving container-based applications in a production environment. However, there
    are still plenty of interesting techniques and topics to learn in order to take
    your DevOps skills to the next level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的七章提供了丰富的项目，让你了解一些公司在生产环境中托管和服务基于容器的应用程序时所面临的核心概念。然而，仍然有许多有趣的技术和话题需要学习，以便将你的
    DevOps 技能提升到一个新的水平。
- en: Chaos engineering and building resilient production systems
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混沌工程与构建弹性生产系统
- en: With a complex production system in place, containers being orchestrated in
    the cloud, and CD happening, how do we ensure our systems are resilient against
    faults and unexpected crashes? This is where the concept of chaos engineering
    comes into play.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有复杂生产系统、容器在云中编排、并且 CD 运行的情况下，我们如何确保系统能够抵御故障和意外崩溃？这就是混沌工程概念发挥作用的地方。
- en: 'Chaos engineering is the practice of understanding that code and infrastructure
    are inherently complex and therefore we should approach the engineering and testing
    process with this in mind. There are five concepts to chaos engineering that can
    be summarized as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌工程是理解代码和基础设施本身复杂性的一种实践，因此我们在进行工程和测试时应考虑到这一点。混沌工程有五个概念，概括如下：
- en: '**Develop a hypothesis around steady state behavior**: Measure outputs from
    the system over a short period of time to gather a baseline. This baseline is
    known as the steady state and could include metrics such as the error rate, response
    and latency times, and traffic loads.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**围绕稳定状态行为发展假设**：在短时间内衡量系统的输出，以收集基线数据。这个基线被称为稳定状态，可能包括错误率、响应时间、延迟时间和流量负载等指标。'
- en: '**Test a variety of real-world events**: When testing for real-world events
    that could impact a production system, consider testing software failures, mangled
    inputs, containers crashing, and other events that could degrade performance.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试各种现实世界事件**：在测试可能影响生产系统的现实世界事件时，可以考虑测试软件故障、损坏的输入、容器崩溃以及其他可能导致性能下降的事件。'
- en: '**Experiment in production**: Testing in production may seem like anathema.
    However, each environment is different and, for authentic results, testing in
    production is a must.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在生产环境中实验**：在生产环境中进行测试可能看起来像是禁忌。然而，每个环境都是不同的，为了获得真实结果，生产环境中的测试是必须的。'
- en: '**Minimize the impact, aka blast radius**: Running tests in production, however,
    does not absolve us of the responsibility to ensure that any degradation of performance
    is temporary and easily recovered from. Always make sure your experiments are
    well contained.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化影响，亦即爆炸半径**：在生产环境中进行测试，然而，这并不意味着我们可以忽略确保任何性能下降是暂时性的，并且可以轻松恢复的责任。始终确保你的实验是有良好隔离的。'
- en: '**Run automated experiments in a continuous fashion**: Using an automated approach
    allows you to reduce the labor overhead and for tests and experiments to run at
    all hours of the day.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续运行自动化实验**：使用自动化的方法可以减少人工开销，并让测试和实验在一天中的任何时间进行。'
- en: One such tool developed by Netflix implementing this concept is Chaos Monkey.
    Chaos Monkey is a platform to which you deploy your infrastructure that will randomly
    terminate containers that run in a production environment. The goal is to test
    how a production system will respond/recover and to allow engineers to tune the
    system to be more resilient.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix开发的一个实现这一概念的工具是Chaos Monkey。Chaos Monkey是一个平台，你可以将你的基础设施部署到其中，它会随机终止在生产环境中运行的容器。其目标是测试生产系统如何响应/恢复，并允许工程师调优系统以增强其韧性。
- en: You've already seen how to set up Spinnaker, so as a next step, you can integrate
    Chaos Monkey into your existing pipeline. Chaos Monkey also works with AWS and
    Kubernetes. The source code can be found at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过如何设置Spinnaker，接下来，你可以将Chaos Monkey集成到现有的管道中。Chaos Monkey也可以与AWS和Kubernetes一起使用。源代码可以在[https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey)找到。
- en: If you are interested in installing Chaos Monkey and adding it to the existing
    CI/CD Spinnaker pipeline that you built in [*Chapter 9*](B11641_09_Final_NM_ePub.xhtml#_idTextAnchor191),
    *Cloud-Native Continuous Deployment Using Spinnaker*, you can follow the official
    installation guide at [https://netflix.github.io/chaosmonkey/How-to-deploy/](https://netflix.github.io/chaosmonkey/How-to-deploy/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣安装Chaos Monkey并将其添加到你在[*第9章*](B11641_09_Final_NM_ePub.xhtml#_idTextAnchor191)中构建的现有CI/CD
    Spinnaker管道中，*云原生连续部署使用Spinnaker*，你可以参考官方安装指南[https://netflix.github.io/chaosmonkey/How-to-deploy/](https://netflix.github.io/chaosmonkey/How-to-deploy/)。
- en: Once it's up and running, you can now test Chaos Monkey in your Spinnaker-based
    container environment to see how it copes with terminating services and what corresponding
    metrics are displayed in your monitoring tools.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它运行起来，你可以在基于Spinnaker的容器环境中测试Chaos Monkey，看看它如何处理终止服务，并观察你的监控工具中显示的相关指标。
- en: 'If you are interested in combining Chaos Monkey with security techniques, be
    sure to check out Packt''s video guide on how you can use Chaos Monkey to **fuzz**
    **test** applications you host:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣将Chaos Monkey与安全技术结合使用，务必查看Packt的视频指南，了解如何使用Chaos Monkey进行应用程序的**模糊**
    **测试**：
- en: '[https://subscription.packtpub.com/video/virtualization_and_cloud/9781788394901/94651/94677/chaos-monkey-and-fuzz-testing](https://subscription.packtpub.com/video/virtualization_and_cloud/9781788394901/94651/94677/chaos-monkey-and-fuzz-testing)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://subscription.packtpub.com/video/virtualization_and_cloud/9781788394901/94651/94677/chaos-monkey-and-fuzz-testing](https://subscription.packtpub.com/video/virtualization_and_cloud/9781788394901/94651/94677/chaos-monkey-and-fuzz-testing)'
- en: What is fuzz testing?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是模糊测试？
- en: Fuzz testing is the process of testing random, invalid, and incompatible randomized
    data inputs to an application to see how it responds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试是测试应用程序对随机、无效和不兼容的随机数据输入的反应过程。
- en: 'In addition to Chaos Monkey, the following tools also offer mechanisms for
    building and testing resilient systems:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Chaos Monkey，以下工具还提供了构建和测试弹性系统的机制：
- en: '**Gremlin**: A chaos engineering platform that can be used with Kubernetes,
    Mesos, ECS, and Docker Swam, available at [https://www.gremlin.com/](https://www.gremlin.com/).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gremlin**：一个可以与Kubernetes、Mesos、ECS和Docker Swarm一起使用的混沌工程平台，详情请见[https://www.gremlin.com/](https://www.gremlin.com/)。'
- en: '**Mangle**: VMware''s open source platform for orchestrating chaos engineering
    that supports Kubernetes and Docker, available at [https://vmware.github.io/mangle/](https://vmware.github.io/mangle/).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mangle**：VMware的开源混沌工程平台，支持Kubernetes和Docker，详情请见[https://vmware.github.io/mangle/](https://vmware.github.io/mangle/)。'
- en: '**Chaos Mesh**: A cloud-native chaos engineering platform geared toward Kubernetes
    environments. It can be deployed via Helm, and is available at [https://github.com/pingcap/chaos-mesh](https://github.com/pingcap/chaos-mesh).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chaos Mesh**：一个面向Kubernetes环境的云原生混沌工程平台。它可以通过Helm进行部署，详情请见[https://github.com/pingcap/chaos-mesh](https://github.com/pingcap/chaos-mesh)。'
- en: We've briefly covered chaos engineering as a concept you could explore further
    from a DevOps perspective. Let's now recap what we studied under the banner of
    security.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了混沌工程作为一种概念，你可以从DevOps的角度进一步探索。现在，让我们回顾一下我们在安全性方面学习的内容。
- en: A summary on security and where to go next
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于安全性的总结及下一步该怎么做
- en: The final section of this book, *Docker Security – Securing Your Containers*,
    was dedicated to the subject of security. First, we looked at how containers work
    with the underlying hardware from a security perspective. We studied container
    and hypervisor security models and quickly dipped our toes into security best
    practices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的最后一部分，*Docker 安全 – 保护你的容器*，专门讨论了安全主题。首先，我们从安全角度分析了容器如何与底层硬件协同工作。我们研究了容器和虚拟机监控程序的安全模型，并快速了解了安全最佳实践。
- en: Security fundamentals and best practices came next and provided us with guidance
    on the best approach to handling our Dockerfile and building minimal base images.
    After this, we looked at how secrets can be handled in Docker Swarm. This provided
    insight for readers who may need to maintain legacy systems or migrate from Swarm
    to Kubernetes. We also looked at how tags, metadata, and labels can be used from
    a security perspective.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随后我们探讨了安全基础和最佳实践，为我们提供了处理Dockerfile和构建最小基础镜像的最佳方法。在此之后，我们研究了如何在Docker Swarm中处理秘密信息。这为那些可能需要维护遗留系统或从Swarm迁移到Kubernetes的读者提供了见解。我们还探讨了从安全角度如何使用标签、元数据和标签。
- en: The penultimate chapter of this book, [*Chapter 15*](B11641_15_Final_NM_ePub.xhtml#_idTextAnchor329),
    *Scanning, Monitoring, and using Third-Party Tools*, gave us a whistle-stop tour
    of Google, Amazon, and Microsoft's container security features in the cloud. We
    also installed Anchore for security scanning, looked at some extra monitoring
    tools that may be useful, and briefly tried out Datadog for container monitoring,
    which, in turn, can be used in a security context.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本书倒数第二章，[*第15章*](B11641_15_Final_NM_ePub.xhtml#_idTextAnchor329)，*扫描、监控和使用第三方工具*，为我们提供了Google、Amazon和Microsoft在云中提供的容器安全功能的简要介绍。我们还安装了Anchore进行安全扫描，查看了一些可能有用的额外监控工具，并简要尝试了Datadog进行容器监控，而Datadog也可以在安全环境下使用。
- en: With these basics under your belt, the following are ideas for some next steps
    regarding container security projects that build upon this knowledge.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些基础知识后，以下是一些基于这些知识的容器安全项目的下一步思路。
- en: Metasploit – container-based penetration testing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metasploit – 基于容器的渗透测试
- en: Now that we've built secure containers, and hopefully a secure application too,
    you can explore penetration testing in a container-based environment, such as
    the one you deployed via Spinnaker. Penetration testing is the process of looking
    for security flaws in a system that can then be leveraged to gain access, exfiltrate
    data, disrupt performance, or turn the compromised system into a platform to launch
    other attacks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了安全容器，并且希望应用程序也足够安全，你可以在基于容器的环境中进行渗透测试，例如通过Spinnaker部署的环境。渗透测试是寻找系统中的安全漏洞的过程，这些漏洞可能被利用来获取访问权限、外泄数据、干扰性能，或者将受损系统转变为发起其他攻击的平台。
- en: A popular tool for performing penetration tests is the **Metasploit** framework
    ([https://www.metasploit.com/](https://www.metasploit.com/)). Metasploit is an
    open source framework for developing and deploying security exploit code against
    a remote target, such as a container running in your environment. Metasploit is
    available in a container format from Docker Hub, at [https://hub.docker.com/r/metasploitframework/metasploit-framework](https://hub.docker.com/r/metasploitframework/metasploit-framework).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个广泛使用的渗透测试工具是**Metasploit**框架（[https://www.metasploit.com/](https://www.metasploit.com/)）。Metasploit是一个开源框架，用于开发和部署针对远程目标（例如在你环境中运行的容器）的安全漏洞代码。Metasploit可以从Docker
    Hub以容器格式获取，网址是[https://hub.docker.com/r/metasploitframework/metasploit-framework](https://hub.docker.com/r/metasploitframework/metasploit-framework)。
- en: 'With this tool in place, you can test vulnerabilities found in containers with
    tools such as Anchore. Vulnerabilities may include, for example, old versions
    of software installed on a container that may be open to attack. To grab the latest
    copy, run the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此工具到位后，你可以使用如Anchore等工具测试容器中的漏洞。例如，漏洞可能包括容器中安装的旧版软件，这些软件可能容易受到攻击。要获取最新版本，请运行以下代码：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then run the container as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式运行容器：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once loaded, you will be dropped into the Metasploit shell, called `msfconsole`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 加载完成后，你将进入Metasploit shell，称为`msfconsole`：
- en: '![Figure 16.1 – Example of a Metasploit container running](img/B11641_16_001.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – Metasploit容器运行示例](img/B11641_16_001.jpg)'
- en: Figure 16.1 – Example of a Metasploit container running
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – Metasploit容器运行示例
- en: From here, you can begin to explore the commands available and consider projects
    you can run from inside the container. A free course on using Metasploit can be
    found on the Offensive Security website at [https://www.offensive-security.com/metasploit-unleashed/](https://www.offensive-security.com/metasploit-unleashed/).
    Once you are familiar with the basic commands, consider exploring some of the
    following features in Metasploit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以开始探索可用的命令，并考虑可以在容器内运行的项目。关于使用Metasploit的免费课程可以在Offensive Security网站找到：[https://www.offensive-security.com/metasploit-unleashed/](https://www.offensive-security.com/metasploit-unleashed/)。一旦你熟悉了基本命令，可以考虑探索Metasploit中的一些其他功能。
- en: Unprotected TCP socket exploit
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无保护的TCP套接字漏洞
- en: You will remember that we discussed how leaving the TCP socket for Docker exposed
    could be exploited by attackers. Metasploit provides an example of how this can
    be achieved. Try running Docker via `2375/tcp` on a second machine and load up
    the `docker_daemon_tcp` module ([https://www.rapid7.com/db/modules/exploit/linux/http/docker_daemon_tcp](https://www.rapid7.com/db/modules/exploit/linux/http/docker_daemon_tcp))
    in the Metasploit container we just set up. You can now target the compromised
    socket via this module and create a Docker container with the `/` path mounted
    with read and write permissions on the underlying target host that is running
    the container.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们讨论过的将Docker的TCP套接字暴露出去可能被攻击者利用的情况。Metasploit提供了一个如何实现这一点的示例。尝试在第二台机器上通过`2375/tcp`运行Docker，并在我们刚刚设置的Metasploit容器中加载`docker_daemon_tcp`模块([https://www.rapid7.com/db/modules/exploit/linux/http/docker_daemon_tcp](https://www.rapid7.com/db/modules/exploit/linux/http/docker_daemon_tcp))。现在你可以通过此模块针对被攻破的套接字，并在正在运行容器的目标主机上创建一个容器，并将`/`路径挂载为具有读写权限。
- en: Testing third-party vulnerable containers – Apache Struts
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试第三方易受攻击的容器 - Apache Struts
- en: The following is just one example of the many vulnerable containers available
    for downloading and experimenting with. This container, created by `piesecurity`,
    includes a vulnerable version of Apache Struts ([https://hub.docker.com/r/piesecurity/apache-struts2-cve-2017-5638/](https://hub.docker.com/r/piesecurity/apache-struts2-cve-2017-5638/)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下只是许多可供下载和实验的易受攻击容器中的一个示例。这个由`piesecurity`创建的容器，包含了Apache Struts的一个易受攻击版本([https://hub.docker.com/r/piesecurity/apache-struts2-cve-2017-5638/](https://hub.docker.com/r/piesecurity/apache-struts2-cve-2017-5638/))。
- en: Apache Struts is a popular framework built in Java for developing web applications.
    In 2017, a vulnerability was discovered in the framework that allowed an attacker
    to execute code remotely on the server running it. One of the most well-known
    victims of this vulnerability was Equifax, who suffered a catastrophic data breach.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Struts是一个流行的Java框架，用于开发Web应用程序。在2017年，发现了该框架中的一个漏洞，攻击者可以利用此漏洞在运行该框架的服务器上远程执行代码。此漏洞的著名受害者之一是Equifax，该公司遭遇了重大数据泄露事件。
- en: You can deploy and run this container loaded with Struts via Spinnaker and test
    out the exploit yourself. Once installed, use the Metasploit module `struts2_content_type_ognl`
    ([https://www.rapid7.com/db/modules/exploit/multi/http/struts2_content_type_ognl](https://www.rapid7.com/db/modules/exploit/multi/http/struts2_content_type_ognl)).
    This will allow you to launch an attack that creates a reverse shell on the compromised
    container and demonstrates how security flaws inside third-party frameworks can
    be exploited even when running in Kubernetes and Docker.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Spinnaker部署并运行加载了Struts的容器，自己测试漏洞。安装完成后，使用Metasploit模块`struts2_content_type_ognl`([https://www.rapid7.com/db/modules/exploit/multi/http/struts2_content_type_ognl](https://www.rapid7.com/db/modules/exploit/multi/http/struts2_content_type_ognl))。这将允许你发起攻击，在被攻破的容器上创建反向Shell，并演示即便在Kubernetes和Docker中运行，第三方框架内的安全漏洞也可能被利用。
- en: If you'd like to dig into this further, the book *Advanced Infrastructure Penetration
    Testing* from Packt provides guidance for using the Metasploit Framework and testing
    container-based environment security.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步了解，可以参考Packt出版的《*高级基础设施渗透测试*》一书，书中提供了使用Metasploit框架并测试基于容器的环境安全的指导。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We hope you have enjoyed reading this book. It aimed to provide a comprehensive
    guide to Docker development, both locally and in the cloud. Throughout the 16
    chapters, our goal was to demonstrate not only how to develop applications in
    containers, but how they can be built, deployed, scanned, and monitored.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢阅读本书。本书旨在提供一份全面的Docker开发指南，包括本地开发和云端开发。在这16章中，我们的目标不仅是展示如何在容器中开发应用，还包括如何构建、部署、扫描和监控它们。
- en: Whether you plan to build a new project from scratch, are maintaining legacy
    systems on Docker Swarm, or migrating to a Kubernetes-based environment, *Docker
    For Developers* is the type of book you can dip back into again to refresh your
    knowledge or seek guidance as required.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是打算从零开始构建一个新项目、在 Docker Swarm 上维护遗留系统，还是迁移到基于 Kubernetes 的环境，*Docker For
    Developers* 这本书都是你可以随时翻阅来刷新知识或根据需要寻求指导的书籍。
- en: We hope you have enjoyed your journey into the world of containers as much as
    we have enjoyed sharing this knowledge with you. Good luck with your future projects!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在容器世界的旅程中获得的收获，与我们分享这些知识时的喜悦一样多。祝你未来的项目好运！
