- en: '*Chapter 16*: Conclusion – End of the Road, but not the Journey'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now reached the final chapter of this book. Over the previous 15 chapters,
    a variety of topics have been covered. As you may have noticed, the book was grouped
    into three areas—development, DevOps with monitoring, and finally security. So,
    let's take the time to recap what we studied in each area and where we can go
    next.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will run through an overview of what we learned in the book. Next,
    a summary of the skills we acquired on the development front will be presented.
    After this, we will explore where we can go next to learn more about DevOps with
    containers and expand our newly learned skills. Our penultimate review will consider
    what we learned about security and how we can stay on top of it. Then, we will
    finish up with a general conclusion on everything we've studied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to review these items, we''ve broken them down into the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up – let's get started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we learned about development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next steps for taking your DevOps knowledge further
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary on security and where to go next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grab your containerized environment and get ready for our last foray together
    into the world of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have access to a Linux machine running Docker.
    We recommend that you use the setup you have been using so far in this book. This
    is so you can follow up with some of the tools and techniques recommended in this
    chapter if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/2CpGTfZ](https://bit.ly/2CpGTfZ)'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up – let's get started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this book, we have explored the world of containerization.
    As the technology becomes ever more ubiquitous in companies and projects across
    the world, having a solid handle on the basics and the toolsets supporting containers
    becomes ever more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Before we close the book, we are going to wrap up by reviewing what we have
    learned on the development front. After this, we will discuss what steps can be
    taken next to build on your DevOps skills and finally do a quick tour of some
    security projects that may be of interest.
  prefs: []
  type: TYPE_NORMAL
- en: You may wish to have your project from [*Chapter 9*](B11641_09_Final_NM_ePub.xhtml#_idTextAnchor191),
    *Cloud-Native Continuous Deployment Using Spinnaker*, ready in order to augment
    it with some of the recommended projects in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember you can revisit the source code for setting up this project here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter9](https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter9)'
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let's look at what we have learned about developing in a Docker-based
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: What we learned about development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first section of this book, *An Introduction to Docker – Containers and
    Local Development*, we got into the basics of Docker and containers, and how they
    are used for development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: First, we introduced the topic of containerization and related technologies
    such as virtualization. Following this, we sized up the differences between Docker
    containers and virtual machines to see how they compared for development purposes.
    In [*Chapter 3*](B11641_03_Final_NM_ePub.xhtml#_idTextAnchor044), *Sharing Containers
    using Docker Hub*, we got our first taste of using Docker Hub to store and retrieve
    images from a third-party location. Finally, having looked at pre-built containers
    and container images, we explored the scenario where multiple containers must
    work together to form a more complex system.
  prefs: []
  type: TYPE_NORMAL
- en: These four chapters in this section, taken together, provide the basics for
    local development and understanding the tooling required to make you a successful
    engineer in this area. To build upon this knowledge, understanding design patterns
    for container-based systems would be a logical next step for you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Going deeper – design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first section of this book provided a guide to hands-on development. Just
    because you are using containers does not mean that architectural patterns for
    software development have to be abandoned!
  prefs: []
  type: TYPE_NORMAL
- en: So, you may be asking what a design pattern is if you are new to the subject.
    In short, patterns are reusable blueprints for solving common architectural problems.
    Much as engineers and architects in the construction industry reuse workable models
    for constructing buildings, we can use a similar approach for building software
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The following container-oriented patterns provide a great jumping-off point
    for you to explore the subject further once you have finished this book. In fact,
    you may recognize some of them from earlier chapters, which is why we have included
    them here. Let's now take a brief tour of five of them and look at which services
    and projects in this book have implemented them.
  prefs: []
  type: TYPE_NORMAL
- en: A single container – keeping it simple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we first embarked on the projects in this book, we kept things simple and
    used a **single container** pattern. This is the simplest pattern you can adopt
    in a container-based environment and the ShipIt Clicker application uses it.
  prefs: []
  type: TYPE_NORMAL
- en: The sidecar design pattern – useful for logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've looked at logging throughout this book and log-monitoring systems are
    common implementors of something known as a **sidecar** pattern. In its simplest
    form, we have a container such as the ShipIt Clicker one, and then a second container
    with a log monitoring tool. This could be Grafana, Datadog, or one of the other
    tools we experimented with. As you start to build out your own projects, this
    simple pattern makes a great starting point. Deploy your application on a container,
    and then use a second container to handle log processing. You will also remember
    from our exploration of Envoy that the sidecar pattern is used here to allow us
    to create a service mesh without having to directly edit our applications to handle
    complex networking problems.
  prefs: []
  type: TYPE_NORMAL
- en: Leader and elections – adding redundancy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've seen how highly available systems are desirable, and how tools such as
    Kubernetes can help us achieve this goal through orchestrating multiple containers
    across pods. A common design pattern used in conjunction with Kubernetes is the
    **leader and election** approach. Here, data can be split across multiple nodes
    to provide redundancy; for example, the data may be replicated across containers.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, our container crashes, the other containers will elect
    a new leader and Kubernetes will spin up a new node to plug the gap.
  prefs: []
  type: TYPE_NORMAL
- en: The ambassador design pattern – an approach to proxying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proxying is an important part of many systems, especially in microservice architectures.
    As you have seen, in Docker-based environments, we can have multiple containers
    residing on the same virtual network. Each of these containers is assigned a name,
    which allows containers to communicate with one another.
  prefs: []
  type: TYPE_NORMAL
- en: An example of where we can use the **ambassador** pattern is in communicating
    between a backend caching service, such as Redis, and a set of applications. In
    this instance, the applications communicate with a single Redis proxy node, believing
    it to be Redis itself. However, the proxy node then distributes the traffic across
    multiple other Redis nodes on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  prefs: []
  type: TYPE_NORMAL
- en: Redis ([redis.io](http://redis.io)), as you may remember from earlier chapters,
    is an in-memory, open source caching and message brokering system. It allows you
    to store a variety of data structures in memory such as lists, sets, and hashes,
    and can additionally be used as a primary database if you wish ([https://redislabs.com/blog/goodbye-cache-redis-as-a-primary-database/](https://redislabs.com/blog/goodbye-cache-redis-as-a-primary-database/)).
  prefs: []
  type: TYPE_NORMAL
- en: The tool Envoy, which we examined in [*Chapter 11*](B11641_11_Final_NM_ePub.xhtml#_idTextAnchor261),
    *Scaling and Load Testing Docker Applications*, is very useful for deploying an
    ambassador-style approach. If you are interested in trying it out with Redis,
    then check out Dmitry Polyakovsky's article, *Envoy Proxy with Redis* ([http://dmitrypol.github.io/redis/2019/03/18/envoy-proxy.html](http://dmitrypol.github.io/redis/2019/03/18/envoy-proxy.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Redis can be obtained from Docker Hub as a container ([https://hub.docker.com/_/redis/](https://hub.docker.com/_/redis/)).
    Let's now look at our final design pattern before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter design pattern – solution reuse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a consistent way to communicate information between containers is important,
    and this is especially the case when aggregating metrics. For example, if different
    containers produce logs in different formats, we need to be able to ingest this
    data in a common format. This is where the **adapter** pattern comes in. We can
    use this pattern to develop a uniform interface and subsequently receive log files
    from multiple containers, standardize them, and then store the data in a centralized
    monitoring service.
  prefs: []
  type: TYPE_NORMAL
- en: We saw in [*Chapter 10*](B11641_10_Final_AM_ePub.xhtml#_idTextAnchor226), *Monitoring
    Docker Using Prometheus, Grafana, and Jaeger*, that Prometheus is a useful tool
    for container monitoring. However, Prometheus requires a uniform interface from
    which to pull metrics, that being the metrics API. Where an application does not
    expose endpoints that are compatible with Prometheus, we can deploy an interface
    using the adapter pattern that wraps the target service containers with a Prometheus-compatible
    set of endpoints. This then allows Prometheus to pull data from the containers
    we are interested in seamlessly via the intermediate interface container.
  prefs: []
  type: TYPE_NORMAL
- en: Reading more on design patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using container-based design patterns helps to ensure that the right model is
    being used for your system, only introducing as much complexity is as needed,
    while ensuring the system is resilient and easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn more about container patterns in Kubernetes and Docker,
    be sure to check out the book, *Kubernetes Design Patterns and Extensions*, by
    Packt.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps for taking your DevOps knowledge further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second section, *Running Containers in Production*, was geared toward DevOps
    practices such as **continuous integration** and **continuous deployment** (**CI/CD**),
    container orchestration with Kubernetes, and monitoring with tools such as Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we looked at options around hosting containers in cloud-based
    systems and hybrid environments. Next up, we explored the simple option of serving
    up our application on a single host with Docker Compose. After this, experimenting
    with Jenkins provided us with our first introduction to CI/CD tools and how these
    can be used with Docker. With the concept of CD under our belt, it was then on
    to [*Chapter 8*](B11641_08_Final_AM_ePub.xhtml#_idTextAnchor157), *Deploying Docker
    Apps to Kubernetes*, which gave us our first taste of Kubernetes for container
    orchestration. Subsequently, the topic of special container-native cloud deployment
    options in the form of Spinnaker was then trialed, including understanding what
    deployment methodologies are useful for production environments. The penultimate
    chapter of section two of this book explored monitoring tools for performance,
    such as Jaeger, Prometheus, and Grafana. Finally, we closed this section with
    a discussion looking at Envoy service meshes, proxying, and scaling and load testing
    projects in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The seven chapters in this section provided a wealth of projects that gave you
    an understanding of some of the core concepts companies face when hosting and
    serving container-based applications in a production environment. However, there
    are still plenty of interesting techniques and topics to learn in order to take
    your DevOps skills to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Chaos engineering and building resilient production systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a complex production system in place, containers being orchestrated in
    the cloud, and CD happening, how do we ensure our systems are resilient against
    faults and unexpected crashes? This is where the concept of chaos engineering
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chaos engineering is the practice of understanding that code and infrastructure
    are inherently complex and therefore we should approach the engineering and testing
    process with this in mind. There are five concepts to chaos engineering that can
    be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Develop a hypothesis around steady state behavior**: Measure outputs from
    the system over a short period of time to gather a baseline. This baseline is
    known as the steady state and could include metrics such as the error rate, response
    and latency times, and traffic loads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test a variety of real-world events**: When testing for real-world events
    that could impact a production system, consider testing software failures, mangled
    inputs, containers crashing, and other events that could degrade performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experiment in production**: Testing in production may seem like anathema.
    However, each environment is different and, for authentic results, testing in
    production is a must.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize the impact, aka blast radius**: Running tests in production, however,
    does not absolve us of the responsibility to ensure that any degradation of performance
    is temporary and easily recovered from. Always make sure your experiments are
    well contained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run automated experiments in a continuous fashion**: Using an automated approach
    allows you to reduce the labor overhead and for tests and experiments to run at
    all hours of the day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One such tool developed by Netflix implementing this concept is Chaos Monkey.
    Chaos Monkey is a platform to which you deploy your infrastructure that will randomly
    terminate containers that run in a production environment. The goal is to test
    how a production system will respond/recover and to allow engineers to tune the
    system to be more resilient.
  prefs: []
  type: TYPE_NORMAL
- en: You've already seen how to set up Spinnaker, so as a next step, you can integrate
    Chaos Monkey into your existing pipeline. Chaos Monkey also works with AWS and
    Kubernetes. The source code can be found at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey).
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in installing Chaos Monkey and adding it to the existing
    CI/CD Spinnaker pipeline that you built in [*Chapter 9*](B11641_09_Final_NM_ePub.xhtml#_idTextAnchor191),
    *Cloud-Native Continuous Deployment Using Spinnaker*, you can follow the official
    installation guide at [https://netflix.github.io/chaosmonkey/How-to-deploy/](https://netflix.github.io/chaosmonkey/How-to-deploy/).
  prefs: []
  type: TYPE_NORMAL
- en: Once it's up and running, you can now test Chaos Monkey in your Spinnaker-based
    container environment to see how it copes with terminating services and what corresponding
    metrics are displayed in your monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in combining Chaos Monkey with security techniques, be
    sure to check out Packt''s video guide on how you can use Chaos Monkey to **fuzz**
    **test** applications you host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://subscription.packtpub.com/video/virtualization_and_cloud/9781788394901/94651/94677/chaos-monkey-and-fuzz-testing](https://subscription.packtpub.com/video/virtualization_and_cloud/9781788394901/94651/94677/chaos-monkey-and-fuzz-testing)'
  prefs: []
  type: TYPE_NORMAL
- en: What is fuzz testing?
  prefs: []
  type: TYPE_NORMAL
- en: Fuzz testing is the process of testing random, invalid, and incompatible randomized
    data inputs to an application to see how it responds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to Chaos Monkey, the following tools also offer mechanisms for
    building and testing resilient systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gremlin**: A chaos engineering platform that can be used with Kubernetes,
    Mesos, ECS, and Docker Swam, available at [https://www.gremlin.com/](https://www.gremlin.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mangle**: VMware''s open source platform for orchestrating chaos engineering
    that supports Kubernetes and Docker, available at [https://vmware.github.io/mangle/](https://vmware.github.io/mangle/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaos Mesh**: A cloud-native chaos engineering platform geared toward Kubernetes
    environments. It can be deployed via Helm, and is available at [https://github.com/pingcap/chaos-mesh](https://github.com/pingcap/chaos-mesh).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've briefly covered chaos engineering as a concept you could explore further
    from a DevOps perspective. Let's now recap what we studied under the banner of
    security.
  prefs: []
  type: TYPE_NORMAL
- en: A summary on security and where to go next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final section of this book, *Docker Security – Securing Your Containers*,
    was dedicated to the subject of security. First, we looked at how containers work
    with the underlying hardware from a security perspective. We studied container
    and hypervisor security models and quickly dipped our toes into security best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Security fundamentals and best practices came next and provided us with guidance
    on the best approach to handling our Dockerfile and building minimal base images.
    After this, we looked at how secrets can be handled in Docker Swarm. This provided
    insight for readers who may need to maintain legacy systems or migrate from Swarm
    to Kubernetes. We also looked at how tags, metadata, and labels can be used from
    a security perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The penultimate chapter of this book, [*Chapter 15*](B11641_15_Final_NM_ePub.xhtml#_idTextAnchor329),
    *Scanning, Monitoring, and using Third-Party Tools*, gave us a whistle-stop tour
    of Google, Amazon, and Microsoft's container security features in the cloud. We
    also installed Anchore for security scanning, looked at some extra monitoring
    tools that may be useful, and briefly tried out Datadog for container monitoring,
    which, in turn, can be used in a security context.
  prefs: []
  type: TYPE_NORMAL
- en: With these basics under your belt, the following are ideas for some next steps
    regarding container security projects that build upon this knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit – container-based penetration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've built secure containers, and hopefully a secure application too,
    you can explore penetration testing in a container-based environment, such as
    the one you deployed via Spinnaker. Penetration testing is the process of looking
    for security flaws in a system that can then be leveraged to gain access, exfiltrate
    data, disrupt performance, or turn the compromised system into a platform to launch
    other attacks.
  prefs: []
  type: TYPE_NORMAL
- en: A popular tool for performing penetration tests is the **Metasploit** framework
    ([https://www.metasploit.com/](https://www.metasploit.com/)). Metasploit is an
    open source framework for developing and deploying security exploit code against
    a remote target, such as a container running in your environment. Metasploit is
    available in a container format from Docker Hub, at [https://hub.docker.com/r/metasploitframework/metasploit-framework](https://hub.docker.com/r/metasploitframework/metasploit-framework).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this tool in place, you can test vulnerabilities found in containers with
    tools such as Anchore. Vulnerabilities may include, for example, old versions
    of software installed on a container that may be open to attack. To grab the latest
    copy, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once loaded, you will be dropped into the Metasploit shell, called `msfconsole`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Example of a Metasploit container running](img/B11641_16_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Example of a Metasploit container running
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can begin to explore the commands available and consider projects
    you can run from inside the container. A free course on using Metasploit can be
    found on the Offensive Security website at [https://www.offensive-security.com/metasploit-unleashed/](https://www.offensive-security.com/metasploit-unleashed/).
    Once you are familiar with the basic commands, consider exploring some of the
    following features in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Unprotected TCP socket exploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will remember that we discussed how leaving the TCP socket for Docker exposed
    could be exploited by attackers. Metasploit provides an example of how this can
    be achieved. Try running Docker via `2375/tcp` on a second machine and load up
    the `docker_daemon_tcp` module ([https://www.rapid7.com/db/modules/exploit/linux/http/docker_daemon_tcp](https://www.rapid7.com/db/modules/exploit/linux/http/docker_daemon_tcp))
    in the Metasploit container we just set up. You can now target the compromised
    socket via this module and create a Docker container with the `/` path mounted
    with read and write permissions on the underlying target host that is running
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: Testing third-party vulnerable containers – Apache Struts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is just one example of the many vulnerable containers available
    for downloading and experimenting with. This container, created by `piesecurity`,
    includes a vulnerable version of Apache Struts ([https://hub.docker.com/r/piesecurity/apache-struts2-cve-2017-5638/](https://hub.docker.com/r/piesecurity/apache-struts2-cve-2017-5638/)).
  prefs: []
  type: TYPE_NORMAL
- en: Apache Struts is a popular framework built in Java for developing web applications.
    In 2017, a vulnerability was discovered in the framework that allowed an attacker
    to execute code remotely on the server running it. One of the most well-known
    victims of this vulnerability was Equifax, who suffered a catastrophic data breach.
  prefs: []
  type: TYPE_NORMAL
- en: You can deploy and run this container loaded with Struts via Spinnaker and test
    out the exploit yourself. Once installed, use the Metasploit module `struts2_content_type_ognl`
    ([https://www.rapid7.com/db/modules/exploit/multi/http/struts2_content_type_ognl](https://www.rapid7.com/db/modules/exploit/multi/http/struts2_content_type_ognl)).
    This will allow you to launch an attack that creates a reverse shell on the compromised
    container and demonstrates how security flaws inside third-party frameworks can
    be exploited even when running in Kubernetes and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to dig into this further, the book *Advanced Infrastructure Penetration
    Testing* from Packt provides guidance for using the Metasploit Framework and testing
    container-based environment security.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We hope you have enjoyed reading this book. It aimed to provide a comprehensive
    guide to Docker development, both locally and in the cloud. Throughout the 16
    chapters, our goal was to demonstrate not only how to develop applications in
    containers, but how they can be built, deployed, scanned, and monitored.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you plan to build a new project from scratch, are maintaining legacy
    systems on Docker Swarm, or migrating to a Kubernetes-based environment, *Docker
    For Developers* is the type of book you can dip back into again to refresh your
    knowledge or seek guidance as required.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you have enjoyed your journey into the world of containers as much as
    we have enjoyed sharing this knowledge with you. Good luck with your future projects!
  prefs: []
  type: TYPE_NORMAL
