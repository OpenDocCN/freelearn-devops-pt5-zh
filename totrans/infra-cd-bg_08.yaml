- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Common Troubleshooting Tips and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we have primarily discussed code samples that have been
    pre-written and shared through the GitHub repository accompanying this book. As
    you progress in your journey with **Infrastructure as Code** (**IaC**), it’s essential
    to understand that writing and planning your IaC projects will involve a learning
    curve and some inevitable debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the second-to-last one, we’ll look at some essential aspects
    to help you better plan, write, and troubleshoot your IaC projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover three key areas to ensure you’re well equipped to handle any challenges
    that may arise during the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as Code – best practices and troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform – best practices and troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible – best practices and troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ll notice some common themes and advice that apply
    to both Terraform and Ansible, as they are both IaC tools. However, each tool
    uniquely interacts with your resources, resulting in some differences in the approaches
    and techniques you’ll use when troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be well prepared to tackle the challenges
    of implementing IaC projects using these powerful tools.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as Code – best practices and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start by discussing some general IaC best practices that can apply to
    various tools and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: General IaC best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some common threads that we have already touched upon here, but it
    is essential to bring them up again as they are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version control**: Make sure you use a version control system such as Git
    or one of the other available systems such as Mercurial, Subversion, or Azure
    DevOps Server, which was previously known as **Team Foundation Server** (**TFS**),
    to name a few of the more common ones, to store and manage your infrastructure
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The odds of you, either personally or within the business, already using version
    control for your other projects is extremely high if you are taking steps to both
    define and deploy your infrastructure in and as code. This means that you have
    experience with version control and access to the tools, processes, and procedures
    to maintain code using version control.
  prefs: []
  type: TYPE_NORMAL
- en: Employing version control enables collaboration, change tracking, and easy rollback
    to previous versions if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation**: You can approach documentation in several ways, and it doesn’t
    matter how you do it, just as long as you do it!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My personal approach to documenting my IaC deployments is to try and keep as
    much of the documentation within the code as possible using both in-comments and
    making sure that sections, tasks, functions, or variables are as clearly named
    and descriptive as possible while keeping within any of the constraints of the
    tool I am using.
  prefs: []
  type: TYPE_NORMAL
- en: Also, depending on the complexity, I will summarise what the code does, attach
    it as a `README` file, and commit it to version control.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I do this is that while it is easy to keep track of what is going
    on while you are working on the project, when it comes to someone else picking
    it up – or even you revisiting it yourself after a few months of being away from
    the project – it can sometimes take them a little time to get their bearings.
  prefs: []
  type: TYPE_NORMAL
- en: Your approach may differ, which leads nicely into the next piece of best practice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code reviews**: I recommend conducting regular code reviews to maintain code
    quality, ensure compliance with best practices, and share knowledge among team
    members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may already have processes to enforce this across other types of development
    within the business, such as your applications. It is just as crucial that the
    same principles govern your IaC projects as you may be asked to demonstrate that
    your code adheres to any guidelines that your application has to follow for compliance
    reasons. After all, your IaC project will be deploying and maintaining the resources
    your application will run upon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity**: When you write your infrastructure code, do it in smaller,
    reusable modules. This promotes reusability, maintainability, and better organization
    of your code base. We covered this in [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350),
    *Building upon* *the Foundations*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration and Continuous Deployment** (**CI/CD**): We discussed
    this at length in the previous chapter, [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431),
    *Leveraging CI/CD in the Cloud*. Even for development purposes, if you have your
    code in source control, you should ideally be leveraging CI/CD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: In the perfect world, you should implement automated testing for
    your infrastructure code to validate its correctness, identify issues early, and
    increase its overall reliability. If you are using version control and CI/CD,
    you already have most of the tools to make this process easy. For example, in
    [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging CI/CD in the Cloud*,
    we had some break-points when running Terraform plan to catch potential issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and logging**: Implement monitoring and logging solutions to track
    executions and detect issues allowing you to troubleshoot problems promptly. In
    [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging CI/CD in the Cloud*,
    our CI/CD pipelines kept a log of everything that happened during the execution.
    In Terraform’s case, we generated and attached a snapshot of the plan file – this
    level of information can be very valuable when trying to figure out what would
    happen if something unexpected happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The principle of least privilege**: Limit access to resources and creation
    by granting the minimum necessary permissions for your infrastructure code executions
    to interact with the components they are working with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your target infrastructure, this may only sometimes be possible,
    but most cloud providers allow you to be very granular with the permissions. Also,
    depending on what you are deploying, this could take a little trial and error
    – but in the long run, it is worth investing the time in looking at it from a
    security point of view.
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable infrastructure**: Rather than updating existing infrastructure,
    create new infrastructure to replace the old one and reroute requests to it. This
    reduces the risk of errors due to configuration drift and forces deployments to
    be more predictable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach depends on your application, and it may only sometimes be practical
    for you to fully implement this approach. Still, the more your infrastructure
    components you can make immutable, the easier it will be for you to scale out
    and back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure by Design (SBD)**: As you write your infrastructure code, incorporate
    security best practices and tools from the beginning, such as encryption, identity
    management, and network segmentation if possible, and as already mentioned, focus
    on making these parts of your code as modular as possible so that you can easily
    reuse them across your projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have established some general best practices, let us move on and
    discuss some general troubleshooting tips.
  prefs: []
  type: TYPE_NORMAL
- en: General IaC troubleshooting tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some general troubleshooting tips, tricks, and approaches.
    As we are talking about general IaC tips, many of them are more preventive than
    tasks you would do to debug an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid hardcoding sensitive information**: Use secret management tools such
    as Azure Key Vault, HashiCorp Vault, or AWS Secrets Manager to securely store
    and retrieve sensitive information at runtime or use your infrastructure code
    to configure your resources to use the secret management tools directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it goes without saying that you shouldn’t hardcode sensitive information
    such as passwords, private information, or secrets directly within your code (Ansible
    could be an exception, but more on that in the *Ansible – best practices and troubleshooting*
    section), there are advantages to using secret management tools – the biggest
    one is for things such as certificate management.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine it’s a day or two before your SSL certificate expires, and you are rushing
    to get all resources that reference it updated. Using your target platform’s secret
    store may mean that you only have to update the certificate; then all resources
    that use the certificate are automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep dependencies up-to-date**: Throughout [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268),
    *Deploying to Amazon Web Services*, you will have noticed that our infrastructure
    code utilized a lot of different tasks and modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly updating your dependencies will help you avoid security vulnerabilities
    and compatibility issues. As your target cloud APIs are updated, you may find
    that your code has issues or no longer works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t overcomplicate your infrastructure code**: Keep your infrastructure
    code as simple as possible and avoid unnecessary complexity that may be difficult
    to maintain and troubleshoot should there be issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may look “cool” to build lots of logic or loops into your IaC. Still, it
    only takes a slight change as part of a tool or dependency update for it to come
    tumbling down – the more effort and time needed to code something, the more effort
    you are likely to put into debugging and refactoring it if and when there are
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Trust me, from experience, your future self will thank you for this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintain a clean, well-organized code base**: Consistently use naming conventions,
    follow a directory structure, and remove obsolete code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone within your team needs to be able to pick up your code and know what
    is going on without having seen it; you will not always be the only one who looks
    into any problems with your code.
  prefs: []
  type: TYPE_NORMAL
- en: You want to avoid creating more work for whoever picks it up, as they will likely
    already be under pressure because someone has reported a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t ignore error or warning messages**: Address any messages, especially
    non-breaking warning messages in your infrastructure code, promptly to prevent
    future issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most tools will stop execution when there are errors. However, most will also
    print warnings – these could be just be small things such as letting you know
    that functionality you are using will be deprecated or changed in future releases,
    and warnings will not stop execution. Still, they need to be addressed just like
    any errors you receive; it isn’t every day you get the chance to avoid future
    errors, so take it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, and this goes without saying, **communicate with your team**. Regularly
    communicate with your team about infrastructure changes, potential issues, and
    best practices to ensure everyone is on the same page when it comes to your IaC.
    You do not want to be a single point of failure, nor do you want to set your team
    up for failure should there be any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have worked through the general best practices and troubleshooting
    tips, let us look at some of the things you should consider when using the two
    tools we have discussed in the book, starting with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform – best practices and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover some of the recommendations we have already touched upon in the
    *General IaC best practices* section. Still, as mentioned at the start of the
    chapter, we will go into more detail about how they apply to just Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform – best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some best practices for approaching your Terraform deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a modular approach**: Break down infrastructure into reusable modules,
    simplifying code maintenance and enabling reusability across different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we discussed in [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350), *Building
    upon the Foundations*, Terraform modules can be hosted in the Terraform Registry
    or, which I have not mentioned, privately in your own Git repository. The following
    example code downloads the module from GitHub using **Secure Shell** (**SSH**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assuming you are executing your Terraform code from somewhere that has access
    to the repository, it will download and use it.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to build a library of reusable modules for use across all of
    your projects, and it also allows you to share modules with the rest of your teams.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep a consistent naming convention**: Using a consistent naming convention
    for resources and modules improves readability and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the size of the team working on your infrastructure code, you should
    establish a style guide and guidelines for developing and maintaining your Terraform
    infrastructure code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manage state files securely**: We have already discussed storing your state
    files remotely in a backend such as an Azure storage account or AWS **Simple Storage
    Service** (**S3**) in [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging
    CI/CD in* *the Cloud*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the supported backend services allow you to enable versioning and force
    encryption to ensure data integrity and security – make sure that this is enabled.
    Most services do it by default, but it is best to double-check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, there is another service that should have been mentioned: Terraform Cloud.
    HashiCorp (the makers of Terraform), has a cloud service that can store your state
    files securely and also act as a remote execution environment for your Terraform
    run. There are both free and paid options, and if you can use them, I recommend
    taking a look.'
  prefs: []
  type: TYPE_NORMAL
- en: '`terraform plan` command to visualize the potential impact of the code run.
    Use code reviews and automated testing to validate changes and minimize the risk
    of errors or something unexpected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use provider and resource version pinning**: While Terraform development
    rates differ from provider to provider, you may find that breaking changes are
    introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should lock the versions of providers within your infrastructure code and
    define an explicit version number when registering the providers used to ensure
    a consistent and stable infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: '`lookup`, `count`, and `for_each` to reduce complexity and improve flexibility.
    There are also functions, as we discussed in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268),
    *Deploying to Amazon Web Services*, where you work out **Classless Inter-Domain
    Routing** (**CIDR**) ranges and perform transformations on input and output variables
    – all of which can help reduce the number of variables you have to define.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform – troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the best practices for approaching your Terraform deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid hardcoding sensitive information**: As you may have already guessed,
    this is a common but significant recurring theme; *please do not do it!* Instead,
    with Terraform, you can use environment variables or secret management tools to
    avoid exposing sensitive data in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on` parameter when necessary to avoid issues related to resource ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed this in [*Chapter 2*](B19537_02.xhtml#_idTextAnchor085), *Ansible
    and Terraform beyond the Documentation*, in the *Fixing the error* section.
  prefs: []
  type: TYPE_NORMAL
- en: '`prevent_destroy` and ensure proper access controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of how you would use `prevent_destroy` to protect
    against the accidental deletion of an Azure storage account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You would receive an error if you attempted to run `terraform` `destroy` against
    the resource, which is much better than unexpectedly deleting the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is not a resource lock at the cloud-provider level; you
    are just instructing Terraform that it can’t destroy the resource on execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitor resource limits**: Be aware of provider-specific limits and quotas,
    which could lead to resource provisioning failures if they are hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors while provisioning resources due to limits or quotas could result in
    a corrupted state file, which may not be easily recoverable depending on the resource
    you are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: '`terraform refresh` and `terraform plan`. You could do this using CI/CD and
    have it alert depending on the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Watch for state file conflicts**: If multiple team members work on the same
    infrastructure, use remote state backends with locking mechanisms to prevent conflicting
    changes. Most backends support this by default, but to avoid state file corruption
    for production resources, I recommend triple-checking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If possible, avoid using multiple provisioning tools**: Mixing Terraform
    with other provisioning tools (for example, CloudFormation or **Azure Resource
    Manager** (**ARM**) templates) can cause conflicts and unexpected behavior on
    subsequent executions. Stick to one provisioning tool for consistency and predictability,
    and if possible, attempt to find a workaround for your reason to deploy using
    the multiple tools in this place. This is a slightly different use case than what
    we discussed in [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350), *Building upon
    the Foundations*, where we used Ansible to trigger Terraform; this is using Terraform
    to run other IaC tools – which some providers support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this functionality is built into each provider, and each provider is a separate
    project away from the core Terraform development, you may see that functionality
    between different providers is very different.
  prefs: []
  type: TYPE_NORMAL
- en: If you have to take this route, please consult your provider’s documentation
    and, where necessary, examine the issues logged in its GitHub repo to see whether
    any problems have been reported with the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen in this section, much of the advice is similar to the general
    advice we covered at the start of the chapter. Let us see if this trend continues
    for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible – best practices and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point in the chapter, you know the drill by now: we are going start
    by discussing best practices, but this time putting an Ansible spin on them.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible – best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the best practices for approaching your Ansible playbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Organize your playbooks with roles**: Use roles to group related tasks, variables,
    files, and templates, making your playbooks easier to understand and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on this, see [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350),
    *Building upon the Foundations*, where we discussed roles and Ansible Galaxy in
    more detail – this also leads into our next bit of advice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep playbooks modular and reusable**: Write modular playbooks and tasks
    that can be reused in different scenarios to minimize duplication and improve
    maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is where we start to differ slightly from Terraform, as Ansible can also
    be used to access both Linux or Windows hosts and execute commands on them, so
    reusable code for everyday tasks such as installing Apache, enabling **Internet
    Information Services** (**IIS**), or even just patching the operating systems
    you are targetting will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use version control**: Keep your Ansible playbook and configurations in a
    version control system such as Git to track changes and encourage/enable collaboration
    amongst your team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Employ a consistent naming convention**: Adopt a clear and consistent naming
    convention for tasks, files, templates, and especially variables to make it easier
    for other team members to pick up and follow your playbook quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a dynamic inventory**: This is not something we have touched upon so
    far, but when Ansible targets a host’s operating system, it uses an inventory
    file, which is a list of hosts to interact with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of hardcoding host details in an inventory file, you can use a dynamic
    inventory script to discover and manage resources in your environment automatically.
    There are scripts for most providers that typically work on tags to discover what
    to target.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine your Ansible playbook launches half a dozen virtual machines in
    your chosen cloud. If you were to tag them with `Role:Web`, then you could use
    a dynamic inventory script to search the cloud provider for all virtual machines
    tagged with `Role` of `Web` and build up a list of IP addresses to run your playbook
    against.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement idempotence**: Ensure your tasks are idempotent, which means they
    can be executed multiple times without producing unexpected results or side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your Ansible playbook deals exclusively with just infrastructure code, then
    this should be straightforward, as much of this logic is handled by the APIs with
    which the modules will interact.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are targeting operating systems, this becomes important, as
    you want to avoid anything unexpected happening across potentially several hosts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure sensitive data with Ansible Vault**: I have left this one until the
    end. Ansible has a built-in secrets management system called Ansible Vault, which
    allows you to encrypt sensitive data, such as passwords and API keys, to protect
    them from unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As well as commands such as `ansible-playbook` and `ansible-galaxy`, Ansible
    also ships with `ansible-vault`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command can encrypt and decrypt both entire files and simple strings.
    In the following example, we will look at encrypting a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command will prompt for a new password and confirmation of the
    password. Once entered, it will encrypt the specified text, which is super-secret
    `HelloWorld`, and give you something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the encrypted string, you can use it in your playbook file
    as in the following example (pease note that the spacing has been removed to make
    it easier to read):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a copy of the preceding code in the GitHub repository that accompanies
    this title. To run the playbook, we need to tweak our `ansible-playbook` command
    slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming you enter the correct password for the vault, this should give you
    something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Running the playbook and viewing the secret](img/Figure_8.01_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Running the playbook and viewing the secret
  prefs: []
  type: TYPE_NORMAL
- en: If you promise not to tell anyone, the password for the playbook is `password`,
    so you can run the playbook in the repo yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Vault can also encrypt entire files, meaning you can include files such
    as a private key for `base64` to encode a binary file as text and then use a vault
    to encrypt the encoded context, as Ansible has built-in functions for decoding
    `base64`.
  prefs: []
  type: TYPE_NORMAL
- en: So how is this any better than using a secret management tool? Well, it could
    be less complicated – you could use your secret management tool to store the password
    for Ansible Vault and then embed the rest of your secrets in your repo.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some best practices, let’s talk about troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible – troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What follows are some troubleshooting tips for Ansible, and a lot of the general
    ones also apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debug` module to display variables, messages, or task output, helping you
    identify issues in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is extremely helpful when trying to find out the contents of a variable
    or the output of a task; the following example playbook uses the `debug` module
    to output the contents of the `ansible_facts` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running the playbook using `ansible-playbook site.yml` should show you information
    about your host.
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible-playbook`; you can add the `-v`, `-vv`, or `-vvv` options to increase
    the verbosity of the output, providing more insight into what’s happening during
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check your YAML syntax**: I have lost countless hours looking at a problem
    only to find I haven’t formatted the YAML in my playbook correctly. Save yourself
    some time and validate your YAML files with a linter or online validator to catch
    any formatting or syntax errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review the failed and skipped task summaries**: Examine the *failed* and
    *skipped* task summaries at the end of a playbook run to identify tasks that did
    not execute as expected; Ansible may not completely stop execution on a failed
    task, so ensure that you pay attention to your playbook runs as you may have problems
    and not immediately realize it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verify file and directory permissions**: Ensure that the appropriate file
    and directory permissions are set for your Ansible files and target hosts, allowing
    the required access for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you are using SSH to access a host after it has been launched,
    ensure that the permissions on your local machine for things such as your SSH
    key are correct, or your Ansible playbook run may fail.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with the addition of managing workloads within the target hosts
    rather than just the infrastructure, there are a few more considerations with
    Ansible than with a tool such as Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed a lot in this chapter; we have talked about several similar
    concepts but have taken slightly different approaches depending on the tool we
    chose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For me, the biggest takeaways from this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version control**: Use version control to track changes and collaborate with
    your team and colleagues easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation and consistency**: Ensure that your infrastructure code is
    well documented and has been written in line with your style guides or other IaC
    projects – no one wants to pick up messy or undocumented code during a crisis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep an eye on the content**: Ensure you do not expose passwords, keys, or
    other sensitive content by checking it into your version control system. A lot
    of the IaC we have spoken about is designed to be human-readable, and that is
    the last thing you want for sensitive information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Please keep it simple**: Believe me, it is very easy to go down a rabbit
    hole and create some very complex, and some would say overkill, IaC projects.
    From experience, these types of projects always end up causing more problems than
    they solve. They are challenging to maintain and for other team members to pick
    up and work with if they end up inheriting them – keep things simple and follow
    the previously listed takeaways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our next and final chapter, we are going to take a look at three other IaC
    tools, including two native tools from the cloud providers Microsoft Azure and
    Amazon Web Services, before then discussing what your next steps with IaC could
    be.
  prefs: []
  type: TYPE_NORMAL
