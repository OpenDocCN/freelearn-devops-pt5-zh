- en: Integrating Ansible with CI and CD Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible, DevOps, Agile, **Continuous Integration** (**CI**), and **Continuous
    Delivery** (**CD**) implementations go hand in hand. Each transitions smoothly
    into the next. Through Ansible's comprehensive module implementation that we learned
    about in the last chapter, we can saw how Ansible integrates quite nicely with
    many industry standard Agile, Continuous Integration and Continuous Delivery solutions.
    Some of the more common CI->CD solutions that Ansible integrates with include
    Jenkins, Artifactory, Maven, Bamboo, and so on. Ansible integrates with these
    solutions so tightly that in fact, Ansible even has a complete CI->CD integration
    guide provided at the following URL [https://www.ansible.com/continuous-delivery](https://www.ansible.com/continuous-delivery).
  prefs: []
  type: TYPE_NORMAL
- en: For those unfamiliar with Continuous Integration and Continuous Delivery, these
    solutions have taken the software development world by storm. They propose a modern
    standardized way for committing, building, delivering, and testing code via software
    automation. The progression of code to production through automation and process
    is called a pipeline. The result of implementing a CI->CD pipelines is a highly
    effective way of automating the release of a software project by creating a repeatable
    process, and providing the team members with automatic feedback loops on the quality.
  prefs: []
  type: TYPE_NORMAL
- en: CI->CD best practices aim to provide a highly reliable way to build and keep
    a software project releasable at any moment in time. This is accomplished through
    a combination of highly disciplined development practices and automation of the
    build, delivery, and testing apparatuses of the software solution. By combining
    some fundamental practices with automation, an organization can become highly
    efficient at developing and delivering code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will begin to look at Continuous Integration and Continuous
    Delivery. We will take a deep dive into the fundamental constructs associated
    with each and provide details on how to integrate Ansible with popular CI->CD
    solutions that are readily available. Specifically, in this chapter, we will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Continuous Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Continuous Delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible's Role in a CI->CD oriented organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Ansible with Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Ansible with Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin exploring this crucial integration piece.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous integration, otherwise known as CI, has been around for quite some
    time. Its origins can be traced back to Kent Beck, Martin Fowler, and their work
    at the Chrysler corporation in the mid-nineties. The basic idea was that organizations
    could save a significant amount of time and effort by performing small yet frequent
    code merges into a central mainline within source control instead of a large risky
    merge just prior to release.
  prefs: []
  type: TYPE_NORMAL
- en: This way of thinking requires a team to discipline itself fairly well and requires
    that each team member commit their code frequently. It discourages isolated feature
    development efforts for long periods of time and encourages a higher level of
    collaboration and communication. The result of such an implementation is a much
    higher quality release due to less complex merge conflicts and code integration
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of continuous integration has been a trending topic for years. This
    is because of the higher level of communication that is required for it to become
    a successful practice. Beyond the basic commit stage, CI also includes an automated
    verification system and notification feedback loop so stakeholders can be notified
    if the commit and merge were defective. This notification system provides instant
    feedback on the quality of the commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software development professionals have debated the effectiveness of this solution
    for quite some time and will continue to debate in the future. Generally, the
    practice of CI can be described with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/836870e3-079b-48a8-8b6e-0742ebe0507d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from this diagram, continuous integration spans the full development
    life cycle of a software project. This specifically includes the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Code development collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code commit and merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation-based provisioning of build/development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation-based builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation-based testing of the completed builds (unit test, code coverage,
    lint and style tests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation based packaging of the build results (binaries and deliverables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration concepts and practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the concept of Continuous Integration is not new.
    The general practice of implementing a continuous integration oriented development
    team requires a change in mindset across the team, a level of engineering collaboration
    applied across the team, and a set of basic required practices. These practices
    are outlined in the list here:'
  prefs: []
  type: TYPE_NORMAL
- en: Mainline development (no source-control-based branches or highly frequent branch
    merges).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A CI based automation system that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically checks out code onto a system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifies the compilability of the source code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifies users of any failures
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The branching concept of CI over a period of time would look something like
    what is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5af46a46-1827-416e-a4b7-b4f415f12671.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on this illustration, we can see that in a Continuous Integration environment,
    developers would be required to push and pull from a central mainline frequently.
    Each push is then automatically verified using an automated build and test system.
    Any failures are reported to the larger team and stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: If a failure is reported by the system, all commits and pushes to the system
    should stop until the error is fixed. This is because the system is *not* in a
    known working state and that failed state must be fixed in order to prevent compounded
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: While CI generally encourages mainline development, it is possible to achieve
    Continuous Integration with branches. The main requirement of CI is to have developers
    remain in sync with the mainline. If a branching system is adopted, strict discipline
    will need to be maintained in order to ensure branch development does not go on
    in isolation for long periods of time.
  prefs: []
  type: TYPE_NORMAL
- en: The result of implementing a CI solution is commit phase elements within a build
    pipeline. Now that we have an understanding of what CI is and how it might work,
    let's look at Continuous Delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Handling unfinished work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working in a Continuous Integration or Continuous Delivery development
    environment, there is often a common misconception that developers need source
    control branching as a way to isolate unfinished work. This branch-based development
    is the antithesis of a Continuous Integration pattern. As such, there are structures
    and development practices that can be implemented to allow CI and CD to continue
    without the need for extraneous branches within source control. Let's spend a
    few minutes looking at the options available to developers who want to satisfy
    Continuous Integration without having their work complete.
  prefs: []
  type: TYPE_NORMAL
- en: Branch by abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Branching by abstraction provides a solid way for developers to continue working
    on an incomplete implementation and they not need to create a new branch. The
    idea behind the branching by abstraction architecture is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularize the architecture of the software system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace dated modules by simply creating a new class or folder structure on
    side by side the old one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swap out the calls to the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The basic implementation documented earlier can also be summarized with the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30e833a-b65c-44a8-a972-edf62c4e88f1.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the architecture, the new component is simply interchanged
    from the old one once it has been completed and deemed functional. This allows
    the source control level for the components to be committed and pushed without
    the need for a new branch.
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feature toggles are another way to provide a comprehensive CI implementation.
    Feature toggles exist in the form of switches. Switches can be turned off/turned
    on via a configuration change, UI implementation switch, or other configurable
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software programming languages provide the ability to feature toggle code by
    nature. The most simple example of a feature toggle would be a simple `if`/`else`
    condition, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Beyond a programmatic implementation, a feature toggle''s basic flow of operation
    would be something like what is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1785885f-517f-4821-a51d-3cc09429c196.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature toggles allow us to commit code into the mainline and even push that
    code into production without the necessary overhead of creating a branch.
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A/B testing is a relatively new addition to the software landscape. For those
    not familiar with it, the user base is presented with two distinct data implementations.
    Depending on which implementation the user base likes best, the feature that is
    the most popular gets rolled out to the larger audience and becomes permanent.
    Let''s look at a simple diagram of A/B testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bed39e93-73de-4dee-a57f-14aff1c17af4.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding diagram, A/B testing allows us to expose only
    a certain percentage of users to a feature and thus use that control group as
    a testing ground for whether the feature is useful. This type of implementation
    helps reduce the risk of over-engineering a feature only to find out it's not
    actually valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, A/B testing aims to save an organization time and money. These savings
    provide the business with better agility and higher competency in becoming/remaining
    competitive. Even though the diagram illustrates 50% of users being shown a **Variation
    B**, it does not always need to be an exact 50%.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we were doing A/B properly, we might show *only* 1% of users
    a feature and leave the other 99% on the stable version. Then, if the 1% generally
    approves of the feature, we might expand that scope.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in time, you may be asking where and how Ansible fits into A/B
    testing. This would be a great question. Ansible provides us with a way of targeting
    hosts with our playbook's. As such, 1% of users may simply be delegated to a single
    host-oriented deployment. However, in most cases, you wouldn't want to just deploy
    an upgrade to a single host. Instead, you might consider something like blue-green
    deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous Delivery was conceptualized by Jez Humble in 2012 with his revolutionary
    book on Continuous Delivery. The idea that Humble had when writing the book was
    to extend the concept of CI to support the delivery and automated testing apparatuses
    a software team would undertake prior to release. This concept radically changed
    the way software organizations looked at releasing software solutions to customers
    and aims to keep the software releasable at any time.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous years of software development, having and maintaining a build
    system was considered a best practice. However, once the build was completed and
    unit tests all passed, there were still numerous manual processes that needed
    to be maintained in order to ensure the software solution was, in fact, releasable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the more popular post build tasks include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality assurance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment environment provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-deployment verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As software companies suffered more and more failures, those who were managing
    software projects realized that manually performing these tasks can become error-prone
    and time-consuming. These tasks also increased in complexity as the software systems
    they were building grew in size and increased in the user base. The solution Jez
    proposed was a repeatable and highly automated advance to Continuous Integration.
    He titled the implementation Continuous Delivery, or CD.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery defined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD, as we mentioned earlier, aimed to extend the implementation of CI. This
    way, a software system remains in a releasable state. This is accomplished by
    combining mainline development practices, Continuous Integration automation a
    set of automated provisioning and deployment solutions (to pre-production environments),
    and automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Continuous Delivery oriented organization, deployment pipelines are created
    to help implement the previously listed solutions. An example of a high-level
    deployment pipeline is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b35ae327-5dea-4d02-b589-e066273b8ddb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The deployment pipeline shown here is pretty simple in nature. It simply shows
    a commit flowing from a developer''s hands into production and release. In the
    following diagram, we can see how a deployment pipeline looks from a bit lower
    of a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/965ee5fd-5959-46ab-a1f6-29f6bf0caef2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the shown diagram, we can see that there are a few more visible components
    within the build pipeline. These components include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An artifact repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push button deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoke tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capacity tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A production stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These additional components of Continuous Delivery are important. Let''s go
    over each and see what they do or aim to accomplish:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version control**: Version control aims to allow a central location for developers
    to communicate their code changes with the larger group. Some examples of modern
    version control systems include Git, Mercurial, SVN, and Perforce. The version
    control system allows not only easy communication but also the reverting of faulty
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artifact repository**: Adding a structured **Digital Media Library** (**DML**)
    to your organization is an important step in relation to implementing Continuous
    Delivery. This represents a definitive location where the output of the build
    system can be versioned and kept as a release approaches. It also allows multiple
    versions of the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push button deployments**: Push button deployments are solutions that can
    be automatically deployed via a single button push.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how the solution can be deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: The automation pulls the binary from the artifact repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The automation pushes the artifact using a configuration management solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The artifact is unzipped and the automation inside is executed to perform the
    deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the other component in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration management**: In this step, a configuration management solution
    (such as Ansible) is used to deploy/configure the software installation onto the
    target environment machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoke tests**: Smoke tests are high-level functional tests that determine
    whether the software is worth testing further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional tests**: Functional tests are verification tests (automated) that
    verify that the software meets business functional requirements. Each test suite
    within a functional test solution should be parallelized where possible in order
    to ensure that there is no bottleneck in performance when executing these tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capacity tests**/**stress tests**: This type of test helps validate that
    the software can operate and perform effectively under normal traffic loads from
    the potential user base. Often, this type of test is overlooked, which results
    in unscalable software solutions that crash under heavy load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling complex and long running builds and deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, a build or deployment will be time-consuming (multiple different
    components or complicated environment setup steps). When this happens, Continuous
    Delivery-oriented organizations can handle this as well. This is best handled
    by modularizing the architecture of the software project into uniquely deployable
    entities. Once the software has been modularized, the deployment and automated
    testing apparatuses can be broken into multiple component-oriented delivery pipelines.
    An example of a multi-component delivery pipeline is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d21a897d-478e-48c4-956a-54a6f1db4f58.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the diagram, multiple pipelines can be created in an effort
    to streamline the deployment process. Each pipeline would have its own build,
    package, unit test, and related apparatuses. From these multiple pipelines, we
    can deploy individual component versions into environments swiftly and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good grasp on how a basic pipeline would be architected,
    let's take a look at how the same type of pipeline would look in terms of notifications
    and feedback.
  prefs: []
  type: TYPE_NORMAL
- en: CI->CD feedback loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CI feedback loop is one of the major selling points of CI->CD. The basic
    idea is that the user base and stakeholders can get CD feedback loop almost instantaneous
    feedback on the quality of committed code. This would allow the developers to
    address automation-identified issues quickly and will help improve the quality
    of the overall system. The basic feedback loop would look something like what
    is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c3cb88b-b73b-4248-a34e-53b340944aa3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the notification loop provides the stakeholders with a notification
    (e-mail, IM, Slack, Hipchat, and so on) at every stage in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-green deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blue-green deployments represent a wise innovation on the part of system operators
    and engineering groups. The basic concept of a blue-green deployment is, in many
    ways, similar to the branching by abstraction concept we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blue-green deployments offer the idea of deploying a side-by-side instance
    of a component or application, all the while leaving the existing instance running
    and serving live traffic. When the deployment is deemed a success, traffic is
    flipped from the old version over to the new one. The following is a simple diagram
    illustrating blue-green deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d5da00d-58a8-4f89-8682-f5fde552360e.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, new connections go to the green instance and old connections
    remain persistent with the blue instance.
  prefs: []
  type: TYPE_NORMAL
- en: CI->CD anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the talk of CD anti-patterns branching by abstraction and feature
    toggles it is probably a good idea at CD anti-patterns this point to look at some
    anti-patterns that are commonly employed by organizations that represent the antithesis
    of CI->CD best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature branches**: This is because one of the core tenants of Continuous
    Integration is the merging of code with the main line. This is the area where
    defects become most prevalent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaving the build in a failed state**: Leaving the build in a known failed
    state is a common anti-pattern for Continuous Integration efforts. This is an
    anti-pattern since it effectively leaves a landmine for other developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'K**eeping code locally on a developer workstation for long periods of time**:
    Coding software changes on a local system and not merging it with the mainline
    is, in essence, hiding changes. The risk from this pattern comes with the huge
    merge that needs to be done. This large-scale merge usually takes place right
    before a release, which puts the release quality at risk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible's Role in CI->CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible fits in a number of areas of the CI->CD implementation. It can be used
    for build environment provisioning, local workstation environment provisioning,
    configuration management on deployment servers, managing physical deployments,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of Implementing DevOps with Ansible, we will take a look at
    where Ansible fits into the CI->CD pipeline implementation and some best practices
    associated with each implementation location. Before we begin looking into focus
    areas, let's identify the common steps in a CI->CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, a delivery pipeline will be simple; it may contain a set of very
    basic steps. These steps might include the followng:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the source control when a change is committed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a build or syntax check.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute some unit tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Report on the quality of the commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/404eeb7a-2316-4612-a2f1-8106ce2d2760.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the initial CI process described, we might consider using Ansible
    in the following CI steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To help developers provision their development environment using an Ansible
    playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provision the build machine automatically and ensure the build machine's
    configuration is maintained by Ansible playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To act as the automation binding to execute the build and unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see from these set of steps, we can leverage Ansible in more ways
    than simply to perform configuration management tasks and deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have Continuous Integration defined, let''s take a look at how
    Ansible can be used within the extension of CI and CD. Take a look at the following
    Continuous Delivery diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd16b2d1-d389-4236-b18d-8a5d1f3d205c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on this diagram and flowchart, we can see that there are a number of
    places within CI->CD where Ansible would prove useful. Let''s take a look at these
    places:'
  prefs: []
  type: TYPE_NORMAL
- en: In provisioning the test environments (smoke, functional, and unit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In provisioning the deployment environments (DEV, QA, STG, PROD).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In performing the deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In launching the application after it has been deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In rolling back the environment if there are failures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In performing a feathered/incremental rollout of the application into production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ansible best practices in CI->CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible can be leveraged for a number of tasks within a Continuous Integration
    and Continuous Delivery atmosphere. When adopting Ansible, it makes sense to start
    with a small footprint and expand it to be more and more responsible for the automation
    being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, let''s take a few minutes to explore some best practices within
    CI->CD in conjunction with Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: Always store your Ansible playbooks in source control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ship your ansible playbooks with your artifacts (version everything!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maintain separate inventory files for each environment (DEV, QA, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to use the same playbooks for deploying to DEV as you would in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage Ansible's configuration management implementation to help keep your
    infrastructure in sync.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep your playbooks as simple as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use roles to help define reusable automation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Ansible for your build and deployment automation glue where possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep your environments in sync (Apples | Apples | Apples, Dev | QA | PROD).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating Ansible with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will talk about integrating Ansible with Jenkins. Jenkins
    is a modern CI and automation orchestration solution created and distributed by
    the open source community. Jenkins originated as Hudson and was eventually transitioned
    with a new brand name and developed into a comprehensive free and open source
    build and delivery pipeline orchestration solution. You can download a copy of
    Jenkins at [https://jenkins.io/](https://jenkins.io/)[.](https://www.ansible.com/continuous-delivery)
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Ansible with Jenkins is generally a straightforward task. To accomplish
    this, there are a few well-known integration points where Ansible can be leveraged.
    They include the Jenkins Ansible plugin, installing Ansible on the Jenkins CI
    server directly and calling it through an execute shell operation and using the
    Ansible module to control Jenkins. Let's spend a few minutes discussing each of
    these options and see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: The Jenkins Ansible plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jenkins Ansible plugin provides the ability for Jenkins to directly communicate
    with Ansible and run a playbook. This option is probably the most straightforward
    integration point between Jenkins and Ansible. Using this solution, Ansible doesn't
    necessarily need to run playbooks on a remote server (however, it definitely can).
    In this solution, we can run playbooks directly from the Jenkins server and either
    have those playbooks run locally or run them against targeted infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In order to facilitate the execution of playbooks through Jenkins, we will need
    to first install the Ansible plugin via the Jenkins plugin manager. Let's take
    a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial assumes you have a Jenkins instance already installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will want to do is fire up Jenkins. Upon the initial load
    of Jenkins, we will see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e42cccfa-03ad-4904-9489-d82b47fb8f80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To install the Ansible plugin. simply navigate to Plugin Manager (as a Jenkins
    administrator) and select Ansible plugin from the Available plugins tab and install
    the plugin. This is shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/110ed814-1452-4a1d-a822-c2d034ffa808.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Search for the Ansible plugin and select it. Now install the plugin by clicking
    on Install without restart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a64391d6-fab8-427f-ad7f-f8fabe6e5e55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will want to go to the job configuration page for the job we wish
    to leverage Ansible through and enable the job to use Ansible. The configuration
    would look something like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/815c6266-2d26-4738-bc2f-e181af812dd5.png)'
  prefs: []
  type: TYPE_IMG
- en: From this screenshot, we can see that there are a number of options available
    for use with the Ansible plugin in Jenkins. The complete documentation is available
    at [https://wiki.jenkins-ci.org/display/JENKINS/Ansible+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Ansible+Plugin).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the plugin and job are configured, run the Jenkins job to see it connect
    to Ansible and leverage Ansible for the automation engine of the job. The output
    from the execution of a Jenkins job using the Ansible plugin would be something
    like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/428f61dc-4658-48e5-b9e0-e6028bdd8c30.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a good idea of how to leverage Jenkins to execute Ansible playbook,
    let's take a look at how to have Ansible control Jenkins via the API.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbooks in this scenario are best stored in source control and checked
    out during the SCM phase of the Jenkins job.
  prefs: []
  type: TYPE_NORMAL
- en: The Jenkins Ansible API modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jenkins Ansible module provides a direct API-level integration between Jenkins
    and Ansible. Through this solution, Ansible can manage and control Jenkins through
    its REST API. The Jenkins REST API is fairly robust and provides the ability to
    create jobs, execute jobs, manage users, and much more. In this section, we will
    take a look at some examples of the capabilities that the Ansible module provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible''s integration with Jenkins is broken down into three uniquely classified
    modules. These modules (as mentioned previously) communicate with Jenkins on an
    API level and provide a level of control over the Jenkins solution. The three
    specific modules that we will be looking at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jenkins_job`: Manages Jenkins jobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jenkins_plugin`: Adds or removes the Jenkins plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jenkins_script`: Executes a groovy script in the Jenkins instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the `jenkins_job` Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: The jenkins_job Ansible Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `jenkins_job` Ansible module provides a level of inter-connectivity between
    Jenkins jobs and Ansible. Through this module, Ansible can create Jenkins jobs,
    execute them, manage them, delete them, and more. In order to use this module,
    we will need the following package libraries installed on the Ansible control
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`python-jenkins` >= 0.4.12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lxml` >= 3.3.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These libraries can be installed using `pip` or a package management system
    such as `apt-get` or `yum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making sure the modules are installed, we can begin to make use of the
    Ansible module''s features. Let''s take a look at some example playbook plays
    to create and control Jenkins jobs via the REST API. In addition to this, we will
    also take a look at the documentation for the supported features of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the `example.xml` template, you will need to use the Jenkins UI wizard
    to create a new template. This can be done via the job templates plugin. More
    information on this plugin can be found at the following URL: [https://www.cloudbees.com/products/cloudbees-jenkins-platform/enterprise-edition/features/templates-plugin](https://www.cloudbees.com/products/cloudbees-jenkins-platform/enterprise-edition/features/templates-plugin)'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Ansible with Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will talk about integrating Ansible with Vagrant. Vagrant
    is a freely available infrastructure virtualization solution that is currently
    in use by countless organizations. It is provided free of charge via the kind
    folks at HashiCorp. A complete documentation for Vagrant can be found at [https://www.vagrantup.com/intro/index.html](https://www.vagrantup.com/intro/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we will assume you already have Vagrant up and running. If not, refer
    to the instructions located within HashiCorp's Vagrant Up website at [https://www.vagrantup.com/docs/cli/up.html](https://www.vagrantup.com/docs/cli/up.html)
    to get the initial setup completed. Once the initial setup of Vagrant has been
    completed, we can take a look at how to leverage Ansible within Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Ansible for Vagrant provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible''s playbook implementation can be used to provision Vagrant machines
    through the Ansible provider. Providers in Vagrant allow the Vagrant user to specify
    a configuration management solution that will be leveraged to automate the standup
    of a given virtual machine. This information is contained in a Ruby Vagrantfile.
    An example of a simple Vagrantfile is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: From this example, we can see that we use Ansible to configure our Vagrant environment.
    This will cause Vagrant to execute the Ansible playbook. Once the Vagrantfile
    has been updated, we can run it using the `vagrant up` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about Continuous Integration, Continuous Delivery,
    and Ansible. We also talked about the organizational requirements of CI->CD and
    how CI->CD makes software delivery more efficient. You learned about some of the
    patterns that make a CI->CD implementation effective.
  prefs: []
  type: TYPE_NORMAL
- en: After talking about CI->CD in depth and discussing the said patterns, we talked
    about Ansible's role within a CI->CD oriented organization. We discovered the
    connecting points that tools such as Ansible can be leveraged to make the process
    more efficient. By standardizing and making a software development organization
    more efficient through the use of modern tools such as Ansible, we can save the
    organization time and money.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to use Ansible with Docker. The chapter
    will teach you how to provision docker containers using Ansible, how to integrate
    Ansible with dockers service, how to manage docker image facts, and how to gain
    full control over docker images.
  prefs: []
  type: TYPE_NORMAL
