<html><head></head><body>
  
    
      <h1>Testing with Docker</h1>
    

    
      <p>Undoubtedly, the trait of testing has been at the forefront of the software engineering discipline. The deep and decisive presence of software in every kind of tangible object in our daily environments these days in order to have plenty of smart, connected, and digitized assets is widely accepted. Also, with an increased focus on distributed and synchronized software, the complexity of the software design, development, testing and debugging, deployment, and delivery are continuously on the rise. Various means and mechanisms are unearthed to simplify and streamline the much-needed automation of software building and the authentication of software reliability, resiliency, and sustainability. Docker is emerging as an extremely flexible tool to test a wide variety of software applications. In this chapter, we will discuss how to effectively leverage the noteworthy advancements of Docker for software testing and its unique advantages in accelerating and augmenting testing automation.</p>

      <p>The following topics are discussed in this chapter:</p>

      <ul>
        <li>A brief overview of TDD</li>

        <li>Testing your code inside Docker</li>

        <li>Integrating the Docker testing process into Jenkins</li>
      </ul>

      <p>Docker containers are currently being leveraged to create development and testing environments that are the exact replicas of the production environment. Containers require less overhead when compared with virtual machines, which have been the primary environments for development, staging, and deployment environments. Let's start with an overview of <strong>Test-driven Development</strong> (<strong>TDD</strong>) of the next generation software and how Docker-inspired containerization becomes handy in simplifying the TDD process.</p>
    
  

  
    
      <h2 id="sigil_toc_id_124">A brief overview of TDD</h2>
    

    
      <p>The long and arduous journey of software development has taken many twists and turns in the past decades, and one of the prominent software engineering technique is nonetheless TDD.</p>

      <p>For more details and documents on TDD refer to <a href="http://agiledata.org/essays/tdd.html">http://agiledata.org/essays/tdd.html</a>.
      </p>

      <p>In a nutshell, TDD is a software development practice in which the development cycle begins with writing a test case that will fail, then writes the actual software to make the test pass, and continues to refactor and repeat the cycle till the software reaches the acceptable level. This process is depicted in the following diagram:</p>

      <div><img class="image-border" height="188" src="img/image_09_001.jpg" width="190"/>
      </div>
    
  

  
    
      <h2 id="sigil_toc_id_125">Testing your code inside Docker</h2>
    

    
      <p>In this section, we will take you through a journey in which we will show you how TDD is done using stubs and how Docker can come in handy when developing software in the deployment equivalent system. For this purpose, we take a web application use case that has a feature to track the visit count of each of its users. For this example, we use Python as the implementation language and <code>redis</code> as the key-value pair database to store the users hit count. Besides, to showcase the testing capability of Docker, we limit our implementation to just two functions—<code>hit</code> and <code>getHit</code>.</p>

      <p>All the examples in this chapter use Python 3 as the runtime environment. The Ubuntu 16.04 installation comes with Python 3 by default. If you don't have Python 3 installed on your system, refer to the respective manual to install Python 3.
      </p>

      <p>As per the TDD practice, we start by adding unit test cases for the <code>hit</code> and <code>getHit</code> functions, as depicted in the following code snippet. Here, the test file is named <code>test_hitcount.py</code>:</p>

      <pre>import unittest <br/>import hitcount <br/><br/>class HitCountTest (unittest.TestCase): <br/>     def testOneHit(self): <br/>         # increase the hit count for user user1 <br/>         hitcount.hit("user1") <br/>         # ensure that the hit count for user1 is just 1 <br/>         self.assertEqual(b'1', hitcount.getHit("user1")) <br/><br/>if __name__ == '__main__': <br/>    unittest.main() 
</pre>

      <p>This example is also available at <a href="https://github.com/thedocker/testing/tree/master/src">https://github.com/thedocker/testing/tree/master/src</a>.</p>

      <p>Here, in the first line, we are importing the <code>unittest</code> Python module that provides the necessary framework and functionality to run the unit test and generate a detailed report on the test execution. In the second line, we are importing the <code>hitcount</code> Python module, where we are going to implement the hit count functionality. Then, we will continue to add the test code that will test the <code>hitcount</code> module's functionality.</p>

      <p>Now, run the test suite using the unit test framework of Python, as follows:</p>

      <pre><strong>$ python3 -m unittest </strong>  
</pre>

      <p>The following is the output generated by the unit test framework:</p>

      <pre><strong>E</strong><br/><strong>======================================================================</strong><br/><strong>ERROR: test_hitcount (unittest.loader.ModuleImportFailure)</strong><br/><strong>----------------------------------------------------------------------</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>...OUTPUT TRUNCATED ...</strong><br/><strong>ImportError: No module named 'hitcount'</strong><br/><br/><strong>----------------------------------------------------------------------</strong><br/><strong>Ran 1 test in 0.001s</strong><br/><br/><strong>FAILED (errors=1)</strong>
</pre>

      <p>As expected, the test failed with the <code>ImportError: No module named 'hitcount'</code> error message because we had not even created the file and hence, it could not import the <code>hitcount</code> module.</p>

      <p>Now, create a file with the <code>hitcount.py</code> name in the same directory as <code>test_hitcount.py</code>:</p>

      <pre><strong>$ touch hitcount.py</strong>  
</pre>

      <p>Continue to run the unit test suite:</p>

      <pre><strong>$ python3 -m unittest</strong>  
</pre>

      <p>The following is the output generated by the unit test framework:</p>

      <pre><strong>E<br/>======================================================================</strong><br/><strong>ERROR: testOneHit (test_hitcount.HitCountTest)</strong><br/><strong>----------------------------------------------------------------------</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong> File "/home/user/test_hitcount.py", line 10, in testOneHit</strong><br/><strong> hitcount.hit("peter")</strong><br/><strong>AttributeError: 'module' object has no attribute 'hit'</strong><br/><br/><strong>----------------------------------------------------------------------<br/></strong><br/><strong>Ran 1 test in 0.001s</strong><br/><br/><strong>FAILED (errors=1)</strong>
</pre>

      <p>Again, the test suite failed like earlier, but with a different error message <code>AttributeError: 'module' object has no attribute 'hit'</code>. We are getting this error because we have not implemented the <code>hit</code> function yet.</p>

      <p>Let's proceed to implement the <code>hit</code> and <code>getHit</code> functions in <code>hitcount.py</code>, as shown here:</p>

      <pre>import redis <br/># connect to redis server <br/>r = redis.StrictRedis(host='0.0.0.0', port=6379, db=0) <br/><br/># increase the hit count for the usr <br/>def hit(usr): <br/>    r.incr(usr) <br/><br/># get the hit count for the usr <br/>def getHit(usr): <br/>    return (r.get(usr)) 
</pre>

      <p>This example is also available on GitHub at <a href="https://github.com/thedocker/testing/tree/master/src">https://github.com/thedocker/testing/tree/master/src</a>.</p>

      <p>To continue with this example, you must have the Python 3 compatible version of package installer (<code>pip3</code>).
      </p>

      <p>The following command is used to install <code>pip3</code>:</p>

      <pre><strong>$ wget -qO- https://bootstrap.pypa.io/get-pip.py | sudo python3 -</strong><br/>
</pre>

      <p>In the first line of the preceding program, we are importing the <code>redis</code> driver, which is the connectivity driver of the <code>redis</code> database. In the following line, we are connecting to the <code>redis</code> database, and then we will continue to implement the <code>hit</code> and <code>getHit</code> function.</p>

      <p>The <code>redis</code> driver is an optional Python module, so let's proceed to install the <code>redis</code> driver using the <code>pip</code> installer, which is illustrated as follows:</p>

      <pre><strong>$ sudo pip3 install redis</strong>  
</pre>

      <p>Our <code>unittest</code> module will still fail even after installing the <code>redis</code> driver because we are not running a <code>redis</code> database server yet. So, we can either run a <code>redis</code> database server to successfully complete our unit testing or take the traditional TDD approach of mocking the <code>redis</code> driver. Mocking is a testing approach wherein complex behavior is substituted by predefined or simulated behavior. In our example, to mock the <code>redis</code> driver, we are going to leverage a third-party Python package called <code>mockredis</code>. This mock package is available at <a href="https://github.com/locationlabs/mockredis">https://github.com/locationlabs/mockredis</a> and the <code>pip</code> installer name is <code>mockredispy</code>. Let's install this mock using the <code>pip</code> installer:</p>

      <pre><strong>$ sudo pip3 install mockredispy</strong>  
</pre>

      <p>Having installed <code>mockredispy</code>, the <code>redis</code> mock, let's refactor our test code <code>test_hitcount.py</code> (which we had written earlier) to use the simulated <code>redis</code> functionality provided by the <code>mockredis</code> module. This is accomplished by the <code>patch</code> method provided by the <code>unittest.mock</code> mocking framework, as shown in the following code:</p>

      <pre>import unittest <br/>from unittest.mock import patch <br/><br/># Mock for redis <br/>import mockredis <br/>import hitcount <br/><br/>class HitCountTest(unittest.TestCase): <br/><br/><br/>    @patch('hitcount.r',<br/>        mockredis.mock_strict_redis_client(host='0.0.0.0', <br/>        port=6379,  db=0)) <br/>    def testOneHit(self): <br/>        # increase the hit count for user user1 <br/>        hitcount.hit("user1") <br/>        # ensure that the hit count for user1 is just 1 <br/>        self.assertEqual(b'1', hitcount.getHit("user1")) <br/><br/>if __name__ == '__main__': <br/>    unittest.main() 
</pre>

      <p>This example is also available on GitHub at <a href="https://github.com/thedocker/testing/tree/master/src">https://github.com/thedocker/testing/tree/master/src</a>.</p>

      <p>Now, run the test suite again:</p>

      <pre><strong>$ python3 -m unittest</strong><br/><strong>.</strong><br/><strong>----------------------------------------------------------------------</strong><br/><strong>Ran 1 test in 0.000s</strong><br/><br/><strong>OK</strong>
</pre>

      <p>Finally, as we can see in the preceding output, we successfully implemented our visitors count functionality through the test, code, and refactor cycle.</p>
    
  

  
    
      <h3 id="sigil_toc_id_126">Running the test inside a container</h3>
    

    
      <p>In the previous section, we walked you through the complete cycle of TDD, in which we installed additional Python packages to complete our development. However, in the real world, one might work on multiple projects that might have conflicting libraries and hence, there is a need for the isolation of runtime environments. Before the advent of Docker technology, the Python community used to leverage the Virtualenv tool to isolate the Python runtime environment. Docker takes this isolation a step further by packaging the OS, the Python toolchain, and the runtime environment. This type of isolation gives a lot of flexibility to the development community to use appropriate software versions and libraries as per the project needs.</p>

      <p>Here is the step-by-step procedure to package the test and visitor count implementation of the previous section to a Docker container and perform the test inside the container:</p>

      <ol>
        <li>Craft a <code>Dockerfile</code> to build an image with the <code>python3</code> runtime, the <code>redis</code> and <code>mockredispy</code> packages, and both the <code>test_hitcount.py</code> test file and the visitors count implementation <code>hitcount.py</code>, and finally, launch the unit test:</li>
      </ol>

      <pre>      ############################################# <br/>      # Dockerfile to build the unittest container <br/>      ############################################# <br/><br/>      # Base image is python <br/>      FROM python:latest <br/><br/>      # Author: Dr. Peter <br/>      MAINTAINER Dr. Peter &lt;peterindia@gmail.com&gt; <br/><br/>      # Install redis driver for python and the redis mock <br/>      RUN pip install redis &amp;&amp; pip install mockredispy <br/><br/>      # Copy the test and source to the Docker image <br/>      ADD src/ /src/ <br/><br/>      # Change the working directory to /src/ <br/>      WORKDIR /src/ <br/><br/>      # Make unittest as the default execution <br/>      ENTRYPOINT python3 -m unittest 
</pre>

      <p style="padding-left: 60px">This example is also available on GitHub at <a href="https://github.com/thedocker/testing/tree/master/src">https://github.com/thedocker/testing/tree/master/src</a>.</p>

      <ol start="2">
        <li>Now create a directory called <code>src</code>, where we crafted our <code>Dockerfile</code>. Move the <code>test_hitcount.py</code> and <code>hitcount.py</code> files to the newly created <code>src</code> directory.</li>

        <li>Build the <code>hit_unittest</code> Docker image using the <code>docker build</code> subcommand:</li>
      </ol>

      <pre><strong> $ sudo docker build -t hit_unittest .</strong><br/><strong> Sending build context to Docker daemon 11.78 kB</strong><br/><strong> Sending build context to Docker daemon</strong><br/><strong> Step 0 : FROM python:latest</strong><br/><strong> ---&gt; 32b9d937b993</strong><br/><strong> Step 1 : MAINTAINER Dr. Peter &lt;peterindia@gmail.com&gt;</strong><br/><strong> ---&gt; Using cache</strong><br/><strong> ---&gt; bf40ee5f5563</strong><br/><strong> Step 2 : RUN pip install redis &amp;&amp; pip install mockredispy</strong><br/><strong> ---&gt; Using cache</strong><br/><strong> ---&gt; a55f3bdb62b3</strong><br/><strong> Step 3 : ADD src/ /src/</strong><br/><strong> ---&gt; 526e13dbf4c3</strong><br/><strong> Removing intermediate container a6d89cbce053</strong><br/><strong> Step 4 : WORKDIR /src/</strong><br/><strong> ---&gt; Running in 5c180e180a93</strong><br/><strong> ---&gt; 53d3f4e68f6b</strong><br/><strong> Removing intermediate container 5c180e180a93</strong><br/><strong> Step 5 : ENTRYPOINT python3 -m unittest</strong><br/><strong> ---&gt; Running in 74d81f4fe817</strong><br/><strong> ---&gt; 063bfe92eae0</strong><br/><strong> Removing intermediate container 74d81f4fe817</strong><br/><strong> Successfully built 063bfe92eae0</strong>  
</pre>

      <ol start="4">
        <li>Now that we have successfully built the image, let's launch our container with the unit testing bundle using the <code>docker run</code> subcommand, as illustrated here:</li>
      </ol>

      <pre><strong> $ sudo docker run --rm -it hit_unittest .</strong><br/><strong> --------------------------------------------------------------- <br/> --</strong><strong>-----</strong><br/><strong> Ran 1 test in 0.001s<br/></strong><br/><strong> OK</strong>
</pre>

      <p style="padding-left: 60px">Apparently, the unit test ran successfully with no errors because we already packaged the tested code.</p>

      <p>In this approach, for every change, the Docker image is built and then the container is launched to complete the test.</p>
    
  

  
    
      <h4 id="sigil_toc_id_127">Using a Docker container as a runtime environment</h4>
    

    
      <p>In the previous section, we built a Docker image to perform the testing. Particularly, in the TDD practice, the unit test cases and the code go through multiple changes. Consequently, the Docker image needs to be built over and over again, which is a daunting task. In this section, we will see an alternative approach in which the Docker container is built with a runtime environment, the development directory is mounted as a volume, and the test is performed inside the container.</p>

      <p>During this TDD cycle, if an additional library or update to the existing library is required, then the container will be updated with the required libraries and the updated container will be committed as a new image. This approach gives the isolation and flexibility that any developer would dream of because the runtime and its dependency live within the container, and any misconfigured runtime environment can be discarded and a new runtime environment can be built from a previously working image. This also helps to preserve the sanity of the Docker host from the installation and uninstallation of libraries.</p>

      <p>The following example is a step-by-step instruction on how to use the Docker container as a non-polluting yet very powerful runtime environment:</p>

      <ol>
        <li>We begin with launching the Python runtime interactive container, using the <code>docker run</code> subcommand:</li>
      </ol>

      <pre>      <strong>$ sudo docker run -it \</strong><br/><strong> -v /home/peter/src/hitcount:/src \</strong><br/><strong> python:latest /bin/bash</strong>
</pre>

      <p style="padding-left: 60px">Here, in this example, the <code>/home/peter/src/hitcount</code> Docker host directory is earmarked as the placeholder for the source code and test files. This directory is mounted in the container as <code>/src</code>.</p>

      <ol start="2">
        <li>Now, on another Terminal of the Docker host, copy both the <code>test_hitcount.py</code> test file and the <code>hitcount.py</code> visitors count implementation to the <code>/home/peter/src/hitcount</code> directory.</li>

        <li>Switch to the Python runtime interactive container Terminal, change the current working directory to <code>/src</code>, and run the unit test:</li>
      </ol>

      <pre><strong> root@a8219ac7ed8e:~# cd /src</strong><br/><strong> root@a8219ac7ed8e:/src# python3 -m unittest</strong><br/><strong> E</strong><br/><strong> =====================================================<br/> =================</strong><br/><strong> ERROR: test_hitcount </strong><br/><strong> (unittest.loader.ModuleImportFailure)</strong><br/><strong> . . . TRUNCATED OUTPUT . . . </strong><br/><strong> File "/src/test_hitcount.py", line 4, in &lt;module&gt;</strong><br/><strong> import mockredis</strong><br/><strong> ImportError: No module named 'mockredis'</strong><br/><strong> ---------------------------------------------------------------<br/></strong><br/><strong> Ran 1 test in 0.001s<br/></strong><br/><strong> FAILED (errors=1)</strong>
</pre>

      <p class="western" style="padding-left: 60px">Evidently, the test failed because it could not find the <code>mockredis</code> Python library.</p>

      <ol start="4">
        <li>Proceed to install the <code>mockredispy</code> pip package because the previous step failed as it could not find the <code>mockredis</code> library in the runtime environment:</li>
      </ol>

      <pre>      <strong>root@a8219ac7ed8e:/src# pip install mockredispy</strong>
</pre>

      <ol start="5">
        <li>Rerun the Python unit test:</li>
      </ol>

      <pre><strong> root@a8219ac7ed8e:/src# python3 -m unittest</strong><br/><strong> E</strong><br/><strong> =====================================================<br/> ============</strong><br/><strong> ERROR: test_hitcount </strong><br/><strong> (unittest.loader.ModuleImportFailure)</strong><br/><strong> . . . TRUNCATED OUTPUT . . . </strong><br/><strong> File "/src/hitcount.py", line 1, in &lt;module&gt;</strong><br/><strong> import redis</strong><br/><strong> ImportError: No module named 'redis'</strong><br/><br/><strong> Ran 1 test in 0.001s</strong><br/><br/><strong> FAILED (errors=1)</strong>
</pre>

      <p style="padding-left: 60px">Again, the test failed because the <code>redis</code> driver is not yet installed.</p>

      <ol start="7">
        <li>Continue to install the <code>redis</code> driver using the <code>pip</code> installer, as shown here:</li>
      </ol>

      <pre>      <strong>root@a8219ac7ed8e:/src# pip install redis</strong>
</pre>

      <ol start="8">
        <li>Having successfully installed the <code>redis</code> driver, let's once again run the unit test:</li>
      </ol>

      <pre><strong> root@a8219ac7ed8e:/src# python3 -m unittest</strong><br/><strong> .</strong><br/><strong> ---------------------------------------------------------------<br/> --</strong><br/><strong> Ran 1 test in 0.000s</strong><br/><br/><strong> OK</strong>
</pre>

      <p style="padding-left: 60px">Apparently, this time the unit test passed with no warnings or error messages.</p>

      <ol start="9">
        <li>Now we have a runtime environment that is good enough to run our test cases. It is better to commit these changes to a Docker image for reuse, using the <code>docker commit</code> subcommand:</li>
      </ol>

      <pre>      <strong>$ sudo docker commit a8219ac7ed8e \ <br/> python_rediswithmock</strong><br/><strong>fcf27247ff5bb240a935ec4ba1bddbd8c90cd79cba66e52b21e1b48f984c7db2</strong>
</pre>

      <ol start="10">
        <li>From now on, we can use the <code>python_rediswithmock</code> image to launch new containers for our TDD.</li>
      </ol>

      <p>In this section, we vividly illustrated the approach on how to use the Docker container as a testing environment, and also at the same time, preserve the sanity and sanctity of the Docker host by isolating and limiting the runtime dependency within the container.</p>
    
  

  
    
      <h2 id="sigil_toc_id_128">Integrating Docker testing into Jenkins</h2>
    

    
      <p>In the previous section, we laid out a stimulating foundation on software testing, how to leverage the Docker technology for the software testing, and the unique benefits of the container technology during the testing phase. In this section, we will introduce you to the steps required to prepare the Jenkins environment for testing with Docker, and then, demonstrate how Jenkins can be extended to integrate and automate testing with Docker, using the well-known hit count use case.</p>
    
  

  
    
      <h3 id="sigil_toc_id_129">Preparing the Jenkins environment</h3>
    

    
      <p>In this section, we will take you through the steps to install Jenkins, the GitHub plugin for Jenkins and <code>git</code>, and the revision control tool. The steps are as follows:</p>

      <ol>
        <li>We begin with adding the Jenkins' trusted PGP public key:</li>
      </ol>

      <pre><strong> $ wget -q -O - \</strong><br/><strong> https://jenkins-ci.org/debian/jenkins-ci.org.key | \</strong><br/><strong> sudo apt-key add -</strong>
</pre>

      <p style="padding-left: 60px">Here, we are using <code>wget</code> to download the PGP public key, and then we add it to the list of trusted keys using the <code>apt-key</code> tool. Since Ubuntu and Debian share the same software packaging, Jenkins provides a single common package for both Ubuntu and Debian.</p>

      <ol start="2">
        <li>Add the Debian package location to the <code>apt</code> package source list, as follows:</li>
      </ol>

      <pre><strong> $ sudo sh -c \</strong><br/><strong> 'echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; \</strong><br/><strong> /etc/apt/sources.list.d/jenkins.list'</strong>
</pre>

      <ol start="3">
        <li>After adding the package source, continue to run the <code>apt-get</code> command <code>update</code> option to resynchronize the package index from the sources:</li>
      </ol>

      <pre>      <strong>$ sudo apt-get update</strong>
</pre>

      <ol start="4">
        <li>Now, install Jenkins using the <code>apt-get</code> command <code>install</code> option, as demonstrated here:</li>
      </ol>

      <pre>      <strong>$ sudo apt-get install jenkins</strong>
</pre>

      <ol start="5">
        <li>Finally, activate the Jenkins service using the <code>service</code> command:</li>
      </ol>

      <pre>      <strong>$ sudo service jenkins start</strong>
</pre>

      <p style="padding-left: 60px">The Jenkins service can be accessed through any web browser by specifying the IP address (<code>54.86.87.243</code>) of the system in which Jenkins is installed. The default port number for Jenkins is <code>8080</code>. The latest Jenkins 2.62 is already installed. The following screenshot is the entry page or dashboard of Jenkins:</p>

      <div><img class="image-border" height="225" src="img/image_09_002.jpg" width="498"/>
      </div>

      <ol start="6">
        <li>Provide the password from the file and login. This user is the admin:</li>
      </ol>

      <pre><strong> $ sudo cat \</strong><br/><strong> /var/lib/jenkins/secrets/initialAdminPassword</strong><br/><strong> b7ed7cfbde1443819455ab1502a19de2</strong>
</pre>

      <ol start="7">
        <li>This will take you to the Customize Jenkins page, as shown in the following screenshot:</li>
      </ol>

      <div><img class="image-border" height="227" src="img/image_09_003.jpg" width="405"/>
      </div>

      <ol start="8">
        <li>Select Install suggested plugins on the left-hand side of the screen, which will take us to the installation page.</li>
      </ol>

      <ol start="9">
        <li>On the Create First Admin User page, select Continue as admin:</li>
      </ol>

      <div><strong><img class="image-border" height="325" src="img/image_09_004.jpg" width="438"/></strong>
      </div>

      <p style="padding-left: 60px">This will take us to the Jenkins is ready! page, as shown in the following screenshot:</p>

      <div><img class="image-border" height="153" src="img/image_09_005.jpg" width="486"/>
      </div>

      <ol start="10">
        <li>Now, clicking on the Start using Jenkins button will take you to the Welcome to Jenkins! page:</li>
      </ol>

      <div><img class="image-border" height="221" src="img/image_09_006.jpg" width="488"/>
      </div>

      <ol start="11">
        <li>Ensure that the <code>git</code> package is installed, otherwise install the <code>git</code> package using the <code>apt-get</code> command:</li>
      </ol>

      <pre>      <strong>$ sudo apt-get install git</strong>
</pre>

      <ol start="12">
        <li>So far, we have been running the Docker client using the <code>sudo</code> command, but unfortunately, we could not invoke <code>sudo</code> inside Jenkins because sometimes it prompts for a password. To overcome the <code>sudo</code> password prompt issue, we can make use of the Docker group, wherein any user who is part of the Docker group can invoke the Docker client without using the <code>sudo</code> command. Jenkins installation always sets up a user and group called <code>jenkins</code> and runs the Jenkins server using that user and group. So, we just need to add the <code>jenkins</code> user to the Docker group to get the Docker client working without the sudo command:</li>
      </ol>

      <pre><strong> $ sudo gpasswd -a jenkins docker</strong><br/><strong> Adding user jenkins to group docker</strong>  
</pre>

      <ol start="13">
        <li>Restart the Jenkins service for the group change to take effect using the following command:</li>
      </ol>

      <pre><strong> $ sudo service jenkins restart</strong><br/><strong> * Restarting Jenkins Continuous Integration Server<br/> jenkins [ OK ]</strong>  
</pre>

      <p>We have set up a Jenkins environment that is now capable of automatically pulling the latest source code from the <a href="http://github.com">http://github.com</a> repository, packaging it as a Docker image, and executing the prescribed test scenarios.</p>

      <p>You are also encouraged to run Jenkins as a Docker container from the official Jenkins Docker image at <a href="https://github.com/jenkinsci/docker">https://github.com/jenkinsci/docker</a>. This will be very good exercise also to validate your Docker container concepts from previous chapters.</p>
    
  

  
    
      <h3 id="sigil_toc_id_130">Automating the Docker testing process</h3>
    

    
      <p>In this section, we will explore how to automate testing using Jenkins and Docker. As mentioned earlier, we are going to use GitHub as our repository. We have already uploaded the <code>Dockerfile</code>, <code>test_hitcount.py</code>, and <code>hitcount.py</code> files of our previous example to GitHub at <a href="https://github.com/thedocker/testing">https://github.com/thedocker/testing</a>, which we are to use in the ensuing example. However, we strongly encourage you to set up your own repository at<br/> <a href="http://github.com">http://github.com</a>, using the fork option that you can find at <a href="https://github.com/thedocker/testing">https://github.com/thedocker/testing</a>, and substitute this address wherever applicable in the ensuing example.</p>

      <p>The following are the detailed steps to automate Docker testing:</p>

      <p>Configure Jenkins to trigger a build when a file is modified in the GitHub repository, which is illustrated in the following substeps:</p>

      <ol>
        <li>Connect to the Jenkins server again.</li>

        <li>Select create new jobs.</li>
      </ol>

      <ol start="3">
        <li>As shown in the following screenshot, give a name to the project (for example, <code>Docker-Testing</code>), and select Freestyle project:</li>
      </ol>

      <div><img class="image-border" src="img/JenkinsUpdate_1.png"/>
      </div>

      <ol start="4">
        <li>As shown in the next screenshot, select the Git radio button under Source Code Management, and specify the GitHub repository URL in the Repository URL text field:</li>
      </ol>

      <div><img class="image-border" height="223" src="img/image_09_008.jpg" width="452"/>
      </div>

      <ol start="5">
        <li>Select Poll SCM under Build Triggers to schedule GitHub polling for every<br/> 15-minute interval. Type the following line of code <code>H/15 * * * *</code> in the Schedule textbox, as shown in the following screenshot. For testing purposes, you can reduce the polling interval:</li>
      </ol>

      <div><img class="image-border" src="img/JenkinsUpdate_2.png"/>
      </div>

      <ol start="6">
        <li>Scroll down the screen a little further and click on the Add build step button under Build. In the drop-down list, select Execute shell and type in the text, as shown in the following screenshot:</li>
      </ol>

      <div><img class="image-border" src="img/JenkinsUpdate_3.png"/>
      </div>

      <ol start="7">
        <li>Finally, save the configuration by clicking on the Save button.</li>

        <li>Go back to the Jenkins dashboard, and you can find your test listed on the dashboard:</li>
      </ol>

      <div><img class="image-border" height="155" src="img/image_09_011.jpg" width="581"/>
      </div>

      <ol start="9">
        <li>You can either wait for the Jenkins schedule to kick-start the build or you can click on the clock icon on the right-hand side of the screen to kick-start the build immediately. As soon as the build is done, the dashboard is updated with the build status as a success or failure and the build number:</li>
      </ol>

      <div><img class="image-border" height="138" src="img/image_09_012.jpg" width="411"/>
      </div>

      <ol start="10">
        <li>If you hover the mouse closer to the build number, you will get a drop-down button with options, such as Changes and Console Output, as shown in the following screenshot:</li>
      </ol>

      <div><img class="image-border" height="237" src="img/image_09_013.jpg" width="408"/>
      </div>

      <ol start="11">
        <li>The Console Output option will show the details highlighted for the build, as follows:</li>
      </ol>

      <pre><strong> Started by user Vinod Singh</strong><br/><strong> Building in workspace <br/> /var/lib/jenkins/workspace/Docker-testing</strong><br/><strong> Cloning the remote Git repository</strong><br/><strong> Cloning repository <br/> https://github.com/thedocker/testing</strong><br/><strong> &gt; git init \ <br/> /var/lib/jenkins/workspace/Docker-testing \<br/> # timeout=10</strong><br/><strong> Fetching upstream changes from <br/> https://github.com/thedocker/testing</strong><br/><strong> &gt; git --version # timeout=10</strong><br/><strong> Removing intermediate container 76a53284f1e3</strong><br/><strong> Successfully built d9e22d1d52c6</strong><br/><strong> + docker run --rm docker_testing_using_jenkins</strong><br/><strong> .</strong><br/><strong> --------------------------------------------<br/> --------------------------</strong><br/><strong> Ran 1 test in 0.000s</strong><br/><br/><strong> OK</strong><br/><strong> Finished: SUCCESS</strong>
</pre>

      <ol start="12">
        <li>Now, let's test the failed case because of the wrong module name, <code>error_hitcount</code>, which we deliberately introduced. Now, let's experiment a negative scenario by deliberately introducing a bug in <code>test_hitcount.py</code> and observe the effect on the Jenkins build. As we have configured Jenkins, it faithfully polls the GitHub and kick-starts the build.</li>
      </ol>

      <p style="padding-left: 60px">Apparently, the build failed as we expected:</p>

      <div><img class="image-border" height="149" src="img/image_09_014.jpg" width="449"/>
      </div>

      <ol start="13">
        <li>As a final step, open Console Output of the failed build:</li>
      </ol>

      <pre><strong> Started by an SCM change</strong><br/><strong> Building in workspace <br/> /var/lib/jenkins/jobs/Docker-Testing/workspace</strong><br/><strong> . . . OUTPUT TRUNCATED . . . </strong><br/><strong> ImportError: No module named 'error_hitcount'</strong><br/><br/><br/><strong> ---------------------------------------------<br/> -------------------------</strong><br/><strong> Ran 1 test in 0.001s</strong><br/><br/><strong> FAILED (errors=1)</strong><br/><strong> Build step 'Execute shell' marked build as failure</strong><br/><strong> Finished: FAILURE</strong>  
</pre>

      <p style="padding-left: 60px">Evidently, the test failed because of the wrong module name, <code>error_hitcount</code>, which we deliberately introduced.</p>

      <p>Cool, isn't it? We automated our testing using Jenkins and Docker. Besides, we are able to experience the power of testing automation using Jenkins and Docker. In a large-scale project, Jenkins and Docker can be combined together to automate the complete unit testing needs, and thus, to automatically capture any defects and deficiencies introduced by any developers.</p>
    
  

  
    
      <h2 id="sigil_toc_id_131">Summary</h2>
    

    
      <p>The potential benefits of containerization are being discovered across the breadth and the length of software engineering. Previously, testing sophisticated software systems involved a number of expensive and hard-to-manage server modules and clusters. Considering the costs and complexities involved, most of the software testing is accomplished using mocking procedures and stubs. All of this is going to end for good with the maturity of the Docker technology. The openness and flexibility of Docker enable it to work seamlessly with other technologies to substantially reduce the testing time and complexity.</p>

      <p>For a long time, the leading ways of testing software systems included mocking, dependency, injection, and so on. Usually, these mandate creating many sophisticated abstractions in the code. The current practice for developing and running test cases against an application is actually done on stubs rather than on the full application. This means that, with a containerized workflow, it is very much possible to test against real application containers with all the dependencies. The contributions of the Docker paradigm, especially for the testing phenomenon and phase are therefore being carefully expounded and recorded in the recent past. Precisely speaking, the field of software engineering is moving towards smarter and sunnier days with all the innovations in the Docker space.</p>

      <p>In this chapter, we clearly expounded and explained a powerful testing framework for integrated applications using the Docker-inspired containerization paradigm. Increasingly, for the agile world, the proven and potential TDD method is being insisted as an efficient software building and sustenance methodology. This chapter has utilized the Python unit test framework to illustrate how the TDD methodology is a pioneering tool for software engineering. The unit test framework is tweaked to be efficiently and elegantly containerized, and the Docker container is seamlessly integrated with Jenkins, which is a modern day deployment tool for continuous delivery, and is part and parcel of the agile programming world, as described in this chapter. The Docker container source code is pre-checked before it enters into the GitHub code repository. The Jenkins tool downloads the code from GitHub and runs the test inside a container. In the next chapter, we will dive deep into and describe the theoretical aspects of the process isolation through the container technology and various debugging tools and techniques.</p>
    
  
</body></html>