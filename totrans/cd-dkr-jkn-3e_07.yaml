- en: '*Chapter 5*: Automated Acceptance Testing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've configured the commit phase of the **continuous delivery** (**CD**) process
    and it's now time to address the acceptance testing phase, which is usually the
    most challenging part. By gradually extending the pipeline, we will see different
    aspects of a well-executed acceptance testing automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using the Docker Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance tests in the Jenkins pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing acceptance tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you''ll need the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java Development Kit** (**JDK**) 8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All examples and solutions to the exercises can be found at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3Ki1alm](https://bit.ly/3Ki1alm).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Acceptance testing** is a step performed to determine whether the business
    requirements or contracts are met. It involves black-box testing against a complete
    system from a user perspective, and a positive result means acceptance of the
    software delivery. Sometimes also called **user acceptance testing** (**UAT**)
    or end-user testing, it is a phase of the development process where software meets
    a *real-world* audience.'
  prefs: []
  type: TYPE_NORMAL
- en: Many projects rely on manual steps performed by **quality assurers** (**QAs**)
    or users to verify the **functional** and **non-functional requirements** (**FRs**
    and **NFRs**), but still, it's way more reasonable to run them as programmed repeatable
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automated acceptance tests, however, can be considered difficult due to their
    specifics, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-facing**: They need to be written together with a user, which requires
    an understanding between two worlds—technical and non-technical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies integration**: The tested application should be run together
    with its dependencies in order to check that the system as a whole works properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging environment**: The staging (testing) environment needs to be identical
    to the production one so as to ensure the same functional and non-functional behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application identity**: Applications should be built only once, and the same
    binary should be transferred to production. This eliminates the risk of different
    building environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relevance and consequences**: If the acceptance test passes, it should be
    clear that the application is ready for release from the user''s perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We address all these difficulties in different sections of this chapter. Application
    identity can be achieved by building the Docker image only once and using Docker
    Registry for its storage and versioning. Creating tests in a user-facing manner
    is explained in the *Writing acceptance tests* section, and the environment identity
    is addressed by the Docker tool itself and can also be improved by other tools
    described in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing can have multiple meanings; in this book, we treat acceptance
    testing as a complete integration test suite from a user perspective, excluding
    NFRs such as performance, load, and recovery.
  prefs: []
  type: TYPE_NORMAL
- en: Since we understand the goal and meaning of acceptance testing, let's describe
    the first aspect we need—the **Docker Registry**.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using the Docker Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker Registry is a store for Docker images. To be precise, it is a stateless
    server application that allows the images to be published (pushed) and later retrieved
    (pulled). In [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034), *Introducing
    Docker*, we already saw an example of the Registry when running the official Docker
    images, such as `hello-world`. We pulled the images from Docker Hub, which is
    an official cloud-based Docker Registry. Having a separate server to store, load,
    and search software packages is a more general concept called the software repository
    or, in even more general terms, the artifact repository. Let's look closer at
    this idea.
  prefs: []
  type: TYPE_NORMAL
- en: The artifact repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the source control management stores the source code, the artifact repository
    is dedicated to storing software binary artifacts, such as compiled libraries
    or components, later used to build a complete application. *Why do we need to
    store binaries on a separate server using a separate tool?* Here''s why:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File size**: Artifact files can be large, so the systems need to be optimized
    for their download and upload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versions**: Each uploaded artifact needs to have a version that makes it
    easy to browse and use. Not all versions, however, have to be stored forever;
    for example, if there was a bug detected, we may not be interested in the related
    artifact and remove it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revision mapping**: Each artifact should point to exactly one revision of
    the source control and, what''s more, the binary creation process should be repeatable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packages**: Artifacts are stored in a compiled and compressed form so that
    these time-consuming steps don''t need to be repeated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access control**: Users can be restricted differently in terms of access
    to the source code and artifact binary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clients**: Users of the artifact repository can be developers outside the
    team or organization who want to use the library via its public **application
    programming interface** (**API**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use cases**: Artifact binaries are used to guarantee that exactly the same
    build version is deployed to every environment to ease the rollback procedure
    in case of failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The most popular artifact repositories are **JFrog Artifactory** and **Sonatype
    Nexus**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The artifact repository plays a special role in the CD process because it guarantees
    that the same binary is used throughout all pipeline steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Artifact repository in the CD process'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Artifact repository in the CD process
  prefs: []
  type: TYPE_NORMAL
- en: The **developer** pushes a change to the **source code repository**, which triggers
    the pipeline build. As the last step of the **commit stage**, a binary is created
    and stored in the **artifact repository**. Afterward, during all other stages
    of the delivery process, the same binary is (pulled and) used.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The binary is often called the **release candidate**, and the process of moving
    the binary to the next stage is called **promotion**.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the programming language and technologies, the binary formats can
    differ. For example, in the case of Java, **Java ARchive** (**JAR**) files are
    usually stored and, in the case of Ruby, gem files. We work with Docker, so we
    will store Docker images as artifacts, and the tool to store Docker images is
    called the **Docker Registry**.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Some teams maintain two repositories at the same time; the artifact repository
    for JAR files and the Docker Registry for Docker images. While it may be useful
    during the first phase of the Docker introduction, there is no good reason to
    maintain both forever.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Docker Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install a Docker Registry. There are a number of options
    available, but all of them fall into two categories: a cloud-based Docker Registry
    and a self-hosted Docker Registry. Let''s dig into them.'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based Docker Registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The benefit of using a cloud-based service is that you don't need to install
    or maintain anything on your own. There are a number of cloud offerings available;
    however, Docker Hub is by far the most popular. That is why we will use it throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Docker Hub provides a Docker Registry service and other related features, such
    as building images, testing them, and pulling code directly from the code repository.
    Docker Hub is cloud-hosted, so it does not really need any installation process.
    All you need to do is create a Docker Hub account, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://hub.docker.com/](https://hub.docker.com/) in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Sign Up**, fill in the password, email address, and Docker **identifier**
    (**ID**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After receiving an email and clicking the activation link, an account is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Hub is definitely the simplest option to start with, and it allows the
    storing of both private and public images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub alternatives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are more cloud offerings worth mentioning. First of all, each of the
    following three main cloud platforms offers its own Docker Registry:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon **Elastic Container Registry** (**ECR**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Artifact Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Container Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other widely used solutions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Quay Container Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JFrog Artifactory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab Container Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the mentioned registries implement the same Docker Registry protocol,
    so the good news is that no matter which you choose, the commands used are exactly
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Self-hosted Docker Registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud solutions may not always be acceptable. They are not free for enterprises
    and, what's even more important, a lot of companies have policies not to store
    their software outside their own network. In this case, the only option is to
    install a self-hosted Docker Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Registry installation process is quick and simple, but making it
    secure and available in public requires setting up access restrictions and the
    domain certificate. This is why we split this section into three parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker Registry application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a domain certificate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an access restriction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a look at each part.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker Registry application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Docker Registry is available as a Docker image. To start this, we can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: By default, the registry data is stored as a Docker volume in the default host
    filesystem's directory. To change it, you can add `-v <host_directory>:/var/lib/registry`.
    Another alternative is to use a volume container.
  prefs: []
  type: TYPE_NORMAL
- en: The command starts the registry and makes it accessible through port `5000`.
    The `registry` container is started from the registry image (version 2). The `--restart=always`
    option causes the container to automatically restart whenever it's down.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider setting up a load balancer and starting a few Docker Registry containers
    in case of a large number of users. Note that, in such a case, they need to share
    the storage or have a synchronization mechanism in place.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a domain certificate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the registry is run on the localhost, then everything works fine and no other
    installation steps are required. However, in most cases, we want to have a dedicated
    server for the registry so that the images are widely available. In that case,
    Docker requires the securing of the registry with `--insecure-registry` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can read about creating and using self-signed certificates at [https://docs.docker.com/registry/insecure/#use-self-signed-certificates](https://docs.docker.com/registry/insecure/#use-self-signed-certificates).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the certificates are either signed by the CA or self-signed, we can move
    `domain.crt` and `domain.key` to the `certs` directory and start the registry,
    which listens on the default **HyperText Transfer Protocol Secure** (**HTTPS**)
    port, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the `--insecure-registry` flag is not recommended since it provides no
    proper CA verification.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Read more about setting up Docker registries and making them secure in the official
    Docker documentation at [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding an access restriction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unless we use the registry inside a highly secure private network, we should
    configure authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to do this is to create a user with a password using the `htpasswd`
    tool from the `registry` image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The command runs the `htpasswd` tool to create an `auth/htpasswd` file (with
    one user inside). Then, we can run the registry with that one user authorized
    to access it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The command, in addition to setting the certificates, creates an access restriction
    limited to the users specified in the `auth/passwords` file.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, before using the registry, a client needs to specify the username
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Access restriction doesn't work in the case of the `--insecure-registry` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When our registry is configured, we can show how to work with it in three stages,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing the image into the registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling the image from the registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s use the example from [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034),
    *Introducing Docker*, and build an image with Ubuntu and the Python interpreter
    installed. In a new directory, we need to create a Dockerfile, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can build the image with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After the image is built, we can push it into the Docker Registry.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the image into the registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to push the created image, we need to tag it according to the naming
    convention, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `registry_address` value can be either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A username in the case of Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A domain name or `localhost:5000`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, `<tag>` is in the form of the image/application version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s tag the image to use Docker Hub, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember to use your Docker Hub username instead of `leszko`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have also tagged the image in the `build` command, like this: `docker
    build -t leszko/ubuntu_with_python:1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the repository has access restriction configured, we need to authorize it
    first, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: If you use a Docker Registry other than Docker Hub, then you also need to add
    a `login` command—for example, `docker login quay.io`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can store the image in the registry using the `push` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no need to specify the registry address because Docker uses
    the naming convention to resolve it. The image is stored, and we can check it
    using the Docker Hub web interface available at [https://hub.docker.com](https://hub.docker.com).
  prefs: []
  type: TYPE_NORMAL
- en: Pulling the image from the registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate how the registry works, we can remove the image locally and
    retrieve it from the registry, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the image has been removed using the `docker images` command.
    Then, let''s retrieve the image back from the registry by executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you use a free Docker Hub account, you may need to change the `ubuntu_with_python`
    repository to `public` before pulling it.
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm that the image is back with the `docker images` command.
  prefs: []
  type: TYPE_NORMAL
- en: When we have the registry configured and understand how it works, we can see
    how to use it inside the CD pipeline and build the acceptance testing stage.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests in the Jenkins pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already understand the idea behind acceptance testing and know how to configure
    the Docker Registry, so we are ready for its first implementation inside the Jenkins
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram, which presents the process we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Acceptance tests in the Jenkins pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Acceptance tests in the Jenkins pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The process goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer pushes a code change to GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins detects the change, triggers the build, and checks out the current code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins executes the commit phase and builds the Docker image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins pushes the image to the **Docker Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins runs the Docker container in the staging environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker host on the staging environment needs to pull the image from the
    Docker Registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins runs the acceptance test suite against the application running in the
    staging environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the sake of simplicity, we will run the Docker container locally (and not
    on a separate staging server). In order to run it remotely, we need to use the
    `-H` option or configure the `DOCKER_HOST` environment variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s continue the pipeline we started in [*Chapter 4*](B18223_04_ePub.xhtml#_idTextAnchor106),
    *Continuous Integration Pipeline*, and add three more stages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Docker build`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Docker push`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Acceptance test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that you need to have the Docker tool installed on the Jenkins
    executor (agent or master, in the case of agentless configuration) so that it
    can build Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you use dynamically provisioned Docker agents, then make sure you use the
    `leszko/jenkins-docker-slave` image. Remember to also mark the `privileged` option
    in the Docker agent configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker build stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We would like to run the calculator project as a Docker container, so we need
    to create a Dockerfile and add the `Docker build` stage to the Jenkinsfile.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Dockerfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a Dockerfile in the root directory of the calculator project,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The default build directory for Gradle is `build/libs/`, and `calculator-0.0.1-SNAPSHOT.jar`
    is the complete application packaged into one JAR file. Note that Gradle automatically
    versioned the application using the `0.0.1-SNAPSHOT` Maven-style version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile uses a base image that contains the `openjdk:11-jre`). It also
    copies the application JAR (created by Gradle) and runs it. Let''s now check whether
    the application builds and runs by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding commands, we've built the application, built the Docker
    image, and run the Docker container. After a while, we should be able to open
    the browser at `http://localhost:8080/sum?a=1&b=2` and see `3` as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can stop the container and push the Dockerfile to the GitHub repository,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Docker build to the pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final step we need to perform is to add the `Docker build` stage to the
    Jenkinsfile. Usually, the JAR packaging is also declared as a separate `Package`
    stage, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: We don't explicitly version the image, but each image has a unique hash ID.
    We will cover explicit versioning in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used the Docker Registry name in the image tag. There is no need
    to have the image tagged twice as `calculator` and `leszko/calculator`.
  prefs: []
  type: TYPE_NORMAL
- en: When we commit and push the Jenkinsfile, the pipeline build should start automatically
    and we should see all boxes in green. This means that the Docker image has been
    built successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you see a failure in the Docker build stage, then most probably, your Jenkins
    executor doesn't have access to the Docker daemon. In case you use the Jenkins
    master as the executor, make sure that the `jenkins` user is added to the `docker`
    user group. In case you use Jenkins agents, make sure they have access to the
    Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker push stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the image is ready, we can store it in the registry. The `Docker push`
    stage is very simple. It''s enough to add the following code to the Jenkinsfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: If the Docker Registry has access restricted, first, we need to log in using
    the `docker login` command. Needless to say, the credentials must be well secured—for
    example, using a dedicated credential store, as described on the official Docker
    page at [https://docs.docker.com/engine/reference/commandline/login/#credentials-store](https://docs.docker.com/engine/reference/commandline/login/#credentials-store).
  prefs: []
  type: TYPE_NORMAL
- en: As always, pushing changes to the GitHub repository triggers Jenkins to start
    the build and, after a while, we should have the image automatically stored in
    the registry.
  prefs: []
  type: TYPE_NORMAL
- en: The acceptance testing stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To perform acceptance testing, we first need to deploy the application to the
    staging environment and then run the acceptance test suite against it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a staging deployment to the pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add a stage to run the `calculator` container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After running this stage, the `calculator` container is running as a daemon,
    publishing its port as `8765`, and being removed automatically when stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are ready to add the acceptance test to our Jenkins pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an acceptance test to the pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Acceptance testing usually requires running a dedicated black-box test suite
    that checks the behavior of the system. We will cover it in the *Writing acceptance
    tests* section. At the moment, for the sake of simplicity, let's perform acceptance
    testing simply by calling the web service endpoint with the `curl` tool and checking
    the result using the `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root directory of the project, let''s create an `acceptance_test.sh`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We call the `sum` endpoint with the `a=1` and `b=2` parameters and expect to
    receive `3` in response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, an `Acceptance test` stage can be added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since the `docker run -d` command is asynchronous, we need to wait, using the
    `sleep` operation to make sure the service is already running.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: There is no good way to check whether the service is already running. An alternative
    to sleeping could be a script checking every second to see whether the service
    has already started.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our pipeline has already performed the automated acceptance tests.
    One last thing we should never forget about is to add a cleanup stage.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a cleanup stage environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the final stage of acceptance testing, we can add the staging environment
    cleanup. The best place to do this is in the `post` section, to make sure it executes
    even in case of failure. Here''s the code we need to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This statement makes sure that the `calculator` container is no longer running
    on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Writing acceptance tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we used the `curl` command to perform a suite of acceptance tests.
    That is, obviously, a considerable simplification. Technically speaking, if we
    write a `curl` calls. However, this solution would be very difficult to read,
    understand, and maintain. What''s more, the script would be completely incomprehensible
    to non-technical, business-related users. *How do we address this issue and create
    tests with a good structure that are readable by users and meet their fundamental
    goal: automatically checking that the system is as expected?* I will answer this
    question throughout this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing user-facing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Acceptance tests are written with users and should be comprehensible to users.
    This is why the choice of a method for writing them depends on who the customer
    is.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a purely technical person. If you write a web service that
    optimizes database storage and your system is used only by other systems and read-only
    by other developers, your tests can be expressed in the same way as unit tests.
    As a rule, the test is good if understood by both developers and users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In real life, most software is written to deliver a specific business value,
    and that business value is defined by non-developers. Therefore, we need a common
    language to collaborate. On one side, there is the business, which understands
    what is needed but not how to do it; on the other side, the development team knows
    how but doesn''t know what. Luckily, there are a number of frameworks that helps
    to connect these two worlds, such as **Cucumber**, **FitNesse**, **JBehave**,
    and **Capybara**. They differ from each other, and each of them may be a subject
    for a separate book; however, the general idea of writing acceptance tests is
    the same and is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – User-facing acceptance tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – User-facing acceptance tests
  prefs: []
  type: TYPE_NORMAL
- en: 'The **acceptance criteria** are written by users (or a product owner as their
    representative), with the help of developers. They are usually written in the
    form of the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Developers write the testing implementation, called **fixtures** or **step definitions**,
    that integrates the human-friendly **domain-specific language** (**DSL**) specification
    with the programming language. As a result, we have an automated test that can
    be easily integrated into the CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to add, writing acceptance tests is a continuous Agile process, not
    a Waterfall one. It requires constant collaboration, during which the test specifications
    are improved and maintained by both developers and the business.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an application with a **user interface** (**UI**), it can be
    tempting to perform the acceptance test directly through the interface (for example,
    by recording Selenium scripts). However, this approach, when not done properly,
    can lead to tests that are slow and tightly coupled to the interface layer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how writing acceptance tests looks in practice and how to bind them
    to the CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Using the acceptance testing framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use the Cucumber framework and create an acceptance test for the calculator
    project. As previously described, we will do this in three stages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating acceptance criteria
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating step definitions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running an automated acceptance test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating acceptance criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s put the business specification in `src/test/resources/feature/calculator.feature`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This file should be created by users with the help of developers. Note that
    it is written in a way that non-technical people can understand.
  prefs: []
  type: TYPE_NORMAL
- en: Creating step definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is to create Java bindings so that the feature specification
    will be executable. In order to do this, we create a new file, `src/test/java/acceptance/StepDefinitions.java`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line (`Given`, `When`, and `Then`) from the feature specification file
    is matched by `(.*)` are passed as parameters. Note that the server address is
    passed as the `calculator.url` Java property. The method performs the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i_have_two_numbers`: Saves parameters as fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`the_calculator_sums_them`: Calls the remote calculator service and stores
    the result in a field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i_receive_as_a_result`: Asserts that the result is as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running an automated acceptance test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run an automated test, we need to make a few configurations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Java Cucumber libraries. In the `build.gradle` file, add the following
    code to the `dependencies` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Gradle target. In the same file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This splits the tests into unit tests (run with `./gradlew test`) and acceptance
    tests (run with `./gradlew acceptanceTest`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a JUnit Test Runner, add a new file, `src/test/java/acceptance/AcceptanceTest.java`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the entry point to the acceptance test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this configuration, if the server is running on the localhost, we can
    test it by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we can add this command instead of `acceptance_test.sh`. This would
    make the Cucumber acceptance test run in the Jenkins pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance test-driven development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Acceptance tests, as with most aspects of the CD process, are less about technology
    and more about people. The test quality depends, of course, on the engagement
    of users and developers, but also, what is maybe less intuitive is the time when
    the tests are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last question to ask is this: *During which phase of the software development
    life cycle should the acceptance tests be prepared?* Or, to rephrase it: *Should
    we create acceptance tests before or after writing the code?*'
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, the result is the same; the code is well covered with
    both unit and acceptance tests. However, it's tempting to consider writing tests
    first. The idea of **test-driven development** (**TDD**) can be well adapted for
    acceptance testing. If unit tests are written before the code, the resulting code
    is cleaner and better structured. Analogously, if acceptance tests are written
    before the system feature, the resulting feature corresponds better to the customer's
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process, often called acceptance TDD, is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Acceptance TDD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Acceptance TDD
  prefs: []
  type: TYPE_NORMAL
- en: Users (with developers) write the acceptance criteria specification in the human-friendly
    DSL format. Developers write the fixtures, and the tests fail. Then, feature development
    starts using the TDD methodology internally. Once the feature is completed, the
    acceptance test should pass, and this is a sign that the feature is completed.
  prefs: []
  type: TYPE_NORMAL
- en: A very good practice is to attach the Cucumber feature specification to the
    request ticket in the issue-tracking tool (for example, JIRA) so that the feature
    would always be requested together with its acceptance test. Some development
    teams take an even more radical approach and refuse to start the development process
    if no acceptance tests are prepared. There is a lot of sense in that. After all,
    how can you develop something that the client can't test?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to build a complete and functional acceptance
    test stage, which is an essential part of the CD process. Here are the key takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests can be difficult to create because they combine technical challenges
    (application dependencies; setting up the environment) with personal challenges
    (developer/business collaboration).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing frameworks provide a way to write tests in a human-friendly
    language that makes them comprehensible to non-technical people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Registry is an artifact repository for Docker images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Registry fits well with the CD process because it provides a way
    to use exactly the same Docker image throughout the stages and environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will cover clustering and service dependencies, which
    is the next step toward creating a complete CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered a lot of new material throughout this chapter, so to aid your understanding,
    I recommend doing the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Ruby-based web service, `book-library`, to store books.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The acceptance criteria are delivered in the form of the following Cucumber
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Write step definitions for the Cucumber test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the web service (the simplest way is to use the Sinatra framework (http://www.sinatrarb.com/),
    but you can also use Ruby on Rails).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The book should have the following attributes: `name`, `author`, and `ISBN`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The web service should have the following endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST /books` to add a book'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /books/<isbn>` to retrieve the book'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The data can be stored in the memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end, check that the acceptance test is green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `book-library` as a Docker image to the Docker Registry by doing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an account on Docker Hub.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Dockerfile for the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the Docker image and tag it according to the naming convention.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the image to Docker Hub.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Jenkins pipeline to build the Docker image, push it to the Docker
    Registry, and perform acceptance testing by doing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Docker build` stage.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `Docker login` and `Docker push` stages.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Acceptance test` stage to the pipeline.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the pipeline and observe the result.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To verify the knowledge acquired from this chapter, please answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the Docker Registry?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Docker Hub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the convention for naming Docker images (later pushed to the Docker
    Registry)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the staging environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Docker commands would you use to build an image and push it into Docker
    Hub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main purpose of acceptance testing frameworks such as Cucumber and
    FitNesse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three main parts of a Cucumber test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is acceptance TDD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about Docker Registry, acceptance testing, and Cucumber, please
    refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Registry documentation**: [https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jez Humble*, *David Farley*—*Continuous Delivery*: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cucumber framework**: [https://cucumber.io/](https://cucumber.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
