- en: '*Chapter 5*: Automated Acceptance Testing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：自动化验收测试'
- en: We've configured the commit phase of the **continuous delivery** (**CD**) process
    and it's now time to address the acceptance testing phase, which is usually the
    most challenging part. By gradually extending the pipeline, we will see different
    aspects of a well-executed acceptance testing automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了**持续交付**（**CD**）过程中的提交阶段，现在是时候处理验收测试阶段了，这通常是最具挑战性的部分。通过逐步扩展管道，我们将看到一个执行良好的验收测试自动化的不同方面。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introducing acceptance testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入验收测试
- en: Installing and using the Docker Registry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用Docker Registry
- en: Acceptance tests in the Jenkins pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins管道中的验收测试
- en: Writing acceptance tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写验收测试
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you''ll need the following software:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为完成本章内容，您需要以下软件：
- en: Jenkins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: Docker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: The **Java Development Kit** (**JDK**) 8+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java开发工具包**（**JDK**）8+'
- en: All examples and solutions to the exercises can be found at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例和练习的解决方案可以在[https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter05)找到。
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3Ki1alm](https://bit.ly/3Ki1alm).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的Code in Action视频可以通过[https://bit.ly/3Ki1alm](https://bit.ly/3Ki1alm)观看。
- en: Introducing acceptance testing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入验收测试
- en: '**Acceptance testing** is a step performed to determine whether the business
    requirements or contracts are met. It involves black-box testing against a complete
    system from a user perspective, and a positive result means acceptance of the
    software delivery. Sometimes also called **user acceptance testing** (**UAT**)
    or end-user testing, it is a phase of the development process where software meets
    a *real-world* audience.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收测试**是用来确定业务需求或合同是否满足的步骤。它涉及从用户角度对完整系统进行黑盒测试，测试通过的结果意味着软件交付的接受。有时也称为**用户验收测试**（**UAT**）或终端用户测试，这是开发过程中的一个阶段，软件面对的是*真实世界*的受众。'
- en: Many projects rely on manual steps performed by **quality assurers** (**QAs**)
    or users to verify the **functional** and **non-functional requirements** (**FRs**
    and **NFRs**), but still, it's way more reasonable to run them as programmed repeatable
    operations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目依赖于**质量保证人员**（**QA**）或用户执行的手动步骤来验证**功能**和**非功能要求**（**FRs**和**NFRs**），但从更合理的角度来看，还是将它们作为程序化的可重复操作来执行。
- en: 'Automated acceptance tests, however, can be considered difficult due to their
    specifics, as outlined here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自动化验收测试可能会因为其特性而变得困难，正如这里所描述的那样：
- en: '**User-facing**: They need to be written together with a user, which requires
    an understanding between two worlds—technical and non-technical.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向用户**：这些测试需要与用户一起编写，这需要在技术和非技术两个世界之间达成理解。'
- en: '**Dependencies integration**: The tested application should be run together
    with its dependencies in order to check that the system as a whole works properly.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖集成**：被测试的应用程序应与其依赖项一起运行，以确保整个系统正常工作。'
- en: '**Staging environment**: The staging (testing) environment needs to be identical
    to the production one so as to ensure the same functional and non-functional behavior.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂存环境**：暂存（测试）环境需要与生产环境完全相同，以确保相同的功能和非功能行为。'
- en: '**Application identity**: Applications should be built only once, and the same
    binary should be transferred to production. This eliminates the risk of different
    building environments.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序身份**：应用程序应该只构建一次，并将相同的二进制文件传输到生产环境。这消除了不同构建环境的风险。'
- en: '**Relevance and consequences**: If the acceptance test passes, it should be
    clear that the application is ready for release from the user''s perspective.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相关性与后果**：如果验收测试通过，那么从用户的角度来看，应用程序应该已准备好发布。'
- en: We address all these difficulties in different sections of this chapter. Application
    identity can be achieved by building the Docker image only once and using Docker
    Registry for its storage and versioning. Creating tests in a user-facing manner
    is explained in the *Writing acceptance tests* section, and the environment identity
    is addressed by the Docker tool itself and can also be improved by other tools
    described in the next chapters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的不同部分解决这些问题。通过只构建一次 Docker 镜像并使用 Docker 注册表进行存储和版本控制，可以实现应用程序身份。如何以用户面向的方式创建测试将在《编写验收测试》一节中解释，而环境身份则由
    Docker 工具本身解决，并且可以通过下一章中描述的其他工具进一步改进。
- en: Information
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Acceptance testing can have multiple meanings; in this book, we treat acceptance
    testing as a complete integration test suite from a user perspective, excluding
    NFRs such as performance, load, and recovery.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试可以有多种含义；在本书中，我们将验收测试视为从用户角度出发的完整集成测试套件，不包括性能、负载和恢复等非功能需求（NFRs）。
- en: Since we understand the goal and meaning of acceptance testing, let's describe
    the first aspect we need—the **Docker Registry**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了验收测试的目标和意义，接下来让我们描述我们需要的第一个方面——**Docker 注册表**。
- en: Installing and using the Docker Registry
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用 Docker 注册表
- en: The Docker Registry is a store for Docker images. To be precise, it is a stateless
    server application that allows the images to be published (pushed) and later retrieved
    (pulled). In [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034), *Introducing
    Docker*, we already saw an example of the Registry when running the official Docker
    images, such as `hello-world`. We pulled the images from Docker Hub, which is
    an official cloud-based Docker Registry. Having a separate server to store, load,
    and search software packages is a more general concept called the software repository
    or, in even more general terms, the artifact repository. Let's look closer at
    this idea.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 注册表是一个存储 Docker 镜像的地方。准确来说，它是一个无状态的服务器应用程序，允许镜像被发布（推送）并随后被检索（拉取）。在[*第2章*](B18223_02_ePub.xhtml#_idTextAnchor034)，《介绍
    Docker》中，我们已经看到过官方 Docker 镜像的例子，例如 `hello-world`。我们从 Docker Hub 拉取了这些镜像，Docker
    Hub 是一个官方的基于云的 Docker 注册表。拥有一个独立的服务器来存储、加载和搜索软件包是一个更为通用的概念，叫做软件仓库，或者更广义地称为文物库。让我们更深入地了解这个概念。
- en: The artifact repository
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文物库
- en: 'While the source control management stores the source code, the artifact repository
    is dedicated to storing software binary artifacts, such as compiled libraries
    or components, later used to build a complete application. *Why do we need to
    store binaries on a separate server using a separate tool?* Here''s why:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源代码管理存储源代码，但文物库专门用于存储软件二进制文物，如编译后的库或组件，稍后用于构建完整的应用程序。*为什么我们需要使用单独的服务器和工具来存储二进制文件？*
    下面是原因：
- en: '**File size**: Artifact files can be large, so the systems need to be optimized
    for their download and upload.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件大小**：文物文件可能很大，因此系统需要对其下载和上传进行优化。'
- en: '**Versions**: Each uploaded artifact needs to have a version that makes it
    easy to browse and use. Not all versions, however, have to be stored forever;
    for example, if there was a bug detected, we may not be interested in the related
    artifact and remove it.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：每个上传的文物需要有一个版本，以便轻松浏览和使用。然而，并非所有版本都必须永久保存；例如，如果发现了一个bug，我们可能对相关文物不感兴趣并将其删除。'
- en: '**Revision mapping**: Each artifact should point to exactly one revision of
    the source control and, what''s more, the binary creation process should be repeatable.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订映射**：每个文物应指向源代码管理的一个修订版本，并且更重要的是，二进制文件的创建过程应当是可重复的。'
- en: '**Packages**: Artifacts are stored in a compiled and compressed form so that
    these time-consuming steps don''t need to be repeated.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**：文物以编译和压缩的形式存储，这样就不需要重复这些耗时的步骤。'
- en: '**Access control**: Users can be restricted differently in terms of access
    to the source code and artifact binary.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制**：用户可以根据访问源代码和文物二进制文件的权限设置不同的限制。'
- en: '**Clients**: Users of the artifact repository can be developers outside the
    team or organization who want to use the library via its public **application
    programming interface** (**API**).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：文物库的用户可以是团队或组织外部的开发人员，他们希望通过公共**应用程序编程接口**（**API**）使用该库。'
- en: '**Use cases**: Artifact binaries are used to guarantee that exactly the same
    build version is deployed to every environment to ease the rollback procedure
    in case of failure.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用场景**：文物二进制文件用于确保每个环境中部署的构建版本完全相同，以便在失败时轻松回滚。'
- en: Information
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: The most popular artifact repositories are **JFrog Artifactory** and **Sonatype
    Nexus**.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最流行的制品库是**JFrog Artifactory**和**Sonatype Nexus**。
- en: The artifact repository plays a special role in the CD process because it guarantees
    that the same binary is used throughout all pipeline steps.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 制品库在CD过程中的作用特殊，因为它保证在所有管道步骤中使用相同的二进制文件。
- en: 'Let''s look at the following diagram to understand how it works:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图表来理解它是如何工作的：
- en: '![Figure 5.1 – Artifact repository in the CD process'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – CD过程中的制品库'
- en: '](img/B18223_05_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_05_01.jpg)'
- en: Figure 5.1 – Artifact repository in the CD process
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – CD过程中的制品库
- en: The **developer** pushes a change to the **source code repository**, which triggers
    the pipeline build. As the last step of the **commit stage**, a binary is created
    and stored in the **artifact repository**. Afterward, during all other stages
    of the delivery process, the same binary is (pulled and) used.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发人员**将变更推送到**源代码仓库**，触发管道构建。作为**提交阶段**的最后一步，创建并存储一个二进制文件到**制品库**中。之后，在交付过程的所有其他阶段，都会使用相同的二进制文件（被拉取并使用）。'
- en: Information
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The binary is often called the **release candidate**, and the process of moving
    the binary to the next stage is called **promotion**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件通常被称为**发布候选版**，将二进制文件移动到下一阶段的过程称为**晋升**。
- en: Depending on the programming language and technologies, the binary formats can
    differ. For example, in the case of Java, **Java ARchive** (**JAR**) files are
    usually stored and, in the case of Ruby, gem files. We work with Docker, so we
    will store Docker images as artifacts, and the tool to store Docker images is
    called the **Docker Registry**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同的编程语言和技术，二进制格式可能有所不同。例如，在Java的情况下，通常会存储**Java ARchive**（**JAR**）文件，而在Ruby的情况下，则是gem文件。我们使用Docker，因此我们会将Docker镜像作为制品存储，存储Docker镜像的工具被称为**Docker
    Registry**。
- en: Information
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Some teams maintain two repositories at the same time; the artifact repository
    for JAR files and the Docker Registry for Docker images. While it may be useful
    during the first phase of the Docker introduction, there is no good reason to
    maintain both forever.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队同时维护两个制品库，一个用于存储JAR文件的制品库，另一个用于存储Docker镜像的Docker Registry。虽然在Docker引入的初期阶段，这种做法可能有用，但没有必要一直维护两个库。
- en: Installing a Docker Registry
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Docker Registry
- en: 'First, we need to install a Docker Registry. There are a number of options
    available, but all of them fall into two categories: a cloud-based Docker Registry
    and a self-hosted Docker Registry. Let''s dig into them.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装一个Docker Registry。有很多可用的选项，但它们都属于两个类别：基于云的Docker Registry和自托管的Docker
    Registry。我们来深入了解一下它们。
- en: Cloud-based Docker Registry
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于云的Docker Registry
- en: The benefit of using a cloud-based service is that you don't need to install
    or maintain anything on your own. There are a number of cloud offerings available;
    however, Docker Hub is by far the most popular. That is why we will use it throughout
    this book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于云的服务的好处在于你不需要在自己本地安装或维护任何东西。有很多云服务可供选择，但Docker Hub无疑是最受欢迎的。这就是为什么我们在本书中会一直使用它的原因。
- en: Docker Hub
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker Hub
- en: 'Docker Hub provides a Docker Registry service and other related features, such
    as building images, testing them, and pulling code directly from the code repository.
    Docker Hub is cloud-hosted, so it does not really need any installation process.
    All you need to do is create a Docker Hub account, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub提供Docker Registry服务和其他相关功能，例如构建镜像、测试镜像，以及直接从代码仓库拉取代码。Docker Hub是基于云的，因此实际上不需要任何安装过程。你需要做的就是创建一个Docker
    Hub账户，步骤如下：
- en: Open [https://hub.docker.com/](https://hub.docker.com/) in a browser.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开[https://hub.docker.com/](https://hub.docker.com/)。
- en: In **Sign Up**, fill in the password, email address, and Docker **identifier**
    (**ID**).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**注册**中，填写密码、电子邮件地址和Docker **标识符**（**ID**）。
- en: After receiving an email and clicking the activation link, an account is created.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到电子邮件并点击激活链接后，会创建一个账户。
- en: Docker Hub is definitely the simplest option to start with, and it allows the
    storing of both private and public images.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub无疑是最简单的选择，适合初学者使用，并允许存储私有和公共镜像。
- en: Docker Hub alternatives
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker Hub替代品
- en: 'There are more cloud offerings worth mentioning. First of all, each of the
    following three main cloud platforms offers its own Docker Registry:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多值得一提的云服务。首先，以下三个主要云平台每个平台都提供自己的Docker Registry：
- en: Amazon **Elastic Container Registry** (**ECR**)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**弹性容器注册表**（**ECR**）
- en: Google Artifact Registry
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌制品库
- en: Azure Container Registry
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 容器注册表
- en: 'Other widely used solutions include the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其他广泛使用的解决方案包括：
- en: Quay Container Registry
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quay 容器注册表
- en: JFrog Artifactory
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JFrog Artifactory
- en: GitLab Container Registry
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 容器注册表
- en: All of the mentioned registries implement the same Docker Registry protocol,
    so the good news is that no matter which you choose, the commands used are exactly
    the same.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述提到的注册表都实现了相同的 Docker 注册表协议，因此好消息是无论选择哪个，使用的命令完全相同。
- en: Self-hosted Docker Registry
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自托管 Docker 注册表
- en: Cloud solutions may not always be acceptable. They are not free for enterprises
    and, what's even more important, a lot of companies have policies not to store
    their software outside their own network. In this case, the only option is to
    install a self-hosted Docker Registry.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 云解决方案可能并不总是可接受的。它们对企业并非免费的，更重要的是，许多公司有政策要求不将软件存储在自己的网络之外。在这种情况下，唯一的选择是安装自托管
    Docker 注册表。
- en: 'The Docker Registry installation process is quick and simple, but making it
    secure and available in public requires setting up access restrictions and the
    domain certificate. This is why we split this section into three parts, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 注册表的安装过程快速且简单，但要确保其安全性并使其对公众可用，需要设置访问限制和域证书。这就是为什么我们将此部分分为三个部分，如下所示：
- en: Installing the Docker Registry application
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker 注册表应用
- en: Adding a domain certificate
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加域证书
- en: Adding an access restriction
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加访问限制
- en: Let's have a look at each part.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个部分。
- en: Installing the Docker Registry application
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 Docker 注册表应用
- en: 'The Docker Registry is available as a Docker image. To start this, we can run
    the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 注册表作为 Docker 镜像提供。要启动它，我们可以运行以下命令：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: By default, the registry data is stored as a Docker volume in the default host
    filesystem's directory. To change it, you can add `-v <host_directory>:/var/lib/registry`.
    Another alternative is to use a volume container.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，注册表数据存储为 Docker 卷，位于默认主机文件系统的目录中。要更改它，您可以添加`-v <host_directory>:/var/lib/registry`。另一个选择是使用卷容器。
- en: The command starts the registry and makes it accessible through port `5000`.
    The `registry` container is started from the registry image (version 2). The `--restart=always`
    option causes the container to automatically restart whenever it's down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动注册表并通过端口`5000`使其可访问。`registry`容器从注册表镜像（版本 2）启动。`--restart=always`选项使容器在停止时自动重新启动。
- en: Tip
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Consider setting up a load balancer and starting a few Docker Registry containers
    in case of a large number of users. Note that, in such a case, they need to share
    the storage or have a synchronization mechanism in place.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑设置负载均衡器，并在用户数量较多时启动几个 Docker 注册表容器。请注意，在这种情况下，它们需要共享存储或有一个同步机制。
- en: Adding a domain certificate
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加域证书
- en: If the registry is run on the localhost, then everything works fine and no other
    installation steps are required. However, in most cases, we want to have a dedicated
    server for the registry so that the images are widely available. In that case,
    Docker requires the securing of the registry with `--insecure-registry` flag.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册表运行在本地主机上，那么一切正常，不需要其他安装步骤。然而，在大多数情况下，我们希望为注册表配置专用服务器，以便图像能够广泛可用。在这种情况下，Docker
    需要使用`--insecure-registry`标志来保护注册表。
- en: Information
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can read about creating and using self-signed certificates at [https://docs.docker.com/registry/insecure/#use-self-signed-certificates](https://docs.docker.com/registry/insecure/#use-self-signed-certificates).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读有关创建和使用自签名证书的内容：[https://docs.docker.com/registry/insecure/#use-self-signed-certificates](https://docs.docker.com/registry/insecure/#use-self-signed-certificates)。
- en: 'Once the certificates are either signed by the CA or self-signed, we can move
    `domain.crt` and `domain.key` to the `certs` directory and start the registry,
    which listens on the default **HyperText Transfer Protocol Secure** (**HTTPS**)
    port, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦证书被 CA 签署或自签署，我们可以将`domain.crt`和`domain.key`移动到`certs`目录，并启动注册表，注册表将监听默认的**超文本传输安全协议**（**HTTPS**）端口，如下所示：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `--insecure-registry` flag is not recommended since it provides no
    proper CA verification.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不推荐使用`--insecure-registry`标志，因为它没有进行适当的 CA 验证。
- en: Information
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Read more about setting up Docker registries and making them secure in the official
    Docker documentation at [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 详细了解如何在官方 Docker 文档中设置 Docker 注册表并使其安全：[https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/)。
- en: Adding an access restriction
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加访问限制
- en: Unless we use the registry inside a highly secure private network, we should
    configure authentication.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们在高度安全的私有网络内使用注册表，否则应该配置身份验证。
- en: 'The simplest way to do this is to create a user with a password using the `htpasswd`
    tool from the `registry` image, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用`registry`镜像中的`htpasswd`工具创建一个带有密码的用户，如下所示：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The command runs the `htpasswd` tool to create an `auth/htpasswd` file (with
    one user inside). Then, we can run the registry with that one user authorized
    to access it, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令运行`htpasswd`工具来创建一个`auth/htpasswd`文件（其中包含一个用户）。然后，我们可以使用该文件中的用户来运行注册表，以便授权访问，如下所示：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The command, in addition to setting the certificates, creates an access restriction
    limited to the users specified in the `auth/passwords` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令除了设置证书之外，还会创建一个访问限制，限制仅有`auth/passwords`文件中指定的用户可以访问。
- en: As a result, before using the registry, a client needs to specify the username
    and password.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，在使用注册表之前，客户端需要指定用户名和密码。
- en: Important Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Access restriction doesn't work in the case of the `--insecure-registry` flag.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`--insecure-registry`标志，访问限制将不起作用。
- en: Using the Docker Registry
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker 注册表
- en: 'When our registry is configured, we can show how to work with it in three stages,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的注册表配置好之后，我们可以分三步展示如何使用它，如下所示：
- en: Building an image
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Pushing the image into the registry
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送镜像到注册表
- en: Pulling the image from the registry
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从注册表拉取镜像
- en: Building an image
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Let''s use the example from [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034),
    *Introducing Docker*, and build an image with Ubuntu and the Python interpreter
    installed. In a new directory, we need to create a Dockerfile, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[*第2章*](B18223_02_ePub.xhtml#_idTextAnchor034)中的示例，*介绍 Docker*，并构建一个安装了
    Ubuntu 和 Python 解释器的镜像。在一个新的目录中，我们需要创建一个 Dockerfile，如下所示：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can build the image with the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下命令构建镜像：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the image is built, we can push it into the Docker Registry.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像构建完成后，我们可以将其推送到 Docker 注册表。
- en: Pushing the image into the registry
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推送镜像到注册表
- en: 'In order to push the created image, we need to tag it according to the naming
    convention, like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推送创建的镜像，我们需要根据命名约定对其进行标签，如下所示：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `registry_address` value can be either of the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`registry_address`值可以是以下之一：'
- en: A username in the case of Docker Hub
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub 中的用户名
- en: A domain name or `localhost:5000`)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名或`localhost:5000`
- en: Information
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: In most cases, `<tag>` is in the form of the image/application version.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，`<tag>`是镜像/应用版本的形式。
- en: 'Let''s tag the image to use Docker Hub, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给镜像添加标签，以便使用 Docker Hub，如下所示：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember to use your Docker Hub username instead of `leszko`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得使用您的 Docker Hub 用户名，而不是`leszko`。
- en: Tip
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'We could have also tagged the image in the `build` command, like this: `docker
    build -t leszko/ubuntu_with_python:1`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`build`命令中对镜像进行标签，例如：`docker build -t leszko/ubuntu_with_python:1`。
- en: 'If the repository has access restriction configured, we need to authorize it
    first, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仓库已配置访问限制，我们需要先进行授权，如下所示：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Information
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: If you use a Docker Registry other than Docker Hub, then you also need to add
    a `login` command—for example, `docker login quay.io`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是除 Docker Hub 以外的 Docker 注册表，则还需要添加`login`命令，例如`docker login quay.io`。
- en: 'Now, we can store the image in the registry using the `push` command, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`push`命令将镜像存储到注册表中，如下所示：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that there is no need to specify the registry address because Docker uses
    the naming convention to resolve it. The image is stored, and we can check it
    using the Docker Hub web interface available at [https://hub.docker.com](https://hub.docker.com).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不需要指定注册表地址，因为 Docker 使用命名约定来解析它。镜像已存储，我们可以通过 Docker Hub 网页界面查看它，地址为[https://hub.docker.com](https://hub.docker.com)。
- en: Pulling the image from the registry
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从注册表拉取镜像
- en: 'To demonstrate how the registry works, we can remove the image locally and
    retrieve it from the registry, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示注册表的工作原理，我们可以在本地删除镜像并从注册表中拉取它，如下所示：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see that the image has been removed using the `docker images` command.
    Then, let''s retrieve the image back from the registry by executing the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`docker images`命令看到镜像已经被移除。接下来，通过执行以下代码从注册表中取回镜像：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you use a free Docker Hub account, you may need to change the `ubuntu_with_python`
    repository to `public` before pulling it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是免费的 Docker Hub 账户，在拉取`ubuntu_with_python`仓库之前，可能需要将其更改为`public`。
- en: We can confirm that the image is back with the `docker images` command.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`docker images`命令确认镜像是否已生成。
- en: When we have the registry configured and understand how it works, we can see
    how to use it inside the CD pipeline and build the acceptance testing stage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们配置好注册表并理解它的工作原理后，我们可以看到如何在CD流水线中使用它，并构建验收测试阶段。
- en: Acceptance tests in the Jenkins pipeline
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins流水线中的验收测试
- en: We already understand the idea behind acceptance testing and know how to configure
    the Docker Registry, so we are ready for its first implementation inside the Jenkins
    pipeline.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了验收测试的概念，并且知道如何配置Docker注册表，所以我们已经准备好在Jenkins流水线中实现它。
- en: 'Let''s look at the following diagram, which presents the process we will use:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图示，它展示了我们将要使用的过程：
- en: '![Figure 5.2 – Acceptance tests in the Jenkins pipeline'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – Jenkins流水线中的验收测试'
- en: '](img/B18223_05_02.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_05_02.jpg)'
- en: Figure 5.2 – Acceptance tests in the Jenkins pipeline
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Jenkins流水线中的验收测试
- en: 'The process goes like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: The developer pushes a code change to GitHub.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者将代码更改推送到GitHub。
- en: Jenkins detects the change, triggers the build, and checks out the current code.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins检测到更改，触发构建，并检出当前代码。
- en: Jenkins executes the commit phase and builds the Docker image.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins执行提交阶段并构建Docker镜像。
- en: Jenkins pushes the image to the **Docker Registry**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins将镜像推送到**Docker注册表**。
- en: Jenkins runs the Docker container in the staging environment.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins在预生产环境中运行Docker容器。
- en: The Docker host on the staging environment needs to pull the image from the
    Docker Registry.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预生产环境中的Docker主机需要从Docker注册表拉取镜像。
- en: Jenkins runs the acceptance test suite against the application running in the
    staging environment.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins在预生产环境中运行的应用程序上执行验收测试套件。
- en: Information
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: For the sake of simplicity, we will run the Docker container locally (and not
    on a separate staging server). In order to run it remotely, we need to use the
    `-H` option or configure the `DOCKER_HOST` environment variable.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将本地运行Docker容器（而不是在单独的预生产服务器上运行）。若要远程运行，需要使用`-H`选项或配置`DOCKER_HOST`环境变量。
- en: 'Let''s continue the pipeline we started in [*Chapter 4*](B18223_04_ePub.xhtml#_idTextAnchor106),
    *Continuous Integration Pipeline*, and add three more stages, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在[*第4章*](B18223_04_ePub.xhtml#_idTextAnchor106)，*持续集成流水线*中开始的流水线，并添加以下三个阶段：
- en: '`Docker build`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker build`'
- en: '`Docker push`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker push`'
- en: '`Acceptance test`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Acceptance test`'
- en: Keep in mind that you need to have the Docker tool installed on the Jenkins
    executor (agent or master, in the case of agentless configuration) so that it
    can build Docker images.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要在Jenkins执行器（代理或主机，若是无代理配置）上安装Docker工具，以便它可以构建Docker镜像。
- en: Tip
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you use dynamically provisioned Docker agents, then make sure you use the
    `leszko/jenkins-docker-slave` image. Remember to also mark the `privileged` option
    in the Docker agent configuration.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用动态配置的Docker代理，请确保使用`leszko/jenkins-docker-slave`镜像。记得在Docker代理配置中也要标记`privileged`选项。
- en: The Docker build stage
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker构建阶段
- en: We would like to run the calculator project as a Docker container, so we need
    to create a Dockerfile and add the `Docker build` stage to the Jenkinsfile.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将计算器项目作为Docker容器运行，因此需要创建一个Dockerfile并在Jenkinsfile中添加`Docker build`阶段。
- en: Adding a Dockerfile
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加Dockerfile
- en: 'Let''s create a Dockerfile in the root directory of the calculator project,
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在计算器项目的根目录中创建一个Dockerfile，如下所示：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Information
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The default build directory for Gradle is `build/libs/`, and `calculator-0.0.1-SNAPSHOT.jar`
    is the complete application packaged into one JAR file. Note that Gradle automatically
    versioned the application using the `0.0.1-SNAPSHOT` Maven-style version.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的默认构建目录是`build/libs/`，`calculator-0.0.1-SNAPSHOT.jar`是将应用程序打包成的完整JAR文件。请注意，Gradle使用`0.0.1-SNAPSHOT`的Maven风格版本自动为应用程序进行了版本控制。
- en: 'The Dockerfile uses a base image that contains the `openjdk:11-jre`). It also
    copies the application JAR (created by Gradle) and runs it. Let''s now check whether
    the application builds and runs by executing the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile使用了一个包含`openjdk:11-jre`的基础镜像。它还复制了应用程序JAR（由Gradle创建）并运行它。现在让我们通过执行以下代码来检查应用程序是否构建并运行：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the preceding commands, we've built the application, built the Docker
    image, and run the Docker container. After a while, we should be able to open
    the browser at `http://localhost:8080/sum?a=1&b=2` and see `3` as a result.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们构建了应用程序，构建了 Docker 镜像，并运行了 Docker 容器。过一会儿，我们应该能够在浏览器中打开 `http://localhost:8080/sum?a=1&b=2`，并看到结果为
    `3`。
- en: 'We can stop the container and push the Dockerfile to the GitHub repository,
    like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以停止容器并将 Dockerfile 推送到 GitHub 仓库，如下所示：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding the Docker build to the pipeline
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Docker build 添加到管道中
- en: 'The final step we need to perform is to add the `Docker build` stage to the
    Jenkinsfile. Usually, the JAR packaging is also declared as a separate `Package`
    stage, as illustrated in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的最后一步是将 `Docker build` 阶段添加到 Jenkinsfile 中。通常，JAR 打包也会作为一个单独的 `Package`
    阶段声明，如下代码片段所示：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Information
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We don't explicitly version the image, but each image has a unique hash ID.
    We will cover explicit versioning in the following chapters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有明确地为镜像指定版本，但每个镜像都有一个唯一的哈希 ID。我们将在后续章节中讨论显式版本控制。
- en: Note that we used the Docker Registry name in the image tag. There is no need
    to have the image tagged twice as `calculator` and `leszko/calculator`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在镜像标签中使用了 Docker Registry 名称。无需将镜像同时标记为 `calculator` 和 `leszko/calculator`。
- en: When we commit and push the Jenkinsfile, the pipeline build should start automatically
    and we should see all boxes in green. This means that the Docker image has been
    built successfully.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交并推送 Jenkinsfile 后，管道构建应该会自动开始，我们应该看到所有的框都变成绿色。这意味着 Docker 镜像已成功构建。
- en: Tip
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you see a failure in the Docker build stage, then most probably, your Jenkins
    executor doesn't have access to the Docker daemon. In case you use the Jenkins
    master as the executor, make sure that the `jenkins` user is added to the `docker`
    user group. In case you use Jenkins agents, make sure they have access to the
    Docker daemon.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Docker 构建阶段看到失败，最有可能是你的 Jenkins 执行器无法访问 Docker 守护进程。如果你使用 Jenkins 主机作为执行器，请确保
    `jenkins` 用户已添加到 `docker` 用户组中。如果你使用 Jenkins 代理，请确保它们能够访问 Docker 守护进程。
- en: The Docker push stage
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker push 阶段
- en: 'When the image is ready, we can store it in the registry. The `Docker push`
    stage is very simple. It''s enough to add the following code to the Jenkinsfile:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当镜像准备好后，我们可以将其存储在注册表中。`Docker push` 阶段非常简单，只需要在 Jenkinsfile 中添加以下代码：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Information
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: If the Docker Registry has access restricted, first, we need to log in using
    the `docker login` command. Needless to say, the credentials must be well secured—for
    example, using a dedicated credential store, as described on the official Docker
    page at [https://docs.docker.com/engine/reference/commandline/login/#credentials-store](https://docs.docker.com/engine/reference/commandline/login/#credentials-store).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Docker Registry 限制了访问权限，首先，我们需要使用 `docker login` 命令登录。不言而喻，凭据必须妥善保管——例如，使用专门的凭据存储，如官方
    Docker 页面中所描述的 [https://docs.docker.com/engine/reference/commandline/login/#credentials-store](https://docs.docker.com/engine/reference/commandline/login/#credentials-store)。
- en: As always, pushing changes to the GitHub repository triggers Jenkins to start
    the build and, after a while, we should have the image automatically stored in
    the registry.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，向 GitHub 仓库推送更改会触发 Jenkins 开始构建，过一会儿，我们应该能看到镜像自动存储到注册表中。
- en: The acceptance testing stage
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收测试阶段
- en: To perform acceptance testing, we first need to deploy the application to the
    staging environment and then run the acceptance test suite against it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行验收测试，我们首先需要将应用程序部署到预发布环境，然后在该环境中运行验收测试套件。
- en: Adding a staging deployment to the pipeline
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将预发布部署添加到管道中
- en: 'Let''s add a stage to run the `calculator` container, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个阶段来运行 `calculator` 容器，如下所示：
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After running this stage, the `calculator` container is running as a daemon,
    publishing its port as `8765`, and being removed automatically when stopped.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此阶段后，`calculator` 容器作为守护进程运行，公开其端口为 `8765`，并在停止时自动移除。
- en: Finally, we are ready to add the acceptance test to our Jenkins pipeline.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备将验收测试添加到 Jenkins 管道中。
- en: Adding an acceptance test to the pipeline
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将验收测试添加到管道中
- en: Acceptance testing usually requires running a dedicated black-box test suite
    that checks the behavior of the system. We will cover it in the *Writing acceptance
    tests* section. At the moment, for the sake of simplicity, let's perform acceptance
    testing simply by calling the web service endpoint with the `curl` tool and checking
    the result using the `test` command.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试通常需要运行一个专门的黑盒测试套件，用以检查系统的行为。我们将在*编写验收测试*章节中详细介绍这一点。目前，为了简化处理，我们只需通过`curl`工具调用
    web 服务端点，并使用`test`命令检查结果来进行验收测试。
- en: 'In the root directory of the project, let''s create an `acceptance_test.sh`
    file, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下，我们创建一个`acceptance_test.sh`文件，如下所示：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We call the `sum` endpoint with the `a=1` and `b=2` parameters and expect to
    receive `3` in response.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`a=1`和`b=2`参数调用`sum`端点，期望收到`3`的响应。
- en: 'Then, an `Acceptance test` stage can be added, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以添加一个`验收测试`阶段，如下所示：
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the `docker run -d` command is asynchronous, we need to wait, using the
    `sleep` operation to make sure the service is already running.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`docker run -d`命令是异步的，我们需要使用`sleep`操作来等待，以确保服务已经启动。
- en: Information
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: There is no good way to check whether the service is already running. An alternative
    to sleeping could be a script checking every second to see whether the service
    has already started.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种好的方法可以检查服务是否已经在运行。睡眠的替代方案可以是一个脚本，每秒检查一次服务是否已启动。
- en: At this point, our pipeline has already performed the automated acceptance tests.
    One last thing we should never forget about is to add a cleanup stage.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的流水线已经执行了自动化验收测试。我们永远不应该忘记的最后一件事是，添加一个清理阶段。
- en: Adding a cleanup stage environment
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加清理阶段环境
- en: 'As the final stage of acceptance testing, we can add the staging environment
    cleanup. The best place to do this is in the `post` section, to make sure it executes
    even in case of failure. Here''s the code we need to execute:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为验收测试的最后阶段，我们可以添加暂存环境的清理操作。执行此操作的最佳位置是在`post`部分，以确保即使在失败的情况下也会执行。以下是我们需要执行的代码：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This statement makes sure that the `calculator` container is no longer running
    on the Docker host.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句确保`calculator`容器在 Docker 主机上不再运行。
- en: Writing acceptance tests
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写验收测试
- en: 'So far, we used the `curl` command to perform a suite of acceptance tests.
    That is, obviously, a considerable simplification. Technically speaking, if we
    write a `curl` calls. However, this solution would be very difficult to read,
    understand, and maintain. What''s more, the script would be completely incomprehensible
    to non-technical, business-related users. *How do we address this issue and create
    tests with a good structure that are readable by users and meet their fundamental
    goal: automatically checking that the system is as expected?* I will answer this
    question throughout this section.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用`curl`命令执行了一系列验收测试。显然，这是一种相当简化的做法。从技术上讲，如果我们写了`curl`调用。然而，这种解决方案将非常难以阅读、理解和维护。更重要的是，脚本对非技术性、与业务相关的用户来说完全无法理解。*我们如何解决这个问题，并创建结构良好的、易于用户阅读且满足其根本目标的测试：自动检查系统是否按预期工作？*
    我将在本节中回答这个问题。
- en: Writing user-facing tests
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写面向用户的测试
- en: Acceptance tests are written with users and should be comprehensible to users.
    This is why the choice of a method for writing them depends on who the customer
    is.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是面向用户编写的，应该易于用户理解。这就是编写验收测试的方法选择取决于客户是谁的原因。
- en: For example, imagine a purely technical person. If you write a web service that
    optimizes database storage and your system is used only by other systems and read-only
    by other developers, your tests can be expressed in the same way as unit tests.
    As a rule, the test is good if understood by both developers and users.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你是一个纯技术人员。如果你编写了一个优化数据库存储的 web 服务，而该系统只被其他系统使用，并且其他开发者只能读取系统数据，你的测试可以像单元测试一样进行表达。一般来说，如果测试既能被开发人员也能被用户理解，那么这个测试就是好的。
- en: 'In real life, most software is written to deliver a specific business value,
    and that business value is defined by non-developers. Therefore, we need a common
    language to collaborate. On one side, there is the business, which understands
    what is needed but not how to do it; on the other side, the development team knows
    how but doesn''t know what. Luckily, there are a number of frameworks that helps
    to connect these two worlds, such as **Cucumber**, **FitNesse**, **JBehave**,
    and **Capybara**. They differ from each other, and each of them may be a subject
    for a separate book; however, the general idea of writing acceptance tests is
    the same and is shown in the following diagram:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，大多数软件是为了交付特定的商业价值而编写的，而这种商业价值是由非开发人员定义的。因此，我们需要一种共同的语言来进行协作。一方面是业务方，了解需要什么，但不清楚如何实现；另一方面是开发团队，知道如何做，但不知道做什么。幸运的是，有许多框架帮助连接这两个世界，例如**Cucumber**、**FitNesse**、**JBehave**
    和 **Capybara**。它们彼此有所不同，每一个都可能是一本独立的书的主题；然而，编写验收测试的基本理念是相同的，如下图所示：
- en: '![Figure 5.3 – User-facing acceptance tests'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 面向用户的验收测试'
- en: '](img/B18223_05_03.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_05_03.jpg)'
- en: Figure 5.3 – User-facing acceptance tests
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 面向用户的验收测试
- en: 'The **acceptance criteria** are written by users (or a product owner as their
    representative), with the help of developers. They are usually written in the
    form of the following scenarios:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收标准**由用户（或作为其代表的产品负责人）在开发人员的帮助下编写。它们通常以以下场景的形式编写：'
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Developers write the testing implementation, called **fixtures** or **step definitions**,
    that integrates the human-friendly **domain-specific language** (**DSL**) specification
    with the programming language. As a result, we have an automated test that can
    be easily integrated into the CD pipeline.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员编写测试实现，称为**固定器**或**步骤定义**，将人性化的**领域特定语言**（**DSL**）规范与编程语言进行集成。结果是我们拥有了一个可以轻松集成到
    CD 管道中的自动化测试。
- en: Needless to add, writing acceptance tests is a continuous Agile process, not
    a Waterfall one. It requires constant collaboration, during which the test specifications
    are improved and maintained by both developers and the business.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 不必多说，编写验收测试是一个持续的敏捷过程，而非瀑布式过程。它需要不断的协作，在此过程中，测试规范由开发人员和业务人员共同改进和维护。
- en: Information
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In the case of an application with a **user interface** (**UI**), it can be
    tempting to perform the acceptance test directly through the interface (for example,
    by recording Selenium scripts). However, this approach, when not done properly,
    can lead to tests that are slow and tightly coupled to the interface layer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有**用户界面**（**UI**）的应用程序中，直接通过界面进行验收测试（例如，通过录制 Selenium 脚本）可能会很有吸引力。然而，如果这种方法没有正确实施，可能会导致测试变得缓慢且与界面层紧密耦合。
- en: Let's see how writing acceptance tests looks in practice and how to bind them
    to the CD pipeline.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编写验收测试在实际中的样子，以及如何将其绑定到 CD 管道。
- en: Using the acceptance testing framework
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用验收测试框架
- en: 'Let''s use the Cucumber framework and create an acceptance test for the calculator
    project. As previously described, we will do this in three stages, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Cucumber 框架，并为计算器项目创建一个验收测试。正如前面所述，我们将分三阶段进行，具体如下：
- en: Creating acceptance criteria
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建验收标准
- en: Creating step definitions
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建步骤定义
- en: Running an automated acceptance test
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行自动化验收测试
- en: Creating acceptance criteria
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建验收标准
- en: 'Let''s put the business specification in `src/test/resources/feature/calculator.feature`,
    as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将业务规范放在 `src/test/resources/feature/calculator.feature` 中，具体如下：
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This file should be created by users with the help of developers. Note that
    it is written in a way that non-technical people can understand.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件应该由用户在开发人员的帮助下创建。请注意，它是以非技术人员能够理解的方式编写的。
- en: Creating step definitions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建步骤定义
- en: 'The next step is to create Java bindings so that the feature specification
    will be executable. In order to do this, we create a new file, `src/test/java/acceptance/StepDefinitions.java`,
    as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 Java 绑定，以便特性规范可以执行。为此，我们创建一个新文件 `src/test/java/acceptance/StepDefinitions.java`，具体如下：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each line (`Given`, `When`, and `Then`) from the feature specification file
    is matched by `(.*)` are passed as parameters. Note that the server address is
    passed as the `calculator.url` Java property. The method performs the following
    actions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 特性规范文件中的每一行（`Given`、`When` 和 `Then`）由 `(.*)` 匹配，并作为参数传递。请注意，服务器地址作为 `calculator.url`
    Java 属性传递。该方法执行以下操作：
- en: '`i_have_two_numbers`: Saves parameters as fields'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i_have_two_numbers`：将参数保存为字段'
- en: '`the_calculator_sums_them`: Calls the remote calculator service and stores
    the result in a field'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`the_calculator_sums_them`：调用远程计算器服务并将结果存储在一个字段中'
- en: '`i_receive_as_a_result`: Asserts that the result is as expected'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i_receive_as_a_result`：断言结果符合预期'
- en: Running an automated acceptance test
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行自动化验收测试
- en: 'To run an automated test, we need to make a few configurations, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行自动化测试，我们需要做一些配置，如下所示：
- en: 'Add the Java Cucumber libraries. In the `build.gradle` file, add the following
    code to the `dependencies` section:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Java Cucumber 库。在 `build.gradle` 文件中，向 `dependencies` 部分添加以下代码：
- en: '[PRE24]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the Gradle target. In the same file, add the following code:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Gradle 目标。在同一个文件中，向 `dependencies` 部分添加以下代码：
- en: '[PRE25]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This splits the tests into unit tests (run with `./gradlew test`) and acceptance
    tests (run with `./gradlew acceptanceTest`).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将测试分为单元测试（通过 `./gradlew test` 运行）和验收测试（通过 `./gradlew acceptanceTest` 运行）。
- en: 'Add a JUnit Test Runner, add a new file, `src/test/java/acceptance/AcceptanceTest.java`,
    as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 JUnit 测试运行器，添加一个新文件，`src/test/java/acceptance/AcceptanceTest.java`，内容如下：
- en: '[PRE26]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is the entry point to the acceptance test suite.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是验收测试套件的入口点。
- en: 'After this configuration, if the server is running on the localhost, we can
    test it by executing the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，如果服务器在本地主机上运行，我们可以通过执行以下代码进行测试：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Obviously, we can add this command instead of `acceptance_test.sh`. This would
    make the Cucumber acceptance test run in the Jenkins pipeline.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以添加此命令来代替 `acceptance_test.sh`。这样，Cucumber 验收测试将在 Jenkins 流水线中运行。
- en: Acceptance test-driven development
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收测试驱动开发
- en: Acceptance tests, as with most aspects of the CD process, are less about technology
    and more about people. The test quality depends, of course, on the engagement
    of users and developers, but also, what is maybe less intuitive is the time when
    the tests are created.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试，和 CD 过程中的大多数方面一样，更多的是关于人，而不是技术。当然，测试的质量依赖于用户和开发人员的参与，但也有一个可能不太直观的因素——测试创建的时机。
- en: 'The last question to ask is this: *During which phase of the software development
    life cycle should the acceptance tests be prepared?* Or, to rephrase it: *Should
    we create acceptance tests before or after writing the code?*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是：*在软件开发生命周期的哪个阶段应该准备验收测试？* 或者换句话说：*我们应该在编写代码之前还是之后创建验收测试？*
- en: Technically speaking, the result is the same; the code is well covered with
    both unit and acceptance tests. However, it's tempting to consider writing tests
    first. The idea of **test-driven development** (**TDD**) can be well adapted for
    acceptance testing. If unit tests are written before the code, the resulting code
    is cleaner and better structured. Analogously, if acceptance tests are written
    before the system feature, the resulting feature corresponds better to the customer's
    requirements.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，结果是相同的；代码已经通过单元测试和验收测试的覆盖。然而，写测试先行的想法是令人诱惑的。**测试驱动开发**（**TDD**）的理念可以很好地应用于验收测试。如果单元测试在代码之前编写，那么最终的代码会更加简洁和结构化。同理，如果在系统功能之前编写验收测试，那么最终的功能会更好地对应客户的需求。
- en: 'This process, often called acceptance TDD, is presented in the following diagram:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程，通常被称为验收 TDD，在以下图表中展示：
- en: '![Figure 5.4 – Acceptance TDD'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 验收 TDD'
- en: '](img/B18223_05_04.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_05_04.jpg)'
- en: Figure 5.4 – Acceptance TDD
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 验收 TDD
- en: Users (with developers) write the acceptance criteria specification in the human-friendly
    DSL format. Developers write the fixtures, and the tests fail. Then, feature development
    starts using the TDD methodology internally. Once the feature is completed, the
    acceptance test should pass, and this is a sign that the feature is completed.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 用户（与开发人员）以人类友好的 DSL 格式编写验收标准规范。开发人员编写夹具，测试失败。然后，功能开发开始，在内部使用 TDD 方法论。一旦功能完成，验收测试应该通过，这标志着功能的完成。
- en: A very good practice is to attach the Cucumber feature specification to the
    request ticket in the issue-tracking tool (for example, JIRA) so that the feature
    would always be requested together with its acceptance test. Some development
    teams take an even more radical approach and refuse to start the development process
    if no acceptance tests are prepared. There is a lot of sense in that. After all,
    how can you develop something that the client can't test?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常好的做法是将Cucumber功能规格附加到问题跟踪工具中的请求票证（例如JIRA），以便功能总是与其接受测试一起被请求。有些开发团队采取更激进的方式，如果没有准备好接受测试，他们会拒绝开始开发过程。这是很有道理的。毕竟，如何开发出客户无法测试的东西呢？
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned how to build a complete and functional acceptance
    test stage, which is an essential part of the CD process. Here are the key takeaways:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何构建一个完整且功能齐全的接受测试阶段，这是CD过程中的一个关键部分。以下是关键要点：
- en: Acceptance tests can be difficult to create because they combine technical challenges
    (application dependencies; setting up the environment) with personal challenges
    (developer/business collaboration).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建接受测试可能很困难，因为它们结合了技术挑战（应用程序依赖关系、环境设置）和个人挑战（开发人员/业务协作）。
- en: Acceptance testing frameworks provide a way to write tests in a human-friendly
    language that makes them comprehensible to non-technical people.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试框架提供了一种使用人类友好的语言编写测试的方法，使非技术人员也能理解它们。
- en: The Docker Registry is an artifact repository for Docker images.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Registry是一个用于Docker镜像的工件库。
- en: The Docker Registry fits well with the CD process because it provides a way
    to use exactly the same Docker image throughout the stages and environments.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Registry非常适合与CD过程配合使用，因为它提供了一种在各个阶段和环境中使用完全相同的Docker镜像的方法。
- en: In the next chapter, we will cover clustering and service dependencies, which
    is the next step toward creating a complete CD pipeline.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍集群和服务依赖关系，这是创建完整CD管道的下一步。
- en: Exercises
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'We covered a lot of new material throughout this chapter, so to aid your understanding,
    I recommend doing the following exercises:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了许多新内容，为了帮助你的理解，我建议做以下练习：
- en: Create a Ruby-based web service, `book-library`, to store books.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于Ruby的Web服务，`book-library`，用于存储书籍。
- en: 'The acceptance criteria are delivered in the form of the following Cucumber
    feature:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接受标准以以下Cucumber功能的形式提供：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Proceed as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: Write step definitions for the Cucumber test.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Cucumber测试编写步骤定义。
- en: Write the web service (the simplest way is to use the Sinatra framework (http://www.sinatrarb.com/),
    but you can also use Ruby on Rails).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写Web服务（最简单的方式是使用Sinatra框架（http://www.sinatrarb.com/），但也可以使用Ruby on Rails）。
- en: 'The book should have the following attributes: `name`, `author`, and `ISBN`).'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 书籍应具有以下属性：`name`、`author`和`ISBN`）。
- en: 'The web service should have the following endpoints:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web服务应具有以下端点：
- en: '`POST /books` to add a book'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /books` 用于添加一本书'
- en: '`GET /books/<isbn>` to retrieve the book'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /books/<isbn>` 用于检索书籍'
- en: The data can be stored in the memory.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据可以存储在内存中。
- en: At the end, check that the acceptance test is green.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查接受测试是否通过（绿色）。
- en: 'Add `book-library` as a Docker image to the Docker Registry by doing the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式将`book-library`作为Docker镜像添加到Docker Registry：
- en: Create an account on Docker Hub.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker Hub上创建一个帐户。
- en: Create a Dockerfile for the application.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序创建一个Dockerfile。
- en: Build the Docker image and tag it according to the naming convention.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Docker镜像并根据命名惯例对其进行标记。
- en: Push the image to Docker Hub.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到Docker Hub。
- en: 'Create a Jenkins pipeline to build the Docker image, push it to the Docker
    Registry, and perform acceptance testing by doing the following:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Jenkins管道来构建Docker镜像，推送到Docker Registry，并执行接受测试，方法如下：
- en: Create a `Docker build` stage.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Docker build`阶段。
- en: Create `Docker login` and `Docker push` stages.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Docker login`和`Docker push`阶段。
- en: Add an `Acceptance test` stage to the pipeline.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管道中添加`Acceptance test`阶段。
- en: Run the pipeline and observe the result.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行管道并观察结果。
- en: Questions
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To verify the knowledge acquired from this chapter, please answer the following
    questions:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证从本章获得的知识，请回答以下问题：
- en: What is the Docker Registry?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Docker Registry？
- en: What is Docker Hub?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Docker Hub？
- en: What is the convention for naming Docker images (later pushed to the Docker
    Registry)?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker镜像的命名惯例是什么（稍后推送到Docker Registry）？
- en: What is the staging environment?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是暂存环境？
- en: Which Docker commands would you use to build an image and push it into Docker
    Hub?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪些 Docker 命令来构建镜像并将其推送到 Docker Hub？
- en: What is the main purpose of acceptance testing frameworks such as Cucumber and
    FitNesse?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受测试框架，如 Cucumber 和 FitNesse，主要的目的是什么？
- en: What are the three main parts of a Cucumber test?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cucumber 测试的三个主要部分是什么？
- en: What is acceptance TDD?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是接受 TDD？
- en: Further reading
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'To learn more about Docker Registry, acceptance testing, and Cucumber, please
    refer to the following resources:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Docker Registry、接受测试和 Cucumber 的信息，请参考以下资源：
- en: '**Docker Registry documentation**: [https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Registry 文档**: [https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
- en: '*Jez Humble*, *David Farley*—*Continuous Delivery*: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jez Humble*, *David Farley*—*持续交付*: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
- en: '**Cucumber framework**: [https://cucumber.io/](https://cucumber.io/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黄瓜框架**: [https://cucumber.io/](https://cucumber.io/)'
