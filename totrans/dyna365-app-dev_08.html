<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Leverage Azure Extensions in Dynamics 365</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned how we can consume the new REST Web API endpoint in Dynamics 365 to perform various operations and how to use it to develop custom business applications. In this chapter, we will learn how Dynamics 365 natively supports integration with Microsoft Azure. This chapter assumes a basic understanding of fundamentals of the Microsoft Azure.</p>
<div class="mce-root packt_infobox"><span>For Microsoft Azure reference—</span><a href="https://docs.microsoft.com/en-us/azure/fundamentals-introduction-to-azure">https://docs.microsoft.com/en-us/azure/fundamentals-introduction-to-azure</a> <span>and</span> <a href="https://azure.microsoft.com/en-in/training/">https://azure.microsoft.com/en-in/training/</a>  </div>
<p>Microsoft Azure can be defined as a cloud computing platform or collection of cloud-based services that developers and IT professionals can use to build, test, deploy and manage applications through various data centers across the globe. Microsoft Azure provides <strong>Infrastructure as a service </strong>(<strong>IaaS</strong>), <strong>Platform as a service</strong> (<strong>PaaS</strong>) and <strong>Software</strong> <strong>as a service</strong> (<strong>SaaS</strong>).</p>
<p>With <strong>IaaS,</strong> we are basically referring to Azure virtual machines, that is servers hosted on the cloud. The cloud computing service provider, Microsoft in this case, manages the infrastructure and we need to pay for using the resources. Here we have complete control and are responsible for managing operating systems, middleware and applications running there. We can also deploy Dynamics 365 On-premises in Microsoft Azure virtual machines.</p>
<p>With <strong>PaaS</strong>, we have a complete development and deployment environment available to us inside the cloud, which we can use to build, deploy, and manage our applications in the cloud. We pay for the cloud services that we are using. Here, we only manage our applications and services, and the cloud service provider manages everything else.</p>
<p>With <strong>SaaS</strong>, we basically connect and use software or cloud-based apps over the internet. Here, we just need to pay for the cloud-based app that we are going to use. The cloud service provider manages everything, be it underlying infrastructure, middleware, application software and so on. We just need to connect to these apps, mostly using a web browser over the internet to use them. Dynamics 365 Online falls under SaaS.</p>
<p>In this chapter, we will be covering the following points:</p>
<ul>
<li>Understanding Azure Integration with Dynamics 365</li>
<li>Configuring Azure Integration with Dynamics 365</li>
<li>Writing Azure-aware plugins and different listener applications</li>
</ul>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Azure integration with Dynamics 365</h1>
                </header>
            
            <article>
                
<p>Microsoft Azure Service Bus is the main component in Microsoft Azure Stack that enables us to connect Dynamics 365 with Microsoft Azure. Through Azure Service Bus we can pass the details of an operation performed inside Dynamics 365 to multiple applications that are listening to it and can read and process that information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Microsoft Azure Service Bus</h1>
                </header>
            
            <article>
                
<p>Azure Service Bus can be defined as a cloud messaging service that runs in Microsoft's Azure Data Center. Azure Service Bus enables us to connect different applications, services or devices that are hosted in the cloud or on-Premises inside the firewalled networks. It can be used to connect different <strong>line-of-business</strong> (<strong>LOB</strong>) applications, tablets, phones or even any household appliances or sensors. This Azure Service Bus supports two different communication mechanisms: brokered messaging (queues, topics, and subscriptions) and relay service.</p>
<p>The Azure Service Bus brokered messaging capabilities include queues and topics that can be created and hosted in Microsoft's Azure Data Center. An application can connect to the queue or topics created and send messages to them. These messages will be stored durably. Receiving applications can then connect to them and can receive and process the messages. The sending applications and the receiving applications can either be hosted in the cloud or can be on-premises. Queues provide unidirectional asynchronous communication where the publisher publishes a message and the subscriber receives the message. Each message is received by a single subscriber. Topics also provide unidirectional asynchronous messaging infrastructure where a publisher publishes a message and receivers receive the message like a queue. The main difference is that the same message can be received by multiple subscribers, who can optionally specify some criteria so that they only receive the messages that match the rules specified. As they provide one-way asynchronous communication through a broker, that is there is no direct connection between senders and receivers, it is not suitable for scenarios where we want both sender and receiver to exchange messages or directly connect to each other, or want synchronous communication between them. To address this Azure Service provides relays.</p>
<p>The Azure Service Bus relay service provides bi-directional synchronous communication capabilities between applications, unlike queues and topics. The relay service allows us to expose an endpoint in the cloud that serves as a proxy for our services hosted on the cloud or on-premises services. Any client with internet access can then make calls to this endpoint, which are relayed back to the service hosted behind the firewall or any other application listening for the messages. This provides a very reliable and cost-effective way for organizations to expose service.</p>
<div class="mce-root packt_tip"><span>Azure Service Bus documentation :</span><span class="URLPACKT"><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/"> https://docs.microsoft.com/en-us/azure/service-bus-messaging/</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Dynamics 365 and Azure Service Bus</h1>
                </header>
            
            <article>
                
<p>In the previous section, we covered the basics of Azure Service Bus, in this section we will look at how Dynamics 365 is integrated with Azure Service Bus.</p>
<p>The following diagram shows how Dynamics 365 works along with Azure Service Bus to connect to applications that can be in the cloud or hosted behind the firewall:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="413" src="assets/741fde55-1da3-414a-8a00-ae41e8165c52.png" width="764"/></div>
<p>Here is a step-by-step explanation for the same:</p>
<ol>
<li>A Dynamics 365 user performs an operation inside CRM, like creating a lead record, updating an opportunity and so on.</li>
<li>This triggers the execution of registered Azure-aware OOB (out of the box) plugins or custom Azure-aware plugins or workflow activity, which then notifies the asynchronous service system job.</li>
<li>Once the asynchronous service receives the notification, it handles the posting of data context of the request message to the Azure Service Bus. The posting is performed through a system job. Dynamics 365 User can check the status of the system job inside Dynamics 365 Web application, (<span class="packt_screen">Settings</span> | <span class="packt_screen">System Jobs</span>).</li>
<li>Microsoft Azure Service Bus then relays the execution context to Microsoft Azure Service Bus listener applications. The Azure Service Bus also manages the authorization. Dynamics 365 that posts the data to Service Bus and any listener application that reads it, are authorized by using <strong>either Access Control Service</strong> (<strong>ACS</strong>) or <strong>Shared Access Signature</strong> (<strong>SAS</strong>).</li>
</ol>
<div class="mce-root packt_tip"><span><span class="packt_screen">Azure Service Bus</span>: Authentication and Authorization—</span><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-authentication-and-authorization">https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-authentication-and-authorization</a>.</div>
<ol start="5">
<li>Microsoft Azure Service Bus listener applications that are registered on an Azure Service Bus solution endpoint can read and process the Dynamics 365 execution context posted by Azure Service Bus.</li>
<li>The Azure Service Bus then sets the status of the related system job as completed.</li>
</ol>
<div class="mce-root packt_tip"><span>SAS Authorization was introduced in CRM Online 2016 Update 1 and performs better than ACS. SAS is the recommended authorization method for Dynamics 365.  Refer here for updating a service endpoint from ACS to SAS Authorization—</span><span class="URLPACKT"><a href="https://msdn.microsoft.com/en-us/library/mt728940.aspx">https://msdn.microsoft.com/en-us/library/mt728940.aspx</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the Azure-aware plugin</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, we can register an Azure-aware plugin against a particular event inside Dynamics 365, which then passes this execution context to Azure Service Bus, which in turn relays it to the listener applications. Here, we can either use the OOB Azure-aware plugin or we can write our own custom Azure-aware plugin or custom workflow activity.</p>
<div class="mce-root packt_infobox"><span>With Dynamics 365 Online Version 9.0, we can use Webhooks as an alternative to Azure Service Bus to send data about the events to a web application—</span><a href="https://docs.microsoft.com/en-us/dynamics365/customer-engagement/developer/use-webhooks">https://docs.microsoft.com/en-us/dynamics365/customer-engagement/developer/use-webhooks</a>.</div>
<p>For the OOB Azure-aware plugin, we need to first register the new service endpoint through the plugin registration tool:</p>
<div class="CDPAlignCenter CDPAlign"><img height="127" src="assets/1df8a907-14d4-4e8f-8514-c253c434f362.png" width="323"/></div>
<p>Inside service endpoint registration, we need to specify a connection to Azure Service Bus to which we want to pass the plugin events:</p>
<div class="CDPAlignCenter CDPAlign"><img height="147" src="assets/0538aa22-6ecd-4146-b59b-aa5de641d363.png" width="442"/></div>
<p>The service endpoint holds the authorization information about the Azure Service Bus such as Service Bus Namespace address and SAS Key. After successful registration, we can then add a plugin step to the service endpoint added, the way we do for our usual plugin assemblies.</p>
<p>This Azure-aware OOB plugin executes in full trust. However, there are certain limitations with the OOB Azure-aware plugin, such as it can only run asynchronously, cannot call CRM SDK Method, and cannot write trace statements for logging, or auditing purposes.</p>
<p>Apart from the OOB Azure-aware plugin that Dynamics 365 provides, we can also create our own custom Azure-aware plugin or custom workflow activity.</p>
<p>The <kbd>IServiceProvider</kbd> passed to the <kbd>Execute</kbd> method of IPlugin contains an instance of <kbd>IServiceEndpointNotificationService</kbd><strong>.</strong> We can call its <kbd>Execute</kbd> method to post the execution context to Azure Service Bus. The <kbd>Execute</kbd> method needs an entity reference of the service endpoint; we can grab the service endpoint ID from the plugin registration tool. Adding this code to invoke the endpoint notification service makes our Plugin <strong>Azure aware</strong>:</p>
<pre style="padding-left: 60px">public class AzureAwarePlugin : IPlugin 
{ 
public void Execute(IServiceProvider serviceProvider) 
{ 
// set the Service Endpoint Id 
var serviceEndpointId = "[ServiceEndpointGuid]"; 
 
// Obtain the execution context from the service provider. 
IPluginExecutionContext context = (IPluginExecutionContext) 
serviceProvider.GetService(typeof(IPluginExecutionContext)); 
 
// Extract the notification service for posting execution context 
IServiceEndpointNotificationService notificationService = (IServiceEndpointNotificationService) 
serviceProvider.GetService(typeof(IServiceEndpointNotificationService)); 
// Call the Execute method. 
var response = notificationService.Execute(new EntityReference("serviceendpoint", 
new Guid(serviceEndpointId)), context); 
} 
} </pre>
<p>The custom Azure-aware plugin executes in partial trust mode in the sandbox. The benefit of writing a custom plugin is that we can call CRM SDK methods and can also receive a response from the listener applications in case of two-way relay service. Additionally, the plugin can be registered as either synchronous or asynchronous.</p>
<div class="mce-root packt_tip"><span>For Azure-aware plugins, it is recommended to register them to run asynchronously for best system performance.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding different contracts between Dynamics 365 and an Azure solution</h1>
                </header>
            
            <article>
                
<p>The following are the different types of contract that can be defined while registering a new service endpoint through the plugin registration tool:</p>
<p><strong>Queue:</strong></p>
<p>For a queue contract, a message queue needs to be created in Azure Service Bus. The listener application waits for the message to be posted by Service Bus in the queue. When the message is available in the queue, the listener application can read and process the message. The listener application doesn't need to be actively listening in the case of a queue contract.</p>
<p><strong>One-way:</strong></p>
<p>In the case of a one-way contract, the listener application needs to be actively listening. The post to the Service Bus fails if there is no active listener and the status of the system job is set to "Failed" after the system job runs out of retries.</p>
<p>The listener application needs to implement the <kbd>IServiceEndpointPlugin</kbd> interface's <kbd>Execute</kbd> method along with <kbd>WS2007HttpRelayBinding</kbd>, to which <kbd>RemoteExecutionContext</kbd> is passed from the Azure Service Bus.</p>
<p><strong>Two-way:</strong></p>
<p>The two-way contract is similar to a one-way contract, the only difference is that in the case of the two-way contract a message of type string can be returned back to the custom plugin workflow activity that posted the message to Azure Service Bus from the listener application.</p>
<p>The listener application needs to implement <kbd>ITwoWayServiceEndpointPlugin</kbd> interface's <kbd>Execute</kbd> method along with <kbd>WS2007HttpRelayBinding</kbd>, to which <kbd>RemoteExecutionContext</kbd> is passed from the Azure Service Bus.</p>
<p><strong>REST:</strong></p>
<p>A REST contract is similar to a two-way contract. Here, the listener application needs to implement the <kbd>IWebHttpServiceEndpointPlugin</kbd> interface's <kbd>Execute</kbd> method, along with <kbd>WebHttpRelayBinding</kbd>, to which <kbd>RemoteExecutionContext</kbd> is passed from the Azure Service Bus.</p>
<p><strong>Topic:</strong></p>
<p>Topics are similar to queues. However, with topics, one or more listeners can subscribe to receive messages from the topic. The messages are filtered and routed to the subscriber via the corresponding subscription from the topic.</p>
<p><strong>Event Hub:</strong></p>
<p>Microsoft Azure event hubs provide telemetry services on a very large scale. They are typically used for large-scale application telemetry and Internet of Things scenarios. Several devices or applications can send telemetry messages to the event hubs. The messages can be in thousands or millions per second to be read and processed. Creating an event hub solution application is similar to writing an Azure Service Bus listener application. Here, we first start by creating an event hub in Microsoft Azure just as in Azure Service Bus. Next, we need to specify the event hub connection string while registering the Dynamics 365 service endpoint through the plugin registration tool. We will talk in more detail about it later on in the chapter.</p>
<div class="packt_infobox">To write listener applications for the above contracts, we need to use Azure SDK Version 1.7 or later—<span class="URLPACKT"><a href="https://azure.microsoft.com/en-in/downloads/">https://azure.microsoft.com/en-in/downloads/</a>.</span></div>
<p>Now, as we have a basic understanding of the Azure Extensions available inside Dynamics 365, we will implement a simple business scenario in the next section to see it in action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Dynamics 365 and Azure Service Bus integration</h1>
                </header>
            
            <article>
                
<p>Let us take a simple scenario for implementation which will help us in understanding how to configure Azure Extensions inside Dynamics 365 and how to write different listener applications for different contract types. The listener application is basically a third-party application which needs to get notified whenever an event occurs in Dynamics 365.  The listener application and the Dynamics 365 are two separate disconnected applications. </p>
<p>Scenario: On creation of a lead record in Dynamics 365, pass its information (execution context) to the listener application through Azure Service Bus. The listener application can then read and process that information.</p>
<p>Let us walk through all the steps in detail:</p>
<ol>
<li>Log in to an Azure Management portal <a href="https://portal.azure.com"><span class="URLPACKT">https://portal.azure.com</span></a> using an existing account or create a free account at <a href="https://azure.microsoft.com/en-us/free/"><span class="URLPACKT">https://azure.microsoft.com/en-us/free</span>/</a></li>
</ol>
<ol start="2">
<li>Search and Add a new Service Bus service in the portal. Provide the required details and click on <span class="packt_screen">Create namespace</span> to create the Service Bus namespace. The name that must be specified needs to be unique across the entire data center. This creates a URI for the Service Bus namespace which can be used to access it over the internet. This Service Bus namespace acts as a container for the communication mechanisms such as relay service and brokered messaging (queues and topics):
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="457" src="assets/4368cfd1-3ea4-4f4c-aebc-a155c9b37887.png" width="284"/></div>
</li>
</ol>
<ol start="3">
<li>Next, we would create a queue to which we would be posting the message from Dynamics 365. Open the Service Bus and click on the <span class="packt_screen"><strong><span class="packt_screen">+</span></strong> <span class="packt_screen">Que</span><strong><span class="packt_screen">ue</span></strong></span> button to create a queue with the required details:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="77" src="assets/a9fd163c-7023-4ab2-8bfe-f791488cf5c7.png" width="450"/></div>
</li>
<li>Provide the details as shown here and click on the <span class="packt_screen">Create</span> button to create the queue:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="440" src="assets/30a56508-769f-44b1-861e-d6230b8df185.png" width="231"/></div>
<ol start="5">
<li>For the Queue created, select <span class="packt_screen">Shared access policies</span> and click on <span class="packt_screen">Add</span> to create a new shared access policy. As the name suggests, send rights are required for sending messages to a listener at a namespace, similarly, listen rights will be required by a listener application to begin listening on a namespace. Manage rights would be required to create a queue, delete a queue, create a subscription, enumerate topics, subscriptions and so on. Here, we have selected the <span class="packt_screen">Send</span> and <span class="packt_screen">Listen</span> checkbox while adding the SAS policy as we are going to use the same policy for both sending and listening. We can also create two separate policies, one for the sender and another for the listening application. Click on <span class="packt_screen">Create</span>, to create a new SAS policy:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="494" src="assets/5773cd38-b0c3-4fd3-bc39-9578e78ab78b.png" width="711"/></div>
<div class="mce-root packt_tip"><span>Rights required for</span> <strong>Service Bus Operations</strong> <span>(</span><strong>SAS</strong><span>) are detailed here—</span><span class="URLPACKT"><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-sas#rights-required-for-service-bus-operations">https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-sas#rights-required-for-service-bus-operations</a></span></div>
<ol start="6">
<li>Select the shared access policy created and copy its primary connection string.</li>
<li>Back in Dynamics 365, we need to register a service endpoint through the plugin registration tool. Select <span class="packt_screen">Register New Service Endpoint</span> in the plugin registration tool.</li>
</ol>
<div class="mce-root packt_tip"><span>Download the latest Microsoft Dynamics 365 SDK from—</span><span class="URLPACKT"><a href="https://www.microsoft.com/en-us/download/details.aspx?id=50032">https://www.microsoft.com/en-us/download/details.aspx?id=50032</a></span></div>
<ol start="8">
<li>Paste the connection string into the <span class="packt_screen">Register New Service Endpoint</span> dialog box and click <span class="packt_screen">Next</span>:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/35de414d-9e59-493d-be8f-b1fc87cb4d75.png"/></div>
</li>
</ol>
<ol start="9">
<li>This auto-populates the <span class="packt_screen">Service Endpoint Registration</span> details. Click on <span class="packt_screen">Save</span>:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="395" src="assets/b497793f-38fa-43f8-baea-1a5511b2c764.png" width="378"/></div>
</li>
</ol>
<p style="padding-left: 60px">This adds the service endpoint in the plugin registration tool. Next, we register a new step for create message on the Lead entity. Set <span class="packt_screen">Execution Mode</span> to <span class="packt_screen">Asynchronous</span>. If we try setting it as <span class="packt_screen">Synchronous</span> we will get the following alert <span class="packt_screen">Only asynchronous steps are supported for Service Endpoint plug-ins</span> as OOB Azure-aware plugin only supports asynchronous execution mode:</p>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img height="450" src="assets/5728f833-6414-4640-82d9-e37f68d1a39d.png" width="412"/></div>
<ol start="10">
<li>Now let us create a lead record inside Dynamics 365 to trigger the plugin:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="346" src="assets/603709d0-fd5d-4bf9-9c2f-01c454a05bc6.png" width="274"/></div>
</li>
<li>Go to <span class="packt_screen">Settings</span> | <span class="packt_screen">System Jobs</span>, a corresponding system job would have been created which shows the status of the message posted to Azure Service Bus from the asynchronous service:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/cafb16d2-db7d-467e-b224-1a25155d02f1.png"/></div>
<ol start="12">
<li>Back in our queue, we can see a new message added to <span class="packt_screen">ACTIVE MESSAGE COUNT</span>:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="247" src="assets/cae56573-5469-4d0e-83b3-a22da4725bdd.png" width="189"/></div>
</li>
</ol>
<p>In next section, we will create listener applications to read the data posted to Azure Service Bus from Dynamics 365.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a queue listener</h1>
                </header>
            
            <article>
                
<p>Let us create a simple queue listener to read the message passed to queue:</p>
<ol>
<li>Open Visual Studio and select <span class="packt_screen">Project Type</span> as <span class="packt_screen">Console Application</span>.</li>
<li>Install the following NuGet Package in the project—<kbd>WindowsAzure.ServiceBus</kbd>. It provides a client library for Microsoft Azure Service Bus operations.</li>
<li>Add a reference to the <kbd>Microsoft.Xrm.Sdk</kbd> assembly or install the following NuGet Package – <kbd>Microsoft.CrmSdk.Core</kbd> assemblies.</li>
<li>Specify the same connection string that was defined for the service endpoint in the plugin registration tool.</li>
</ol>
<ol start="5">
<li>We need to create a <kbd>QueueClient</kbd> object using the connection string and get the remote execution context using the <kbd>BrokeredMessage</kbd> received. Next, we are retrieving the value for the topic field, the name of the entity and the message on which the plugin was fired from the <kbd>RemoteExecutionConext</kbd> and writing it to console as shown as follows:</li>
</ol>
<pre style="padding-left: 60px">// set the connection string of the Shared Access Policy created for the Queue 
var connectionString = "Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=[KeyName];SharedAccessKey=[KeyValue];EntityPath=[QueueName]"; 
 
// create the Queue Client object 
var client = QueueClient.CreateFromConnectionString(connectionString); 
 
while (true) 
{ 
Console.Write("Press [Enter] to retrieve a message from the queue."); 
string line = Console.ReadLine(); 
Console.WriteLine("Waiting for a message from the queue... "); 
try 
{ 
// get the message from the Queue Client 
BrokeredMessage brokeredMessage = client.Receive(); 
 
// if message recieved 
if (brokeredMessage != null) 
{ 
// get the Remote Execution Context passed from the Azure Service Bus 
RemoteExecutionContext context = brokeredMessage.GetBody&lt;RemoteExecutionContext&gt;(); 
 
// cast to Entity object 
Entity entity = (Entity)context.InputParameters["Target"]; 
 
// get the lead's topic attribute value 
var leadTopic = entity.Attributes["subject"].ToString(); 
 
// output to console 
Console.WriteLine(string.Format("   Entity Name = {0}, Message Name = {1}, Lead's Topic = {2}", 
context.PrimaryEntityName, context.MessageName, leadTopic)); 
 
// marks message as processed and deleted 
brokeredMessage.Complete(); 
} 
} 
catch (TimeoutException ex) 
{ 
Console.WriteLine(ex.Message); 
continue; 
} 
catch (FaultException ex) 
{ 
Console.WriteLine(ex.Message); 
continue; 
} 
} </pre>
<ol start="6">
<li>On running our application, we can see the following details passed as <kbd>RemoteExecutionContext</kbd> to the queue in the output:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="90" src="assets/14523ab2-794e-4d20-a6f5-b1824c6f1fa7.png" width="474"/></div>
</li>
</ol>
<p>The sample application, when run, will read the message in the queue and print the details in the console.</p>
<p>Here, the <strong>Message Time to Live</strong> property of the queue defines the time span the message will remain in the queue, if not processed. After which it is will be either removed or dead lettered, that is, moved to another secondary sub-queue named dead letter queue. The dead letter queue holds the messages that were not delivered or processed.</p>
<div class="mce-root packt_tip"><span>Azure Service Bus dead letter queue—</span><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dead-letter-queues">https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dead-letter-queues</a>.</div>
<p>The <strong>Lock Duration</strong> property of the queue specifies the number of seconds for which a message will be locked by a receiver once it receives it. This specifies the time the listener application has to process the message. If not processed, the message will be available to be received by another receiver.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a topic listener</h1>
                </header>
            
            <article>
                
<p>Let us continue with our previous scenario of the creation of a lead record and update it to use topics instead of queues:</p>
<ol>
<li>Log in to Azure Portal to create a topic in Azure Service Bus by clicking on <span class="packt_screen">+Topic</span>.</li>
<li>Add the required details and click on the <span class="packt_screen">Create</span> button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="359" src="assets/6e3a8600-1894-47cf-a8cf-bd0caf3da7e2.png" width="265"/></div>
<ol start="3">
<li>Inside <span class="packt_screen">Topic</span>, create a new shared access policy and copy its primary connection string. This connection string will be used while registering a new service endpoint in the plugin registration tool as shown here:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="381" src="assets/cbf1843a-93b4-4b3d-84e1-d1bb6b8ce6ff.png" width="365"/></div>
</li>
<li>Add a new step to this registered service endpoint for it to be triggered by the <span class="packt_screen">Create</span> of the lead record in Dynamics 365.</li>
</ol>
<ol start="5">
<li>Now let us go back to our created topic. Click on the <span class="packt_screen">+ Subscription</span> button inside <span class="packt_screen">Topic</span> to add a new subscription. Specify required details as shown here and click on <span class="packt_screen">Create</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="438" src="assets/0ff12b0a-9240-4985-8030-e14920b80d0c.png" width="247"/></div>
<ol start="6">
<li>This creates a new subscription inside <span class="packt_screen">Topic</span>. We can create multiple subscriptions and each subscription will receive a copy of the message that has been posted to the Azure Service Bus.</li>
<li>The following is the sample code for our topic listener application. Here instead of a <kbd>QueueClient</kbd> object, we would be using a <kbd>SubscriptionClient</kbd> object to read and process the context passed:</li>
</ol>
<pre style="padding-left: 60px">// set the connection string of the Shared Access Policy created for the Subscription 
// along with name of the Topic and Subscription 
 
var connectionString = "Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=[KeyName];SharedAccessKey=[KeyValue];EntityPath=[TopicName]"; 
 
var topic = "[topic]"; 
var subscriptionName = "[subscription]"; </pre>
<pre style="padding-left: 60px">// create the Subcription Client object 
var client = SubscriptionClient.CreateFromConnectionString(connectionString, topic, subscriptionName); 
 
while (true) 
{ 
Console.Write("Press [Enter] to retrieve a message from the topic."); 
string line = Console.ReadLine(); 
Console.WriteLine("Waiting for a message from the topic... "); 
try 
{ 
// get the message from the client 
BrokeredMessage brokeredMessage = client.Receive(); 
 
// get the Remote Execution Context passed from the Azure Service Bus 
RemoteExecutionContext context = brokeredMessage.GetBody&lt;RemoteExecutionContext&gt;(); 
 
// cast to Entity object 
Entity entity = (Entity)context.InputParameters["Target"]; 
 
// get the lead's topic attribute value 
var leadTopic = entity.Attributes["subject"].ToString(); 
 
// output to console 
Console.WriteLine(string.Format("  Entity Name = {0}, Message Name = {1}, Lead's Topic = {2}", 
context.PrimaryEntityName, context.MessageName, leadTopic)); 
 
// marks message as processed and deleted 
brokeredMessage.Complete(); 
} 
catch (TimeoutException ex) 
{ 
Console.WriteLine(ex.Message); 
continue; 
} 
catch (FaultException ex) 
{ 
Console.WriteLine(ex.Message); 
continue; 
} 
} </pre>
<ol start="8">
<li>Now, let us go back to Dynamics 365 and create a lead record to trigger our plugin:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="317" src="assets/6b362696-9c1e-492e-b6d6-d1d1c431c8a2.png" width="264"/></div>
</li>
<li>Inside our topic, we can see that all the subscriptions created for that topic have received the message:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img height="101" src="assets/c97b1a1d-29bf-4603-b1d8-0c9ba5b3b9bb.png" width="501"/></div>
<ol start="10">
<li>Running our subscription listener, we get the expected output:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="71" src="assets/02029edc-0e90-419b-8e1d-45518c52e53c.png" width="479"/></div>
<p>Until now we have covered how to write a listener application for queues and topics, in the next section we will cover writing listener applications for one-way, two-way and REST contracts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a one-way listener</h1>
                </header>
            
            <article>
                
<p>Let us walk through all the steps required for writing a one-way listener:</p>
<ol>
<li>Continuing with the same scenario, first, we need to register our service endpoint. For this, create a new shared access policy for the Azure Service Bus namespace. Go to shared access policies settings for the Azure Service Bus and click on <span class="packt_screen">Add</span> to create a new policy with send and listen rights and copy its primary connection string.</li>
<li>Paste the copied connection string in the <span class="packt_screen">Register Service Endpoint</span> dialog box of the plugin registration tool.</li>
</ol>
<div class="mce-root packt_tip"><span>When we create an Azure Service Bus namespace, a policy called</span> <kbd>RootManageSharedAccessKey</kbd> <span>is automatically created. It has an associated pair of primary and secondary keys that grant send,</span> listen<span>, and manage rights to the Service Bus namespace. It is recommended you create additional policies instead of using this default policy which has all the permissions.</span></div>
<ol start="3">
<li>Update the value for properties in <span class="packt_screen">Service Endpoint Registration</span> as shown here:</li>
</ol>
<ul>
<li><span class="packt_screen">Namespace Address</span>: Replace <kbd>sb</kbd> with <kbd>https</kbd></li>
<li><span class="packt_screen">Designation type</span>: <kbd>OneWay</kbd></li>
<li><span class="packt_screen">Path</span>: <kbd>MyPath</kbd></li>
</ul>
<p>The following screenshot shows the <span class="packt_screen">Service Endpoint Registration</span> dialog box populated with the appropriate values:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="335" src="assets/45196d0c-5aca-477a-8b16-ab802bba4047.png" style="text-align: center;color: black;font-size: 1em" width="313"/></div>
<ol start="4">
<li>Register a step, on the <span class="packt_screen">Create</span> of<strong> </strong>the lead record for the service endpoint registered and trigger it by creating a lead record inside Dynamics 365.</li>
<li>Go to <span class="packt_screen">Settings</span> | <span class="packt_screen">System Jobs</span> and check the corresponding system job created.</li>
<li>Here the system job will fail with the following message:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c807d437-5b9b-4ede-9a1a-64bd0427707a.png"/></div>
<ol start="7">
<li>As we discussed earlier, for the relay service, an active listener is required, unlike queues or topics.</li>
</ol>
<ol start="8">
<li>In our one-way listener application, we need to implement the <kbd>IServiceEndpointPlugin</kbd> interface and use <kbd>WS2007HttpRelayBinding</kbd>.</li>
<li>In the following, we are self hosting the service in a console application:</li>
</ol>
<pre style="padding-left: 60px">[ServiceBehavior] 
class AzureExample : IServiceEndpointPlugin 
{ 
static void Main(string[] args) 
{ 
// get the shared access key name 
// shared access key value 
// service bus endpoint from the Shared Access Policy Connection String. 
var sharedAccessKeyName = "[keyName]"; 
var sharedAccessKey = "[keyValue]"; 
var serviceBusEndPoint = "https://[serviceBusNameSpace].servicebus.windows.net"; 
 
// initialize the ServiceHost 
var serviceHost = new ServiceHost(typeof(AzureExample)); 
 
// define the behaviour 
var transportClient = new TransportClientEndpointBehavior 
(TokenProvider.CreateSharedAccessSignatureTokenProvider(sharedAccessKeyName, sharedAccessKey)); 
 
// add the service endpoint 
serviceHost.AddServiceEndpoint(typeof(IServiceEndpointPlugin), 
new WS2007HttpRelayBinding(), serviceBusEndPoint).EndpointBehaviors.Add(transportClient); 
 
serviceHost.Open(); 
 
Console.ReadLine(); 
} 
 
void IServiceEndpointPlugin.Execute(RemoteExecutionContext context) 
{ 
// cast to Entity object 
Entity entity = (Entity)context.InputParameters["Target"]; 
 
// get the lead's topic attribute value 
var leadTopic = entity.Attributes["subject"].ToString(); 
 
// output to console 
Console.WriteLine(string.Format("  Entity Name = {0}, Message Name = {1}, Lead's Topic = {2}", 
context.PrimaryEntityName, context.MessageName, leadTopic)); 
} 
} </pre>
<ol start="10">
<li>Run the listener application so that it can actively listen for messages passed to it and create the lead record inside Dynamics 365. This will invoke the <kbd>Execute</kbd> method in our listener application and output the remote execution context details in the console window.</li>
</ol>
<p>In this section, we learned how to write a one-way listener, in the next section we will cover how to write a two-way listener application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a two-way listener and an Azure-aware plugin</h1>
                </header>
            
            <article>
                
<p>Let us walk through all the steps in detail for writing a two-way listener:</p>
<ol>
<li>In the case of a two-way contract, we need to implement a custom Azure-aware plugin that can receive the response back from the two-way listener application, but before that let's register a new service endpoint for a two-way contract as shown here:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="317" src="assets/52f70e55-d4c6-4cf6-8308-3720e0d4f6e2.png" width="301"/></div>
</li>
</ol>
<ol start="2">
<li>The two-way listener application needs to implement the <kbd>ITwoWayServiceEndPointPlugin</kbd> interface and use <kbd>WS2007HttpRelayBinding</kbd>. Also, the <kbd>Execute</kbd> method returns a string that enables the two-way communication. As mentioned earlier, with relay, it is real time, so the listener needs to be actively listening to the messages, unlike queue and topics.</li>
<li>In the following, we are self-hosting the service in a console application:</li>
</ol>
<pre style="padding-left: 60px">[ServiceBehavior] 
class AzureExample : ITwoWayServiceEndpointPlugin 
    { 
        static void Main(string[] args) 
        { 
            // get the shared access key name 
            // shared access key value 
            // service bus endpoint from the Shared Access Policy <br/>            Connection String. 
            var sharedAccessKeyName = "RootManageSharedAccessKey"; 
            var sharedAccessKey = "[KeyValue]"; 
            var serviceBusEndPoint =  <br/>           "https://[ServiceBusNamespace].servicebus.windows.net"; 
 
            // initialize the ServiceHost  
            var serviceHost = new ServiceHost(typeof(AzureExample)); 
 
            // define the behaviour 
            var transportClient = new<br/>            TransportClientEndpointBehavior 
                 <br/>        (TokenProvider.CreateSharedAccessSignatureTokenProvider<br/>        (sharedAccessKeyName,  <br/>          sharedAccessKey)); 
 
            // add the service endpoint 
            serviceHost.AddServiceEndpoint<br/>           (typeof(ITwoWayServiceEndpointPlugin), 
                new WS2007HttpRelayBinding(),  <br/>                serviceBusEndPoint).EndpointBehaviors.<br/>                Add(transportClient); 
 
            serviceHost.Open(); 
 
            Console.ReadLine(); 
        }        
 
        string ITwoWayServiceEndpointPlugin.Execute<br/>        (RemoteExecutionContext context) 
        { 
            // cast to Entity object 
            Entity entity =  <br/>            (Entity)context.InputParameters["Target"]; 
 
            // get the lead's topic attribute value 
            var leadTopic = entity.Attributes["subject"].ToString(); 
 
            // output to console 
            Console.WriteLine(string.Format<br/>            ("  Entity Name = {0}, Message Name = <br/>            {1}, <br/>            Lead's Topic = {2}", 
                context.PrimaryEntityName, <br/>               context.MessageName, leadTopic)); 
 
            // return the message back to the<br/>            custom azure aware plugin 
            return "Message Processed"; 
        } 
    } </pre>
<ol start="4">
<li>To read the message returned from the listener application in a two-way relay, let us write a custom Azure-aware plugin.</li>
<li>The first thing we need here is the GUID of the service endpoint we registered. We can get the GUID, <span class="packt_screen">ServiceEndpointId</span> from the properties window of the service endpoint registered as shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/43afe7b4-e7a9-421f-b8ad-f2a763cd647a.png"/></div>
<ol start="6">
<li>Here, <kbd>IServiceEndpointNotificationService</kbd> will provide us with the service endpoint, for which we will pass the service endpoint entity reference to it.</li>
<li>We need to call the <kbd>Execute</kbd> method of the notification service to post the execution context to the Azure Service Bus. The <kbd>Execute</kbd> method returns the response received from the listener application, which we are then tracing using the <kbd>ITracingService</kbd> inside our custom Azure-aware plugin:</li>
</ol>
<pre style="padding-left: 60px">public class AzureAwarePlugin : IPlugin 
    { 
        public void Execute(IServiceProvider serviceProvider) 
        { 
            // set the Service Endpoint Id 
            var serviceEndpointId = "[serviceEndpointGUID]"; 
 
            // Obtain the execution context from <br/>            the service provider. 
            IPluginExecutionContext context = <br/>           (IPluginExecutionContext) 
                serviceProvider.GetService<br/>                 (typeof(IPluginExecutionContext)); 
 
            //Extract the tracing service for use in debugging <br/>           sandboxed plug-ins. 
            ITracingService tracingService = 
                 <br/>          (ITracingService)serviceProvider.GetService<br/>         (typeof(ITracingService)); 
 
            // Extract the notification service for posting <br/>            execution context 
            IServiceEndpointNotificationService <br/>            notificationService =  <br/>           (IServiceEndpointNotificationService) 
                 <br/>           serviceProvider.GetService(typeof<br/>          (IServiceEndpointNotificationService)); 
 
            var response = notificationService.Execute(new <br/>          EntityReference("serviceendpoint", new <br/>           Guid(serviceEndpointId)), context); 
 
            if (!string.IsNullOrEmpty(response)) 
            { 
                tracingService.Trace("Response = {0}", response); 
            } 
        } 
    } </pre>
<ol start="8">
<li>Register the plugin and add a new step for<strong> </strong>the <strong>Lead on Create</strong> message to it. The custom Azure-aware plugin can be registered as synchronous, unlike the OOB Azure-aware plugin.</li>
<li>Create a lead record to trigger the plugin. Make sure our two-way listener application is running and ready to receive the message.</li>
<li>The listener application, on successfully receiving the context passed from the Azure Service Bus, returns the string <span class="packt_screen">Message Processed</span>.</li>
<li>Inside Dynamics 365, go to <span class="packt_screen">Settings</span> |<strong> </strong><span class="packt_screen">Plug-In Trace Log</span> to verify the same:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="228" src="assets/b89b1454-526b-4fe4-96da-267a48f14ccc.png" width="438"/></div>
</li>
</ol>
<div class="packt_infobox">To enable logging for the Plug-in Trace Log, go to <span class="packt_screen">Settings</span> |<strong> </strong><span class="packt_screen">System Settings</span> |<strong> </strong><span class="packt_screen">Customization</span> tab. Select <strong>All options</strong> to enable logging to the Plug-in Trace Log field.</div>
<p>In the next section, we will cover how to write REST listener applications, which is similar to the two-way listener application, the main difference being that it uses a REST endpoint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a REST listener</h1>
                </header>
            
            <article>
                
<p>Let us walk through all the steps in detail for writing a two-way REST listener. As it uses a REST endpoint, it allows us to create a relay service in Node.js which can be executed on multiple platforms such as macOS, Windows, Linux and so on:</p>
<ol>
<li>Before writing a REST listener, let us first register a new service endpoint as shown here:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="340" src="assets/b5c27824-531f-42a1-86eb-6f0b925dc144.png" width="325"/></div>
</li>
<li>The REST Listener needs to implement the <kbd>IWebHttpServiceEndpointPlugin</kbd> interface and use <kbd>WebHttpRelayBinding</kbd>. Here again, we are self hosting the service in a console application:</li>
</ol>
<pre style="padding-left: 60px">[ServiceBehavior] 
  class AzureExample : IWebHttpServiceEndpointPlugin 
    { 
        static void Main(string[] args) 
        { 
            // get the shared access key name 
            // shared access key value 
            // service bus endpoint from the Shared <br/>           Access Policy Connection String. 
            var sharedAccessKeyName = "RootManageSharedAccessKey"; 
            var sharedAccessKey = "[KeyValue]"; 
            var serviceBusEndPoint = <br/>            "https://[ServiceBusNamespace].servicebus.windows.net"; 
             
            // Create the service host for <br/>           Azure to post messages to. 
            var serviceHost = new <br/>           WebServiceHost(typeof(AzureExample)); 
 
            // define the behaviour 
            var transportClient = new <br/>            TransportClientEndpointBehavior 
                <br/>          <br/>        (TokenProvider.CreateSharedAccessSignatureTokenProvider<br/>        (sharedAccessKeyName,  <br/>           sharedAccessKey)); 
 
 
            // Using an HTTP binding instead of a <br/>            SOAP binding for this RESTful <br/>             endpoint. 
            WebHttpRelayBinding binding = new WebHttpRelayBinding(); 
            binding.Security.Mode = <br/>            EndToEndWebHttpSecurityMode.Transport; 
 
            // add the service endpoint 
            serviceHost.AddServiceEndpoint<br/>             (typeof(IWebHttpServiceEndpointPlugin), 
               binding, serviceBusEndPoint).<br/>              EndpointBehaviors.Add(transportClient); 
 
            // Begin listening for messages posted to Azure. 
            serviceHost.Open();            
 
            Console.ReadLine(); 
        } 
 
        string IWebHttpServiceEndpointPlugin.<br/>         Execute(RemoteExecutionContext context) 
        { 
            // cast to Entity object 
            Entity entity = <br/>            (Entity)context.InputParameters["Target"]; 
 
            // get the lead's topic attribute value 
            var leadTopic = entity.Attributes["subject"].ToString(); 
 
            // output to console 
            Console.WriteLine(string.Format<br/>            ("  Entity Name = {0}, Message Name = <br/>             {1}, <br/>             Lead's Topic = {2}", 
                context.PrimaryEntityName, <br/>                context.MessageName, leadTopic)); 
 
            // return the message back to the <br/>            custom azure aware plugin 
            return "Message Processed by Rest Listener"; 
        } 
 
    } </pre>
<ol start="3">
<li>Back in Dynamics 365, create a lead record to trigger the plugin, which calls the <kbd>Execute</kbd> method of the listener application. The listener, on receiving the message, returns the string <span class="packt_screen">Message Processed by Rest Listener</span>, which is traced by the plugin in the Plug-in Trace Logs as shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="292" src="assets/f6dc9d9b-810c-47ca-9aa7-d33f7b144b4c.png" width="484"/></div>
<p>In this section, we learned how to write a REST listener, in the next section we will cover how to write an event hub listener application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing an event hub listener</h1>
                </header>
            
            <article>
                
<p>Let us walk through all the steps in detail for writing an event hub listener. To create an event hub listener:</p>
<ol>
<li>Go to Azure Portal, search for event hubs, and create a new event hubs namespace.</li>
<li>Select <span class="packt_screen">Event Hubs</span> inside <span class="packt_screen">Event Hubs Namespace</span> and click on <span class="packt_screen">Add Event Hub</span> to create a new event hub.</li>
<li>For the event hub created, add a new <kbd>SharedAccessKey</kbd> with appropriate rights and copy its connection string and use it while registering a new service endpoint in the plugin registration tool as shown here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="387" src="assets/de11c177-145a-4cc5-ad04-30f0ad938744.png" width="371"/></div>
<ol start="4">
<li>Add a step to trigger the plugin on <span class="packt_screen">Create</span> of the Lead record.</li>
<li>For the event hub listener application, create a new console application, add the following NuGet Package in it—<kbd>WindowsAzure.ServiceBus</kbd>.</li>
</ol>
<ol start="6">
<li>The following is the sample code for our event hub listener application. Here we are using the <kbd>EventHubClient</kbd> object to create the receiver:</li>
</ol>
<pre style="padding-left: 60px">var connectionString = "Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=[KeyName];SharedAccessKey=[KeyValue];EntityPath=[QueueName]"; 
 
// create the Event Hub Client object 
var client = EventHubClient.CreateFromConnectionString(connectionString); 
 
// create the event hub reciever 
EventHubConsumerGroup consumerGroup = client.GetDefaultConsumerGroup(); 
var eventHubReciever = consumerGroup.CreateReceiver(client.GetRuntimeInformation().PartitionIds[0]); 
 
while (true) 
{ 
Console.Write("Press [Enter] to retrieve a message from the Event Hub."); 
string line = Console.ReadLine(); 
Console.WriteLine("Waiting for a message from the eventhub... "); 
 
// call the Recieve method 
var message = eventHubReciever.Receive(); 
 
// get the JSON result 
string jsonResult = Encoding.UTF8.GetString(message.GetBytes()); 
// output to window 
Console.WriteLine("JSON Output" + jsonResult); 
} </pre>
<ol start="7">
<li>Create a new lead inside Dynamics 365.</li>
<li>Running our event hub listener, we see the expected JSON output inside the console:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="120" src="assets/deb1181e-2a8d-4a48-bdd8-0ea14d32100f.png" width="518"/></div>
<div class="packt_infobox">The recommended way to receive events from event hubs is by using the event processor host—<span class="MsoHyperlink"><a href="https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-dotnet-standard-api-overview#event-processor-host-apis">https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-dotnet-standard-api-overview#event-processor-host-apis</a>.</span> (The source code for the chapter includes the example of receiving events using the event processor.)</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered Azure Extensions provided within Dynamics 365 and how to configure and write listener applications for different supported contract types.</p>
<p>In the next chapter, we will look at the new Editable Grid introduced with CRM 2016 and different properties that are supported.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>