- en: '*Chapter 11*: Beyond Automation; an Introduction to Scripting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have focused on automating everyday tasks in Jira using a code-free
    approach. This automation functionality is native to Jira Cloud and is available
    in Jira Server and Jira Data Center with the addition of the *Automation for Jira*
    app.
  prefs: []
  type: TYPE_NORMAL
- en: This approach makes it very easy for Jira administrators to get up and running
    with automation quickly as they require no specialist coding knowledge. In addition,
    the ability to create automations can be delegated to project administrators,
    thereby allowing Jira administrators to focus on other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: However, any book on automation in Jira would not be complete if it did not
    mention scripting and, in particular, **ScriptRunner for Jira**, which is arguably
    the most well-known automation app available.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll provide a brief introduction to ScriptRunner for Jira
    and to the Groovy scripting language, which ScriptRunner uses under the hood.
    In addition, we'll look at the differences between scripting for Jira Cloud and
    Jira Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing advanced automations with ScriptRunner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring scripting in Jira Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring scripting in Jira Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jira cloud environment**: If you don''t already have access to Jira, you
    can create a free Jira Cloud account at [https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)
    and ensure that you have both Jira Software and Jira Service Management selected.
    You will also need to install *ScriptRunner for Jira* from the Atlassian Marketplace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jira Server environment**: If you are using Jira Server (available from [https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)),
    ensure that you have licenses for both Jira Software and Jira Service Desk. In
    addition, you will also need to ensure that you install the *ScriptRunner for
    Jira* app available from the Atlassian Marketplace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to be a global Jira administrator in order to follow the examples
    in this chapter. In addition, we have used the *IT Service Management project
    template* to create the Service Desk project that these examples run against.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the latest code samples for this chapter from this book''s
    official GitHub repository at [https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira).
    Please visit the following link to check the CiA videos: [https://bit.ly/39L6BIB](https://bit.ly/39L6BIB)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing advanced automations with ScriptRunner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ScriptRunner** for Jira allows you to extend the functionality of both Jira
    Cloud and Jira Server or Jira Data Center using scripts written in the **Groovy**
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to use the Groovy language in your automations gives you access
    to the underlying Java platform and the Jira API, as well as providing the full
    power of the scripting language itself.
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see, in the case of Jira Cloud, access to the Jira API is limited to
    the interaction with the REST API provided by Jira. In Jira Server, however, your
    scripts gain access to the entire API that Jira exposes to developers.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin this section with a quick introduction to the Groovy language, which
    underpins ScriptRunner, followed by an overview of the ScriptRunner for Jira app.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Groovy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Groovy**, or **Apache Groovy** to give it its full name, is a programming
    language built on the Java platform. It is both a static language, in that it
    can be compiled to bytecode, as well as a dynamic language in that it can be interpreted
    at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Groovy is syntax-compatible with Java. This means that it integrates and operates
    seamlessly with Java and, more importantly, with third-party libraries. It also
    means that you can write Java code in a Groovy script and have it correctly interpreted
    and executed.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Groovy supports functional programming and optional typing, meaning
    it can infer the object type at runtime. It also has a much more concise and expressive
    syntax than Java and is able to efficiently process both XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an example that highlights both the differences and similarities
    between Java and Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a list of names and then iterate that list,
    printing each name out to the console, prepended with the word `"Hello"`, using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although this code is written in Java, it can run entirely unmodified in Groovy.
    When writing scripts, an execution context is usually provided by the application.
    This execution context is essentially an empty method within a class and our script
    is the method body, so we do not need to declare a surrounding class or method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the Groovy version of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This Groovy script is equivalent to the Java code we saw previously. Let''s
    take a quick look at what is going on in this example line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def nameList = ["Andrew", "Evelyn", "Tony"]`: We have used optional typing
    for the `nameList` variable by declaring it using the `def` keyword. In addition,
    we have initialized the variable with a list of strings using square brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nameList.each { name ->`: Here we are calling the `each` closure on the list,
    and naming the closure parameter `name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures are identified by the use of curly braces, while the arrow (`->`) separates
    the closure parameters from the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using a closure with only a single parameter, and where you do not need
    to reference the parameter in an inner closure, you can omit both the parameter
    and the separating arrow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this case, the parameter name defaults to the word `it`, as seen in the
    following example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`nameList.each { println "Hello ${it}" }`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`println "Hello ${name}"`: This line is using string interpolation to print
    the word `"Hello"` followed by the name currently being iterated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you will notice that the semicolon used in Java to terminate a
    statement is not required in Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Groovy on the official Apache Groovy website at [https://groovy-lang.org/learn.html](https://groovy-lang.org/learn.html),
    where there are numerous books, presentations, and courses available to help you
    learn and get the most out of the Groovy language.
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned, Groovy allows you to write concise, easily readable code
    in addition to enabling you to write your scripts in Java. Next, let's take a
    look at how ScriptRunner for Jira leverages this to allow us to create automation
    scripts in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ScriptRunner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adaptavist's **ScriptRunner** is an app in the Atlassian ecosystem that has
    been around for over a decade. It incorporates the Groovy scripting engine and
    configures it in a manner that facilitates scripted access to Jira via the available
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: It has been the go-to app for many Jira administrators looking to both automate
    and extend the base functionality of Jira, and indeed other Atlassian tools, including
    Confluence, Bitbucket, and Bamboo.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, ScriptRunner gives you access to the Jira application by providing
    a ready-made framework with all the underlying plumbing already in place, thereby
    allowing you to concentrate on the business logic of your automations.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: ScriptRunner provides a lot more functionality than just the ability to create
    scripted automations. It provides the ability to create workflow functions using
    both built-in and custom Groovy scripts. In addition, it also provides a number
    of powerful additional JQL features to make searching Jira easier. It also allows
    you to make customizations to the user interface using script fragments, the complexity
    of which will vary depending on whether you use Jira Cloud or Jira Server.
  prefs: []
  type: TYPE_NORMAL
- en: Adaptavist provides comprehensive documentation and tutorials for ScriptRunner
    for both Jira Cloud and Jira Server. You can learn more about *ScriptRunner for
    Jira Cloud* at [https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html](https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html).
    To learn more about *ScriptRunner for Jira Server*, you can find the documentation
    at [https://scriptrunner.adaptavist.com/latest/jira/quickstart.html](https://scriptrunner.adaptavist.com/latest/jira/quickstart.html).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Adaptavist provides a library of scripts that you can use as is or as a starting
    point for your own scripts. You can find these at [https://library.adaptavist.com](https://library.adaptavist.com).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had a brief introduction to ScriptRunner and the Groovy scripting
    language, let's look at how we can create automations using scripts in Jira Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring scripting in Jira Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ScriptRunner for Jira Cloud enables you to create automations in response to
    events that occur in Jira, such as when an issue is created or updated, among
    others. It also has an escalation service, which allows you to perform a scheduled
    action against a list of issues provided by a JQL query.
  prefs: []
  type: TYPE_NORMAL
- en: ScriptRunner also provides the ability to run scripts at scheduled intervals.
    This differs from the escalation service in that it does not require a list of
    issues on which to perform actions, allowing you to perform tasks such as creating
    issues on a recurring basis.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take a high-level overview of how the Jira Cloud API
    works and then recreate the *Incident priority matrix* example from [*Chapter
    2*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038), *Automating Jira Issues*,
    to understand how to write automations using scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Jira Cloud API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for an app to integrate with Jira Cloud, it needs to be built using
    the *Atlassian Connect framework*. This framework allows apps to extend the Jira
    user interface, access the Jira APIs, and respond to events from Jira Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: An app built using the Connect framework is a web application that operates
    remotely over the HTTP protocol. This means that when you build a Connect app
    for Jira, it needs to be hosted on a publicly accessible web server that can receive
    requests over HTTP from Jira Cloud, and which can send REST API requests to Jira
    Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic interaction between Jira Cloud and an app built using the Connect
    framework can be seen in the following diagram. This is a simplified representation
    as it pertains to automation with ScriptRunner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – App interaction with the Atlassian Connect framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B16551.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – App interaction with the Atlassian Connect framework
  prefs: []
  type: TYPE_NORMAL
- en: When an event occurs in Jira Cloud, a webhook is sent over HTTP to notify the
    ScriptRunner app that the event has occurred. This prevents the app from needing
    to poll Jira periodically to determine whether changes have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In response, ScriptRunner will initiate the execution of any scripts that are
    configured to listen for the specific events. In turn, these scripts make use
    of the Jira REST API to retrieve additional information and to update data in
    Jira.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts that make use of ScriptRunner's scheduled or escalation service will
    only require access to the Jira REST API to interact with data in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the webhooks available in Jira Cloud at [https://developer.atlassian.com/cloud/jira/platform/webhooks/](https://developer.atlassian.com/cloud/jira/platform/webhooks/),
    while you can learn about the Jira Cloud REST API at [https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/](https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned how the Jira Cloud API basically works, let's take a
    look at how we can use this to create a scripted automation in Jira Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scripted automation in Jira Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are going to recreate the incident priority matrix automation
    that we first introduced in the *If/else block* section in [*Chapter 2*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038),
    *Automating Jira Issues*. If you have a similar rule using Jira Automation, you
    should disable it before implementing this rule.
  prefs: []
  type: TYPE_NORMAL
- en: This example will show you how to achieve a similar automation in Jira Cloud
    utilizing a Groovy script and the Jira Cloud API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Groovy script we will use to achieve this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The incident priority matrix script in Jira Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B16551.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – The incident priority matrix script in Jira Cloud
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what''s going on in this script:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is use Jira's REST API to retrieve all the custom fields
    into a list stored in the `customFields` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the list of custom fields, we then ascertain the IDs of the `Impact` and
    `Urgency` fields and save them in the corresponding variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the IDs for the `Impact` and `Urgency` fields, we can use these
    to extract their respective values from the issue, which is represented as a `Map`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this block, we are using the values of the fields to determine the correct
    priority according to the priority matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're making use of the Groovy `switch` statement to make the code more readable
    than if we had used an if/else block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we use Jira's REST API to update the issue with the new priority calculated
    in *step 4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve created the automation script in Groovy, we need to create
    a script listener in ScriptRunner to actually get the automation working:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Jira administrator, click on the **Apps** menu in the top menu bar, and
    then select **Manage your apps**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the left-hand menu, select the **Script Listeners** tab under the **ScriptRunner**
    section, and then click the **Add Listener** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the script listener fields as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Incident priority matrix`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Issue Created` and `Issue Updated`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`IT Service Desk (DESK)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Current User`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We only want this listener to be called if the issue is an incident, so we need
    to add a condition to the listener, which will evaluate to `true` only if we're
    dealing with an incident.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `issue.issueType.name == 'Incident'`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will ensure that this listener only continues to execute if the name of
    the issue type is `Incident`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, type the script into the `11.1 Incident priority matrix – Cloud.groovy`
    from this chapter's GitHub repository and then copy and paste the code into the
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your script listener should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Creating a script listener in Jira Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B16551.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Creating a script listener in Jira Cloud
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to recreate the incident priority matrix
    using a Groovy script in a script listener in Jira Cloud. You should now understand
    how scripting can also be used to automate tasks in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will take a look at how we can create scripted
    automations in Jira Server, and we'll reuse the incident priority matrix example
    so you can see the differences between the platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring scripting in Jira Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to ScriptRunner for Jira Cloud, ScriptRunner for Jira Server allows
    you to create automations in response to events within Jira.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in Jira Cloud, however, you are able to create automations against a
    much wider range of events in Jira Server due to the fact that you have access
    to the full Jira API.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take a look at the API available to scripts on the Jira
    Server platform. We'll then take another look at the incident priority matrix
    example so that we can more easily understand the differences between scripting
    between the platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Jira Server API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to the Jira Cloud API, apps written using the Jira Server API run
    in the same Java process as the core Jira application and therefore have full
    access to the underlying application via the public Java-based API.
  prefs: []
  type: TYPE_NORMAL
- en: ScriptRunner for Jira Server is an app built using the Jira **Plugins2** (**P2**)
    framework. This framework allows apps to register as listeners for events within
    Jira, as well as provide access to the underlying API and public third-party libraries
    shipped with the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Jira API is vast, and fully understanding every aspect of it could fill
    a couple of books. For our purposes, however, we will concentrate on the `ComponentAccessor`
    class, which is documented at [https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html](https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html).
  prefs: []
  type: TYPE_NORMAL
- en: This class is the entry point to most of the components you will require when
    writing scripts in ScriptRunner. It gives you a handle of things such as the `IssueService`
    and `IssueManager` classes, which deal with creating, updating, and modifying
    issues. You will also use it to get access to the `CustomFieldManager` class,
    which allows you to manipulate most custom fields you define in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about how to use `IssueService` and `IssueManager` to interact
    with issues in Jira in the official *Performing issue operations* tutorial located
    at [https://developer.atlassian.com/server/jira/platform/performing-issue-operations/](https://developer.atlassian.com/server/jira/platform/performing-issue-operations/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get access to `ComponentAccessor`, you will need to explicitly import the
    class at the start of your script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import com.atlassian.jira.component.ComponentAccessor`'
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in the example we present in the next section, `ComponentAccessor`
    is integral to our ability to find and manipulate data in Jira Server.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had a brief introduction to the Jira Server API, let's take a
    look at how we can create an automation script using the API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scripted automation in Jira Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are again going to recreate the incident priority matrix
    using a Groovy script so that we can learn about the differences between scripting
    in Jira Server and Jira Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script we are going to use for this example is presented in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – The incident priority matrix script in Jira Server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B16551.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – The incident priority matrix script in Jira Server
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine what this script is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is import the Jira API classes that we'll need
    for this script. Without these, the script will not compile and will not be able
    to access the Jira API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Script listeners in ScriptRunner for Jira Server present an event object to
    the script. The event object contains the underlying issue in the issue field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, we are ensuring that the `issue` variable is cast as a `MutableIssue`
    type, which will allow us to make changes to the issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Custom script listeners in ScriptRunner for Jira Server do not have a condition
    field, so we need to use an `if` statement to ensure that we only continue execution
    if we're dealing with an incident issue type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we are retrieving the custom field objects for the `Impact` and `Urgency`
    fields by using the `CustomFieldManager` component accessible from `ComponentAccessor`.
    In this example, I am retrieving the fields by name rather than by ID, but you
    could use either method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the custom field objects for the `Impact` and `Urgency` fields,
    we can use these to retrieve their respective values from the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, we are also extracting the string representations of the value
    so that we can compare them in the next block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this block, we are using the values of the fields to determine the correct
    priority according to the priority matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're making use of the Groovy `switch` statement to make the code more readable
    than if we had used an if/else block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Jira Server, the priority field is an object of the priority type, so we
    need to find the `Priority` object that corresponds to the string value we calculated
    in *step 6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do this by retrieving all the priorities in the system using the `ConstantsManager`
    class available from `ComponentAccessor`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then use the `find` closure to search for the priority object whose name
    field matches the priority we have calculated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have found the correct priority object, we can update the issue accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to persist the changes to the database, and we do this by calling
    the `updateIssue` method on the `IssueManager` object, again obtained from `ComponentAccessor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not want this particular update to cause any more update events to fire,
    so we use the `EventDispatchOption.DO_NOT_DISPATCH` option to indicate this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also do not want any email notifications to be sent when we update the issue,
    so we set the final parameter to `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we have learned in this example, scripts written for Jira Server can take
    advantage of the full Jira API rather than the simpler REST API available to scripts
    written for Jira Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Having access to the complete Jira API is both powerful and dangerous at the
    same time. You should exercise caution when writing scripts in Jira Server as
    a badly written script could cause severe performance degradation or worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete this example by attaching the script to a listener so that
    it executes whenever an incident is created or updated:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Jira administrator, click on the settings menu (cog) icon and then select
    **Manage apps**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the left-hand menu, select the **Listeners** tab under the **ScriptRunner**
    section, click the **Create Listeners** button, and then select **Custom listener**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the listener fields as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Incident priority matrix`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`IT Service Desk`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Issue Created` and `Issue Updated`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type the Groovy script into the `11.2 Incident priority matrix - Server.groovy`
    from this chapter's GitHub repository and then copy and paste the code into the
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new script listener should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Creating a script listener in Jira Server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.5_B16551.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Creating a script listener in Jira Server
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed this section, you have learned how to create automations
    using Groovy scripts in ScriptRunner for Jira Server. You should also now understand
    some of the core differences in scripting between the Jira Cloud and Jira Server
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced ScriptRunner for Jira, an app that allows
    us to create advanced automations within Jira using scripting.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the Groovy language, which ScriptRunner uses to enable
    scripting within Jira, and how Groovy can execute both Java and Groovy statements,
    which makes it easier to get started without needing to learn Groovy up front.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how scripts interact with Jira Cloud, we learned about the Atlassian
    Connect framework, which is used to build apps for Jira Cloud, and how this enables
    ScriptRunner to provide scripted access to Jira.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to create a scripted automation by recreating the incident
    priority matrix example from [*Chapter 2*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038),
    *Automating Jira Issues*, and we learned how the interactions with Jira Cloud
    are performed by dissecting the script.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced you to scripting on Jira Server and learned how this differs
    from scripting for Jira Cloud by taking a very brief look at the Jira Server API.
  prefs: []
  type: TYPE_NORMAL
- en: To make it easier to understand the differences between the platforms, we reused
    the incident priority matrix example script and again, dissected the script to
    understand how to interact with the Jira Server API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to create advanced automations using Groovy scripts will empower
    you to create automations beyond the no-code approach, which has been the focus
    of this book and will enable you to customize your Jira instance to your own specifications.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of this book, and my hope is that it has both inspired
    you and given you some ideas on how to take your automations to the next level.
  prefs: []
  type: TYPE_NORMAL
