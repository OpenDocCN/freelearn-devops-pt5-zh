<html><head></head><body>
		<div><h1 id="_idParaDest-191"><em class="italic"><a id="_idTextAnchor169"/>Chapter 11</em>: Beyond Automation; an Introduction to Scripting</h1>
			<p>In this book, we have focused on automating everyday tasks in Jira using a code-free approach. This automation functionality is native to Jira Cloud and is available in Jira Server and Jira Data Center with the addition of the <em class="italic">Automation for Jira</em> app.</p>
			<p>This approach makes it very easy for Jira administrators to get up and running with automation quickly as they require no specialist coding knowledge. In addition, the ability to create automations can be delegated to project administrators, thereby allowing Jira administrators to focus on other tasks.</p>
			<p>However, any book on automation in Jira would not be complete if it did not mention scripting and, in particular, <strong class="bold">ScriptRunner for Jira</strong>, which is arguably the most well-known automation app available.</p>
			<p>In this chapter, we'll provide a brief introduction to ScriptRunner for Jira and to the Groovy scripting language, which ScriptRunner uses under the hood. In addition, we'll look at the differences between scripting for Jira Cloud and Jira Server.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing advanced automations with ScriptRunner</li>
				<li>Exploring scripting in Jira Cloud</li>
				<li>Exploring scripting in Jira Server</li>
			</ul>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor170"/>Technical requirements</h1>
			<p>The requirements for this chapter are as follows:</p>
			<ul>
				<li><strong class="bold">Jira cloud environment</strong>: If you don't already have access to Jira, you can create a free Jira Cloud account at <a href="https://www.atlassian.com/software/jira/free">https://www.atlassian.com/software/jira/free</a> and ensure that you have both Jira Software and Jira Service Management selected. You will also need to install <em class="italic">ScriptRunner for Jira</em> from the Atlassian Marketplace.</li>
				<li><strong class="bold">Jira Server environment</strong>: If you are using Jira Server (available from <a href="https://www.atlassian.com/software/jira/download">https://www.atlassian.com/software/jira/download</a>), ensure that you have licenses for both Jira Software and Jira Service Desk. In addition, you will also need to ensure that you install the <em class="italic">ScriptRunner for Jira</em> app available from the Atlassian Marketplace.</li>
			</ul>
			<p>You will need to be a global Jira administrator in order to follow the examples in this chapter. In addition, we have used the <em class="italic">IT Service Management project template</em> to create the Service Desk project that these examples run against.</p>
			<p>You can download the latest code samples for this chapter from this book's official GitHub repository at <a href="https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira">https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira</a>. Please visit the following link to check the CiA videos: <a href="https://bit.ly/39L6BIB">https://bit.ly/39L6BIB</a></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor171"/>Introducing advanced automations with ScriptRunner</h1>
			<p><strong class="bold">ScriptRunner</strong> for <a id="_idIndexMarker574"/>Jira allows you to extend the functionality of both Jira Cloud and Jira Server or Jira Data Center using scripts written in the <strong class="bold">Groovy</strong> language.</p>
			<p>The ability to use the<a id="_idIndexMarker575"/> Groovy language in your automations gives you access to the underlying Java platform and the Jira API, as well as providing the full <a id="_idIndexMarker576"/>power of the scripting language<a id="_idIndexMarker577"/> itself.</p>
			<p>As we'll see, in the case of Jira Cloud, access to the Jira API is limited to the interaction with the REST API provided by Jira. In Jira Server, however, your scripts gain access to the entire API that Jira exposes to developers.</p>
			<p>We'll begin this section with a quick introduction to the Groovy language, which underpins ScriptRunner, followed by an overview of the ScriptRunner for Jira app.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor172"/>Introducing Groovy</h2>
			<p><strong class="bold">Groovy</strong>,<a id="_idTextAnchor173"/> or <strong class="bold">Apache Groovy</strong> to <a id="_idIndexMarker578"/>give it its full name, is a programming language built on the Java platform. It is both a static language, in that it can be compiled to bytecode, as well as a dynamic language in that it can be interpreted at runtime.</p>
			<p>Groovy is syntax-compatible with Java. This means that it integrates and operates seamlessly with Java and, more importantly, with third-party libraries. It also means that you can write Java code in a Groovy script and have it correctly interpreted and executed.</p>
			<p>In addition, Groovy supports functional programming and optional typing, meaning it can infer the object type at runtime. It also has a much more concise and expressive syntax than Java and is able to efficiently process both XML and JSON.</p>
			<p>Let's take a look at an example that highlights both the differences and similarities between Java and Groovy.</p>
			<p>In this example, we will create a list of names and then iterate that list, printing each name out to the console, prepended with the word <code>"Hello"</code>, using the following code:</p>
			<pre>List&lt;String&gt; nameList = new ArrayList&lt;&gt;();
nameList.add("Andrew");
nameList.add("Evelyn");
nameList.add("Tony");
for (String name : nameList) {
    System.out.println("Hello " + name);
}</pre>
			<p>Although this code is written in Java, it can run entirely unmodified in Groovy. When writing scripts, an execution context is usually provided by the application. This execution context is essentially an empty method within a class and our script is the method body, so we do not need to declare a surrounding class or method. </p>
			<p>Now, let's take a look at the Groovy version of the previous code:</p>
			<pre>def nameList = ["Andrew", "Evelyn", "Tony"]
nameList.each { name -&gt;
    println "Hello ${name}"
}</pre>
			<p>This Groovy<a id="_idIndexMarker579"/> script is equivalent to the Java code we saw previously. Let's take a quick look at what is going on in this example line by line:</p>
			<ul>
				<li><code>def nameList = ["Andrew", "Evelyn", "Tony"]</code>: We have used optional typing for the <code>nameList</code> variable by declaring it using the <code>def</code> keyword. In addition, we have initialized the variable with a list of strings using square brackets.</li>
				<li><code>nameList.each { name -&gt;</code>: Here we are calling the <code>each</code> closure on the list, and naming the closure parameter <code>name</code>.<p>Closures are identified by the use of curly braces, while the arrow (<code>-&gt;</code>) separates the closure parameters from the code.</p><p>When using a closure with only a single parameter, and where you do not need to reference the parameter in an inner closure, you can omit both the parameter and the separating arrow.</p><p>In this case, the parameter name defaults to the word <code>it</code>, as seen in the following example:</p><p><code>nameList.each { println "Hello ${it}" }</code></p></li>
				<li><code>    println "Hello ${name}"</code>: This line is using string interpolation to print the word <code>"Hello"</code> followed by the name currently being iterated.</li>
			</ul>
			<p>Additionally, you will notice that the semicolon used in Java to terminate a statement is not required in Groovy.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can learn more about Groovy<a id="_idIndexMarker580"/> on the official Apache Groovy website at <a href="https://groovy-lang.org/learn.html">https://groovy-lang.org/learn.html</a>, where there are numerous books, presentations, and courses available to help you learn and get the most out of the Groovy language.</p>
			<p>As we have learned, Groovy allows you to write concise, easily readable code in addition to enabling you to write your scripts in Java. Next, let's take a look at how ScriptRunner for Jira leverages this to allow us to create automation scripts in Jira.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor174"/>Understanding ScriptRunner</h2>
			<p>Adaptavist's <strong class="bold">ScriptRunner</strong> is an <a id="_idIndexMarker581"/>app in the Atlassian ecosystem that has been around for over a decade. It incorporates the Groovy scripting engine and configures it in a manner that facilitates scripted access to Jira via the available APIs.</p>
			<p>It has been the go-to app for many Jira administrators looking to both automate and extend the base functionality of Jira, and indeed other Atlassian tools, including Confluence, Bitbucket, and Bamboo.</p>
			<p>In a nutshell, ScriptRunner gives you access to the Jira application by providing a ready-made framework with all the underlying plumbing already in place, thereby allowing you to concentrate on the business logic of your automations.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">ScriptRunner provides a lot more functionality than just the ability to create scripted automations. It provides the ability to create workflow functions using both built-in and custom Groovy scripts. In addition, it also provides a number of powerful additional JQL features to make searching Jira easier. It also allows you to make customizations to the user interface using script fragments, the complexity of which will vary depending on whether you use Jira Cloud or Jira Server.</p>
			<p>Adaptavist<a id="_idIndexMarker582"/> provides comprehensive documentation and tutorials for ScriptRunner for both Jira Cloud and Jira Server. You can learn<a id="_idIndexMarker583"/> more about <em class="italic">ScriptRunner for Jira Cloud</em> at <a href="https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html">https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html</a>. To learn more about <em class="italic">ScriptRunner for Jira Server</em>, you <a id="_idIndexMarker584"/>can find the documentation at <a href="https://scriptrunner.adaptavist.com/latest/jira/quickstart.html">https://scriptrunner.adaptavist.com/latest/jira/quickstart.html</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Adaptavist<a id="_idIndexMarker585"/> provides a library of scripts that you can use as is or as a starting point for your own scripts. You can find these at <a href="https://library.adaptavist.com">https://library.adaptavist.com</a>.</p>
			<p>Now that we've had a brief introduction to ScriptRunner and the Groovy scripting language, let's look at how we can create automations using scripts in Jira Cloud.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor175"/>Exploring scripting in Jira Cloud</h1>
			<p>ScriptRunner for Jira<a id="_idIndexMarker586"/> Cloud enables you to create automations in response to <a id="_idIndexMarker587"/>events that occur in Jira, such as when an issue is created or updated, among others. It also has an escalation service, which allows you to perform a scheduled action against a list of issues provided by a JQL query.</p>
			<p>ScriptRunner also provides the ability to run scripts at scheduled intervals. This differs from the escalation service in that it does not require a list of issues on which to perform actions, allowing you to perform tasks such as creating issues on a recurring basis.</p>
			<p>In this section, we'll take a high-level overview of how the Jira Cloud API works and then recreate the <em class="italic">Incident priority matrix</em> example from <a href="B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Automating Jira Issues</em>, to understand how to write automations using scripting. </p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor176"/>Understanding the Jira Cloud API</h2>
			<p>In order for an app to integrate <a id="_idIndexMarker588"/>with Jira Cloud, it needs to be built using the <em class="italic">Atlassian Connect framework</em>. This framework allows apps to extend the Jira user interface, access the Jira APIs, and respond to events from Jira Cloud.</p>
			<p>An app built using the Connect framework is a web application that operates remotely over the HTTP protocol. This means that when you build a Connect app for Jira, it needs to be hosted on a publicly accessible web server that can receive requests over HTTP from Jira Cloud, and which can send REST API requests to Jira Cloud.</p>
			<p>The basic interaction between <a id="_idIndexMarker589"/>Jira Cloud and an app built using the Connect framework can be seen in the following diagram. This is a simplified representation as it pertains to automation with ScriptRunner:</p>
			<div><div><img src="img/Figure_11.1_B16551.jpg" alt="Figure 11.1 – App interaction with the Atlassian Connect framework&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – App interaction with the Atlassian Connect framework</p>
			<p>When an event occurs in Jira Cloud, a webhook is sent over HTTP to notify the ScriptRunner app that the event has occurred. This prevents the app from needing to poll Jira periodically to determine whether changes have occurred.</p>
			<p>In response, ScriptRunner will initiate the execution of any scripts that are configured to listen for the specific events. In turn, these scripts make use of the Jira REST API to retrieve additional information and to update data in Jira.</p>
			<p>Scripts that make use of ScriptRunner's scheduled or escalation service will only require access to the Jira REST API to interact with data in Jira.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can learn more about the webhooks available in Jira Cloud<a id="_idIndexMarker590"/> at <a href="https://developer.atlassian.com/cloud/jira/platform/webhooks/">https://developer.atlassian.com/cloud/jira/platform/webhooks/</a>, while you can learn about the<a id="_idIndexMarker591"/> Jira Cloud REST API at <a href="https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/">https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/</a>.</p>
			<p>Now that we've learned how the Jira Cloud API basically works, let's take a look at how we can use this to create a scripted automation in Jira Cloud.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor177"/>Creating a scripted automation in Jira Cloud</h2>
			<p>In this example, we <a id="_idIndexMarker592"/>are going to recreate the incident <a id="_idIndexMarker593"/>priority matrix automation that we first introduced in the <em class="italic">If/else block</em> section in <a href="B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Automating Jira Issues</em>. If you have a similar rule using Jira Automation, you should disable it before implementing this rule.</p>
			<p>This example will show you how to achieve a similar automation in Jira Cloud utilizing a Groovy script and the Jira Cloud API.</p>
			<p>The Groovy script we will use to achieve this is shown in the following screenshot: </p>
			<div><div><img src="img/Figure_11.2_B16551.jpg" alt="Figure 11.2 – The incident priority matrix script in Jira Cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – The incident priority matrix script in Jira Cloud</p>
			<p>Let's take a look <a id="_idIndexMarker594"/>at what's going on in this script:</p>
			<ol>
				<li>The first thing <a id="_idIndexMarker595"/>we do is use Jira's REST API to retrieve all the custom fields into a list stored in the <code>customFields</code> variable. </li>
				<li>Using the list of custom fields, we then ascertain the IDs of the <code>Impact</code> and <code>Urgency</code> fields and save them in the corresponding variables.</li>
				<li>Now that we have the IDs for the <code>Impact</code> and <code>Urgency</code> fields, we can use these to extract their respective values from the issue, which is represented as a <code>Map</code> object.</li>
				<li>In this block, we are using the values of the fields to determine the correct priority according to the priority matrix.<p>We're making<a id="_idIndexMarker596"/> use of the Groovy <code>switch</code> statement to make the code more readable than if we had used an if/else block.</p></li>
				<li>Finally, we use<a id="_idIndexMarker597"/> Jira's REST API to update the issue with the new priority calculated in <em class="italic">step 4</em>.</li>
			</ol>
			<p>Now that we've created the automation script in Groovy, we need to create a script listener in ScriptRunner to actually get the automation working:</p>
			<ol>
				<li value="1">As a Jira administrator, click on the <strong class="bold">Apps</strong> menu in the top menu bar, and then select <strong class="bold">Manage your apps</strong>.</li>
				<li>From the left-hand menu, select the <strong class="bold">Script Listeners</strong> tab under the <strong class="bold">ScriptRunner</strong> section, and then click the <strong class="bold">Add Listener</strong> button.</li>
				<li>Complete the script listener fields as follows:<p><code>Incident priority matrix</code></p><p><code>Issue Created</code> and <code>Issue Updated</code></p><p><code>IT Service Desk (DESK)</code></p><p><code>Current User</code></p></li>
				<li>We only want this listener to be called if the issue is an incident, so we need to add a condition to the listener, which will evaluate to <code>true</code> only if we're dealing with an incident.<p>In the <code>issue.issueType.name == 'Incident'</code></p><p>This will ensure that this listener only continues to execute if the name of the issue type is <code>Incident</code>.</p></li>
				<li>Finally, type the <a id="_idIndexMarker598"/>script into the <code>11.1 Incident priority matrix – Cloud.groovy</code> from this chapter's GitHub repository and then copy and paste the code into the field.<p>Your script listener should now look similar to the following screenshot:</p></li>
			</ol>
			<div><div><img src="img/Figure_11.3_B16551.jpg" alt="Figure 11.3 – Creating a script listener in Jira Cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Creating a script listener in Jira Cloud</p>
			<p>In this section, we have learned how to recreate the incident priority matrix using a Groovy script in a script listener in Jira Cloud. You should now understand how scripting can also be used to automate tasks in Jira.</p>
			<p>In the following section, we will take a look at how we can create scripted automations in Jira Server, and we'll reuse the incident priority matrix example so you can see the differences between the platforms.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor178"/>Exploring scripting in Jira Server</h1>
			<p>Similar to ScriptRunner for <a id="_idIndexMarker600"/>Jira Cloud, ScriptRunner for Jira Server <a id="_idIndexMarker601"/>allows you to create automations in response to events within Jira.</p>
			<p>Unlike in Jira Cloud, however, you are able to create automations against a much wider range of events in Jira Server due to the fact that you have access to the full Jira API.</p>
			<p>In this section, we'll take a look at the API available to scripts on the Jira Server platform. We'll then take another look at the incident priority matrix example so that we can more easily understand the differences between scripting between the platforms.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor179"/>Understanding the Jira Server API</h2>
			<p>In contrast to the <a id="_idIndexMarker602"/>Jira Cloud API, apps written using the Jira Server API run in the same Java process as the core Jira application and therefore have full access to the underlying application via the public Java-based API.</p>
			<p>ScriptRunner for Jira Server is an app built using the Jira <strong class="bold">Plugins2</strong> (<strong class="bold">P2</strong>) framework. This framework allows apps to register as listeners for events within Jira, as well as provide access to the underlying API and public third-party libraries shipped with the application.</p>
			<p>The Jira API is vast, and fully understanding every aspect of it could fill a couple of books. For our purposes, however, we will concentrate on the <code>ComponentAccessor</code> class, which is documented <a id="_idIndexMarker603"/>at <a href="https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html">https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html</a>.</p>
			<p>This class is the entry point to most of the components you will require when writing scripts in ScriptRunner. It gives you a handle of things such as the <code>IssueService</code> and <code>IssueManager</code> classes, which deal with creating, updating, and modifying issues. You will also use it to get access to the <code>CustomFieldManager</code> class, which allows you to manipulate most custom<a id="_idIndexMarker604"/> fields you define in Jira.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can learn more about how to use <code>IssueService</code> and <code>IssueManager</code> to interact with issues in Jira in the official <em class="italic">Performing issue operations</em> tutorial located at <a href="https://developer.atlassian.com/server/jira/platform/performing-issue-operations/">https://developer.atlassian.com/server/jira/platform/performing-issue-operations/</a>.</p>
			<p>To get access to <code>ComponentAccessor</code>, you will need to explicitly import the class at the start of your script as follows:</p>
			<p><code>import com.atlassian.jira.component.ComponentAccessor</code></p>
			<p>As you will see in the example we present in the next section, <code>ComponentAccessor</code> is integral to our ability to find and manipulate data in Jira Server.</p>
			<p>Now that we've had a brief introduction to the Jira Server API, let's take a look at how we can create an automation script using the API.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor180"/>Creating a scripted automation in Jira Server</h2>
			<p>In this example, we are again <a id="_idIndexMarker605"/>going to recreate the incident priority <a id="_idIndexMarker606"/>matrix using a Groovy script so that we can learn about the differences between scripting in Jira Server and Jira Cloud.</p>
			<p>The script we are going to use for this example is presented in the following screenshot:</p>
			<div><div><img src="img/Figure_11.4_B16551.jpg" alt="Figure 11.4 – The incident priority matrix script in Jira Server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – The incident priority matrix script in Jira Server</p>
			<p>Let's examine what<a id="_idIndexMarker607"/> this script is doing:</p>
			<ol>
				<li value="1">The first thing <a id="_idIndexMarker608"/>we need to do is import the Jira API classes that we'll need for this script. Without these, the script will not compile and will not be able to access the Jira API.</li>
				<li>Script listeners in ScriptRunner for Jira Server present an event object to the script. The event object contains the underlying issue in the issue field.<p>Additionally, we are ensuring that the <code>issue</code> variable is cast as a <code>MutableIssue</code> type, which will allow us to make changes to the issue.</p></li>
				<li>Custom script listeners in ScriptRunner for Jira Server do not have a condition field, so we need to use an <code>if</code> statement to ensure that we only continue execution if we're dealing with an incident issue type.</li>
				<li>Here we are retrieving the custom field objects for the <code>Impact</code> and <code>Urgency</code> fields by using the <code>CustomFieldManager</code> component accessible from <code>ComponentAccessor</code>. In this example, I am retrieving the fields by name rather than by ID, but you could use either method.</li>
				<li>Now that we have <a id="_idIndexMarker609"/>the custom field objects<a id="_idIndexMarker610"/> for the <code>Impact</code> and <code>Urgency</code> fields, we can use these to retrieve their respective values from the issue.<p>In addition, we are also extracting the string representations of the value so that we can compare them in the next block.</p></li>
				<li>In this block, we are using the values of the fields to determine the correct priority according to the priority matrix.<p>We're making use of the Groovy <code>switch</code> statement to make the code more readable than if we had used an if/else block.</p></li>
				<li>In Jira Server, the priority field is an object of the priority type, so we need to find the <code>Priority</code> object that corresponds to the string value we calculated in <em class="italic">step 6</em>.<p>We do this by retrieving all the priorities in the system using the <code>ConstantsManager</code> class available from <code>ComponentAccessor</code>.</p><p>We then use the <code>find</code> closure to search for the priority object whose name field matches the priority we have calculated.</p></li>
				<li>Once we have found the correct priority object, we can update the issue accordingly.</li>
				<li>Finally, we need to persist the changes to the database, and we do this by calling the <code>updateIssue</code> method on the <code>IssueManager</code> object, again obtained from <code>ComponentAccessor</code>.<p>We do not want this particular update to cause any more update events to fire, so we use the <code>EventDispatchOption.DO_NOT_DISPATCH</code> option to indicate this.</p><p>We also do not<a id="_idIndexMarker611"/> want any email notifications to<a id="_idIndexMarker612"/> be sent when we update the issue, so we set the final parameter to <code>false</code>.</p></li>
			</ol>
			<p>As we have learned in this example, scripts written for Jira Server can take advantage of the full Jira API rather than the simpler REST API available to scripts written for Jira Cloud.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Having access to the complete Jira API is both powerful and dangerous at the same time. You should exercise caution when writing scripts in Jira Server as a badly written script could cause severe performance degradation or worse.</p>
			<p>Let's complete this example by attaching the script to a listener so that it executes whenever an incident is created or updated:</p>
			<ol>
				<li value="1">As a Jira administrator, click on the settings menu (cog) icon and then select <strong class="bold">Manage apps</strong>.</li>
				<li>From the left-hand menu, select the <strong class="bold">Listeners</strong> tab under the <strong class="bold">ScriptRunner</strong> section, click the <strong class="bold">Create Listeners</strong> button, and then select <strong class="bold">Custom listener</strong>.</li>
				<li>Complete the listener fields as follows:<p><code>Incident priority matrix</code></p><p><code>IT Service Desk</code></p><p><code>Issue Created</code> and <code>Issue Updated</code></p></li>
				<li>Type the Groovy script into the <code>11.2 Incident priority matrix - Server.groovy</code> from this<a id="_idIndexMarker613"/> chapter's GitHub repository and <a id="_idIndexMarker614"/>then copy and paste the code into the field.<p>The new script listener should now look similar to the following screenshot:</p></li>
			</ol>
			<div><div><img src="img/Figure_11.5_B16551.jpg" alt="Figure 11.5 – Creating a script listener in Jira Server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Creating a script listener in Jira Server</p>
			<p>Now that we have completed this section, you have learned how to create automations using Groovy scripts in ScriptRunner for Jira Server. You should also now understand some of the core differences in scripting between the Jira Cloud and Jira Server platforms.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor181"/>Summary</h1>
			<p>In this chapter, we have introduced ScriptRunner for Jira, an app that allows us to create advanced automations within Jira using scripting.</p>
			<p>We have learned about the Groovy language, which ScriptRunner uses to enable scripting within Jira, and how Groovy can execute both Java and Groovy statements, which makes it easier to get started without needing to learn Groovy up front.</p>
			<p>To understand how scripts interact with Jira Cloud, we learned about the Atlassian Connect framework, which is used to build apps for Jira Cloud, and how this enables ScriptRunner to provide scripted access to Jira.</p>
			<p>We then learned how to create a scripted automation by recreating the incident priority matrix example from <a href="B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Automating Jira Issues</em>, and we learned how the interactions with Jira Cloud are performed by dissecting the script.</p>
			<p>Next, we introduced you to scripting on Jira Server and learned how this differs from scripting for Jira Cloud by taking a very brief look at the Jira Server API.</p>
			<p>To make it easier to understand the differences between the platforms, we reused the incident priority matrix example script and again, dissected the script to understand how to interact with the Jira Server API. </p>
			<p>Understanding how to create advanced automations using Groovy scripts will empower you to create automations beyond the no-code approach, which has been the focus of this book and will enable you to customize your Jira instance to your own specifications.</p>
			<p>That brings us to the end of this book, and my hope is that it has both inspired you and given you some ideas on how to take your automations to the next level.</p>
		</div>
	</body></html>