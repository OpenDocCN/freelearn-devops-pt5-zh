- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Containers with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned a lot about how container networking works
    on a single Docker host. We introduced the **Container Network Model** (**CNM**),
    which forms the basis of all networking between Docker containers, and then we
    dove deep into different implementations of the CNM, specifically the bridge network.
    Finally, we introduced Traefik, a reverse proxy to enable sophisticated HTTP application-level
    routing between containers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the concept of an application consisting of multiple
    services, each running in a container, and how Docker Compose allows us to easily
    build, run, and scale such an application using a declarative approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying declarative versus imperative orchestration of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a multi-service application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building images with Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running an application with Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and pushing an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose overrides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain, in a few short sentences, the main differences between an imperative
    and declarative approach for defining and running an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe, in your own words, the difference between a container and a Docker
    Compose service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author a Docker Compose YAML file for a simple multi-service application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build, push, deploy, and tear down a simple multi-service application using
    Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Docker Compose to scale an application service up and down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define environment-specific Docker Compose files using overrides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code accompanying this chapter can be found at [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let’s make sure we have a folder ready for the code you are
    going to implement in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the folder in which you cloned the previously listed code repository
    accompanying this book. Normally, this is the `The-Ultimate-Docker-Container-Book`
    folder in your home folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subfolder called `ch11` and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the past, you needed to have a separate docker-compose tool installed on
    your system. This is not the case anymore as the Docker CLI has recently been
    extended such that it contains all the functionality and more than the docker-compose
    tool previously offered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious, you can find detailed installation instructions for the
    old `docker-compose` tool here: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying declarative versus imperative orchestration of containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose is a tool provided by Docker that is mainly used when you need
    to run and orchestrate containers running on a single Docker host. This includes,
    but is not limited to, development, **continuous integration** (**CI**), automated
    testing, manual QA, or demos. Since very recently, Docker Compose is embedded
    in the normal Docker CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose uses files formatted in YAML as input. By default, Docker Compose
    expects these files to be called `docker-compose.yml`, but other names are possible.
    The content of a `docker-compose.yml` file is said to be a declarative way of
    describing and running a containerized application potentially consisting of more
    than a single container.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, what is the meaning* *of declarative?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, declarative is the antonym of imperative. Well, that doesn’t
    help much. Now that I have introduced another definition, I need to explain both:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative**: This is a way in which we can solve problems by specifying
    the exact procedure that has to be followed by the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If I tell a system, such as the Docker daemon, imperatively how to run an application,
    then that means that I must describe, step by step, what the system has to do
    and how it must react if some unexpected situation occurs. I must be very explicit
    and precise in my instructions. I need to cover all edge cases and how they need
    to be treated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative**: This is a way in which we can solve problems without requiring
    the programmer to specify an exact procedure to be followed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A declarative approach means that I tell the Docker engine what my desired state
    for an application is and it has to figure out on its own how to achieve this
    desired state and how to reconcile it if the system deviates from it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker clearly recommends the declarative approach when dealing with containerized
    applications. Consequently, the Docker Compose tool uses this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Running a multi-service app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, applications do not consist of only one monolithic block, but
    rather of several application services that work together. When using Docker containers,
    each application service runs in its own container. When we want to run such a
    multi-service application, we can, of course, start all the participating containers
    with the well-known `docker container run` command, and we have done this in previous
    chapters. But this is inefficient at best. With the Docker Compose tool, we are
    given a way to define the application in a declarative way in a file that uses
    the YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create and analyze a simple `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the chapter’s folder (`ch11`), create a subfolder called `step1` and
    navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this folder, add a file called `docker-compose.yml` and add the following
    snippet to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Simple Docker Compose file](img/Figure_11.01_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Simple Docker Compose file
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines in the file are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 1: `version` – On this line, we specify the version of the Docker Compose
    format we want to use. At the time of writing, this is version `3.8`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 2–21: `services` – In this section, we specify the services that make
    up our application in the `services` block. In our sample, we have two application
    services, and we call them `db` and `pgadmin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 3–11: `db` – The `db` service is using the image name `postgres:alpine`,
    which is the latest version of the Alpine Linux-based PostgreSQL database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 4: `image` – Here, we define which Docker image to use for the service.
    As mentioned previously, we’re using the curated `postgres` image with a tag of
    `alpine`. Since we’re not specifying a version number, it will take the latest
    stable version of the Alpine-based PostgreSQL image.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 5–8: `environment` – Here, we are defining the environment variables
    that will be accessible from within the running PostgreSQL service. In this case,
    we define the default username, password, and database name.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 9–11: `volumes` – We are defining two volume mappings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 10: We are mapping a volume called `pg-data` to the `/var/lib/postgresql/data`
    container folder. This is where PostgreSQL by default stores the data. This way,
    the data is persisted into the `pg-data` volume and will survive a restart of
    the `db` service.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 11: In this case, we are mapping the host folder, `./db`, into a container
    folder called `/docker-entrypoint-initdb.d`. This is the folder where PostgreSQL
    expects any initialization files that are run upon the first start of the database.
    In our case, we’ll use it to define a database initialization script called `init-db.sql`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 13–21: `pgadmin` – The `pgadmin` service uses a Docker image containing
    the popular administration tool for PostgreSQL and similar databases called `Pg4Admin`.
    We are mounting a volume called `pgadmin-data` into the container of the `db`
    service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 14: `image` – This service is using the `dpage/pgadmin4` image. Note we’re
    not defining any tags for the image, so we’ll automatically work with the latest
    version.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 15–16: `ports` – Here, we define which container ports we want to map
    to the host. In this case, we map the default `Pg4Admin` port `80` to the host
    port `5050`. This way, we can access the admin tool on this latter port from a
    browser window, as we will see shortly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 17–19: `environment` – Here, we are defining the environment variables
    that will be accessible from within the running `Pg4Admin` tool container. It
    is the email and password we will need to log in to the tool.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 20–21: `volumes` – We are mapping a Docker volume called `pgadmin-data`
    to the `/var/lib/pgadmin` folder inside the container. This is the place where
    the tool stores its data and makes it possible to survive a restart of the tool
    container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 23–25: `volumes` – The volumes used by any of the services must be declared
    in this section. In our sample, this is the last section of the file. The first
    time the application is run, volumes called `pg-data` and `pgadmin-data` will
    be created by Docker and then, in subsequent runs, if the volumes are still there,
    they will be reused. This could be important if the application, for some reason,
    crashes and must be restarted. Then, the previous data is still around and ready
    to be used by the restarted database service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a folder called `db` in the `step1` folder and add a file called `init-db.sql`
    to it with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Database initialization script](img/Figure_11.02_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Database initialization script
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to type in all of the preceding, you can find the file here:
    [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql).
    As you will see later, this file will be used to initialize our database with
    some initial schema and some data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see how we can run the services with the help of Docker Compose.
    Execute the following command from within your `step1` folder where the `docker-compose.yml`
    file resides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s analyze the output generated by the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: The first few lines are telling us that Docker is pulling the images for the
    `db` and `pgadmin` services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next few lines indicate that Docker is automatically creating a new network
    called `step1_default`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two volumes called `step1_pgadmin-data` and `step1-pg-data`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two container instances called `step1-db-1` and `step1-pgadmin-1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Creating the resources for the Docker Compose application](img/Figure_11.03_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Creating the resources for the Docker Compose application
  prefs: []
  type: TYPE_NORMAL
- en: Note the `step1_` prefix added to all the preceding resources. This is the folder
    name within which the `docker-compose.yml` exists and from where the app was started,
    combined with the underscore character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the third part of the output in blue. Here, the database
    is started up:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Starting up the database](img/Figure_11.04_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Starting up the database
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the initialization of the database looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Initializing the database using the provided script](img/Figure_11.05_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Initializing the database using the provided script
  prefs: []
  type: TYPE_NORMAL
- en: We have shortened the second part of the output a bit. It shows us how the database
    finalizes its initialization. We can specifically see how our initialization script,
    `init-db.sql`, is applied, which defines a database and seeds it with some data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line in the output tells us that the PostgreSQL database is now up
    and running and ready to accept an incoming connection. The connection is expected
    to happen at port `5432`, as indicated by the fourth and fifth last lines in the
    preceding output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: If for some reason your volume mapping does not work – you may have a typo or
    so in the volume mapping part – you can start over by using the `docker compose
    down -v` command, where the `-v` parameter instructs Docker to remove any volumes
    associated with this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have the initialization of the `pgamin` tool, shown in yellow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Starting up the pgadmin tool](img/Figure_11.06_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Starting up the pgadmin tool
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to roll. Let’s open a new browser window and navigate to `http://localhost:5050`.
    When asked, log in using the username (email) and password defined for the `pgadmin`
    tool in the `docker-compose.yml` file, namely `admin@acme.com` for the email and
    `admin` for the password. Add a server called `demo` and fill out the connection
    details as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Pg4Admin connection details](img/Figure_11.07_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Pg4Admin connection details
  prefs: []
  type: TYPE_NORMAL
- en: Note that the hostname/address, `db`, corresponds to the name of the database
    service in our docker-compose file. Port `5432` is the default port used by a
    PostgreSQL database and the username and password correspond to what we have defined
    in our docker-compose file for the database as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once connected to the database, make sure that you can locate the `pets` database
    and within it the `images` table. Use the tool to retrieve all the records in
    the `images` table. You should find the 12 records that we defined in the `init-db.sql`
    initialization script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before you continue, you can stop the application by pressing *Ctrl* + *C*
    in the terminal window where the application still runs. After that, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is to make sure the application container, the network, and the volumes
    are removed. You should see the following output in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, notice the use of the `-v` command-line parameter, which tells
    Docker to forcibly remove volumes that were created and used by the application.
    Use this parameter wisely as it will destroy all data that has been persisted
    into those volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Great, that worked. You have learned how to use the `docker-compose.yml` file
    to declaratively define an application made up of more than one service and start
    it with a simple `docker compose` `up` command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how you can use Docker Compose to build your own custom
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Building images with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate how to build a Docker image using Docker Compose, we need a
    small application. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter’s folder (`ch11`), create a subfolder, `step2`, and navigate
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the previous exercise, copy the `db` folder containing the database initialization
    script to the `step2` folder and also copy the `docker-compose.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a folder called `web` in the `step2` folder. This folder will contain
    a simple Express.js web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a file called `package.json` to the folder with this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – The package.json file of the sample web application](img/Figure_11.08_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The package.json file of the sample web application
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer not to type yourself, you can always download the files from
    the sample solution: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2).'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `src` inside the `web` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a file called `server.js` to the `src` folder with this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.9 – The server.js file of the sample web application](img/Figure_11.09_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – The server.js file of the sample web application
  prefs: []
  type: TYPE_NORMAL
- en: This file contains the complete logic for our simple web application. Of interest
    is specifically the logic for the `/animal` endpoint on lines 32 to 40\. Also
    note how we connect to the PostgreSQL database using a constant `pool` of type
    `Pool` (lines 15 to 21). The username, password, and database name should match
    the ones we define for the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another file called `index.xhtml` to the `src` folder with this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.10 – The index.xhtml file of the sample web application](img/Figure_11.10_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – The index.xhtml file of the sample web application
  prefs: []
  type: TYPE_NORMAL
- en: This file serves as a template to display the image of a wild animal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `public/css` to the `web` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a file called `main.css` to this `public/css` folder, which we will use
    to style our sample web application. Add this content to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.11 – The main.css file of the sample web application](img/Figure_11.11_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – The main.css file of the sample web application
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need some real images to display. The easiest way is to copy our sample
    images from GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder called `images` in the `public` folder.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, download all images into this `images` folder, which you can find here:
    [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to make a small addition to the `docker-compose.yml` file that
    we have copied from the `step1` folder. Locate the `docker-compose.yml` file in
    the `step2` folder, open it, and after line 4, add this snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Add host port mapping to the db service](img/Figure_11.12_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Add host port mapping to the db service
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can actually access the database from any application running on
    the host. We will use this possibility in the coming steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to run and test this application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the database using the docker-compose file and this command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are telling Docker Compose to only start the db service and to run it in
    `detach` mode, indicated by the `--``detach` parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to the `web` folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install all dependencies with the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Running the web application natively](img/Figure_11.13_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Running the web application natively
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a browser tab and navigate to [http://localhost:3000/animal](http://localhost:3000/animal)
    and you should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The web application running and displaying a wild animal](img/Figure_11.14_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – The web application running and displaying a wild animal
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the browser a few times and notice that each time, a new random animal
    is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you leave, make sure to stop the web application and stop the other containers
    with `docker` `compose down`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great, now we can move on to the next step, where we will Dockerize the web
    application and use Docker Compose to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called `Dockerfile` to the `web` folder and add this snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Dockerfile for the web application](img/Figure_11.15_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Dockerfile for the web application
  prefs: []
  type: TYPE_NORMAL
- en: Analyze this Dockerfile and try to understand what it does exactly. Refer to
    what you learned in [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083), *Creating
    and Managing Container Images*, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `docker-compose.yml` file from the `step2` folder and add the definition
    of the `web` service, right after the `db` and `pgadmin` services and before the
    `volumes` section (that is, after line 24). The snippet to add should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Defining the service called web in the docker-compose.yml
    file](img/Figure_11.16_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Defining the service called web in the docker-compose.yml file
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that on line 2, you replace the `gnschenker` username with your own
    Docker Hub username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the image using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command assumes that you are in the `step2` folder and that there
    is a `docker-compose.yml` file located in that folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building the image, Docker looks for and uses a Dockerfile in the `web`
    folder, as instructed by the `build: web` instruction on line 3 in the preceding
    snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build images using Docker Compose, use the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that you are in the `ch11/step2` subfolder of the `The-Ultimate-Docker-Container-Book`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, build the images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we enter the preceding command, then the tool will assume that there must
    be a file in the current directory called `docker-compose.yml` and it will use
    that one to run. In our case, this is indeed the case, and the tool will build
    the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the output in your terminal window. You should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Building the Docker image for the web service](img/Figure_11.17_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Building the Docker image for the web service
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that docker-compose first downloads
    the base image, `node:19.7-alpine`, for the `web` image we’re building from Docker
    Hub. Subsequently, it uses the Dockerfile found in the `web` folder to build the
    image and names it `gnschenker/ch11-web:2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: After building the Docker image for the `web` service, we are ready to use Docker
    Compose to run the whole multi-service application.
  prefs: []
  type: TYPE_NORMAL
- en: Running an application with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have built our images, we can start the application using Docker Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, similar to the output we discussed in the previous section for
    the `db` and `pgadmin` services, will look as follows for the `web` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the containerized `web` service is ready and is listening
    on port `3000`. Coincidentally, we have mapped container port `3000` to the same
    port `3000` on the host in our `docker-compose.yml` file. Thus, we can just open
    a new browser tab and navigate to the URL [http://localhost:3000/animal](http://localhost:3000/animal);
    we should once again see a wild animal displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the browser a few times to see other animal images. The application
    selects the current image randomly from a set of 12 images whose URLs are stored
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the application is running in interactive mode and, thus, the terminal where
    we ran Docker Compose is blocked, we can cancel the application by pressing *Ctrl*
    + *C*. If we do so, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will notice that the `db` and `web` services stop immediately. Sometimes,
    though, some services will take about 10 seconds to do so. The reason for this
    is that the `db` and the `web` service listen, and react, to the `SIGTERM` signal
    sent by Docker, while other services might not, and so Docker kills them after
    a predefined timeout interval of 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application again with `docker compose up`, the startup will be
    much faster as the database didn’t have to initialize from scratch, but it was
    just reusing the data that was already present in the `pg-data` volume from the
    previous run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also run the application in the background. All containers will run
    as daemons. For this, we just need to use the `-d` parameter, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Compose offers us many more commands than just `up`. We can also use
    the tool to list all services that are part of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Output of docker compose ps](img/Figure_11.18_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Output of docker compose ps
  prefs: []
  type: TYPE_NORMAL
- en: This command is similar to `docker container ls`, with the only difference being
    that docker-compose only lists containers or services that are part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop and clean up the application, we use the `docker compose` `down` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we also want to remove the volumes for the database, then we can use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, instead of using the two commands, `docker compose down` and
    `docker volume rm <volume name>`, we can combine them into a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the argument `-v` (or `--volumes`) removes named volumes declared in the
    `volumes` section of the Docker Compose file and anonymous volumes attached to
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is there a `step2` prefix in the name of the volume? In the `docker-compose.yml`
    file, we have called the volumes to use `pg-data` and `pgadmin-data`. But, as
    we have already mentioned, Docker Compose prefixes all names with the name of
    the parent folder of the `docker-compose.yml` file plus an underscore. In this
    case, the parent folder is called `step2`. If you don’t like this approach, you
    can define a project name explicitly, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This way, all resources (containers, networks, and volumes) will be prefixed
    by the project name, in this case, called `demo`.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s, for a moment, assume that our sample application has been live
    on the web and become very successful. Loads of people want to see our cute animal
    images. But now we’re facing a problem: our application has started to slow down.
    To overcome this problem, we want to run multiple instances of the `web` service.
    With Docker Compose, this is readily done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running more instances is also called scaling out. We can use this tool to
    scale our `web` service up to, say, three instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this, we are in for a surprise. The output will look as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Output of docker-compose --scale](img/Figure_11.19_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Output of docker-compose --scale
  prefs: []
  type: TYPE_NORMAL
- en: The second and third instances of the `web` service fail to start. The error
    message tells us why we cannot use the same host port, `3000`, more than once.
    When instances 2 and 3 try to start, Docker realizes that port `3000` is already
    taken by the first instance. What can we do? Well, we can just let Docker decide
    which host port to use for each instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, in the `ports` section of the Docker Compose file, we only specify the
    container port and leave out the host port, then Docker automatically selects
    an ephemeral port. Let’s do exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s tear down the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we modify the `docker-compose.yml` file. The port mapping of the `web`
    service originally looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We change it to simply the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This way, Docker will allocate the host port dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start the application again and scale it up immediately after that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And we should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now execute `docker compose ps`, we should see what is in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Output of the docker compose ps command](img/Figure_11.20_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – Output of the docker compose ps command
  prefs: []
  type: TYPE_NORMAL
- en: Note that in your case, the host ports may be different than those shown in
    the preceding screenshot. There, we have a mapping to ports `590076`, `59078`,
    and `59077` for the three instances of `web`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to see whether those port mappings work, for example, using `curl`.
    Let’s test the third instance, `step2_web-3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The answer tells us that, indeed, our application is still working as expected.
    Try it out for the other two instances to be sure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to build and subsequently push
    the application container images to an image registry.
  prefs: []
  type: TYPE_NORMAL
- en: Building and pushing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw earlier that we can also use the `docker-compose build` command to just
    build the images of an application defined in the underlying `docker-compose`
    file. But to make this work, we’ll have to add the build information to the `docker-compose`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new browser window and navigate to the chapter’s folder (`ch11`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subfolder called `step3` and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the `docker-compose.yml` file from the `step2` folder to this new folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the copied file and please note the `build` key for the web service on
    line 3 in the following screenshot. The value of that key indicates the context
    or folder where Docker is expecting to find the Dockerfile to build the corresponding
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.21 – The build key in the web service of the docker-compose.yml
    file](img/Figure_11.21_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – The build key in the web service of the docker-compose.yml file
  prefs: []
  type: TYPE_NORMAL
- en: Please note the `depends_on` section on lines 8 and 9\. This instructs Docker
    Compose to make sure that the `db` service is started before the `web` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to use a Dockerfile that is named differently, say `Dockerfile.dev`,
    for the `web` service, then the `build` block in the `docker-compose` file would
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the `web` and the `db` folder and their contents from the `step2` folder
    into the `step3` folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `Dockerfile.dev` in the `web` folder, which is just a
    copy of the existing Dockerfile:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To the `step3` folder, add a new file, `docker-compose.dev.yml`, which is a
    copy of the `docker-compose.yml` file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the `build` block according to the preceding snippet.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s use that alternative `docker-compose.dev.yml` file now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-f` parameter will tell the Docker Compose application which Docker Compose
    file to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push all images to Docker Hub, we can use `docker` `compose push`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to be logged in to Docker Hub so that this succeeds; otherwise, we
    get an authentication error while pushing. Thus, in my case, I do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assuming the login succeeds, I can then push the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This may take a while, depending on the bandwidth of your internet connection.
    While pushing, your screen may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Pushing images with docker-compose to Docker Hub](img/Figure_11.22_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – Pushing images with docker-compose to Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command pushes the Docker image for the `web` service to the `gnschenker`
    account on Docker Hub. The other two services, `db` and `pgadmin`, in the Docker
    Compose file are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you are using your own Docker Hub account instead of `gnschenker`.
  prefs: []
  type: TYPE_NORMAL
- en: The last feature of Docker Compose we want to discuss is overrides.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose overrides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want to run our applications in different environments that need
    specific configuration settings. Docker Compose provides a handy capability to
    address exactly this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate the with a specific sample:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new browser window and navigate to the chapter’s folder (`ch11`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subfolder called `step4` and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the `web` and `db` folder and their contents from the `step2` folder into
    the `step4` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can define a base Docker Compose file and then define environment-specific
    overrides. Let’s assume we have a file called `dockercompose.base.yml` with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Docker Compose file used as a base](img/Figure_11.23_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.23 – Docker Compose file used as a base
  prefs: []
  type: TYPE_NORMAL
- en: This only defines the part that should be the same in all environments. All
    specific settings have been taken out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now assume we want to run the application in `docker-compose.ci.yml` and add
    this snippet of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Docker Compose file for CI](img/Figure_11.24_B19199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.24 – Docker Compose file for CI
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run this application with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that with the first `-f` parameter, we provide the base Docker Compose
    file, and with the second one, we provide the override. The `--build` parameter
    instructs Docker Compose to rebuild all Docker images before starting them.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'When using environment variables, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1) Declaring them in the Docker file defines a default value
  prefs: []
  type: TYPE_NORMAL
- en: 2) Declaring the same variable in the Docker Compose file overrides the value
    from the Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter about Docker Compose. But
    before we finish, we have the following tip for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Had we followed the standard naming convention and called the base file just
    `docker-compose.yml` and the override file `docker-compose.overrid.yml` instead,
    then we could have started the application with `docker-compose up -d` without
    explicitly naming the Docker Compose files. In any other case, we need to use
    the following full and more verbose syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker compose -f <base compose file> -f <override compose` `file> up`'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the docker-compose tool. This tool is mostly
    used to run and scale multi-service applications on a single Docker host. Typically,
    developers and CI servers work with single hosts, and those two are the main users
    of Docker Compose. The tool uses YAML files as input, which contain the description
    of the application in a declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: The tool can also be used to build and push images, among many other helpful
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss why logging and monitoring is important
    and show how container logs can be collected and shipped to a central location
    where the aggregated logs can then be parsed to gain useful information.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to instrument an application, so that it exposes metrics,
    and how those metrics can be scraped and shipped again to a central location.
    Finally, you will learn how to convert those collected metrics into graphical
    dashboards that can be used to monitor a containerized application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links provide additional information on the topics discussed
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The official YAML* *website*: [http://www.yaml.org/](http://www.yaml.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Docker Compose* *documentation*: [http://dockr.ly/1FL2VQ6](http://dockr.ly/1FL2VQ6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker Compose file version 2* *reference*: [https://docs.docker.com/compose/compose-file/compose-file-v2/](https://docs.docker.com/compose/compose-file/compose-file-v2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker Compose file version 3* *reference*: [https://docs.docker.com/compose/compose-file/compose-file-v3/](https://docs.docker.com/compose/compose-file/compose-file-v3/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Share Docker Compose configurations between files and* *projects*: [https://docs.docker.com/compose/extends/](https://docs.docker.com/compose/extends/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To assess your learning of Docker Compose, please answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker Compose, and what is it used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Docker Compose file, and what are some of the key elements it can
    contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use Docker Compose to start and stop an application, and what are
    some of the key command-line options?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the benefits of using Docker Compose to manage multi-container
    applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use docker-compose to run an application in daemon mode?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use docker-compose to display the details of the running service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you scale up a particular `web` service to, say, three instances?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions of [*Chapter 11*](B19199_11.xhtml#_idTextAnchor237):'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose is a tool for defining and running multi-container Docker applications.
    It allows you to define the services that make up your application in a YAML file,
    and then run and manage those services with a single command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A Docker Compose file is a YAML file that defines the services that make up
    a Docker application, along with any associated configuration options. Some of
    the key elements that a Docker Compose file can contain include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`version`: The version of the Docker Compose file syntax to use. This field
    is mandatory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services`: A list of the services that make up the application, along with
    any associated configuration options.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: A list of ports that need to be opened for the respective service
    and mapped to a corresponding container port.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`networks`: Any custom networks that need to be created for the application.
    Note that a service can be attached to more than one network at the same time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes`: Any volumes that need to be created for the application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a (shortened) example `docker-compose.yml` file using more than one
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To start an application with Docker Compose, you can use the `docker compose
    up` command. This command reads the Docker Compose file, creates any necessary
    containers, and starts the services. To stop an application, you can use the `docker
    compose down` command. Some of the key command-line options that can be used with
    these commands include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-d` or `--detach`: Run containers in the background and print new container
    names'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p` or `--project-name`: Specify an alternate project name'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--build`: Build images before starting containers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the benefits of using Docker Compose to manage multi-container applications
    include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simplifying the deployment process**: Docker Compose allows you to define
    your application’s services and configurations in a single file, which can simplify
    the deployment process and make it easier to manage complex applications'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling collaboration**: By using a Docker Compose file to define an application,
    developers can easily share their development environments with others and collaborate
    more effectively'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling portability**: Docker Compose allows you to define an application’s
    environment and dependencies in a portable way, which can make it easier to move
    applications between different environments and infrastructure providers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the application services in daemon (or `detach`) mode, use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To display the details of the running services in a Docker Compose application,
    use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To scale, for example, the `web` service of a Docker Compose application to
    three instances, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
