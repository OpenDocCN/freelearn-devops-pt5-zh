<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Customizing Gitolite</h1></div></div></div><p>It must be clear by this time that Gitolite is a pretty powerful tool for managing Git repositories on a server. The most powerful tools, however, allow the administrator to add features that are unique to their site, and thus cannot be expected to be added to the product itself. For example, consider Git itself, its <em>hooks</em> mechanism (see <code class="literal">man githooks</code> for details) contains several predefined hooks, which the user can install on their repositories to customize Git's behavior at various points in the lifecycle of a commit, a rebase, a push, and so on. In fact, Gitolite's ability to perform branch level access control (as opposed to merely repository level access control) is <em>entirely</em> done by using Git's <code class="literal">update</code> hook.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Core and non-core Gitolite</h1></div></div></div><p>Gitolite goes a little further than merely allowing you to customize it for your location-specific needs. Gitolite actually <em>ships</em> with customizations already in place for several optional features. <a id="id181" class="indexterm"/>Some of these customizations are enabled by default, while others are disabled, though requiring only a quick edit of <code class="literal">$HOME/.gitolite.rc</code> to enable them.</p><p>As a result, Gitolite makes a distinction between <strong>core</strong> and <strong>non-core</strong> Gitolite code<a id="id182" class="indexterm"/>. If you happened to look into the Gitolite source tree (under <code class="literal">src</code> if you cloned the Gitolite source code), you will notice several directories at the top level, and a couple of files. Of these, gitolite considers the following directories to contain non-core code: <code class="literal">commands</code>, <code class="literal">syntactic-sugar</code>, <code class="literal">triggers</code>, <code class="literal">lib/Gitolite/Triggers</code>, and <code class="literal">VREF</code>. Everything else is considered <em>core</em>.</p><p>Making this distinction also helps in deciding whether a new feature is to be added or not. If the feature requires change to core Gitolite, a lot more careful consideration and thought will go into it, and even then it will only happen if the change is really needed by several users. In practice, however, Gitolite's customization feature is so powerful that it has become increasingly rare that any change to core Gitolite is required.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Types of non-core code and examples</h1></div></div></div><p>Gitolite allows <a id="id183" class="indexterm"/>four types of customizations you can develop for your site. This might sound somewhat intimidating, but in practice most people use only two of them. We'll describe each of them now.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec43"/>Commands</h2></div></div></div><p>Gitolite<a id="id184" class="indexterm"/> allows remote users to run some specific commands on the server, in the form <code class="literal">ssh git@host command-name</code>. Commands <a id="id185" class="indexterm"/>need to be enabled before they can be used remotely; see the section on making changes to the <code class="literal">rc</code> file in <a class="link" href="ch08.html" title="Chapter 8. Allowing Users to Create Repos">Chapter 8</a>, <em>Allowing Users to Create Repos</em>. One way to look at this is to view it as giving users a very restricted shell to use, which allows only specific commands to be executed.</p><p>We've already encountered some Gitolite commands, the<a id="id186" class="indexterm"/> <code class="literal">perms</code> and <code class="literal">D</code> commands<a id="id187" class="indexterm"/> in <a class="link" href="ch08.html" title="Chapter 8. Allowing Users to Create Repos">Chapter 8</a>, <em>Allowing Users to Create Repos</em>, for instance, and <code class="literal">info</code> and <code class="literal">help</code> in earlier chapters. Gitolite ships with more than twenty commands, although only five are enabled for remote use by default. A few more are listed in <code class="literal">$HOME/.gitolite.rc</code>, but left disabled by being commented out. It only takes a removal of the comment marker in the line to enable them.</p><p>Many of the commands that Gitolite comes with, however, are not meant for remote use at all and thus, they are not listed (even in commented out form) in <code class="literal">$HOME/.gitolite.rc</code>. These commands are meant as helpers to server-side scripts or other non-core programs. One of the most convenient of these is the <code class="literal">access</code> command<a id="id188" class="indexterm"/>, which has the following help message:</p><div><pre class="programlisting">
<strong>Usage:  gitolite access [-q] &lt;repo&gt; &lt;user&gt; &lt;perm&gt; &lt;ref&gt;</strong>

<strong>Print access rights for arguments given.  The string printed has the word</strong>
<strong>DENIED in it if access was denied.  With '-q', returns only an exit code</strong>
<strong>(shell truth, not perl truth -- 0 is success).</strong>

<strong>  - repo: mandatory</strong>
<strong>  - user: mandatory</strong>
<strong>  - perm: defauts to '+'.  Valid values: R, W, +, C, D, M</strong>
<strong>  - ref:  defauts to 'any'.  See notes below</strong>

<strong>Notes:</strong>
<strong>  - ref: Any fully qualified ref ('refs/heads/master', not 'master') is fine.</strong>
<strong>    The 'any' ref is special -- it ignores deny rules (see docs for what this</strong>
<strong>    means and exceptions).</strong>

<strong>Batch mode: see src/triggers/post-compile/update-git-daemon-access-list for a</strong>
<strong>good example that shows how to test several repos in one invocation.  This is</strong>
<strong>orders of magnitude faster than running the command multiple times; you'll</strong>
<strong>notice if you have more than a hundred or so repos.</strong>
</pre></div><p>As you<a id="id189" class="indexterm"/> can see, this is of great use in rolling your own code, where you would like to check a user's access rights to a repository or several repositories.</p><p>Running <code class="literal">gitolite help</code> on the server will list all available commands; just as running <code class="literal">ssh git@host help</code> will list all commands available <em>remotely</em>. In addition, Gitolite comes with several commands that are implemented internally in Gitolite. They are, in effect, part of the "core". Run <code class="literal">gitolite -h</code> to get a list of them with brief descriptions.</p><p>All Gitolite commands respond with a usage message when invoked with a single argument of <code class="literal">-h</code>. If you write your own commands, it would be a good idea to adhere to this convention.</p><p>Here's a list of some of the existing commands in Gitolite with a brief description of each:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">access</code>: This prints or tests access rights on a repository for a user. This is useful when you write your own commands. See the description of the <code class="literal">fork</code> command below for one example.</li><li class="listitem" style="list-style-type: disc"><code class="literal">D</code>: This lets a user delete a repository that they created (see <a class="link" href="ch08.html" title="Chapter 8. Allowing Users to Create Repos">Chapter 8</a>, <em>Allowing Users to Create Repos</em>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">desc</code>: This <a id="id190" class="indexterm"/>shows or sets a description for a user-created repository.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fork</code>: This <a id="id191" class="indexterm"/>forks a repo on the server. This takes a repository and creates a new one with the same content. It checks to make sure the reader has read access to the source repository, and is allowed to create the destination repository (see <a class="link" href="ch08.html" title="Chapter 8. Allowing Users to Create Repos">Chapter 8</a>, <em>Allowing Users to Create Repos</em>). This command uses the <code class="literal">-l</code> option to <code class="literal">git clone</code>, so it runs really fast. (Without this command, the alternative would be for the user to clone the source repository, and then use that to create and push to the destination repository. For large repositories, this could take a while).</li><li class="listitem" style="list-style-type: disc"><code class="literal">git-config</code>: This<a id="id192" class="indexterm"/> prints (or tests existence of) 'config' values in the repo.</li><li class="listitem" style="list-style-type: disc"><code class="literal">help</code>: This<a id="id193" class="indexterm"/> prints a list of all the available commands.</li><li class="listitem" style="list-style-type: disc"><code class="literal">info</code>: This <a id="id194" class="indexterm"/>prints your username, the git/gitolite version numbers, and any repositories you have access to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">perms</code>: This<a id="id195" class="indexterm"/> lists or sets permissions for a user-created repository.</li></ul></div><p>In a subsequent section, we will see how to create your own commands.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec44"/>Syntactic sugar</h2></div></div></div><p>Syntactic sugar <a id="id196" class="indexterm"/>scripts are a form of customization<a id="id197" class="indexterm"/> that most people will rarely, if ever, have to write, or even encounter. They are useful for situations where the administrator would like some additional, purely syntax-related feature added to Gitolite's access control language. In such situations, a syntactic sugar helper script can be written that changes what the administrator writes into something Gitolite can parse.</p><p>Gitolite ships with a few syntactic sugar helper scripts. For example, one is to allow C-style continuation lines in Gitolite's <code class="literal">conf</code> file, since normally Gitolite does not allow that. Another is to provide a simple macro facility.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec45"/>Triggers</h2></div></div></div><p>Arguably, the<a id="id198" class="indexterm"/> most powerful of Gitolite's customization <a id="id199" class="indexterm"/>features is the trigger feature. Gitolite triggers are the equivalent of Git's hooks. Just as Git provides hooks that run at various points (for example, <code class="literal">pre-commit</code>, <code class="literal">pre-receive</code>, and <code class="literal">post-receive</code>, to name a few), similarly Gitolite's triggers also run at specific points in the lifecycle of a Gitolite managed push or fetch.</p><p>There is a difference between Git hooks and Gitolite trigger programs though. Git defines several hooks and requires that your hook code be named exactly one of those (for example, <code class="literal">post-receive</code> or <code class="literal">update</code>). Gitolite on the other hand allows you to define a list of trigger programs, which it will invoke in sequence when the trigger point is reached. It is only the name of the trigger point that is fixed. This also means, of course, that your programs can be called whatever you like.</p><p>The important trigger points, from a customization point of view, are <code class="literal">INPUT</code>
<a id="id200" class="indexterm"/>, <code class="literal">POST_CREATE</code>, and <code class="literal">POST_COMPILE</code>,<a id="id201" class="indexterm"/> although there are several other trigger points supported.</p><p>The purpose<a id="id202" class="indexterm"/> of an <code class="literal">INPUT</code> trigger is to manipulate the input arguments or the environment in some way. Since a child program cannot affect the parent's environment, <code class="literal">INPUT</code> triggers need to be written in Perl and installed as modules in <code class="literal">lib/Gitolite/Triggers</code> (as opposed to being plain programs in any language, that are installed in the <code class="literal">triggers</code> directory). Examples of features using the <code class="literal">INPUT</code> trigger are giving some users full shell access and allowing repositories to have aliases.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>This chapter will contain references to many non-core features that are out of scope for this book. Please refer to Gitolite's online documentation for details.</p></div></div><p>The <code class="literal">POST_CREATE</code> trigger point <a id="id203" class="indexterm"/>is useful to run any housekeeping or reporting tasks that need to be performed after <a id="id204" class="indexterm"/>a new repository is created. For example, Gitolite uses this trigger point to run code that updates the access lists for gitweb and git-daemon whenever a user creates a <em>wild</em> repository.</p><p>The <code class="literal">POST_COMPILE</code> trigger point helps you perform additional tasks when the gitolite-admin repository is pushed. This trigger point is associated with the maximum number of programs shipped with Gitolite. Most of them have to do with with ssh keys, or updating access lists for gitweb and git-daemon.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec46"/>Virtual refs</h2></div></div></div><p>The final <a id="id205" class="indexterm"/>type <a id="id206" class="indexterm"/>of non-core customization available is Gitolite's ability to make access decisions based on what Gitolite calls virtual refs. The scripts that do this are called <code class="literal">VREFs</code>; they are complex and important enough to have the next chapter be devoted entirely to them.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Writing your own non-core code</h1></div></div></div><p>It's reasonably<a id="id207" class="indexterm"/> easy to write your own code to add features that are specific to your site. For example, suppose we want an e-mail to be sent to the administrator every time a developer creates a <em>wild repositor</em>y. We will assume that the standard Unix utilities exist and are available. In particular, we will assume the Unix mail command is available. This command takes the message from standard input, and the subject and recipient data from command-line arguments, and sends the e-mail, thus suits our purposes very well.</p><p>Since this is an action that needs to run when a repository is created, it needs to be added to the <code class="literal">POST_CREATE</code> trigger list. According to the Gitolite documentation, when a wild repository is created, each program in the <code class="literal">POST_CREATE</code> trigger list is called with the second argument being the name of the repository that was just created, while the third argument is the name of the user who created it. (If this is empty, this is not a wild repository creation but a normal repository creation; that is, by the administrator adding the repository to the Gitolite <code class="literal">conf</code> file and pushing the change.)</p><p>As a result, this code could be as simple as follows:</p><div><pre class="programlisting">
<strong>#!/bin/bash</strong>
<strong>[ -n $3 ] &amp;&amp; echo | mail -s "new repo $2 created" admin_group@example.com</strong>
</pre></div><p>Now we've written this code, we need to put it somewhere that Gitolite will find it and use it at the right time.</p><p>We decide to create a new directory called <code class="literal">$HOME/local</code> to hold all our local customizations. In this directory, we add a subdirectory called <code class="literal">triggers</code>, and into this we place this script, naming it <code class="literal">new-repo-alert</code>. (Don't forget to <code class="literal">chmod +x</code> the script!)</p><p>Now, we <a id="id208" class="indexterm"/>edit Gitolite's <code class="literal">rc</code> file<code class="literal">($HOME/.gitolite.rc</code>). In this file, we find a line that defines the <code class="literal">LOCAL_CODE</code> variable commented out but conveniently pointing to precisely where we chose to place our customizations, so we simply uncomment it.</p><p>We then add the following lines of code immediately after the <code class="literal">LOCAL_CODE</code> variable:</p><div><pre class="programlisting">
<strong>POST_CREATE =&gt; [</strong>
<strong>    'new-repo-alert',</strong>
<strong>],</strong>
</pre></div><p>Did you note the trailing comma after the closing bracket? And that's really all you need to do. From now on, any time a user creates a new "wild" repository; the <code class="literal">new-repo-alert</code> script will be executed.</p><p>As a second example, we will create a small command. The example we use will allow a user to check the size of a repository using the <code class="literal">git count-objects</code> command<a id="id209" class="indexterm"/>. Our command will default to running it with the <code class="literal">-v</code> option because that is the most generic and useful.</p><p>To do that, create a directory called <code class="literal">$HOME/local/commands</code>, and put a script called <code class="literal">count-objects</code>
<a id="id210" class="indexterm"/> in that directory. Make sure the script is executable (<code class="literal">chmod +x</code>). The code for the script is as follows:</p><div><pre class="programlisting">
<strong>#!/bin/bash</strong>

<strong>repo=$1</strong>

<strong>gitolite access -q $repo $GL_USER W any || {</strong>
<strong>    echo Sorry $GL_USER, you are not authorized</strong>
<strong>    exit 1</strong>
<strong>}</strong>

<strong>cd $GL_REPO_BASE/$repo.git</strong>
<strong>git count-objects -v</strong>
</pre></div><p>The interesting part of this code is not the actual <code class="literal">count-objects</code> command<a id="id211" class="indexterm"/>. The most generic, and thus most usable for your needs, is the <code class="literal">gitolite access</code> command<a id="id212" class="indexterm"/>, whose usage message we have already seen in an earlier section. Here, we are using it to ensure that the user running the command has at least got write access to the repository in question before allowing the command to run.</p><p>Finally, add this command to the list of commands in <code class="literal">rc</code> file's <code class="literal">ENABLE</code> list, preferably in the <code class="literal">COMMANDS</code> section.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>Note that <code class="literal">count-objects</code> is a harmless command, so it may not need to be protected. However, if you then stretch the use case a little and allow the user to start a <code class="literal">git gc</code> operation, or even a <code class="literal">git fsck</code>, you need to be more careful. Some of those commands don't deal well with being run too many times or simultaneously by multiple people. Ensure your command does some rate limiting or serializing.</p><p>Other commands require arguments to be supplied. If your script takes arguments from the user, be sure to sanitize them before running the command. You can undermine all of Gitolite's access control with one carelessly written command!</p></div></div><p>As you can <a id="id213" class="indexterm"/>see from these two examples, the most important aspect of adding a new feature to your site is to decide when and how the feature should be invoked—should it be a user command, or a trigger that runs at specific points, or perhaps a <code class="literal">VREF</code> that can influence the outcome of the overall command, and so on. In some cases, it could even be a combination, for instance, a command and a VREF working together. As an extreme example, Gitolite's mirroring feature, which is written entirely as non-core code, is implemented as one command, and one Perl module is added to each of the <code class="literal">INPUT, PRE_GIT</code>, and<code class="literal"> POST_GIT</code> trigger lists.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Summary</h1></div></div></div><p>In this chapter, we have seen an introduction to how Gitolite can be customized or new features can be added that are specific to your site. This is a fairly complex topic, but if you get your hands dirty and start writing programs, you will soon get very comfortable with the idea, as well as get a very good feel for how powerful the feature actually is.</p><p>The next chapter will focus on <code class="literal">VREF</code>, a powerful feature for even more fine-grained access control, as well as access control based on factors other than what Gitolite normally uses.</p></div></body></html>