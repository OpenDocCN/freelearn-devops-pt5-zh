<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor161"/>9</h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor162"/>Implementing Automation in a DevOps Workflow</h1>
<p><strong class="bold">DevOps</strong> is a<a id="_idIndexMarker518"/> combination of practices, tools, and philosophies that can help increase the speed, efficiency, and security of software development, application delivery, and infrastructure management processes. DevOps practices and methods are common in organizations now due to several advantages, such as faster and frequent deployments, improvement in quality, fewer errors, and high transparency via automation. By combining automation, collaboration, and integration, it is possible to develop and implement efficient DevOps practices, ensuring much higher quality output from your IT operations team. </p>
<p>Due to the numerous integrations, supported plugins, and modules, Ansible is a great tool for automating the tasks in your DevOps workflows. Ansible can help you automate different stages in the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>), such as building applications, scanning the source code, storing artifacts in repositories, deploying the application, configuring application services, and more. Automating such application life cycle processes is known as <strong class="bold">continuous integration</strong> and <strong class="bold">continuous delivery</strong> (<strong class="bold">CI/CD</strong>). There are several choices for CI/CD tools and frameworks, such as Jenkins, CircleCI, GitLab, GitHub Actions, Bamboo, and others.</p>
<p>This chapter will focus on using Ansible inside the CI/CD and DevOps workflow to deploy and manage applications rather than using Ansible as a CI/CD tool.</p>
<p>In this chapter, we will cover the following topics: </p>
<ul>
<li>A quick introduction to DevOps </li>
<li>Serving applications using a load balancer</li>
<li>Rolling updates using Ansible</li>
<li>Using Ansible as a provisioning tool in Terraform</li>
</ul>
<p>First, you will learn how to use Ansible to deploy applications to servers, including the load balancer configuration. You will also learn how to implement rolling updates using Ansible to deploy the application without downtime and interruption. Finally, you will learn how to use Ansible as a provisioner and configuration management tool with the infrastructure management tool Terraform.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor163"/>Technical requirements</h1>
<p>The following are the technical requirements for this chapter:</p>
<ul>
<li>A Linux machine for the Ansible control node (with internet access)</li>
<li>Three Linux machines for installing and configuring applications</li>
<li>Basic knowledge of DevOps methodologies, CI/CD tools (Jenkins), and the Git workflow</li>
<li>Basic knowledge of Terraform</li>
</ul>
<p>All the Ansible code, playbooks, commands, and snippets for this chapter can be found in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-09">https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-09</a>.  </p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor164"/>A quick introduction to DevOps</h1>
<p>In simple<a id="_idIndexMarker519"/> words, <strong class="bold">DevOps</strong> is the combination of <strong class="bold">development</strong> (<strong class="bold">Dev</strong>) and <strong class="bold">operations</strong> (<strong class="bold">Ops</strong>), but in reality, DevOps is a combination of ideas, tools, and practices that help increase the speed and efficiency of software development, delivery, and infrastructure management processes. There are several known best practices we can follow and <a id="_idIndexMarker520"/>include in the DevOps workflow, as follows:</p>
<ul>
<li>Team collaboration and transparent communication</li>
<li>CI/CD</li>
<li><strong class="bold">Infrastructure as code</strong> (<strong class="bold">IaC</strong>) and automated infrastructure management</li>
<li>Containerization and microservices</li>
<li>Logging, monitoring, and feedback loops</li>
</ul>
<p>One of the key concepts in DevOps practices is to reduce the time and effort required for application life cycle management, such as integration, build, test, release, and deployment. Using<a id="_idIndexMarker521"/> DevOps methodologies and tools, it is possible to automate <a id="_idIndexMarker522"/>this process. This is known as CI/CD. </p>
<p class="callout-heading">Learning about DevOps</p>
<p class="callout">Refer to the <a id="_idIndexMarker523"/>following guides to understand and learn more about DevOps and CI/CD processes:</p>
<ul>
<li class="callout">What is DevOps?: <a href="https://aws.amazon.com/devops/what-is-devops/">https://aws.amazon.com/devops/what-is-devops/</a></li>
<li class="callout">DevOps explained: <a href="https://about.gitlab.com/topics/devops/">https://about.gitlab.com/topics/devops/</a></li>
<li class="callout">Understanding DevOps: <a href="https://www.redhat.com/en/topics/devops">https://www.redhat.com/en/topics/devops</a></li>
</ul>
<p>In a typical CI/CD workflow, the developer will push code to the central code repository (a Git server, for example) and whenever there is a change in the repository’s content, a trigger will be sent to the CI/CD tool (such as Jenkins, CircleCI, GitHub Actions, and so on). The following diagram shows a typical CI/CD environment:</p>
<div><div><img alt="Figure 9.1 – A typical workflow in a CI/CD environment " height="637" src="img/B18383_09_01.jpg" width="1133"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – A typical workflow in a CI/CD environment</p>
<p>Several tasks <a id="_idIndexMarker524"/>are involved in the build, test, delivery, and deployment processes, depending on the application type, application platform, and other environmental factors.</p>
<p>The following diagram shows the typical manual and automated tasks for CI, CD, and continuous deployment processes:</p>
<div><div><img alt="Figure 9.2 – Typical tasks in the CI/CD process " height="523" src="img/B18383_09_02.jpg" width="812"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Typical tasks in the CI/CD process</p>
<p>The application <a id="_idIndexMarker525"/>can be a simple JAR file, a compressed image, a container image, or in any other format (we will learn about container management using Ansible in <a href="B18383_10.xhtml#_idTextAnchor178"><em class="italic">Chapter 10</em></a>, <em class="italic">Managing Containers Using Ansible</em>).</p>
<p><strong class="bold">CI</strong> helps <a id="_idIndexMarker526"/>developers merge the software code changes regularly and complete the testing and scanning processes automatically and quickly. The CI process also helps detect the defects, bugs, and security issues in the code quicker and more effectively. </p>
<p>The <strong class="bold">CD</strong> process<a id="_idIndexMarker527"/> involves automated software life cycle operations such as testing the application, scanning, and preparing the application so that it’s ready for the production environment (release).</p>
<p>Once the application has been built, scanned, and made available in the application repository (application artifacts), it needs to be deployed to production (or the development environment) as per the process. This is the next <strong class="bold">CD</strong> process or <strong class="bold">continuous deployment</strong> task and depending on the environment, this can be implemented as an automated or semi-automated deployment. </p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor165"/>Continuous delivery versus continuous deployment</h2>
<p>CD helps in the<a id="_idIndexMarker528"/> application life cycle by deploying the application to production so that the latest change in the application will reach the end users automatically as part of the CI/CD process without any manual intervention. The same CI/CD tool or a dedicated tool can be used for the continuous deployment process, depending on your application’s nature, environment, and dependencies. </p>
<p>The deployment can be part of the CI/CD pipelines or a separate trigger for the deployment tool, such as <strong class="bold">Ansible Automation Platform</strong> (<strong class="bold">AAP</strong>) (you will learn how to integrate Ansible inside the CI/CD pipeline using Jenkins in <a href="B18383_12.xhtml#_idTextAnchor213"><em class="italic">Chapter 12</em></a>, <em class="italic">Integrating Ansible with Your Tools</em>). </p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor166"/>Ansible inside CI/CD tasks</h2>
<p>Ansible can<a id="_idIndexMarker529"/> be used as the tool for most of the tasks in the CI/CD workflows, as follows:</p>
<ul>
<li>Scanning the application</li>
<li>Building application artifacts</li>
<li>Running unit and integration tests</li>
<li>Promoting and testing the application in the staging environment</li>
<li>Storing application artifacts in the artifacts repository</li>
<li>Deploying the application to production</li>
</ul>
<p>In the next section, you will learn how to use Ansible to deploy applications to production servers as a continuous deployment tool.</p>
<p class="callout-heading">AAP as a CI/CD Tool</p>
<p class="callout">It is possible to use AAP as a CI/CD tool and manage the full life cycle of an application using Ansible playbooks and job templates. You will learn more about this in <a href="B18383_12.xhtml#_idTextAnchor213"><em class="italic">Chapter 12</em></a>, <em class="italic">Integrating Ansible with Your Tools</em>.</p>
<p>It is possible<a id="_idIndexMarker530"/> to reduce the software deployment time by using Ansible. Since Ansible can manage the application deployment effectively and efficiently, inside the CI/CD pipeline, Ansible can be used as the primary tool to deploy applications. The following diagram shows how Ansible is used in Jenkins pipeline jobs for deployment purposes (continuous deployment):</p>
<div><div><img alt="Figure 9.3 – Ansible inside a Jenkins pipeline job " height="691" src="img/B18383_09_03.jpg" width="1078"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Ansible inside a Jenkins pipeline job</p>
<p>The software build and CI/CD workflow can be triggered by several native Jenkins methods and also by using additional plugins. For example, to activate the build trigger based on Git repository changes and to execute Ansible playbooks from Jenkins, you must perform a few mandatory steps, as follows:</p>
<ol>
<li>First, you must install and configure the Ansible plugin for Jenkins to use Ansible inside the Jenkins pipeline job. Refer to the documentation at <a href="https://www.jenkins.io/doc/pipeline/steps/ansible/">https://www.jenkins.io/doc/pipeline/steps/ansible/</a> to learn more about the Ansible plugin for Jenkins.</li>
</ol>
<p class="callout-heading">Ansible in Jenkins</p>
<p class="callout">Refer to <a href="https://plugins.jenkins.io/ansible">https://plugins.jenkins.io/ansible</a> to learn more about the Ansible plugin for Jenkins.</p>
<ol>
<li value="2">Then, you<a id="_idIndexMarker531"/> must install and configure Ansible and its required packages on the Jenkins server (or the Jenkins agent machine) as the Ansible playbook will be executed from the Jenkins machine. (Later, in <a href="B18383_12.xhtml#_idTextAnchor213"><em class="italic">Chapter 12</em></a>, <em class="italic">Integrating Ansible with Your Tools</em>, you will learn how to use Jenkins to call automation jobs in AAP.)</li>
<li>To trigger the Jenkins pipeline job, the build trigger must be configured on the Jenkins job, as shown in the following screenshot. Copy the URL (<code>JENKINS_URL/job/ansible-demo/build?token=TOKEN_NAME</code>) and the <code>TOKEN</code> value and use them in the webhook configuration in the Git server:</li>
</ol>
<div><div><img alt="Figure 9.4 – Build trigger configured on the Jenkins pipeline job " height="466" src="img/B18383_09_04.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Build trigger configured on the Jenkins pipeline job</p>
<ol>
<li value="4">Whenever there is a change in the application code, you need to trigger the Jenkins pipeline job. To do this, we have configured a webhook in the application<a id="_idIndexMarker532"/> repository in GitHub, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 9.5 – Webhook configuration in the GitHub repository " height="573" src="img/B18383_09_05.jpg" width="1206"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Webhook configuration in the GitHub repository</p>
<p>Additional configurations are available in the GitHub webhook configuration to help you decide on what condition the webhook is to be called. Refer to the GitHub webhook documentation (<a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks">https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks</a>) to learn more about webhooks.</p>
<p class="callout-heading">Triggering Jobs with a Simple Webhook</p>
<p class="callout">To learn more about Jenkins and webhooks, read <a href="https://docs.cloudbees.com/docs/admin-resources/latest/triggering-jobs-simple-webhook">https://docs.cloudbees.com/docs/admin-resources/latest/triggering-jobs-simple-webhook</a></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor167"/>Using Ansible inside a Jenkins pipeline</h2>
<p>Once the<a id="_idIndexMarker533"/> Ansible plugin has been installed and configured, an Ansible playbook can be executed from the Jenkins server (or the agent) by calling it inside the pipeline stages. The following screenshot shows sample Jenkin pipeline stages being used to utilize Ansible to deploy applications:</p>
<div><div><img alt="Figure 9.6 – Jenkins pipeline job stages with Ansible tasks to deploy applications " height="599" src="img/B18383_09_06.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Jenkins pipeline job stages with Ansible tasks to deploy applications</p>
<p>In the following exercise, I will explain how to deploy website content from the source repository using Ansible for continuous deployment tasks. </p>
<p>I will use simple website content (static website) to avoid any complications to help you understand the application deployment concept using Ansible. The playbook can be integrated inside the Jenkins pipeline (or whichever CI/CD tool you are using) to implement the continuous deployment task. Follow these steps:</p>
<ol>
<li value="1">Update the <code>Chapter-09/hosts</code> inventory file with <code>node1</code> and <code>node2</code> as part of the web host group, as follows:</li>
</ol>
<div><div><img alt="" height="168" src="img/B18383_09_07.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Web hosts in the inventory</p>
<ol>
<li value="2">Create a <a id="_idIndexMarker534"/>playbook called <code>Chapter-09/deploy-web.yaml</code> and add the following content:</li>
</ol>
<div><div><img alt="Figure 9.8 – Playbook for deploying the web application " height="383" src="img/B18383_09_08.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Playbook for deploying the web application</p>
<p>The variables can be kept in a separate file or passed from your CI/CD tool as arguments.</p>
<ol>
<li value="3">Add a task that will clean up the application directory and recreate it (this is to ensure any old versions of files are removed from the application path), as follows:</li>
</ol>
<div><div><img alt="Figure 9.9 – Tasks to housekeep the application directory " height="433" src="img/B18383_09_09.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Tasks to housekeep the application directory</p>
<ol>
<li value="4">Add tasks<a id="_idIndexMarker535"/> to the same playbook to install the required packages and dependencies. Even if you are deploying the application on the same server, it is a best practice to install and configure dependencies during every deployment. This can include services, packages, system libraries, Python packages, or other files, depending on your application’s type and framework. </li>
<li>It is also possible to mention the specific version of the packages, as shown in the following screenshot. Also add tasks to start <code>firewalld</code>, open the firewall port for the web service, and start the web service, as follows:</li>
</ol>
<div><div><img alt="Figure 9.10 – Installing the package and starting the necessary services " height="857" src="img/B18383_09_10.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Installing the package and starting the necessary services</p>
<ol>
<li value="6">The <a id="_idIndexMarker536"/>next step is to deploy the website’s content to the application path. (In this exercise, we are using static website content and not a dynamic application.) To identify the servers, update the <code>index.xhtml</code> file as follows (we are replacing <code>SERVER_DETAILS</code> with custom text that contains node information in the following task):</li>
</ol>
<div><div><img alt="Figure 9.11 – Deploying the application and updating its content " height="460" src="img/B18383_09_11.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Deploying the application and updating its content</p>
<ol>
<li value="7">Add more<a id="_idIndexMarker537"/> tasks as needed, such as configuring the web server with more restrictions or custom SSL certificates. </li>
<li>It is important to add the verification step as part of automation. We will add automated website verification here. In this case, this is a simple health check to verify whether the website is working or not. Add a new play (not a task) in the same playbook, as follows:</li>
</ol>
<div><div><img alt="Figure 9.12 – Adding a play to verify the web service " height="405" src="img/B18383_09_12.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Adding a play to verify the web service</p>
<p>Note that instead of hardcoding the server names, we are passing the details as Ansible <em class="italic">extra variables</em>, which will help you pass the server details from your CI/CD tools while executing the Ansible playbook.</p>
<p>Whenever we make changes in the application repository (<a href="https://github.com/ginigangadharan/website-demo-one-page">https://github.com/ginigangadharan/website-demo-one-page</a>), GitHub will trigger the build job in the<a id="_idIndexMarker538"/> Jenkins server and the playbook will be executed as part of the pipeline tasks. (We will explore the Jenkins job and pipelines using AAP in <a href="B18383_12.xhtml#_idTextAnchor213"><em class="italic">Chapter 12</em></a>, <em class="italic">Integrating Ansible with Your Tools</em>.) For demonstration and testing purposes, let’s execute the playbook manually from the console, as follows:</p>
<ol>
<li value="1">Execute the playbook and verify the success of tasks (you will get a similar result in the CI/CD console when you execute the playbook via the CI/CD pipeline):</li>
</ol>
<div><div><img alt="Figure 9.13 – Ansible playbook output with a health check " height="309" src="img/B18383_09_13.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Ansible playbook output with a health check</p>
<p>The <code>Verify application health</code> task is successful, which means the website is working and serving the content. </p>
<ol>
<li value="2">Verify the website’s content from a web browser, as shown here:</li>
</ol>
<div><div><img alt="Figure 9.14 – Website deployed using Ansible " height="612" src="img/B18383_09_14.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Website deployed using Ansible</p>
<p>For practicing<a id="_idIndexMarker539"/> further, expand the deployment use case as follows:</p>
<ul>
<li>Deploy other web applications, API applications, or other compressed application files from repositories.</li>
<li>Include more validations, test cases, scanning tasks, and more as needed as part of the health check.</li>
<li>Use roles to deploy web services, load balancers, databases, and more.</li>
</ul>
<p>You will learn about some of these scenarios in <a href="B18383_12.xhtml#_idTextAnchor213"><em class="italic">Chapter 12</em></a>, <em class="italic">Integrating Ansible with Your Tools</em>. In the next section, you will learn how to handle multi-node web server traffic with a load balancer.</p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor168"/>Serving applications using a load balancer</h1>
<p>So far, you <a id="_idIndexMarker540"/>have learned how to deploy applications to multiple servers using Ansible with all the necessary prerequisites, dependencies, and basic health checks. But if the application or website is running on multiple servers, then you will need to tell the end user about multiple servers so that they can access the website. It is a best practice to serve the application from a single entity such as a load balancer, as shown in the following diagram, so that the end user doesn’t need to know the actual web or application server IP addresses. It will also help you implement<a id="_idIndexMarker541"/> high availability and rolling updates for the application:</p>
<div><div><img alt="Figure 9.15 – Website hosted on multiple servers with a load balancer " height="258" src="img/B18383_09_15.jpg" width="702"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Website hosted on multiple servers with a load balancer</p>
<p>Since we are handling the application deployment using Ansible inside the CI/CD workflow, we can include the load balancer installation and configuration tasks inside the pipeline, as shown in the following diagram:</p>
<div><div><img alt="Figure 9.16 – Jenkins pipeline with HA Proxy installation " height="657" src="img/B18383_09_16.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Jenkins pipeline with HA Proxy installation</p>
<p>Since you <a id="_idIndexMarker542"/>have deployed website content on <code>node1</code> and <code>node2</code>, in the following exercise, you will learn how to deploy a simple load balancer using <code>haproxy</code> and then configure <code>node1</code> and <code>node2</code> as backends:</p>
<ol>
<li value="1">Update the <code>Chapter-09/hosts</code> inventory file with <code>node3</code> under the <code>loadbalancer</code> host group:</li>
</ol>
<div><div><img alt="Figure 9.17 – Load balancer entry in inventory " height="141" src="img/B18383_09_17.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Load balancer entry in inventory</p>
<ol>
<li value="2">Instead of creating a playbook from scratch, use the <code>haproxy</code> role by <em class="italic">Jeff Geerling</em> (<a href="https://galaxy.ansible.com/geerlingguy/haproxy">https://galaxy.ansible.com/geerlingguy/haproxy</a>) from<strong class="bold"> </strong><strong class="bold">Ansible Galaxy</strong>, as follows:</li>
</ol>
<div><div><img alt="Figure 9.18 – Installing haproxy role from Ansible Galaxy " height="168" src="img/B18383_09_18.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Installing haproxy role from Ansible Galaxy</p>
<ol>
<li value="3">Create the <code>Chapter-09/deploy-haproxy.yaml</code> playbook and include the <code>geerlingguy.haproxy</code> role that you installed in the previous step. The following<a id="_idIndexMarker543"/> screenshot shows the sample playbook for installing the HAProxy load balancer:</li>
</ol>
<div><div><img alt="Figure 9.19 – Playbook to install the HAProxy load balancer " height="725" src="img/B18383_09_19.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Playbook to install the HAProxy load balancer</p>
<ol>
<li value="4">Include the necessary variables for the <code>geerlingguy.haproxy</code> role, as shown in the preceding screenshot. It is possible to customize the execution of the role by referring to the role documentation (<a href="https://galaxy.ansible.com/geerlingguy/haproxy">https://galaxy.ansible.com/geerlingguy/haproxy</a>), but in this demonstration, you will only be adding the load balancer backend and a few other details. (Change the IP address so that it matches your <code>node1</code> and <code>node2</code> IP addresses, as configured in the inventory.) The role will take care of the <code>haproxy</code> installation, configuration, and more. Also, remember to add a task to allow port <code>80</code> in the firewall (if you are using a different firewall such as <code>ufw</code>, then amend the<a id="_idIndexMarker544"/> playbook with the appropriate firewall module).</li>
<li>Finally, add a new play in the same playbook (<code>Chapter-09/deploy-haproxy.yaml</code>) to automatically validate the load balancer access:</li>
</ol>
<div><div><img alt="Figure 9.20 – Adding an Ansible play to verify the load balancer " height="433" src="img/B18383_09_20.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Adding an Ansible play to verify the load balancer</p>
<ol>
<li value="6">Execute the playbook and verify the output:</li>
</ol>
<div><div><img alt="Figure 9.21 – The HAProxy playbook with a health check success " height="272" src="img/B18383_09_21.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – The HAProxy playbook with a health check success</p>
<p>The <code>Verify load balancer health</code> task is successful, which means the load balancer (<code>haproxy</code>) is working and serving the content from the backend web servers – that is, <code>node1</code> and <code>node2</code>. </p>
<ol>
<li value="7">Verify the <a id="_idIndexMarker545"/>website’s content using the load balancer IP address (for example, <code>http://192.168.56.45</code>) from a web browser, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 9.22 – Website accessed using a load balancer IP " height="609" src="img/B18383_09_22.jpg" width="1098"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – Website accessed using a load balancer IP</p>
<p>Once the load balancer is ready, it is possible to enable the DNS for the load balancer and share it with the end users (for example, <code>website.example.com</code>). Users don’t need to worry about remembering the IP address of the website or web server. When you have a new version of the website or application, it is possible to update the content without downtime as the load balancer will serve the website from the available web server in the backend.</p>
<p>In the next section, you will learn how to handle rolling updates for websites and applications without downtime using Ansible.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor169"/>Rolling updates using Ansible</h1>
<p>Continuous deployment is a <a id="_idIndexMarker546"/>method meant for frequent application deployment (together with CI/CD) and frequent updates of your application or website rather than you having to wait for scheduled downtime and deployment cycles. But you also need to ensure the application will be available during the update process. So far, you have learned that application high availability can be achieved using a load balancer. In this section, you will learn how to update the application on web servers without downtime.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor170"/>Steps involved in an application update</h2>
<p>Depending on<a id="_idIndexMarker547"/> your application’s type and the components involved, the update process may contain different steps and procedures. The following diagram shows the generic steps involved in the application update process, which is running behind a load balancer:</p>
<div><div><img alt="Figure 9.23 – Steps involved in an application update " height="895" src="img/B18383_09_23.jpg" width="1092"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Steps involved in an application update</p>
<p>It is possible to<a id="_idIndexMarker548"/> automate all such tasks using Ansible, including validating and verifying the services, monitoring tasks, and more. </p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor171"/>Deploying updates in a batch of managed nodes</h2>
<p>If you are<a id="_idIndexMarker549"/> running the update tasks on all web servers (for example, <code>node1</code> and <code>node2</code>) in parallel, then there will not be any servers to serve the requests from the load balancer and the website will be down. This is not the desired behavior, so you need to update the web servers in multiple batches instead of all the servers in a single batch. It is possible to achieve this by passing specific remote node names, such as <code>extra-variable</code>, but that is not a best practice or method as you need to execute the playbook multiple times to complete<a id="_idIndexMarker550"/> the full website update. </p>
<p class="callout-heading">CD and Rolling Upgrades Using Ansible</p>
<p class="callout">Ansible orchestration features are very useful for managing multi-tier applications. Refer to the documentation at <a href="https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml">https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml</a> to learn more.</p>
<p>Use the <code>serial</code> keyword in Ansible to specify the number of managed nodes to be executed at a time:</p>
<div><div><img alt="Figure 9.24 – Using serial in Ansible playbook " height="272" src="img/B18383_09_24.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Using serial in Ansible playbook</p>
<p>Here, <code>serial: 25%</code> means that the play will be executed for 25% of the total managed nodes at a time. </p>
<p>The following diagram shows the rolling update flow, where only one node will be executed with the update task. The load balancer will still serve the traffic from another node:</p>
<div><div><img alt="Figure 9.25 – Rolling update using Ansible " height="679" src="img/B18383_09_25.jpg" width="1189"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – Rolling update using Ansible</p>
<p>It is also<a id="_idIndexMarker551"/> possible to mention the exact number of nodes in a batch by using the <code>serial: 2</code> or <code>serial: 5</code> keyword. The <code>serial</code> keyword is very flexible, and you can even control different batches with a different number or managed nodes, as follows:</p>
<div><div><img alt="Figure 9.26 – Using different serial values for host batches " height="194" src="img/B18383_09_26.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Using different serial values for host batches</p>
<p>In the next section, you will learn how to use the <code>serial</code> keyword to deploy updates on web servers without causing downtime for the application.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor172"/>Deploying updates on multiple servers without service downtime</h2>
<p>Now<a id="_idIndexMarker552"/> that the CI/CD pipeline includes more tasks, let’s replace the application deployment playbook with the rolling update playbook, as shown in the following diagram:</p>
<div><div><img alt="Figure 9.27 – The CI/CD pipeline performing a rolling update of the application " height="805" src="img/B18383_09_27.jpg" width="1154"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.27 – The CI/CD pipeline performing a rolling update of the application</p>
<p>In this exercise, you will use <code>serial: 1</code>, which means the operations will be executed only on one managed node at a time. Control this batch size as required based on the number of managed nodes or backend servers:</p>
<ol>
<li value="1">Update the website’s content with some changes by creating a new branch in the repository. (Use the <a href="https://github.com/ginigangadharan/website-demo-one-page">https://github.com/ginigangadharan/website-demo-one-page</a> repository and make a copy for testing purposes.)</li>
<li>Clone the repository to your local machine and switch to the production branch as follows. Also <code>checkout</code> a new branch as <code>v2</code>:</li>
</ol>
<div><div><img alt="Figure 9.28 – Clone the repository, checkout to production branch, and create a new branch " height="484" src="img/B18383_09_28.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.28 – Clone the repository, checkout to production branch, and create a new branch</p>
<ol>
<li value="3">Update<a id="_idIndexMarker553"/> the <code>index.xhtml</code> file with some modifications, as follows (for example, add <code>v2</code> on the home page to identify the changes):</li>
</ol>
<div><div><img alt="Figure 9.29 – Updating index.xhtml in the application repository " height="272" src="img/B18383_09_29.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.29 – Updating index.xhtml in the application repository</p>
<p>After making these changes, save the file.</p>
<ol>
<li value="4">Commit all changes and push the new branch, <code>v2</code>, to the repository:</li>
</ol>
<div><div><img alt="Figure 9.30 – Commit changes and push the v2 branch to origin " height="168" src="img/B18383_09_30.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.30 – Commit changes and push the v2 branch to origin</p>
<p>Now, the <a id="_idIndexMarker554"/>new branch that contains the new version of the application is available in the GitHub repository. This means we can deploy it to the web servers using the <code>Chapter-09/deploy-web.yaml</code> playbook. But for the rolling update, you will create another playbook called <code>Chapter-09/rolling-update.yaml</code> and add the rolling update tasks inside.</p>
<ol>
<li value="5">Create a new playbook called <code>Chapter-09/rolling-update.yaml</code> and add the <code>serial</code> keyword, as follows:</li>
</ol>
<div><div><img alt="Figure 9.31 – Rolling update playbook " height="433" src="img/B18383_09_31.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.31 – Rolling update playbook</p>
<ol>
<li value="6">During the update, the node will not be able to serve the web pages. Therefore, you need to inform the load balancer of this. Add a task to disable the host in the <code>haproxy</code> backend that you configured earlier. Also, add a task to stop the web service (<code>httpd</code>) on the server:</li>
</ol>
<div><div><img alt="Figure 9.32 – Removing the host entry from the load balancer " height="592" src="img/B18383_09_32.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.32 – Removing the host entry from the load balancer</p>
<p>Please note the <code>delegate_to: ‘{{ item }}’</code> line as this task will be running <a id="_idIndexMarker555"/>on the load balancer node. The task will loop through the load balancer nodes by using the <code>with_items: ‘{{ groups.loadbalancer }}’</code> loop. In our case, there is only one load balancer node.</p>
<ol>
<li value="7">Now, you have similar tasks in the deployment playbook, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 9.33 – Cleaning up the directory and deploying the application " height="777" src="img/B18383_09_33.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.33 – Cleaning up the directory and deploying the application</p>
<p>The <a id="_idIndexMarker556"/>default branch is set to production (<code>application_branch: production</code>) inside the playbook; we will override the branch name using the <code>extra-variable</code> later.</p>
<ol>
<li value="8">Once you have the latest application content, start the web service and add the host back to the load balancer backend, as follows:</li>
</ol>
<div><div><img alt="Figure 9.34 – Post-deployment configuration " height="592" src="img/B18383_09_34.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.34 – Post-deployment configuration</p>
<ol>
<li value="9">Finally, add <a id="_idIndexMarker557"/>another play in the same playbook to verify the web server access via the load balancer:</li>
</ol>
<div><div><img alt="Figure 9.35 – Verifying the play " height="433" src="img/B18383_09_35.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.35 – Verifying the play</p>
<ol>
<li value="10">Execute the playbook and check its output. Remember to pass the new branch information as <code>application_branch=v2</code>:</li>
</ol>
<div><div><img alt="Figure 9.36 – Ansible rolling update on node1 " height="405" src="img/B18383_09_36.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.36 – Ansible rolling update on node1</p>
<p>In the <a id="_idIndexMarker558"/>preceding screenshot, the execution is only happening on one node at a time (that is, <code>node1</code>) and completes all the tasks for that batch of nodes. Later, the playbook will start the tasks for the new batch (that is, <code>node2</code>), as follows:</p>
<div><div><img alt="Figure 9.37 – Ansible rolling update on node2 " height="670" src="img/B18383_09_37.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.37 – Ansible rolling update on node2</p>
<p>As shown in the preceding outputs, the update is happening in the <code>rolling</code> method. This means that at any time, one of the web servers will be available to serve the website in the<a id="_idIndexMarker559"/> load balancer backend. It is possible to achieve zero downtime during your application update.</p>
<p>Now, let’s verify the website access using the load balancer’s IP address and see the changes (notice the <code>v2</code> branch):</p>
<div><div><img alt="Figure 9.38 – Website after the rolling update (v2) " height="603" src="img/B18383_09_38.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.38 – Website after the rolling update (v2)</p>
<p>The process is the same for both static websites and dynamic web applications. Include the exact steps you want to execute during the rolling update.</p>
<p class="callout-heading">CD and Rolling Upgrades</p>
<p class="callout">Refer to <a href="https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml">https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml</a> for more details about rolling updates using Ansible. Also, check out application deployment (<a href="https://www.ansible.com/use-cases/application-deployment">https://www.ansible.com/use-cases/application-deployment</a>) and Ansible CD (<a href="https://www.ansible.com/use-cases/continuous-delivery">https://www.ansible.com/use-cases/continuous-delivery</a>) use cases.</p>
<p>The flexibility of Ansible makes it suitable for implementing automation in most of your DevOps workflows. Instead of using Ansible alone, it is always possible to integrate Ansible with <a id="_idIndexMarker560"/>other tools. With AAP and the Ansible API, it is possible to implement more powerful integration in the CI/CD workflow using webhooks, job templates, and callbacks. You will learn about AAP and integration in <a href="B18383_12.xhtml#_idTextAnchor213"><em class="italic">Chapter 12</em></a>, <em class="italic">Integrating Ansible with Your Tools</em>. In the next section, you will learn how to use Ansible with Terraform as a provisioning tool. </p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor173"/>Using Ansible as a provisioning tool in Terraform</h1>
<p>Ansible can<a id="_idIndexMarker561"/> be used as an IaC tool, as you learned in <a href="B18383_07.xhtml#_idTextAnchor125"><em class="italic">Chapter 7</em></a>, <em class="italic">Managing Your Virtualization and Cloud Platforms</em>. At the same time, it is a common practice in the industry to use the right tool for the right task – for example, Terraform for IaC, Ansible for IT automation, Jenkins for CI/CD pipelines, and so on. Instead of comparing similar tools, integrate them in the right place and achieve better results.</p>
<p><strong class="bold">Terraform</strong> is <a id="_idIndexMarker562"/>an open source tool by <strong class="bold">HashiCorp</strong> for implementing IaC practices. Terraform <a id="_idIndexMarker563"/>can be used to deploy and manage the cloud-based infrastructure and applications using infrastructure code written in a declarative configuration language<a id="_idIndexMarker564"/> called <strong class="bold">HashiCorp Configuration Language</strong> (<strong class="bold">HCL</strong>). Depending on the cloud platform and components, use the provider modules and resources available. Refer to <a href="https://registry.terraform.io/browse/providers">https://registry.terraform.io/browse/providers</a> to explore the available and supported providers.</p>
<p>For example, the following Terraform code will provide EC2 instances in the AWS platform with the <a id="_idIndexMarker565"/>specified <strong class="bold">Amazon Machine Images</strong> (<strong class="bold">AMIs</strong>) and other details:</p>
<div><div><img alt="Figure 9.39 – Terraform code for EC2 provisioning " height="378" src="img/B18383_09_39.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.39 – Terraform code for EC2 provisioning</p>
<p>Terraform<a id="_idIndexMarker566"/> is good at handling infrastructure <a id="_idIndexMarker567"/>changes and tracking the updates using its state management<a id="_idIndexMarker568"/> mechanism. But if you want to configure the operating system-level components, you need to use Terraform provisioners (<a href="https://www.terraform.io/language/resources/provisioners/syntax">https://www.terraform.io/language/resources/provisioners/syntax</a>) as such configurations cannot be represented in the declarative code. Terraform supports many provisioners such as <code>file</code>, <code>local-exec</code>, <code>remote-exec</code>, and so on. Use either the <code>local-exec</code> or <code>remote-exec</code> provisioner and use Ansible to configure your system, which has been provisioned by Terraform. Choose either method, depending on your environment and other tool integration options.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor174"/>Using Terraform’s local-exec provisioner with Ansible</h2>
<p>To use<a id="_idIndexMarker569"/> the <code>local-exec</code> provisioner with Ansible, the machine you are running Terraform on should have Ansible installed and configured since the <code>ansible-playbook</code> command will be executed on your local machine, as shown in the following diagram:</p>
<div><div><img alt="Figure 9.40 – Using Ansible as local-exec with Terraform " height="756" src="img/B18383_09_40.jpg" width="1162"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.40 – Using Ansible as local-exec with Terraform</p>
<p>You <a id="_idIndexMarker570"/>also need to pass the credential details such as the username and SSH private key in the command, as follows:</p>
<div><div><img alt="Figure 9.41 – Terraform code for EC2 provisioning with Ansible automation " height="536" src="img/B18383_09_41.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.41 – Terraform code for EC2 provisioning with Ansible automation</p>
<p><code>ec2-user</code> in the preceding snippet is the default user account in the AWS Linux AMI. This username or<a id="_idIndexMarker571"/> credential can be changed, depending on your EC2 AMI or another source image. For example, create a custom base image in AWS, GCP, Azure, or other cloud platforms, and then use that image to create the instances using Terraform and configure them using Ansible.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor175"/>Using Terraform’s remote-exec provisioner with Ansible</h2>
<p>If your local <a id="_idIndexMarker572"/>machine does not support the installation of Ansible (for example, running Terraform on a Windows machine), then it is possible to use the <code>remote-exec</code> provisioner, but you need to ensure that Ansible is installed inside the remote machine provisioned by Terraform. You also need to ensure the playbook and required files have been copied to the target machine before calling the <code>ansible-playbook</code> command using the <code>remote-exec</code> provisioner. The following diagram shows the high-level workflow in Terraform with Ansible <code>remote-exec</code> provisioning:</p>
<div><div><img alt="Figure 9.42 – Ansible remote-exec provisioning in Terraform " height="809" src="img/B18383_09_42.jpg" width="1162"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.42 – Ansible remote-exec provisioning in Terraform</p>
<p>Refer <a id="_idIndexMarker573"/>to <code>Chapter-09/terraform-aws-ansible-lab</code> for the Terraform code used in the following explanation. Follow these steps:</p>
<ol>
<li value="1">Use the <code>user_data</code> argument to pass the basic commands to be executed during the initialization of the EC2 instance and Ansible installation. These commands can be included in the <code>user_data</code> script. A typical user data script can be written as follows:</li>
</ol>
<div><div><img alt="Figure 9.43 – User data script for installing Ansible inside an EC2 instance " height="361" src="img/B18383_09_43.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.43 – User data script for installing Ansible inside an EC2 instance</p>
<ol>
<li value="2">As you <a id="_idIndexMarker574"/>saw in the previous example, the EC2 instance creation code will have more components now, as follows:</li>
</ol>
<div><div><img alt="Figure 9.44 – EC2 resource with the user_data script " height="334" src="img/B18383_09_44.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.44 – EC2 resource with the user_data script</p>
<p>The <code>user-data-dbnodes.sh</code> script will be executed when the new EC2 instance is created. All the components, including Ansible, will be installed inside it. </p>
<ol>
<li value="3">The next step is copying the required playbooks to the remote EC2 instance. Here, we have used the Terraform <code>file</code> provisioner for this. After that, execute the playbook using the <code>remote-exec</code> provisioner:</li>
</ol>
<div><div><img alt="Figure 9.45 – Copying and executing the playbook inside the EC2 instance using the remote-exec method " height="706" src="img/B18383_09_45.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.45 – Copying and executing the playbook inside the EC2 instance using the remote-exec method</p>
<p>For further <a id="_idIndexMarker575"/>practicing and learning, include the system configuration tasks inside the <code>dbnode-config.yaml</code> file, such as creating new users, installing database packages, starting services, mounting disk volumes, and more. </p>
<p>Refer to <em class="italic">Using Ansible with Terraform</em> (<a href="https://www.techbeatly.com/using-ansible-with-terraform-ansible-real-life-series">https://www.techbeatly.com/using-ansible-with-terraform-ansible-real-life-series</a>) to learn more and understand Terraform and Ansible integration.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor176"/>Summary</h1>
<p>In this chapter, you explored the basic concepts, processes, and technical terms surrounding DevOps, such as CI/CD and continuous deployment. You also learned about some of the possibilities of Ansible integration within the DevOps workflow. Then, you learned how to use Ansible inside a continuous deployment workflow using Jenkins. After that, you learned about how to perform rolling updates without downtime while using Ansible as part of continuous application deployment. Finally, you learned how to integrate Ansible with Terraform for IaC provisioning. </p>
<p>In the next chapter, you will learn how to build, run, and manage containers using Ansible.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor177"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><em class="italic">Use Terraform to Create a FREE Ansible Lab in AWS</em>: <a href="https://www.techbeatly.com/use-terraform-to-create-a-free-ansible-lab-in-aws">https://www.techbeatly.com/use-terraform-to-create-a-free-ansible-lab-in-aws</a> </li>
<li><em class="italic">Deep Dive – Automated NetOps – Ansible for Network GitOps</em>: <a href="https://www.youtube.com/watch?v=JqE13sP2sq8">https://www.youtube.com/watch?v=JqE13sP2sq8</a> (Video)</li>
<li><em class="italic">Continuous integration vs. delivery vs. deployment</em>: <a href="https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment">https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment</a></li>
<li><em class="italic">Ansible and HashiCorp: Better Together</em>: <a href="https://www.hashicorp.com/resources/ansible-terraform-better-together">https://www.hashicorp.com/resources/ansible-terraform-better-together</a></li>
<li><em class="italic">Manages a Terraform deployment</em>: <a href="https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.xhtml">https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.xhtml</a></li>
</ul>
</div>
<div><div></div>
</div>
</div></body></html>