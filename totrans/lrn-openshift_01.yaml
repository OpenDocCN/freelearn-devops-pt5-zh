- en: Containers and Docker Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is much more than just the fundamentals of OpenShift. It's about the
    past, present, and the future of microservices and containers in general. In this
    book, we are going to cover OpenShift and its surroundings; this includes topics
    such as the fundamentals of containers, Docker basics, and studying sections where
    we will work with both Kubernetes and OpenShift in order to feel more comfortable
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: During our OpenShift journey, we will walk you through all the main and most
    of the advanced components of OpenShift. We are going to cover OpenShift security
    and networking and also application development for OpenShift using the most popular
    and built-in OpenShift DevOps tools, such as CI/CD with Jenkins and **Source-to-Image**
    (**S2I**) in conjunction with GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn about the most critical part for every person who would like
    to actually implement OpenShift in their company—the design part. We are going
    to show you how to properly design and implement OpenShift, examining the most
    common mistakes made by those who have just started working with OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter is focused on container and Docker technologies. We will describe
    container concepts and Docker basics, from the architecture to low-level technologies.
    In this chapter, we will learn how to use Docker CLI and manage Docker containers
    and Docker images. A significant part of the chapter is focused on building and
    running Docker container images. As a part of the chapter, you are asked to develop
    a number of Dockerfiles and to containerize several applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker container architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker images and layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker Hub and Docker registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Docker software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Docker command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing images via Docker CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing containers via Docker CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the importance of environment variables inside Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing persistent storage for Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to use the following technologies and software:'
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox (recommended) or any other browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vagrant installation and all the code we use in this chapter are located
    on GitHub at [https://github.com/PacktPublishing/Learn-OpenShift](https://github.com/PacktPublishing/Learn-OpenShift).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions on how to install and configure Docker are provided in this chapter
    as we learn.
  prefs: []
  type: TYPE_NORMAL
- en: Bash Shell will be used as a part of your virtual environment based on CentOS
    7.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox or any other browser can be used to navigate through Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: As a prerequisite, you will need a stable internet connection from your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Containers overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, software applications were developed following a monolithic architecture
    approach, meaning all the services or components were locked to each other. You
    could not take out a part and replace it with something else. That approach changed
    over time and became the N-tier approach. The N-tier application approach is one
    step forward in container and microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The major drawbacks of the monolith architecture were its lack of reliability,
    scalability, and high availability. It was really hard to scale monolith applications
    due to their nature. The reliability of these applications was also questionable
    because you could rarely easily operate and upgrade these applications without
    any downtime. There was no way you could efficiently scale out monolith applications,
    meaning you could not just add another one, five, or ten applications back to
    back and let them coexist with each other.
  prefs: []
  type: TYPE_NORMAL
- en: We had monolith applications in the past, but then people and companies started
    thinking about application scalability, security, reliability, and **high availability**
    (**HA**). And that is what created N-tier design. The N-tier design is a standard
    application design like 3-tier web applications where we have a web tier, application
    tier, and database backend. It's pretty standard. Now it is all evolving into
    microservices. Why do we need them? The short answer is *for better numbers*.
    It's cheaper, much more scalable, and secure. Containerized applications bring
    you to a whole new level and this is where you can benefit from automation and
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are a new generation of virtual machines. That brings software development
    to a whole new level. Containers are an isolated set of different rules and resources
    inside a single operating system. This means that containers can provide the same
    benefits as virtual machines but use far less CPU, memory, and storage. There
    are several popular container providers including LXC, Rockt, and Docker, which
    we are going to focus on this book.
  prefs: []
  type: TYPE_NORMAL
- en: Container features and advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This architecture brings a lot of advantages to software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the major advantages of containers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient hardware resource consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application and service isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stateless nature of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient hardware resource consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you run containers natively on a bare-metal server or use virtualization
    techniques, using containers allows you to utilize resources (CPU, memory, and
    storage) in a better and much more efficient manner. In the case of a bare-metal
    server, containers allow you to run tens or even hundreds of the same or different
    containers, providing better resource utilization in comparison to usually one
    application running on a dedicated server. We have seen in the past that some
    server utilization at peak times is only 3%, which is a waste of resources. And
    if you are going to run several of the same or different applications on the same
    servers, they are going to conflict with each other. Even if they work, you are
    going to face a lot of problems during day-to-day operation and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to isolate these applications by introducing popular virtualization
    techniques such as KVM, VMware, XEN, or Hyper-V, you will run into a different
    issue. There is going to be a lot of overhead because, in order to virtualize
    your app using any hypervisor, you will need to install an operating system on
    top of your hypervisor OS. This operating system needs CPU and memory to function.
    For example, each VM has its own kernel and kernel space associated with it. A
    perfectly tuned container platform can give you up to four times more containers
    in comparison to standard VMs. It may be insignificant when you have five or ten
    VMs, but when we talk hundreds or thousands, it makes a huge difference.
  prefs: []
  type: TYPE_NORMAL
- en: Application and service isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a scenario where we have ten different applications hosted on the same
    server. Each application has a number of dependencies (such as packages, libraries,
    and so on). If you need to update an application, usually it involves updating
    the process and its dependencies. If you update all related dependencies, most
    likely it will affect the other application and services. It may cause these applications
    not to work properly. Sure, to a degree these issues are addressed by environment
    managers such as `virtualenv` for Python and `rbenv`/`rvm` for Ruby—and dependencies
    on shared libraries can be isolated via `LD_LIBRARY_PATH`—but what if you need
    different versions of the same package? Containers and virtualization solve that
    issue. Both VMs and containers provide environment isolation for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: But, in comparison to bare-metal application deployment, container technology
    (for example, Docker) provides an efficient way to isolate applications, and other
    computer resources libraries from each other. It not only provides these applications
    with the ability to co-exist on the same OS, but also provides efficient security,
    which is a big must for every customer-facing and content-sensitive application.
    It allows you to update and patch your containerized applications independently
    of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Faster deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using container images, discussed later in this book, allows us speed up container
    deployment. We are talking about seconds to completely restart a container versus
    minutes or tens of minutes with bare-metal servers and VMs. The main reason for
    this is that a container does not need to restart the whole OS, it just needs
    to restart the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers bring application deployment to a whole new level by introducing
    microservices architecture. What it essentially means is that, if you have a monolith
    or N-tier application, it usually has many different services communicating with
    each other. Containerizing your services allows you to break down your application
    into multiple pieces and work with each of them independently. Let's say you have
    a standard application that consists of a web server, application, and database.
    You can probably put it on one or three different servers, three different VMs,
    or three simple containers, running each part of this application. All these options
    require a different amount of effort, time, and resources. Later in this book,
    you will see how simple it is to do using containers.
  prefs: []
  type: TYPE_NORMAL
- en: The stateless nature of containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are stateless, which means that you can bring containers up and down,
    create or destroy them at any time, and this will not affect your application
    performance. That is one of the greatest features of containers. We are going
    to delve into this later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Docker container architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is one of the most popular application containerization technologies
    these days. So why do we want to use Docker if there are other container options
    available? Because collaboration and contribution are key in the era of open source,
    and Docker has made many different things that other technologies have not been
    able to in this area.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Docker partnered with other container developers such as Red Hat,
    Google, and Canonical to jointly work on its components. Docker also contributed
    it's software container format and runtime to the Linux Foundation's open container
    project. Docker has made containers very easy to learn about and use.
  prefs: []
  type: TYPE_NORMAL
- en: Docker architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned already, Docker is the most popular container platform. It
    allows for creating, sharing, and running applications inside Docker containers.
    Docker separates running applications from the infrastructure. It allows you to
    speed up the application delivery process drastically. Docker also brings application
    development to an absolutely new level. In the diagram that follows, you can see
    a high-level overview of the Docker architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker uses a client-server type of architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker server**: This is a service running as a daemon in an operating system.
    This service is responsible for downloading, building, and running containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker client**: The CLI tool is responsible for communicating with Docker
    servers using the REST API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker's main components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker uses three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker containers**: Isolated user-space environments running the same or
    different applications and sharing the same host OS. Containers are created from
    Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker images**: Docker templates that include application libraries and
    applications. Images are used to create containers and you can bring up containers
    immediately. You can create and update your own custom images as well as download
    build images from Docker''s public registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker registries**: This is a images store. Docker registries can be public
    or private, meaning that you can work with images available over the internet
    or create your own registry for internal purposes. One popular public Docker registry
    is Docker Hub, discussed later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, Docker containers are secured and isolated
    from each other. In Linux, Docker containers use several standard features of
    the Linux kernel. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux namespaces**: It is a feature of Linux kernel to isolate resources
    from each other. This allows one set of Linux processes to see one group of resources
    while allowing another set of Linux processes to see a different group of resources.
    There are several kinds of namespaces in Linux: **Mount** (**mnt**), **Process
    ID** (**PID**), **Network** (**net**), **User ID** (**user**), **Control group**
    (**cgroup**), and **Interprocess Communication** (**IPC**). The kernel can place
    specific system resources that are normally visible to all processes into a namespace.
    Inside a namespace, a process can see resources associated with other processes
    in the same namespace. You can associate a process or a group of processes with
    their own namespace or, if using network namespaces, you can even move a network
    interface to a network namespace. For example, two processes in two different
    mounted namespaces may have different views of what the mounted root file system
    is. Each container can be associated with a specific set of namespaces, and these
    namespaces are used inside these containers only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control groups** (**cgroups**): These provide an effective mechanism for
    resource limitation. With cgroups, you can control and manage system resources
    per Linux process, increasing overall resource utilization efficiency. Cgroups
    allow Docker to control resource utilization per container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SELinux**: **Security Enhanced Linux** (**SELinux**) is **mandatory access
    control** (**MAC**) used for granular system access, initially developed by the **National
    Security Agency** (**NSA**). It is an additional security layer for Debian and
    RHEL-based distributions like Red Hat Enterprise Linux, CentOS, and Fedora. Docker
    uses SELinux for two main reasons: host protection and to isolate containers from
    each other. Container processes run with limited access to the system resources
    using special SELinux rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beauty of Docker is that it leverages the aforementioned low-level kernel
    technologies, but hides all complexity by providing an easy way to manage your
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker images and layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Docker image is a read-only template used to build containers. An image consists
    of a number of layers that are combined into a single virtual filesystem accessible
    for Docker applications. This is achieved by using a special technique which combines
    multiple layers into a single view. Docker images are immutable, but you can add
    an extra layer and save them as a new image. Basically, you can add or change
    the Docker image content without changing these images directly. Docker images
    are the main way to ship, store, and deliver containerized applications. Containers
    are created using Docker images; if you do not have a Docker image, you need to
    download or build one.
  prefs: []
  type: TYPE_NORMAL
- en: Container filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The container filesystem, used for every Docker image, is represented as a
    list of read-only layers stacked on top of each other. These layers eventually
    form a base root filesystem for a container. In order to make it happen, different
    storage drivers are being used. All the changes to the filesystem of a running
    container are done to the top level image layer of a container. This layer is
    called a Container layer. What it basically means is that several containers may
    share access to the same underlying level of a Docker image, but write the changes
    locally and uniquely to each other. This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker layers
  prefs: []
  type: TYPE_NORMAL
- en: Docker storage drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Docker storage driver is the main component to enable and manage container
    images. Two main technologies are used for that—copy-on-write and stackable image
    layers. The storage driver is designed to handle the details of these layers so
    that they interact with each other. There are several drivers available. They
    do pretty much the same job, but each and every one of them does it differently.
    The most common storage drivers are AUFS, Overlay/Overlay2, Devicemapper, Btrfs,
    and ZFS. All storage drivers can be categorized into three different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Storage driver category** | **Storage drivers** |'
  prefs: []
  type: TYPE_TB
- en: '| Union filesystems | AUFS, Overlay, Overlay2 |'
  prefs: []
  type: TYPE_TB
- en: '| Snapshotting filesystems | Btrfs, ZFS |'
  prefs: []
  type: TYPE_TB
- en: '| Copy-on-write block devices | Devicemapper |'
  prefs: []
  type: TYPE_TB
- en: Container image layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, a Docker image contains a number of layers that are
    combined into a single filesystem using a storage driver. The layers (also called
    intermediate images) are generated when commands are executed during the Docker
    image build process. Usually, Docker images are created using a Dockerfile, the
    syntax of which will be described later. Each layer represents an instruction
    in the image's Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each layer, except the very last one, is read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.gif)'
  prefs: []
  type: TYPE_IMG
- en: Docker image layers
  prefs: []
  type: TYPE_NORMAL
- en: A Docker image usually consists of several layers, stacked one on top of the
    other. The top layer has read-write permissions, and all the remaining layers
    have read-only permissions. This concept is very similar to the copy-on-write
    technology. So, when you run a container from the image, all the changes are done
    to this top writable layer.
  prefs: []
  type: TYPE_NORMAL
- en: Docker registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, a Docker image is a way to deliver applications. You can
    create a Docker image and share it with other users using a public/private registry
    service. A registry is a stateless, highly scalable server-side application which
    you can use to store and download Docker images. Docker registry is an open source
    project, under the permissive Apache license. Once the image is available on a
    Docker registry service, another user can download it by pulling the image and
    can use this image to create new Docker images or run containers from this image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker supports several types of docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: Public registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can start a container from an image stored in a public registry. By default,
    the Docker daemon looks for and downloads Docker images from Docker Hub, which
    is a public registry provided by Docker. However, many vendors add their own public
    registries to the Docker configuration at installation time. For example, Red
    Hat has its own *proven and blessed* public Docker registry which you can use
    to pull Docker images and to build containers.
  prefs: []
  type: TYPE_NORMAL
- en: Private registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some organization or specific teams don't want to share their custom container
    images with everyone for a reason. They still need a service to share Docker images,
    but just for internal usage. In that case, a private registry service can be useful.
    A private registry can be installed and configured as a service on a dedicated
    server or a virtual machine inside your network.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily install a private Docker registry by running a Docker container
    from a public registry image. The private Docker registry installation process
    is no different from running a regular Docker container with additional options.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Docker registry is accessed via the Docker daemon service using a Docker client.
    The Docker command line uses a RESTful API to request process execution from the
    daemon. Most of these commands are translated into HTTP requests and may be transmitted
    using `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: The process of using Docker registries is shown in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: A developer can create a Docker image and put it into a private or public registry.
    Once the image is uploaded, it can be immediately used to run containers or build
    other images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Hub is a cloud-based registry service that allows you to build your images
    and test them, push these images, and link to Docker cloud so you can deploy images
    on your hosts. Docker Hub provides a centralized resource for container image
    discovery, distribution and change management, user and team collaboration, and
    workflow automation throughout the development pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub is the public registry managed by the Docker project, and it hosts
    a large set of container images, including those provided by major open source
    projects, such as MySQL, Nginx, Apache, and so on, as well as customized container
    images developed by the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Hub provides some of the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image repositories**: You can find and download images managed by other Docker
    Hub users. You can also push or pull images from private image libraries you have
    access to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated builds**: You can automatically create new images when you make
    changes to a source code repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webhooks**: The action trigger that allows you to automate builds when there
    is a push to a repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organizations**: The ability to create groups and manage access to image
    repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to start working with Docker Hub, you need to log in to Docker Hub
    using a Docker ID. If you do not have one, you can create your Docker ID by following
    the simple registration process. It is completely free. The link to create your
    Docker ID if you do not have one is [https://hub.docker.com/](https://hub.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: You can search for and pull Docker images from Docker Hub without logging in;
    however, to push images you must log in. Docker Hub gives you the ability to create
    public and private repositories. Public repositories will be publicly available
    for anyone and private repositories will be restricted to a set of users of organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub contains a number of official repositories. These are public, certified
    repositories from different vendors and Docker contributors. It includes vendors
    like Red Hat, Canonical, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Docker installation and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker software is available in two editions: **Community Edition** (**CE**)
    and **Enterprise Edition** (**EE**).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker CE** is a good point from which to start learning Docker and using
    containerized applications. It is available on different platforms and operating
    systems. Docker CE comes with an installer so you can start working with containers
    immediately. Docker CE is integrated and optimized for infrastructure so you can
    maintain a native app experience while getting started with Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Enterprise Edition** (**EE**) is a **Container-as-a-Service** (**CaaS**)
    platform for IT that manages and secures diverse applications across disparate
    infrastructures, both on-premises and in a cloud. In other words, Docker EE is
    similar to Docker CE in that it is supported by Docker Inc.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker software supports a number of platforms and operating systems. The packages
    are available for most popular operating systems such as Red Hat Enterprise Linux,
    Fedora Linux, CentOS, Ubuntu Linux, Debian Linux, macOS, and Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Docker installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker installation process is dependent on the particular operating system.
    In most cases, it is well described on the official Docker portal—[https://docs.docker.com/install/](https://docs.docker.com/install/).
    As a part of this book, we will be working with Docker software on CentOS 7.x.
    Docker installation and configuration on other platforms is not part of this book.
    If you still need to install Docker on another operating system, just visit the
    official Docker web portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the Docker node installation process looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration of an operating system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker packages installation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Docker settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the Docker service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assume that our readers have sufficient knowledge to install and configure
    a CentOS-based **virtual machine** (**VM**) or bare-metal host. If you do not
    know how to use Vagrant, please follow the guidelines at [https://www.vagrantup.com/intro/getting-started/](https://www.vagrantup.com/intro/getting-started/).
  prefs: []
  type: TYPE_NORMAL
- en: Once you properly install Vagrant on your system, just run `vagrant init centos/7` followed
    by `vagrant up`. You can verify whether vagrant is up with the `vagrant status` command,
    and finally you can `ssh` into VM by using `vagrant ssh` command.
  prefs: []
  type: TYPE_NORMAL
- en: Since Docker is supported on even the most popular OSes, you have an option
    to install Docker directly on your desktop OS. We advise you to either use Vagrant
    or any other virtualization provider such as VMware or KVM, because we have done
    all the tests inside the virtual environment on CentOS 7\. If you still want to
    install Docker on your desktop OS, follow the link: [https://docs.docker.com/install/](https://docs.docker.com/install/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker CE is available on CentOS 7 with standard repositories. The installation
    process is focused on the `docker` package installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is completed, you need to run the Docker daemon to be
    able to manage your containers and images. On RHEL7 and CentOS 7, this just means
    starting the Docker service like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that your Docker daemon works properly by showing Docker information
    provided by the `docker info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Docker configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker daemon configuration is managed by the Docker configuration file (`/etc/docker/daemon.json`)
    and Docker daemon startup options are usually controlled by the `systemd` unit
    named Docker. On Red Hat-based operating systems, some configuration options are
    available at `/etc/sysconfig/docker` and `/etc/sysconfig/docker-storage`. Modification
    of the mentioned file will allow you to change Docker parameters such as the UNIX
    socket path, `listen` on TCP sockets, registry configuration, storage backends,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to start using Docker CLI, you need to configure and bring up a Vagrant
    VM. If you are using macOS, the configuration process using Vagrant will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**# Using Docker man, help, info'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker daemon listens on `unix:///var/run/docker.sock` but you can bind
    Docker to another host/port or a Unix socket. The Docker client (the `docker` utility)
    uses the Docker API to interact with the Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client supports dozens of commands, each with numerous options, so
    an attempt to list them all would just result in a copy of the CLI reference from
    the official documentation. Instead, we will provide you with the most useful
    subsets of commands to get you up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always check available man pages for all Docker sub-commands using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be able to see a list of man pages for Docker and all the sub-commands
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to get information regarding a command is to use `docker COMMAND
    --help`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker` utility allows you to manage container infrastructure. All sub-commands
    can be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Activity type** | **Related subcommands** |'
  prefs: []
  type: TYPE_TB
- en: '| Managing images | `search`, `pull`, `push`, `rmi`, `images`, `tag`, `export`,
    `import`, `load`, `save` |'
  prefs: []
  type: TYPE_TB
- en: '| Managing containers | `run`, `exec`, `ps`, `kill`, `stop`, `start` |'
  prefs: []
  type: TYPE_TB
- en: '| Building custom images | `build`, `commit` |'
  prefs: []
  type: TYPE_TB
- en: '| Information gathering | `info`, `inspect` |'
  prefs: []
  type: TYPE_TB
- en: Managing images using Docker CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in running and using a container on your server or laptop is
    to search and pull a Docker image from the Docker registry using the `docker search` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s search for the web server container. The command to do so is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can go to [https://hub.docker.com/](https://hub.docker.com/)
    and type `httpd` in the search window. It will give us something similar to the `docker
    search httpd` results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Hub search results
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the container image is found, we can pull this image from the Docker registry
    in order to start working with it. To pull a container image to your host, you
    need to use the `docker pull` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that Docker uses concepts from union filesystem layers to build Docker
    images. This is why you can see seven layers being pulled from Docker Hub. One
    stacks up onto another, building a final image.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Docker will try to pull the image with the latest tag, but we can
    also download an older, more specific version of an image we are interested in
    using different tags. The best way to quickly find available tags is to go to
    [https://hub.docker.com/](https://hub.docker.com/), search for the specific image,
    and click on the image details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Hub image details
  prefs: []
  type: TYPE_NORMAL
- en: There we are able to see all the image tags available for us to pull from Docker
    Hub. There are ways to achieve the same goal using the `docker search` CLI command,
    which we are going to cover later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You may notice that the download time for the second image was significantly
    lower than for the first image. It happens because the first image we pulled (`docker:latest`)
    has most layers in common with the second image (`httpd:2.2.29`). So there is
    no need to download all the layers again. This is very useful and saves a lot
    of time in large environments.
  prefs: []
  type: TYPE_NORMAL
- en: Working with images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we want to check the images available on our local server. To do this,
    we can use the `docker images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we downloaded a wrong image, we can always delete it from the local server
    by using the `docker rmi` command: **ReMove Image** (**RMI**). In our case, we
    have two versions of the same image, so we can specify a tag for the image we
    want to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we have only one image left, which is `httpd:latest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Saving and loading images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker CLI allows us to export and import Docker images and container layers
    using export/import or save/load Docker commands. The difference between save/load
    and export/import is that the first one works with images including metadata,
    but the export/import combination uses only container layers and doesn't include
    any image metadata information such as name, tags, and so on. In most cases, the
    save/load combination is more relevant and works properly for images without special
    needs. The `docker save` command packs the layers and metadata of all the chains
    required to build the image. You can then load this *saved* images chain into
    another Docker instance and create containers from these images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker export` will fetch the whole container, like a snapshot of a regular
    VM. It saves the OS, of course, but also any change a you made and any data file
    written during the container life. This one is more like a traditional backup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To load the image back from the file, we can use the `docker load` command.
    Before we do that, though, let''s remove the httpd image from the local repository
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We verify that we do not have any images in the local repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the image file we previously saved with the `docker save` command. Like
    `docker export` and docker import, this command forms a pair with Docker save
    and thus is used for loading a saved container archive with all intermediate layers
    and metadata to the Docker cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Check the local docker images with `docker image` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Uploading images to the Docker registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know how to search, pull, remove, save, load, and list available images.
    The last piece we are missing is how to push images back to Docker Hub or a private
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'To upload an image to Docker Hub, we need to do a few tricks and follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the Docker image you want to push to a different path in the Docker repository
    on your server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that `flashdumper` is your Docker Hub username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, push the copied image back to Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the image is pushed to your Docker Hub and available for anyone to download.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can check the same result using a web browser. If you go to [https://hub.docker.com/](https://hub.docker.com/)
    you should be able to see this `httpd` image available under your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Hub account images
  prefs: []
  type: TYPE_NORMAL
- en: Managing containers using Docker CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to actually run a container from the image we pulled from
    Docker Hub or a private registry in the previous chapter. We are going to use
    the `docker run` command to run a container. Before we do that, let''s check if
    we have any containers running already by using the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a container with the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The container is running, but we cannot leave the terminal and continue working
    in the foreground. And the only way we can escape it is by sending a TERM signal
    (*Ctrl* + *C*) and killing it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker ps and logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the `docker ps` command to show that there are no running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `docker ps -a` to show both running and stopped containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few things to note here. The `STATUS` field says that container
    `5e3820a43ffc` exited about one minute ago. In order to get container log information,
    we can use the `docker logs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last message says `caught SIGTERM, shutting down`. It happened after we
    pressed *Ctrl *+ *C*. In order to run a container in background mode, we can use
    the `-d` option with the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It generates a random ID, the first 12 characters of which are used for the
    container ID. Along with the generated ID, a random container name is also generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `docker ps` to verify the container ID, name, and status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Executing commands inside a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the output, we can see that the container status is `UP`. Now we can execute
    some commands inside the container using the `docker exec` command with different
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Option `-i` (`--interactive`) allows you to run a Docker without dropping inside
    the container. But we can easily override this behavior and enter this container
    by using `-i` and `-t` (`--tty`) options (or just `-it`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We should fall into container bash CLI. From here, we can execute other general
    Linux commands. This trick is very useful for troubleshooting. To exit the container
    console, just type `exit` or press *Ctrl *+ *D*.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also stop and start running containers by running `docker stop` and
    `docker start` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to stop the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following command to start the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Docker port mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to actually benefit from the container, we need to make it publicly
    accessible from the outside. This is where we will need to use the `-p` option
    with a few arguments while running the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Option `-p` maps container port `80` to your server port `8080`. Verify that
    you have a `httpd` container exposed and a web server running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the container is running, we can inspect its parameters by using the `docker
    inspect` command. The output is provided in JSON format and it gives us a very
    comprehensive output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Removing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to delete a container, you can use the `docker rm` command. If the
    container you want to delete is running, you can stop and delete it or use the `-f`
    option and it will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let's try using `-f` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another trick you can use to delete all containers, both stopped and running,
    is the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that all the containers are deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the dynamic and stateless nature of containers, applications cannot rely
    on either fixed IP addresses or DNS hostnames while communicating with middleware
    and other application services. Docker lets you store data such as configuration
    settings, encryption keys, and external resource addresses in environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Passing environment variables to a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At runtime, environment variables are exposed to the application inside the
    container. You can set environment variables in a service's containers with the
    *environment* key, just like with `docker run -e VARIABLE=VALUE`. You can also
    pass environment variables from your shell straight through to a service's containers
    with the environment key by not giving them a value, just like with `docker run
    -e VARIABLE`.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables are used to set specific application parameters, like
    IP addresses, for a server to connect the database server address with login credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Some container startup scripts use environment variables to perform the initial
    configuration of an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `mariadb` image is created to use several environment variables
    to start a container and create users/databases at the start time. This image
    uses the following important parameters, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `MYSQL_ROOT_PASSWORD` | This variable is mandatory and specifies the password
    that will be set for the MariaDB `root` superuser account. |'
  prefs: []
  type: TYPE_TB
- en: '| `MYSQL_DATABASE` | This variable is optional and allows you to specify the
    name of a database to be created on image startup. If a user/password was supplied
    (parameters in the row below) then that user will be granted superuser access
    (corresponding to `GRANT ALL`) to this database. |'
  prefs: []
  type: TYPE_TB
- en: '| `MYSQL_USER` and `MYSQL_PASSWORD` | These variables are optional and used
    in conjunction to create a new user and to set that user''s password. This user
    will be granted superuser permissions for the database specified by the `MYSQL_DATABASE`
    variable. Both variables are required for a user to be created. |'
  prefs: []
  type: TYPE_TB
- en: 'First, we can try to pull and start a `mariadb` container without specifying
    the password/user/database-related information. It will fail since the image expects
    the parameters. In this example, we are starting a container in the foreground
    to be able to see all error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now try to run `mariadb` container without any options and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker run` command failed because the MariaDB image initial startup script
    was not able to find the required variables. This script expects us to have at
    least the MariaDB root password to start a database server. Let''s try to start
    a database container again by providing all required variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker ps` command to verify that the container is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The container was created successfully. Run the verification command to check
    that `example_user` has access to the `example` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The startup script created a user named `example_user` with the password `password`
    as we specified in the environment variables. It also configured a password for
    the root user. The full list of MariaDB image variables you can specify is located
    at [https://hub.docker.com/_/mariadb/](https://hub.docker.com/_/mariadb/).
  prefs: []
  type: TYPE_NORMAL
- en: Linking containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Environment variables adjust settings for a single container. The same approach
    can be used to start a multi-tier application where one container or application
    works alongside the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Multi-tier application example
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-tier application, both the application server container and database
    server container may need to share variables such as database login credentials.
    Of course, we can pass all database connectivity settings to the application container
    using environment variables. It is very easy to make a mistake while passing multiple
    `-e` options to the `docker run` command, and it is very time-consuming, not to
    mention that it is very ineffective. Another option is to use container IP addresses
    to establish connections. We can gather IP address information using `docker inspect` but
    it will be difficult to track this information in a multi-container environment.
  prefs: []
  type: TYPE_NORMAL
- en: This means that using environment variables is just not enough to build multi-tier
    applications where containers depend on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has a featured called *linked containers* to solve this problem. It automatically
    copies all environment variables from one container to another. Additionally,
    by linking containers, we can define environment variables based on the other
    container's IP address and exposed ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using linked containers is done by simply adding the `--link container:alias` option
    to the `docker run` command. For example, the following command links to a container
    named MariaDB using the DB alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The new `my_application` container will then get all variables defined from
    the linked container `mariadb`. Those variable names are prefixed by `DB_ENV_`
    so as not to conflict with the new container's own environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware that the aliases are all uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables providing information about container IP addresses and ports are
    named according to the following scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ALIAS}_PORT_{exposed-port}_TCP_ADDR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ALIAS}_PORT_{exposed-port}_TCP_PORT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continuing with the MariaDB image example, the application container would
    get the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DB_PORT_3306_TCP_ADDR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_PORT_3306_TCP_PORT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the linked container exposes multiple ports, each of them generates a set
    of environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example. We will be creating a WordPress container which needs
    access to a database server. This integration will require shared database access
    credentials. The first step in creating this application is to create a database
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to run a WordPress container. In that command, we will link
    the `wordpress` container with the `mariadb` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check container environments with the `docker exec` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can see all these variables because the WordPress container startup script
    handles the `mysql` link. We can see here that the link set a number of `MYSQL_ENV`
    and `MYSQL_PORT` variables, which are used by the WordPress startup script.
  prefs: []
  type: TYPE_NORMAL
- en: Using persistent storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we saw that containers can be created and deleted
    easily. But when a container is deleted, all the data associated with that container
    disappears too. That is why a lot of people refer to containers as a stateless
    architecture. But we can change this behavior and keep all the data by using persistent
    volumes. In order to enable persistent storage for a Docker container, we need
    to use the `-v` option, which binds the container filesystem to the host filesystem
    that runs that container.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will create a MariaDB container with persistent storage
    in the `/mnt/data` folder on the host. Then, we delete the MariaDB container and
    recreate it again using the same persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, remove all previously created containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to prepare persistent storage on the node before we begin. Be aware
    that we need to give read/write permissions to the persistent storage directory.
    The MariaDB application works with a MySQL user with *UID=999* inside the container.
    Also, it is important to mention that the special SE Linux security context `svirt_sandbox_file_t` is
    required. This can be achieved using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the container running the MariaDB service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new database and verify the existence of this new DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that there is new data in the `/mnt/data` directory created by the `mariadb`
    container. This is how we make the data persistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the `mariadb` container and verify that all files will be kept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to rerun the container and verify whether the previously created
    database *persistent* survived container removal and creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the database with the name `persistent` is still here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove all the containers before you proceed to the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker community has Docker images for most popular software applications.
    These include, for example, images for web servers (Apache, Nginx, and so on),
    enterprise application platforms (JBoss EAP, Tomcat), images with programming
    languages (Perl, PHP, Python), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you do not need to build your own Docker images to run standard
    software. But if you have a business need that requires having a custom application,
    you probably need to create your own Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways to create a new docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commit**: Creating a Docker image from a running container. Docker allows
    you to *convert* a working container to a Docker image using the `docker commit`
    command. This means that image layers will be stored as a separate docker image.
    This approach is the easiest way to create a new image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Import/Export**: This is similar to the first one but uses another Docker
    command. Running container layers will be saved to a filesystem using docker export
    and then the image will be recreated using docker import. We do not recommend
    this method for creating a new image since the first one is simpler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile**: Building a Docker image using a Dockerfile. Dockerfile is a
    plain text file that contains a number of steps sometimes called instructions.
    These instructions can run a particular command inside a container or copy files
    to a container. A user can initiate a build process using Dockerfile and the Docker
    daemon will run all instructions in the Dockerfile in a temporary container. Then
    this container is converted to a docker image. This is the most common way to
    create a new docker image. Building custom docker images from Dockerfile will
    be described in details in a later chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**From scratch**: Building a base Docker image. In the two previous methods,
    Docker images are created using Docker images, and these docker images were created
    from a base Docker image. You cannot modify this base image unless you create
    one yourself. If you want to know what is inside your image, you might want to
    create a base image instead. There are two ways to do so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a base image layer using the `tar` command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use special Dockerfile instructions (from scratch). Both methods will be described
    in later chapters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing images using docker commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general recommendation is that all Docker images should be built from a
    Dockerfile to create clean and proper image layers without unwanted temporary
    and log files, despite the fact that some vendors deliver their Docker images
    without an available Dockerfile . If there is a need to modify that existing image,
    you can use the standard `docker commit` functionality to convert an existing
    container to a new image.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will try to modify our existing httpd container and make an
    image from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get the httpd image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need a container to be running. That container will be used as a template
    for a future image
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can connect to the container and modify its layers. As an example, we
    will update `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the changes we made using the `docker diff` command. This command
    shows you all files that were modified from the original image. The output looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the file states of the `docker diff` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | A file or directory was added |'
  prefs: []
  type: TYPE_TB
- en: '| **D** | A file or directory was deleted |'
  prefs: []
  type: TYPE_TB
- en: '| **C** | A file or directory was changed |'
  prefs: []
  type: TYPE_TB
- en: In our case, `docker diff httpd` command shows that `index.html` was changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new image from the running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the new image has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to verify that the image works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Using Dockerfile build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, those who use Docker containers expect to have a high-level of automation,
    and the `docker commit` command is difficult to automate. Luckily, Docker can
    build images automatically by reading instructions from a special file usually
    called a Dockerfile. A Dockerfile is a text document that contains all the commands
    a user can call on the command line to assemble an image. Using docker build,
    users can create an automated build that executes several command-line instructions
    in succession. On CentOS 7, you can learn a lot more using the Dockerfile built-in
    documentation page `man Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Dockerfile has a number of instructions that help Docker to build an image
    according to your requirements. Here is a Dockerfile example, which allows us
    to achieve the same result as in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this Dockerfile is created, we can build a custom image using the `docker
    build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that the `.` at the end of the first line is important as it specifies
    the working directory. Alternatively, you can use `./` or even `$(pwd)`. So the
    full commands are going to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker build -t custom_image2 .`'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '`docker build -t custom_image2 ./`'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '`docker build -t custom_image2 $(pwd)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Using Docker history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can check the history of image modifications using `docker history`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note that a new layer, `6b9be8efcb3a`, is added. This is where we change the
    content of the `index.html` file in comparison to the original `httpd` image.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some Dockerfile instructions are shown in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description and examples** |'
  prefs: []
  type: TYPE_TB
- en: '| `FROM image[:tag]` | It sets the base image used in the build process.Examples:FROM
    httpdFROM httpd:2.2 |'
  prefs: []
  type: TYPE_TB
- en: '| `RUN <command> <parameters>` | The RUN instruction executes any commands
    in a new layer on top of the current image and commits the results.Examples:RUN
    `yum install -y httpd &&\` `echo "custom answer" >/var/www/html/index.html` |'
  prefs: []
  type: TYPE_TB
- en: '| `RUN ["command", "param1", "param2"]` | This is the same as the last one
    but in Docker format. |'
  prefs: []
  type: TYPE_TB
- en: '| `COPY <src> <dst>` | The COPY instruction copies new files from `<src>` and
    adds them to the filesystem of the container at the path `<dest>`. The `<src>`
    must be the path to a file or directory relative to the source directory that
    is being built (the context of the build) or a remote file URL.Examples:COPY `index.html
    /var/www/html/index.html` |'
  prefs: []
  type: TYPE_TB
- en: '| `ENTRYPOINT ["executable", "param1", "param2"]` | An ENTRYPOINT helps you
    configure a container that can be run as an executable. When you specify an ENTRYPOINT,
    the whole container runs as if it were only that executable.Examples:ENTRYPOINT
    `["/usr/sbin/httpd","-D","FOREGROUND"]`In most cases the default value of ENTRYPOINT
    is `/bin/sh -c`, which means that CMD will be interpreted as a command to run
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPOSE <port>` | This instruction informs a Docker daemon that an application
    will be listening on this port at runtime. This is not very useful when working
    with standalone Docker containers because port publishing is performed via the
    `-p` argument of the CLI, but it is used by OpenShift when creating a service
    for a new application deployed from a Docker image and by Docker itself when exporting
    default environment variables inside a container. |'
  prefs: []
  type: TYPE_TB
- en: '| `CMD ["executable", "param1", "param2"]`  | Provides arguments to an `ENTRYPOINT`
    command and can be overridden at runtime with the `docker run` command.Example:`CMD
     ["/usr/sbin/httpd","-D","FOREGROUND"]` |'
  prefs: []
  type: TYPE_TB
- en: 'When the `docker build` command is run, Docker reads the provided Dockerfile
    from top to bottom, creating a separate layer for every instruction and placing
    it in the internal cache. If an instruction from Dockerfile is updated, it invalidates
    the respective caching layer and every subsequent one, forcing Docker to rebuild
    them when the docker build command is run again. Therefore, it''s more effective
    to place the most malleable instructions at the end of Dockerfile, so that the
    number of invalidated layers is minimized and cache usage is maximized. For example,
    suppose we have a Dockerfile with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the example, if you choose to use MySQL instead of MariaDB, the layer created
    by the second RUN command, as well as the third one, will be invalidated, which
    for complex images means a noticeably longer build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. Docker includes images for minimal OSes. These
    base images can be used to build custom images on top of them. In the example,
    we will be using a CentOS 7 base image to create a web server container from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a `project` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a Dockerfile with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image using `docker build`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can check that the new image exists and has all the required image
    layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The top three layers are the instructions we added in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have discussed container architecture, worked with Docker
    images and containers, examined different Docker registries, learned how to manage
    persistent storage for containers, and finally looked at how to build a Docker
    image with Dockerfile. All these skills will be required in [Chapter 3](part0093.html#2OM4A0-78aafb146b304cdeb9b3261a70edabde),
    *CRI-O Overview*, where we start working with Kubernetes. Kubernetes is an essential
    and critical OpenShift component. It all works like a snowball: Docker skills
    are required by Kubernetes, and Kubernetes skills are required by Openshift.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to work with Kubernetes. Kubernetes is an
    industry-standard orchestration layer for Docker containers. This is where you
    are going to install and run some basic Docker containers using Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are the three main Docker components? choose one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Container, Docker Image, Docker Registry
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Hub, Docker Image, Docker Registry
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Runtime, Docker Image, Docker Hub
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Container, Docker Image, Docker Hub
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose two valid registry types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Personal Registry
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Private Registry
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Public Registry
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security Registry
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main purpose of Docker Persistent Storage is to make sure that an application
    data is saved if a container dies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What Linux feature controls resource limitations for a Docker container? choose
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cgroups
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SELinux
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: chroot
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What commands can be used to build a custom image from a Dockerfile? choose
    two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: docker build -t new_httpd_image .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: docker build -t new_httpd_image .\
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: docker build -t new_httpd_image ($pwd)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: docker build -t new_httpd_image ./
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `docker commit` command saves Docker images to an upstream repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are covering the very basics of Docker containers, you may be interested
    in diving into specific topics. Here''s a list of links that may be helpful to
    look through to learn more about Docker and containers in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker overview**: [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker CLI**: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Storage**: [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker storage drivers**: [https://docs.docker.com/storage/storagedriver/select-storage-driver/](https://docs.docker.com/storage/storagedriver/select-storage-driver/)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
