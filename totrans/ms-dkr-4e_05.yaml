- en: '*Chapter 5*'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be taking a look at another core Docker tool called
    Docker Compose, and also the currently in-development Docker App.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these tools allow you to easily define, build, and distribute applications
    that are made up of more than one container, using syntax similar to the commands
    we have been using to manually launch our containers in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to break the chapter down into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the basics of Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our first Docker Compose application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Docker Compose commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker App
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in previous chapters, we will continue to use our local Docker installations,
    and the screenshots in this chapter will again be from my preferred operating
    system, macOS. As before, the Docker commands we will be running will work on
    all three of the operating systems on which we have installed Docker so far. However,
    some of the supporting commands, which will be few and far between, may only apply
    to macOS- and Linux-based operating systems—these will be highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the basics of Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)*, Docker Overview*,
    we discussed a few of the problems that Docker has been designed to solve. We
    explored how Docker addresses the challenges faced by a lot of development and
    operations teams. One such solution was to run two different application stacks
    side by side by isolating each application stack's processes into a single container.
    This lets you run two entirely different versions of the same software stack—let's
    say PHP 5.6 and PHP 7—on the same host, as we did in [*Chapter 2*](B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068)*,
    Building Container Images*.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)*,
    Managing Containers*, we launched an application that was made up of multiple
    containers rather than running the required software stack in a single container.
    The example application we started, `Moby Counter`, is written in Node.js and
    uses Redis as a backend to store key values, which in our case were the coordinates
    of the Docker logos on screen.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to run the Moby Counter application, we had to launch two different
    containers, one for the Node.js application and one for Redis. While it was quite
    simple to do this as the application itself was quite basic, there are a number
    of disadvantages to manually launching single containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I wanted a colleague to deploy the same application, I would
    have to pass them the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, I could get away with losing the first two commands as the image
    would be pulled down during the two `docker run` commands if the images were not
    present on my colleague's local machine, but as the applications start to get
    more complex, I will have to start passing on an ever-growing set of commands
    and instructions.
  prefs: []
  type: TYPE_NORMAL
- en: I would also have to make it clear that they would have to take into account
    the order in which the commands need to be executed. Furthermore, my notes would
    have to include details of any potential issues to support them through any problems—which
    could mean we find ourselves in a "worked fine in Dev, Ops problem now" scenario,
    which we want to avoid at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: While Docker's responsibility should end at creating the images and launching
    containers using these images, Docker's creators anticipated such a scenario and
    sought to overcome this. Thanks to Docker, people no longer have to worry about
    inconsistencies in the environment in which they are launching their applications,
    as these can now be shipped in images.
  prefs: []
  type: TYPE_NORMAL
- en: Orchard Laboratories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we look at Docker Compose, let's take a quick step back in time to July
    2014, when Docker purchased a small British start-up called Orchard Laboratories
    who offered two container-based products.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of the two products was a Docker-based hosting platform. From a single
    command, `orchard`, you could launch a host machine and then proxy your Docker
    commands through to the newly launched host; for example, you would use the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These commands would have launched a Docker host on Orchard's platform, and
    then a Redis container. I say *would have*, as one of the first things Docker
    did when they purchased Orchard Laboratories was to retire the Orchard hosting
    service.
  prefs: []
  type: TYPE_NORMAL
- en: The second Orchard Laboratories offering was an open source command-line tool
    called Fig, and it is this is what Docker had their eyes on when they purchased
    Orchard Laboratories. Fig, which was written in Python, let you use a YAML file
    to define how you would like your multi-container application to be structured.
    Fig took the YAML file and instructed Docker to launch the containers as defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of this was that because it was a YAML file, it was straightforward
    for developers to start shipping `fig.yml` files alongside their Dockerfiles within
    their code bases. A typical `fig.yml` file would have looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch the two containers defined in the `fig.yml` file, you would have
    had to have run the following command from inside the same folder where the `fig.yml`
    file was stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that I have been referring to Fig in the past tense, and
    that is because in February 2015, Fig became Docker Compose. In the next section
    of this chapter, we are going to be looking at launching our first Docker Compose
    application, and one of the first things you will notice is how close the syntax
    for defining the application is to the original Fig syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Making our first Docker Compose application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of our installation of Docker for Mac, Docker for Windows, and Docker
    on Linux in [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)*, Docker
    Overview*, we installed Docker Compose, so rather than discussing what it does
    any further, let's try to bring up the two-container application we launched manually
    at the end of the last chapter, using just Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, Docker Compose uses a YAML file, typically named `docker-compose.yml`,
    to define what your multi-container application should look like. The Docker Compose
    representation of the two-container application we launched in [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)*,
    Managing Containers* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Even without working through each of the lines in the file, it should be quite
    straightforward to follow along with what is going on based on the commands we
    have been using throughout the previous chapters—we will be looking at the contents
    of the `docker-compose.yml` file in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch our application, we simply change to the folder that contains your
    `docker-compose.yml` file and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, quite a bit happened as
    Docker Compose launched our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Output of docker-compose up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Output of docker-compose up
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the first few lines that Docker Compose did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It created a volume called `mobycounter_redis_data`, using the default driver
    we defined at the end of the `docker-compose.yml` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It created a network called `mobycounter_default` using the default network
    driver—at no point did we ask Docker Compose to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It launched two containers, one called `mobycounter_redis_1` and another called
    `mobycounter_mobycounter_1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have also spotted that the Docker Compose namespace in our multi-container
    application has prefixed everything with `mobycounter`—it took this name from
    the folder our Docker Compose file was being stored in.
  prefs: []
  type: TYPE_NORMAL
- en: Once launched, Docker Compose attached to `mobycounter_redis_1` and `mobycounter_mobycounter_1`
    and streamed the output to our Terminal session. On the Terminal screen, you can
    see both `redis_1 and mobycounter_1` starting to interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: When running Docker Compose using `docker-compose up`, it will run in the foreground.
    Pressing *Ctrl* + *C* will stop the containers and return access to your Terminal
    session.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose YAML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we look at using Docker Compose more, we should have a deeper dive into
    `docker-compose.yml` files as these are at the heart of Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**YAML** is a recursive acronym that stands for **YAML Ain''t Markup Language**.
    It is used by many different applications for both configuration and for defining
    data in a human-readable structured data format. The indentation you see in the
    examples is very important as it helps to define the structure of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: The Moby counter application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker-compose.yml` file we used to launch our multi-container application
    is split into three separate sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section simply specifies which version of the Docker Compose definition
    language we are using; in our case, as we are running a recent version of Docker
    and Docker Compose, we are using version 3, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As already mentioned, Docker Compose has been around since 2015, during which
    time there have been quite a few different versions of both the Docker client
    and engine. As the software has been updated to include new features, the existing
    functionality has been streamlined to make it more performant, and also, some
    functionality has been split out of the core Docker engine or removed altogether.
    Docker Compose has been maintained to remain compatible with previsions versions
    of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: If the version number is not declared at the start of the `docker-compose.yml`
    file, then Docker Compose will default to version 1; this is quite close to the
    original Fig syntax, meaning that Docker Compose will not be able to read our
    `docker-compose.yml` file as containers were defined under the `services` section
    and there is no support for volumes, networks, or even build arguments—all of
    which we will cover later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of what happens if we were to remove
    the version number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Output of docker-compose up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Output of docker-compose up
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, trying to run `docker-compose up` without the version declared
    is going to end with errors, as Docker Compose quite literally doesn't know how
    to interpret the content we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section is where our containers are defined; this section is the `services`
    section. It takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `services` declaration has no indentation at all, and then
    each container has 4 spaces, with each of the options having 8 spaces; further
    options would then have 12 spaces. The number of spaces is a personal choice as
    I find it helps make it more readable—the important thing is to use spaces and
    not tabs, and make sure that your indentation is consistent throughout the file
    as this is used to clearly define blocks of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we defined two containers under the `services` section. In
    the following code snippet, they have been separated out to make it easy to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, the syntax for defining the service appears close to how you
    would launch a container using the `docker container run` command. I say "close"
    because although it makes perfect sense when you read the definition, it is only
    on closer inspection that you realize there is actually a lot of difference between
    the Docker Compose syntax and the `docker container run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are no flags for the following when running the `docker
    container run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image`: This tells Docker Compose which image to download and use. This does
    not exist as an option when running `docker container run` on the command line
    as you can only run a single container; as we have seen in previous chapters,
    the image is always defined toward the end of the command, without the need for
    a flag to be passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume`: This is the equivalent of the `--volume` flag, but it can accept
    multiple volumes. It only uses the volumes that are declared in the Docker Compose
    YAML file; more on that in a moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on`: This would never work as a `docker container run` invocation
    because the command is only targeting a single container. When it comes to Docker
    Compose, `depends_on` is used to help build some logic into the order your containers
    are launched in—for example, only launch container B when container A has successfully
    started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: This is basically the `--publish` flag, which accepts a list of ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only part of the command we used that has an equivalent flag when running
    `docker container run` is `restart`. This is the same as using the `--restart`
    flag and accepts the same input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final section of our Docker Compose YAML file is where we declare our volumes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the equivalent of running `docker volume create redis_data` using the
    Docker command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: Example voting application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned already, the Docker Compose file for the Moby counter application
    is quite a simple example. Let's take a look at a more complex Docker Compose
    file and see how we can introduce building containers and multiple networks.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the repository for this book, you will find a folder in the `chapter05` directory
    called `example-voting-app`. This is a fork of the voting application from the
    official Docker sample repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, if you were to open up the `docker-compose.yml` file, the application
    is made up of five containers, two networks, and a single volume. If we were to
    visualize the application, it would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Container structure for docker-compose.yml'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Container structure for docker-compose.yml
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignore the other files as we will look at some of these in future chapters;
    let''s walk through the `docker-compose.yml` file as there is a lot going on.
    Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it starts simply enough by defining the version, and then it
    starts to list the `service`. Our first container is called vote; it is a Python
    application that allows users to submit their vote. As you can see from the following
    definition, rather than downloading an image that contains the application, we
    are actually building an image by deploying our application using `build` instead
    of the `image` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `build` instruction here tells Docker Compose to build a container using
    the Dockerfile, which can be found in the `./vote` folder. The Dockerfile itself
    is quite straightforward for a Python application.
  prefs: []
  type: TYPE_NORMAL
- en: Once the container launches, we are then mounting the `./vote` folder from our
    host machine into the container, which is achieved by passing the path of the
    folder we want to mount and where within the container we would like it mounted.
  prefs: []
  type: TYPE_NORMAL
- en: We are telling the container to run the `python app.py` command when the container
    launches; we are mapping port `5000` on our host machine to port `80` on the container;
    and, finally, we are further attaching two networks to the container—one called
    `front-tier` and another called `back-tier`.
  prefs: []
  type: TYPE_NORMAL
- en: The `front-tier` network will have the containers that require ports to be mapped
    to the host machine; the `back-tier` network is reserved for containers that do
    not need their ports to be exposed and acts as a private, isolated network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have another container that is connected to the `front-tier` network.
    This container displays the results of the vote. The `result` container contains
    a Node.js application that connects to the PostgreSQL database (which we will
    get to in a moment) and displays the results in real time as votes are cast in
    the `vote` container. As with the `vote` container, the image is built locally
    using a Dockerfile that can be found in the `./result` folder, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are exposing port `5001`, which is where we can connect to see the results.
    The next—and final—application container is called `worker`, as illustrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `worker` container runs a .NET application whose only job is to connect
    to Redis and register each vote by transferring it into a PostgreSQL database
    running on a container called `db`. The container is again built using a Dockerfile,
    but this time, rather than passing the path to the folder where the Dockerfile
    and application are stored, we are using `context`. This sets the working directory
    for the `docker build` command and also allows you to define additional options
    such as labels and changing the name of the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: As this container is doing nothing other than connecting to `redis` and the
    `db` container, it does not need any ports exposed as it has nothing connecting
    directly to it; it also does not need to communicate with either of the containers
    running on the `front-tier` network, meaning we just have to add the `back-tier`
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we now have the `vote` application, which registers the votes from the
    end users and sends them to the `redis` container, where the vote is then processed
    by the `worker` container. The service definition for the `redis` container looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This container uses the official Redis image and is not built from a Dockerfile;
    we are making sure that port `6379` is available, but only on the `back-tier`
    network. We are also specifying the name of the container, setting it to `redis`
    by using `container_name`. This is to avoid us having to make any considerations
    on the default names generated by Docker Compose within our code since, if you
    remember, Docker Compose uses the folder name to launch the containers in their
    own application namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next—and final—container is the PostgreSQL one (which we have already mentioned),
    called `db`, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it looks quite similar to the `redis` container in that we are
    using the official image; however, you may notice that we are not exposing a port,
    as this is a default option in the official image. We are also specifying the
    name of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is where our votes will be stored, we are creating and mounting a volume
    to act as persistent storage for our PostgreSQL database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, finally, here are the two networks we have been speaking about throughout
    when defining our application containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running `docker-compose up` gives a lot of feedback on what is happening during
    the launch; it takes about 5 minutes to launch the application for the first time.
    If you are not following along and launching the application yourself, what follows
    is an abridged version of the launch.
  prefs: []
  type: TYPE_NORMAL
- en: TIP
  prefs: []
  type: TYPE_NORMAL
- en: 'You may get an error that states `npm ERR! request to https://registry.npmjs.org/nodemon
    failed, reason: Hostname/IP doesn''t match certificate''s altnames`. If you do,
    then run the `echo "104.16.16.35 registry.npmjs.org" >> /etc/hosts` command as
    a user with privileges to write to the `/etc/hosts` file on your machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Compose starts by creating the networks and getting the volume ready
    for our containers to use, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It then builds the `vote` container image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the images have been downloaded, the building of the first part of
    the application can start, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the image has been built it will be tagged, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Docker Compose has built the `vote` image, it starts on building the `result`
    image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the PostgreSQL image for the `db` container being pulled
    down from Docker Hub, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `worker` image is constructed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that the `Redis` image being used by the `redis` container
    was not pulled—this is because the latest version was already downloaded. Now
    that all the images have either been built or pulled down and the networking and
    volumes are in place, Docker Compose can launch our application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `result` part of the application can be accessed at `http://localhost:5001`.
    By default, there are no votes and it is split 50/50, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The default voting tally'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – The default voting tally
  prefs: []
  type: TYPE_NORMAL
- en: 'The `voting` part of the application can be found at http://localhost:5000,
    and is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The voting interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – The voting interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on either **CATS** or **DOGS** will register a vote; you should be
    able to see this logged in the Docker Compose output in your Terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – docker-compute output showing votes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – docker-compute output showing votes
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few errors, as the Redis table structure is only created when the
    vote application registers the first vote; once a vote has been cast, the Redis
    table structure will be created and the `worker` container will take that vote
    and process it by writing to the `db` container. Once the vote has been cast,
    the `result` container will update in real time, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Vote result page after vote was cast'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Vote result page after vote was cast
  prefs: []
  type: TYPE_NORMAL
- en: We will be looking at the Docker Compose YAML files again in the upcoming chapters,
    when we look at launching both Docker Swarm stacks and Kubernetes clusters. For
    now, let's get back to Docker Compose and look at some of the commands we can
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Docker Compose commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are over halfway through the chapter, and the only Docker Compose command
    we have run is `docker-compose up`. If you have been following along and you run
    `docker container ls -a`, you will see something similar to the following Terminal
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Output for docker container ls -a'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Output for docker container ls -a
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have a lot of containers with the status of `Exited`. This
    is because when we used *Ctrl* + *C* to return to our Terminal, the Docker Compose
    containers were stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Choose one of the Docker Compose applications and change to the folder that
    contains the `docker-compose.yml` file, and we will work through some more Docker
    Compose commands. I will be using the **Example Vote** application.
  prefs: []
  type: TYPE_NORMAL
- en: up and ps
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command is `docker-compose up`, but this time, we will be adding
    a flag. In your chosen application folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start your application back up, this time in detached mode, which
    will return you to your Terminal prompt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Output for docker-compose up -d'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Output for docker-compose up -d
  prefs: []
  type: TYPE_NORMAL
- en: 'Once control of your Terminal is returned to you, you should be able to check
    that the containers are running, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, all of the containers have
    the state of `Up`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Output for docker-compose ps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Output for docker-compose ps
  prefs: []
  type: TYPE_NORMAL
- en: When running these commands, Docker Compose will only be aware of the containers
    defined in the `services` section of your `docker-compose.yml` file; all other
    containers will be ignored as they don't belong to our service stack.
  prefs: []
  type: TYPE_NORMAL
- en: config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the following command will validate our `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no issues, it will print a rendered copy of your Docker Compose
    YAML file to screen; this is how Docker Compose will interpret your file. If you
    don''t want to see this output and just want to check for errors, then you can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shorthand for `--quiet`. If there are any errors (which the examples
    we have worked through so far shouldn''t have), they will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: pull, build, and create
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next two commands will help you prepare to launch your Docker Compose application.
    The following command will read your Docker Compose YAML file and pull any of
    the images it finds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will execute any build instructions it finds in your
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These commands are useful when you are first defining your Docker Compose-powered
    application and want to test it without launching your application. The `docker-compose
    build` command can also be used to trigger a build if there are updates to any
    of the Dockerfiles used to originally build your images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pull` and `build` commands only generate/pull the images needed for our
    application; they do not configure the containers themselves. For this, we need
    to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create but not launch the containers. As with the `docker container
    create` command, they will have an `Exited` state until you start them. The `create`
    command has a few useful flags you can pass, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--force-recreate`: This recreates the container even if there is no need to,
    as nothing within the configuration has changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-recreate`: This doesn''t recreate a container if it already exists; this
    flag cannot be used with the preceding flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-build`: This doesn''t build the images, even if an image that needs to
    be built is missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--build`: This builds the images before creating the containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: start, stop, restart, pause, and unpause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following commands work in exactly the same way as their `docker container`
    counterparts, the only difference being that they effect change on all of the
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to target a single service by passing its name; for example,
    to pause and unpause the `db` service, we would run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to stop and start all or part of our Docker Compose application,
    we can look at how we can see some more information on our application.
  prefs: []
  type: TYPE_NORMAL
- en: top, logs, events, exec, and run
  prefs: []
  type: TYPE_NORMAL
- en: The next three commands all give us feedback on what is happening within our
    running containers and Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command, as with its `docker container` counterpart, displays
    information on the processes running within each of our Docker Compose-launched
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, each container is split
    into its own section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Output for docker-compose top'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Output for docker-compose top
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would just like to see one of the services, you simply have to pass
    its name when running the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command streams the logs from each of the running containers
    to screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `docker container` command, you can pass flags such as `-f` or
    `--follow` to keep the stream flowing until you press *Ctrl* + *C*. Also, you
    can stream the logs for a single service by appending its name to the end of your
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Log stream'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Log stream
  prefs: []
  type: TYPE_NORMAL
- en: 'The `events` command again works like the `docker container` equivalent; it
    streams events—such as the ones triggered by the other commands we have been discussing—in
    real time. For example, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `docker-compose pause` in a second Terminal window gives the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Output for docker-compose events'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Output for docker-compose events
  prefs: []
  type: TYPE_NORMAL
- en: 'These two commands run similarly to their `docker container` equivalents. Run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch a new process in the already running worker container and
    ping the `db` container three times, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Output for docker-compose exec worker ping -c 3 db'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – Output for docker-compose exec worker ping -c 3 db
  prefs: []
  type: TYPE_NORMAL
- en: 'The `run` command is useful if you need to run a containerized command as a
    one-off within your application. For example, if you use a package manager such
    as `composer` to update the dependencies of your project that is stored on a volume,
    you could run something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This would run the `composer` container with the `install` command and mount
    the `data_volume` at the following path `/app` within the container.
  prefs: []
  type: TYPE_NORMAL
- en: scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `scale` command will take the service you pass to the command and scale
    it to the number you define. For example, to add more `worker` containers, I just
    need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this actually gives the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What we should now be using is the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: While the `scale` command is in the current version of Docker Compose, it will
    be removed from future versions of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that I chose to scale the number of `worker` containers. There
    is a good reason for this, as you will see for yourself if you try running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that while Docker Compose creates the additional two containers,
    they fail to start, with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Output for docker-compose up -d --scale vote=3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – Output for docker-compose up -d --scale vote=3
  prefs: []
  type: TYPE_NORMAL
- en: That is because we cannot have three individual containers all trying to map
    to the same port on the host machine; because of this, you should always use the
    `scale` command on containers where you haven't explicitly defined a port mapping.kill,
    rm, and down
  prefs: []
  type: TYPE_NORMAL
- en: 'The three Docker Compose commands we are going to look at last are the ones
    that remove/terminate our Docker Compose application. The first command stops
    our running containers by immediately stopping running container processes. This
    is the `kill` command, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when running this as it does not wait for containers to gracefully
    stop, such as when running `docker-compose stop`, meaning that using the `docker-compose
    kill` command may result in data loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `rm` command; this removes any containers with the state of
    `exited`, and is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `down` command. This, as you might have already guessed,
    has the opposite effect of running `docker-compose up`, and is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'That will remove the containers and the networks created when running `docker-compose
    up`. If you want to remove everything, you can do so by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This will remove all of the containers, networks, volumes, and images (both
    pulled and built) when you ran the `docker-compose up` command; this includes
    images that may be in use outside of your Docker Compose application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There will, however, be an error if the images are in use, and those images
    will not be removed, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Output of docker-compose down --rmi all --volumes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Output of docker-compose down --rmi all --volumes
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding output, there is a container using the `redis`
    image, the Moby counter application, so it was not removed. However, all other
    images used by the `Example Vote` application are removed, both the ones built
    as part of the initial `docker- compose up` command and the ones downloaded from
    Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start this section, I should issue the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The feature we are going to discuss is very much an experimental one. It is
    in its very early stages of development and should not be considered any more
    than a preview of an upcoming feature.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its experimental nature, I am only going to cover the usage of Docker
    App on macOS. However, before we enable it, let's discuss what exactly is meant
    by a Docker app. While Docker Compose files are really useful when it comes to
    sharing your environment with others, you may have noticed that there is one quite
    crucial element we have been missing so far in this chapter, and that is the ability
    to actually distribute your Docker Compose files in a similar way to how you can
    distribute your Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has acknowledged this and is currently working on a new feature called
    Docker App, which it hopes will fill this gap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker App is currently a command-line client plugin that helps you to create
    an application bundle that can be shared via Docker Hub or a Docker Enterprise
    Registry. The plugin is built in to Docker 19.03, and all you have to do is open
    the Docker desktop **Settings** and toggle on **Enable experimental features**,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Docker desktop Enable experimental features screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – Docker desktop Enable experimental features screen
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be using the Moby Counter application as its `docker-compose.yml`
    file already meets the pre-requisites for a Docker App bundle, as we are using
    a version of 3.6 and higher—3.7, in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create our Docker App configuration. To do this, change to the `mobycounter`
    folder and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Version of the application
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'version: 0.1.0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Name of the application
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'name: mobycounterapp'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A short description of the application
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'description:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List of application maintainers with name and email for each
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'maintainers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: russ.mckendrick'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'email:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s start by updating the `metadata.yml` file. I updated mine to read as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding information will be used when we distribute the application. Initially,
    this will be via the Docker Hub, so please make sure that you are happy for the
    information to be accessible to other people.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our metadata, let''s add some parameters to the `parameters.yml`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update the `docker-compose.yml` file to make use of the parameters
    we have just defined, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, I have added `${port}` to the `docker-compose.yml` file. When
    we launch the application, the values will be populated from the `parameters.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and inspecting the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can double-check that everything we have changed is OK by running the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, this should display something that looks like the following
    Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Output for docker app inspect mobycounterapp.dockerapp'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Output for docker app inspect mobycounterapp.dockerapp
  prefs: []
  type: TYPE_NORMAL
- en: Once we've validated the app, we can finally move on to launching it.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For us to be able to launch the application natively, we need to be running
    a Docker Swarm cluster (we will be covering Docker Swarm in more detail in a future
    chapter). To achieve this, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ignore the output for now—we won't be creating a cluster just yet and only need
    a single node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have Docker Swarm enabled, we can install the application using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once installed, you can run the following command to check the status of the
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see something like the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Output for docker app install and docker app list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Output for docker app install and docker app list
  prefs: []
  type: TYPE_NORMAL
- en: The application should also be accessible on `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing to Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While our application is running, we can publish it to the Docker Hub. To do
    this, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t done so already, log in by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once logged in, run the following command, making sure that you update the
    Docker Hub ID (which is russmckendrick in my case) with your own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a minute, you should see a message that the bundle has been successfully
    pushed, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – hub.docker.com page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.21_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.21 – hub.docker.com page
  prefs: []
  type: TYPE_NORMAL
- en: Opening https://hub.docker.com/ in your browser should show that the application
    is there, as seen in *Figure 5.21*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing from Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let''s create a temporary folder and uninstall the application,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output if you are following along, we don't have any
    applications running, and we have changed folders away from our original `docker-compose.yml`
    file and also the `mobycounterapp.dockerapp` folder, so we know that neither of
    them will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can inspect the application directly from Docker Hub by running the
    following command (again, make sure to replace the Docker Hub ID with your own):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see information on our application similar to that shown when we
    last ran the command locally. First up, let''s create a new `docker-compose.yml`
    file using the Docker Hub-hosted version of the application. To do this, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a `docker-compose.yml` file in the current working folder;
    from there, we can then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You will get a warning that the node is `running Swarm` mode; again, ignore
    this for now. You should see the two containers running, and your application
    will again be accessible at `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s launch the application again natively, but this time alongside
    our Docker Compose-launched version. To do this, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are launching an application named `mobycounterapp8181`.
    We are also using the `--set` command to override the default port of `8080`,
    which we originally set in the `parameters.yml` file, and changing it to `8181`.
    If everything went as planned, you should be able to access the application at
    `http://localhost:8181`.
  prefs: []
  type: TYPE_NORMAL
- en: There is more functionality within Docker App. However, we are not quite ready
    to go into further details. We will return to Docker App in [*Chapter 8*](B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230)*,
    Docker Swarm* and [*Chapter 11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*,
    Docker and Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the top of this section, this feature is still in active development,
    and it is possible that the commands and functionality we have discussed so far
    may change in the future. But even at this development stage, I hope you can see
    the advantages of Docker App and how it is building on the solid foundations laid
    by Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have enjoyed this chapter on Docker Compose, and I hope that, like
    I did, you can see that it has evolved from being an incredibly useful third-party
    tool to an extremely important part of the core Docker experience.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose introduces some key concepts as to how you should approach running
    and managing your containers. We will be taking these concepts one step further
    in [*Chapter 8*](B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230)*, Docker Swarm*
    and [*Chapter 11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*, Docker and
    Kubernetes*, where we start to look at managing multiple Docker hosts and how
    we can distribute containers across them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move away from Linux-based containers and
    take a whistle-stop tour of Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose files use which open source format?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our initial Moby counter Docker Compose file, which was the only flag that
    works exactly the same as its Docker **command-line interface** (**CLI**) counterpart?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: You can only use images from the Docker Hub with your Docker
    Compose files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, how does Docker Compose decide on the namespace to use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flag do you add to docker-compose up to start the containers in the background?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to run a syntax check on your Docker Compose files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the basic principle about how Docker App works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For details on Orchard Laboratories, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Orchard Laboratories website: [https://web.archive.org/web/20171020135129/https://www.orchardup.com/](https://web.archive.org/web/20171020135129/https://www.orchardup.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Orchard Laboratories joins Docker: [https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/](https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a full Docker Compose compatibility matrix, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compose file versions and upgrading: [https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on the Docker App project, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub repository: [http://github.com/docker/app/](http://github.com/docker/app/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, here are some further links to a number of other topics that we have
    covered:'
  prefs: []
  type: TYPE_NORMAL
- en: 'YAML project home page: [http://www.yaml.org/](http://www.yaml.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker sample repository: [https://github.com/dockersamples/](https://github.com/dockersamples/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
