- en: '*Chapter 5*'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第五章*'
- en: Docker Compose
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: In this chapter, we will be taking a look at another core Docker tool called
    Docker Compose, and also the currently in-development Docker App.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍另一个核心 Docker 工具，名为 Docker Compose，同时也会涉及当前正在开发中的 Docker App。
- en: Both of these tools allow you to easily define, build, and distribute applications
    that are made up of more than one container, using syntax similar to the commands
    we have been using to manually launch our containers in previous chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种工具都可以让你轻松地定义、构建和分发由多个容器组成的应用程序，使用的语法与我们在前几章中手动启动容器时使用的命令类似。
- en: 'We are going to break the chapter down into the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这一章分成以下几个部分：
- en: Exploring the basics of Docker Compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Docker Compose 的基础知识
- en: Making our first Docker Compose application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Docker Compose 应用程序
- en: Exploring Docker Compose commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Docker Compose 命令
- en: Using Docker App
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker App
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in previous chapters, we will continue to use our local Docker installations,
    and the screenshots in this chapter will again be from my preferred operating
    system, macOS. As before, the Docker commands we will be running will work on
    all three of the operating systems on which we have installed Docker so far. However,
    some of the supporting commands, which will be few and far between, may only apply
    to macOS- and Linux-based operating systems—these will be highlighted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将继续使用本地 Docker 安装，本章中的截图也将再次来自我偏好的操作系统 macOS。与之前一样，我们将运行的 Docker 命令将适用于我们至今已安装
    Docker 的所有三种操作系统。然而，一些辅助命令，虽然很少，但可能仅适用于 macOS 和 Linux 操作系统——这些将会特别标明。
- en: Exploring the basics of Docker Compose
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Docker Compose 的基础知识
- en: In [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)*, Docker Overview*,
    we discussed a few of the problems that Docker has been designed to solve. We
    explored how Docker addresses the challenges faced by a lot of development and
    operations teams. One such solution was to run two different application stacks
    side by side by isolating each application stack's processes into a single container.
    This lets you run two entirely different versions of the same software stack—let's
    say PHP 5.6 and PHP 7—on the same host, as we did in [*Chapter 2*](B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068)*,
    Building Container Images*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第一章*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)* Docker 概述* 中，我们讨论了
    Docker 设计用于解决的几个问题。我们探讨了 Docker 如何应对许多开发和运维团队所面临的挑战。其中一个解决方案是通过将每个应用栈的进程隔离到一个容器中，来并行运行两个不同的应用栈。这样，你就可以在同一主机上运行两个完全不同版本的同一软件栈——比如
    PHP 5.6 和 PHP 7——正如我们在 [*第二章*](B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068)*
    构建容器镜像* 中所做的那样。
- en: Toward the end of [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)*,
    Managing Containers*, we launched an application that was made up of multiple
    containers rather than running the required software stack in a single container.
    The example application we started, `Moby Counter`, is written in Node.js and
    uses Redis as a backend to store key values, which in our case were the coordinates
    of the Docker logos on screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第四章*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)* 管理容器* 的最后，我们启动了一个由多个容器组成的应用程序，而不是在单个容器中运行所需的软件栈。我们开始的示例应用程序
    `Moby Counter` 是用 Node.js 编写的，并使用 Redis 作为后端存储键值数据，在我们的案例中是 Docker 图标在屏幕上的坐标。
- en: To be able to run the Moby Counter application, we had to launch two different
    containers, one for the Node.js application and one for Redis. While it was quite
    simple to do this as the application itself was quite basic, there are a number
    of disadvantages to manually launching single containers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行 Moby Counter 应用程序，我们必须启动两个不同的容器，一个用于 Node.js 应用程序，一个用于 Redis。虽然因为应用程序本身非常简单，启动这些容器非常容易，但手动启动单个容器也有一些缺点。
- en: 'For example, if I wanted a colleague to deploy the same application, I would
    have to pass them the following commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我希望同事部署相同的应用程序，我必须将以下命令传给他们：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Admittedly, I could get away with losing the first two commands as the image
    would be pulled down during the two `docker run` commands if the images were not
    present on my colleague's local machine, but as the applications start to get
    more complex, I will have to start passing on an ever-growing set of commands
    and instructions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，如果我的同事的本地机器上没有镜像，图像将在两个`docker run`命令执行时被拉取，我可以忽略前两个命令，但随着应用程序变得越来越复杂，我将不得不开始传递一组不断增长的命令和指令。
- en: I would also have to make it clear that they would have to take into account
    the order in which the commands need to be executed. Furthermore, my notes would
    have to include details of any potential issues to support them through any problems—which
    could mean we find ourselves in a "worked fine in Dev, Ops problem now" scenario,
    which we want to avoid at all costs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我还必须明确指出，他们必须考虑命令需要执行的顺序。此外，我的笔记还必须包括任何潜在问题的详细信息，以支持他们解决任何可能出现的问题——这可能导致我们陷入“在开发中运行良好，但在运维中出现问题”的场景，我们务必要尽量避免。
- en: While Docker's responsibility should end at creating the images and launching
    containers using these images, Docker's creators anticipated such a scenario and
    sought to overcome this. Thanks to Docker, people no longer have to worry about
    inconsistencies in the environment in which they are launching their applications,
    as these can now be shipped in images.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Docker的责任应该只限于创建镜像并使用这些镜像启动容器，但Docker的创建者预见到了这种情况，并力求克服这一问题。多亏了Docker，人们再也不必担心他们启动应用程序的环境不一致，因为现在可以通过镜像来进行部署。
- en: Orchard Laboratories
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Orchard Laboratories
- en: Before we look at Docker Compose, let's take a quick step back in time to July
    2014, when Docker purchased a small British start-up called Orchard Laboratories
    who offered two container-based products.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论Docker Compose之前，让我们快速回顾一下2014年7月，当时Docker收购了一家名为Orchard Laboratories的英国初创公司，该公司提供了两种基于容器的产品。
- en: 'The first of the two products was a Docker-based hosting platform. From a single
    command, `orchard`, you could launch a host machine and then proxy your Docker
    commands through to the newly launched host; for example, you would use the following
    commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 两个产品中的第一个是基于Docker的托管平台。通过一个单一命令`orchard`，您可以启动一个主机机器，然后将您的Docker命令代理到新启动的主机上；例如，您将使用以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These commands would have launched a Docker host on Orchard's platform, and
    then a Redis container. I say *would have*, as one of the first things Docker
    did when they purchased Orchard Laboratories was to retire the Orchard hosting
    service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将在Orchard的平台上启动一个Docker主机，然后是一个Redis容器。我说“将会”，因为当Docker收购Orchard Laboratories时，他们首先做的事情之一是停止了Orchard托管服务。
- en: The second Orchard Laboratories offering was an open source command-line tool
    called Fig, and it is this is what Docker had their eyes on when they purchased
    Orchard Laboratories. Fig, which was written in Python, let you use a YAML file
    to define how you would like your multi-container application to be structured.
    Fig took the YAML file and instructed Docker to launch the containers as defined.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Orchard Laboratories的第二个产品是一个名为Fig的开源命令行工具，当时Docker收购Orchard Laboratories时，他们正是看中了这一点。Fig是用Python编写的，它让您可以使用一个YAML文件来定义多容器应用程序的结构。Fig接收YAML文件并指示Docker按定义启动容器。
- en: 'The advantage of this was that because it was a YAML file, it was straightforward
    for developers to start shipping `fig.yml` files alongside their Dockerfiles within
    their code bases. A typical `fig.yml` file would have looked like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，因为它是一个YAML文件，对于开发人员来说，在其代码库中开始使用`fig.yml`文件与其Dockerfile一起进行部署是非常简单的。一个典型的`fig.yml`文件如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To launch the two containers defined in the `fig.yml` file, you would have
    had to have run the following command from inside the same folder where the `fig.yml`
    file was stored:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动在`fig.yml`文件中定义的两个容器，您必须在存储`fig.yml`文件的同一文件夹内运行以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may have noticed that I have been referring to Fig in the past tense, and
    that is because in February 2015, Fig became Docker Compose. In the next section
    of this chapter, we are going to be looking at launching our first Docker Compose
    application, and one of the first things you will notice is how close the syntax
    for defining the application is to the original Fig syntax.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我过去一直在提到Fig，并且这是因为在2015年2月，Fig成为了Docker Compose。在本章的下一部分，我们将看看如何启动我们的第一个Docker
    Compose应用程序，而您将首先注意到的是，定义应用程序的语法与原始Fig语法非常接近。
- en: Making our first Docker Compose application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作我们的第一个Docker Compose应用程序
- en: As part of our installation of Docker for Mac, Docker for Windows, and Docker
    on Linux in [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)*, Docker
    Overview*, we installed Docker Compose, so rather than discussing what it does
    any further, let's try to bring up the two-container application we launched manually
    at the end of the last chapter, using just Docker Compose.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装 Docker for Mac、Docker for Windows 和 Docker for Linux 的过程中，在[*第1章*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046)*《Docker
    概述》*中，我们安装了 Docker Compose，所以我们不再进一步讨论它的作用，让我们尝试仅使用 Docker Compose 来启动我们在上一章末尾手动启动的两容器应用程序。
- en: 'As already mentioned, Docker Compose uses a YAML file, typically named `docker-compose.yml`,
    to define what your multi-container application should look like. The Docker Compose
    representation of the two-container application we launched in [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)*,
    Managing Containers* is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker Compose 使用 YAML 文件，通常命名为`docker-compose.yml`，来定义你的多容器应用程序应该是什么样子。我们在[*第4章*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133)*《容器管理》*中启动的两容器应用程序的
    Docker Compose 表示如下：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even without working through each of the lines in the file, it should be quite
    straightforward to follow along with what is going on based on the commands we
    have been using throughout the previous chapters—we will be looking at the contents
    of the `docker-compose.yml` file in the next section of this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不逐行分析文件内容，基于我们在前几章中使用的命令，你应该能够很容易地跟踪正在发生的事情——我们将在本章的下一节中查看`docker-compose.yml`文件的内容。
- en: 'To launch our application, we simply change to the folder that contains your
    `docker-compose.yml` file and run the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的应用程序，我们只需切换到包含`docker-compose.yml`文件的文件夹，并运行以下命令：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see from the following Terminal output, quite a bit happened as
    Docker Compose launched our application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下终端输出中可以看到，Docker Compose 启动我们的应用程序时发生了不少事情：
- en: '![Figure 5.1 – Output of docker-compose up'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – docker-compose up 的输出'
- en: '](img/Figure_5.01_B15659.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B15659.jpg)'
- en: Figure 5.1 – Output of docker-compose up
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – docker-compose up 的输出
- en: 'You can see in the first few lines that Docker Compose did the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前几行中看到 Docker Compose 执行了以下操作：
- en: It created a volume called `mobycounter_redis_data`, using the default driver
    we defined at the end of the `docker-compose.yml` file.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为`mobycounter_redis_data`的卷，使用的是我们在`docker-compose.yml`文件末尾定义的默认驱动程序。
- en: It created a network called `mobycounter_default` using the default network
    driver—at no point did we ask Docker Compose to do this.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为`mobycounter_default`的网络，使用的是默认网络驱动程序——我们在任何时候都没有要求 Docker Compose 执行此操作。
- en: It launched two containers, one called `mobycounter_redis_1` and another called
    `mobycounter_mobycounter_1`.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启动了两个容器，一个名为`mobycounter_redis_1`，另一个名为`mobycounter_mobycounter_1`。
- en: You may have also spotted that the Docker Compose namespace in our multi-container
    application has prefixed everything with `mobycounter`—it took this name from
    the folder our Docker Compose file was being stored in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，在我们的多容器应用程序中，Docker Compose 命名空间前缀加上了`mobycounter`——它从存储我们 Docker Compose
    文件的文件夹中获取了这个名称。
- en: Once launched, Docker Compose attached to `mobycounter_redis_1` and `mobycounter_mobycounter_1`
    and streamed the output to our Terminal session. On the Terminal screen, you can
    see both `redis_1 and mobycounter_1` starting to interact with each other.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，Docker Compose 附加到`mobycounter_redis_1`和`mobycounter_mobycounter_1`并将输出流式传输到我们的终端会话。在终端屏幕上，你可以看到`redis_1`和`mobycounter_1`开始相互交互。
- en: When running Docker Compose using `docker-compose up`, it will run in the foreground.
    Pressing *Ctrl* + *C* will stop the containers and return access to your Terminal
    session.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`docker-compose up`运行 Docker Compose 时，它将在前台运行。按下*Ctrl* + *C*将停止容器并返回对终端会话的访问。
- en: Docker Compose YAML file
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose YAML 文件
- en: Before we look at using Docker Compose more, we should have a deeper dive into
    `docker-compose.yml` files as these are at the heart of Docker Compose.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步了解 Docker Compose 的使用之前，我们应该深入研究一下`docker-compose.yml`文件，因为它们是 Docker Compose
    的核心。
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '**YAML** is a recursive acronym that stands for **YAML Ain''t Markup Language**.
    It is used by many different applications for both configuration and for defining
    data in a human-readable structured data format. The indentation you see in the
    examples is very important as it helps to define the structure of the data.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML** 是一个递归首字母缩略词，代表**YAML Ain''t Markup Language**。它被许多不同的应用程序用于配置和定义结构化数据格式，且这种格式易于人类阅读。你在示例中看到的缩进非常重要，它有助于定义数据的结构。'
- en: The Moby counter application
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Moby计数器应用
- en: The `docker-compose.yml` file we used to launch our multi-container application
    is split into three separate sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来启动多容器应用的`docker-compose.yml`文件被分为三个独立的部分。
- en: 'The first section simply specifies which version of the Docker Compose definition
    language we are using; in our case, as we are running a recent version of Docker
    and Docker Compose, we are using version 3, as illustrated here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分只是指定我们使用的是哪个版本的Docker Compose定义语言；在我们的例子中，由于我们正在运行的是最新版本的Docker和Docker Compose，因此我们使用的是版本3，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As already mentioned, Docker Compose has been around since 2015, during which
    time there have been quite a few different versions of both the Docker client
    and engine. As the software has been updated to include new features, the existing
    functionality has been streamlined to make it more performant, and also, some
    functionality has been split out of the core Docker engine or removed altogether.
    Docker Compose has been maintained to remain compatible with previsions versions
    of Docker.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker Compose自2015年以来一直存在，在此期间Docker客户端和引擎经历了多个不同版本。随着软件更新以包含新特性，现有功能也进行了简化以提高性能，同时一些功能被从核心Docker引擎中拆分或完全移除。Docker
    Compose一直被维护以保持与旧版本Docker的兼容性。
- en: If the version number is not declared at the start of the `docker-compose.yml`
    file, then Docker Compose will default to version 1; this is quite close to the
    original Fig syntax, meaning that Docker Compose will not be able to read our
    `docker-compose.yml` file as containers were defined under the `services` section
    and there is no support for volumes, networks, or even build arguments—all of
    which we will cover later in the chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`docker-compose.yml`文件开头没有声明版本号，Docker Compose将默认使用版本1；这与原始的Fig语法非常接近，这意味着Docker
    Compose将无法读取我们的`docker-compose.yml`文件，因为容器是定义在`services`部分的，并且不支持卷、网络，甚至构建参数——这些我们将在本章后续部分详细介绍。
- en: 'The following screenshot shows an example of what happens if we were to remove
    the version number:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如果我们移除版本号会发生的情况：
- en: '![Figure 5.2 – Output of docker-compose up'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – docker-compose up 输出'
- en: '](img/Figure_5.02_B15659.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B15659.jpg)'
- en: Figure 5.2 – Output of docker-compose up
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – docker-compose up 输出
- en: As you can see, trying to run `docker-compose up` without the version declared
    is going to end with errors, as Docker Compose quite literally doesn't know how
    to interpret the content we have defined.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尝试在没有声明版本号的情况下运行`docker-compose up`会以错误结束，因为Docker Compose根本不知道如何解释我们定义的内容。
- en: 'The next section is where our containers are defined; this section is the `services`
    section. It takes the following format:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是我们定义容器的地方；这一部分是`services`部分。它的格式如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the `services` declaration has no indentation at all, and then
    each container has 4 spaces, with each of the options having 8 spaces; further
    options would then have 12 spaces. The number of spaces is a personal choice as
    I find it helps make it more readable—the important thing is to use spaces and
    not tabs, and make sure that your indentation is consistent throughout the file
    as this is used to clearly define blocks of information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`services`声明没有任何缩进，然后每个容器有4个空格，每个选项有8个空格；进一步的选项则使用12个空格。空格的数量是个人选择，因为我认为这样有助于提高可读性——重要的是使用空格而不是制表符，并确保文件中的缩进保持一致，因为缩进用于清晰地定义信息块。
- en: 'In our example, we defined two containers under the `services` section. In
    the following code snippet, they have been separated out to make it easy to read:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们在`services`部分下定义了两个容器。在以下代码片段中，它们被分开以便于阅读：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At first glance, the syntax for defining the service appears close to how you
    would launch a container using the `docker container run` command. I say "close"
    because although it makes perfect sense when you read the definition, it is only
    on closer inspection that you realize there is actually a lot of difference between
    the Docker Compose syntax and the `docker container run` command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，定义服务的语法与使用`docker container run`命令启动容器的方式非常相似。我说“相似”是因为，虽然当你阅读定义时它完全合理，但只有在更仔细检查时你才会发现，Docker
    Compose的语法与`docker container run`命令之间其实有很大的区别。
- en: 'For example, there are no flags for the following when running the `docker
    container run` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`docker container run`命令时，没有以下这些标志：
- en: '`image`: This tells Docker Compose which image to download and use. This does
    not exist as an option when running `docker container run` on the command line
    as you can only run a single container; as we have seen in previous chapters,
    the image is always defined toward the end of the command, without the need for
    a flag to be passed.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这告诉 Docker Compose 下载并使用哪个镜像。当使用命令行运行 `docker container run` 时，这个选项不存在，因为你只能运行一个容器；正如我们在前面的章节中看到的，镜像总是在命令的末尾定义，不需要传递标志。'
- en: '`volume`: This is the equivalent of the `--volume` flag, but it can accept
    multiple volumes. It only uses the volumes that are declared in the Docker Compose
    YAML file; more on that in a moment.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：这是 `--volume` 标志的等效项，但它可以接受多个卷。它只使用在 Docker Compose YAML 文件中声明的卷；稍后我们会详细讲解。'
- en: '`depends_on`: This would never work as a `docker container run` invocation
    because the command is only targeting a single container. When it comes to Docker
    Compose, `depends_on` is used to help build some logic into the order your containers
    are launched in—for example, only launch container B when container A has successfully
    started.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`：这在执行 `docker container run` 时是行不通的，因为该命令仅针对单个容器。对于 Docker Compose，`depends_on`
    用来帮助构建容器启动顺序的逻辑——例如，只有在容器 A 成功启动后才启动容器 B。'
- en: '`ports`: This is basically the `--publish` flag, which accepts a list of ports.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：这基本上是 `--publish` 标志，接受一个端口列表。'
- en: The only part of the command we used that has an equivalent flag when running
    `docker container run` is `restart`. This is the same as using the `--restart`
    flag and accepts the same input.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的命令中，唯一在执行 `docker container run` 时有等效标志的是 `restart`。这与使用 `--restart` 标志相同，并接受相同的输入。
- en: 'The final section of our Docker Compose YAML file is where we declare our volumes,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Docker Compose YAML 文件的最后一部分是声明我们的卷，具体如下：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the equivalent of running `docker volume create redis_data` using the
    Docker command-line client.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于使用 Docker 命令行客户端运行 `docker volume create redis_data`。
- en: Example voting application
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例投票应用程序
- en: As mentioned already, the Docker Compose file for the Moby counter application
    is quite a simple example. Let's take a look at a more complex Docker Compose
    file and see how we can introduce building containers and multiple networks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Moby 计数器应用程序的 Docker Compose 文件是一个相当简单的示例。让我们来看看一个更复杂的 Docker Compose 文件，并了解如何引入构建容器和多个网络。
- en: Important note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the repository for this book, you will find a folder in the `chapter05` directory
    called `example-voting-app`. This is a fork of the voting application from the
    official Docker sample repository.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的仓库中，你会在 `chapter05` 目录下找到一个名为 `example-voting-app` 的文件夹。这是官方 Docker 示例仓库中投票应用程序的一个分支。
- en: 'As you can see, if you were to open up the `docker-compose.yml` file, the application
    is made up of five containers, two networks, and a single volume. If we were to
    visualize the application, it would look something like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果打开 `docker-compose.yml` 文件，应用程序由五个容器、两个网络和一个卷组成。如果我们将这个应用程序可视化，它看起来大致如下：
- en: '![Figure 5.3 – Container structure for docker-compose.yml'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – docker-compose.yml 的容器结构'
- en: '](img/Figure_5.03_B15659.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B15659.jpg)'
- en: Figure 5.3 – Container structure for docker-compose.yml
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – docker-compose.yml 的容器结构
- en: 'Ignore the other files as we will look at some of these in future chapters;
    let''s walk through the `docker-compose.yml` file as there is a lot going on.
    Have a look at the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略其他文件，因为我们将在未来章节中讨论其中的一些内容；让我们通过 `docker-compose.yml` 文件，因为其中有很多内容。请查看以下代码片段：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, it starts simply enough by defining the version, and then it
    starts to list the `service`. Our first container is called vote; it is a Python
    application that allows users to submit their vote. As you can see from the following
    definition, rather than downloading an image that contains the application, we
    are actually building an image by deploying our application using `build` instead
    of the `image` definition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它首先通过定义版本开始，然后开始列出 `service`。我们的第一个容器名为 vote，它是一个 Python 应用程序，允许用户提交投票。从下面的定义可以看出，我们并不是下载一个包含应用程序的镜像，而是通过使用
    `build` 来部署我们的应用程序，取代了 `image` 定义：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `build` instruction here tells Docker Compose to build a container using
    the Dockerfile, which can be found in the `./vote` folder. The Dockerfile itself
    is quite straightforward for a Python application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`build`指令告诉Docker Compose使用位于`./vote`文件夹中的Dockerfile构建容器。Dockerfile本身对于一个Python应用程序来说相当简单。
- en: Once the container launches, we are then mounting the `./vote` folder from our
    host machine into the container, which is achieved by passing the path of the
    folder we want to mount and where within the container we would like it mounted.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器启动，我们将从主机机器中挂载`./vote`文件夹到容器中，这通过传递我们要挂载的文件夹路径以及希望它挂载到容器中的位置来实现。
- en: We are telling the container to run the `python app.py` command when the container
    launches; we are mapping port `5000` on our host machine to port `80` on the container;
    and, finally, we are further attaching two networks to the container—one called
    `front-tier` and another called `back-tier`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉容器在启动时运行`python app.py`命令；将主机机器上的`5000`端口映射到容器内的`80`端口；最后，我们还将两个网络连接到容器，一个叫`front-tier`，另一个叫`back-tier`。
- en: The `front-tier` network will have the containers that require ports to be mapped
    to the host machine; the `back-tier` network is reserved for containers that do
    not need their ports to be exposed and acts as a private, isolated network.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`front-tier`网络将包含需要映射端口到主机机器的容器；`back-tier`网络则用于那些不需要暴露端口的容器，作为一个私有的、隔离的网络。'
- en: 'Next up, we have another container that is connected to the `front-tier` network.
    This container displays the results of the vote. The `result` container contains
    a Node.js application that connects to the PostgreSQL database (which we will
    get to in a moment) and displays the results in real time as votes are cast in
    the `vote` container. As with the `vote` container, the image is built locally
    using a Dockerfile that can be found in the `./result` folder, as illustrated
    in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有另一个与`front-tier`网络连接的容器。该容器显示投票结果。`result`容器包含一个Node.js应用程序，该程序连接到PostgreSQL数据库（稍后我们会介绍），并在投票容器中的投票被提交时实时显示结果。与`vote`容器一样，该镜像是使用位于`./result`文件夹中的Dockerfile在本地构建的，如下方代码片段所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are exposing port `5001`, which is where we can connect to see the results.
    The next—and final—application container is called `worker`, as illustrated in
    the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暴露了`5001`端口，这样就可以连接到该端口以查看结果。下一个也是最后一个应用容器叫做`worker`，如以下代码片段所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `worker` container runs a .NET application whose only job is to connect
    to Redis and register each vote by transferring it into a PostgreSQL database
    running on a container called `db`. The container is again built using a Dockerfile,
    but this time, rather than passing the path to the folder where the Dockerfile
    and application are stored, we are using `context`. This sets the working directory
    for the `docker build` command and also allows you to define additional options
    such as labels and changing the name of the Dockerfile.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker`容器运行一个.NET应用程序，其唯一任务是连接到Redis并通过将投票转移到一个名为`db`的容器中的PostgreSQL数据库来注册每一票。该容器仍然是通过Dockerfile构建的，但这次我们不是传递Dockerfile和应用程序所在文件夹的路径，而是使用`context`。这会为`docker
    build`命令设置工作目录，并且还可以定义其他选项，比如标签和更改Dockerfile的名称。'
- en: As this container is doing nothing other than connecting to `redis` and the
    `db` container, it does not need any ports exposed as it has nothing connecting
    directly to it; it also does not need to communicate with either of the containers
    running on the `front-tier` network, meaning we just have to add the `back-tier`
    network.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此容器仅做连接`redis`和`db`容器的工作，因此不需要暴露任何端口，因为没有任何直接连接到它的东西；它也不需要与运行在`front-tier`网络上的容器进行通信，这意味着我们只需要添加`back-tier`网络。
- en: 'So, we now have the `vote` application, which registers the votes from the
    end users and sends them to the `redis` container, where the vote is then processed
    by the `worker` container. The service definition for the `redis` container looks
    like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了`vote`应用程序，它从最终用户那里注册投票并将其发送到`redis`容器，在那里投票会被`worker`容器处理。`redis`容器的服务定义如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This container uses the official Redis image and is not built from a Dockerfile;
    we are making sure that port `6379` is available, but only on the `back-tier`
    network. We are also specifying the name of the container, setting it to `redis`
    by using `container_name`. This is to avoid us having to make any considerations
    on the default names generated by Docker Compose within our code since, if you
    remember, Docker Compose uses the folder name to launch the containers in their
    own application namespace.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器使用官方的 Redis 镜像，并不是从 Dockerfile 构建的；我们确保端口 `6379` 可用，但仅在 `back-tier` 网络上可用。我们还指定了容器的名称，使用
    `container_name` 将其设置为 `redis`。这样可以避免我们在代码中考虑 Docker Compose 默认生成的名称，因为，正如你所记得的，Docker
    Compose 使用文件夹名称来在自己的应用程序命名空间中启动容器。
- en: 'The next—and final—container is the PostgreSQL one (which we have already mentioned),
    called `db`, as illustrated in the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个也是最后一个容器是 PostgreSQL 容器（我们之前已经提到过），名为 `db`，如下代码片段所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, it looks quite similar to the `redis` container in that we are
    using the official image; however, you may notice that we are not exposing a port,
    as this is a default option in the official image. We are also specifying the
    name of the container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它与 `redis` 容器非常相似，因为我们使用的是官方镜像；然而，你可能注意到我们没有暴露端口，因为这是官方镜像的默认选项。我们还指定了容器的名称。
- en: 'As this is where our votes will be stored, we are creating and mounting a volume
    to act as persistent storage for our PostgreSQL database, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们存储投票的地方，我们正在创建并挂载一个卷，作为 PostgreSQL 数据库的持久存储，如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, finally, here are the two networks we have been speaking about throughout
    when defining our application containers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，最后是我们在定义应用程序容器时所提到的两个网络：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running `docker-compose up` gives a lot of feedback on what is happening during
    the launch; it takes about 5 minutes to launch the application for the first time.
    If you are not following along and launching the application yourself, what follows
    is an abridged version of the launch.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker-compose up` 会输出大量关于启动过程的反馈；第一次启动应用程序大约需要 5 分钟。如果你没有跟随并自行启动应用程序，接下来是简化版的启动过程。
- en: TIP
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You may get an error that states `npm ERR! request to https://registry.npmjs.org/nodemon
    failed, reason: Hostname/IP doesn''t match certificate''s altnames`. If you do,
    then run the `echo "104.16.16.35 registry.npmjs.org" >> /etc/hosts` command as
    a user with privileges to write to the `/etc/hosts` file on your machine.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会遇到一个错误，提示 `npm ERR! request to https://registry.npmjs.org/nodemon failed,
    reason: Hostname/IP doesn''t match certificate''s altnames`。如果遇到此错误，请以有权限写入 `/etc/hosts`
    文件的用户身份运行命令 `echo "104.16.16.35 registry.npmjs.org" >> /etc/hosts`。'
- en: 'Docker Compose starts by creating the networks and getting the volume ready
    for our containers to use, as illustrated here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 首先创建网络，并为我们的容器准备好卷，如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It then builds the `vote` container image, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它构建 `vote` 容器镜像，如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that the images have been downloaded, the building of the first part of
    the application can start, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图像已经下载完毕，可以开始构建应用程序的第一部分，如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that the image has been built it will be tagged, as illustrated here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建完成后，它将被标记，如下所示：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once Docker Compose has built the `vote` image, it starts on building the `result`
    image, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker Compose 构建了 `vote` 镜像，它将开始构建 `result` 镜像，如下所示：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is followed by the PostgreSQL image for the `db` container being pulled
    down from Docker Hub, as illustrated here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随后是从 Docker Hub 拉取 `db` 容器的 PostgreSQL 镜像，如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the `worker` image is constructed, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，构建 `worker` 镜像，如下所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You may have noticed that the `Redis` image being used by the `redis` container
    was not pulled—this is because the latest version was already downloaded. Now
    that all the images have either been built or pulled down and the networking and
    volumes are in place, Docker Compose can launch our application, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，`redis` 容器使用的 `Redis` 镜像并没有被拉取——这是因为最新版本已经下载完毕。现在，所有镜像都已经构建或拉取完毕，网络和卷也已经就绪，Docker
    Compose 可以启动我们的应用程序，如下所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `result` part of the application can be accessed at `http://localhost:5001`.
    By default, there are no votes and it is split 50/50, as illustrated in the following
    screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的 `result` 部分可以通过 `http://localhost:5001` 访问。默认情况下，没有投票，且结果是 50/50，如下图所示：
- en: '![Figure 5.4 – The default voting tally'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 默认投票统计]'
- en: '](img/Figure_5.04_B15659.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B15659.jpg)'
- en: Figure 5.4 – The default voting tally
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 默认投票统计
- en: 'The `voting` part of the application can be found at http://localhost:5000,
    and is shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的 `voting` 部分可以在 http://localhost:5000 上访问，下面是该页面的截图：
- en: '![Figure 5.5 – The voting interface'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 投票界面'
- en: '](img/Figure_5.05_B15659.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.05_B15659.jpg)'
- en: Figure 5.5 – The voting interface
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 投票界面
- en: 'Clicking on either **CATS** or **DOGS** will register a vote; you should be
    able to see this logged in the Docker Compose output in your Terminal, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **CATS** 或 **DOGS** 其中一个选项将注册一票；你应该能够在终端中看到类似的 Docker Compose 输出，如下所示：
- en: '![Figure 5.6 – docker-compute output showing votes'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 显示投票的 docker-compute 输出'
- en: '](img/Figure_5.06_B15659.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.06_B15659.jpg)'
- en: Figure 5.6 – docker-compute output showing votes
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 显示投票的 docker-compute 输出
- en: 'There are a few errors, as the Redis table structure is only created when the
    vote application registers the first vote; once a vote has been cast, the Redis
    table structure will be created and the `worker` container will take that vote
    and process it by writing to the `db` container. Once the vote has been cast,
    the `result` container will update in real time, as illustrated in the following
    screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些错误，因为 Redis 表结构只有在投票应用注册第一票时才会创建；一旦投票完成，Redis 表结构将被创建，`worker` 容器将处理这票并写入
    `db` 容器。投票完成后，`result` 容器将实时更新，如下图所示：
- en: '![Figure 5.7 – Vote result page after vote was cast'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 投票后结果页面'
- en: '](img/Figure_5.07_B15659.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.07_B15659.jpg)'
- en: Figure 5.7 – Vote result page after vote was cast
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 投票后结果页面
- en: We will be looking at the Docker Compose YAML files again in the upcoming chapters,
    when we look at launching both Docker Swarm stacks and Kubernetes clusters. For
    now, let's get back to Docker Compose and look at some of the commands we can
    run.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将再次查看 Docker Compose YAML 文件，当我们讨论如何启动 Docker Swarm 堆栈和 Kubernetes
    集群时。现在，让我们回到 Docker Compose，看看我们可以运行的一些命令。
- en: Exploring Docker Compose commands
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Docker Compose 命令
- en: 'We are over halfway through the chapter, and the only Docker Compose command
    we have run is `docker-compose up`. If you have been following along and you run
    `docker container ls -a`, you will see something similar to the following Terminal
    screen:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了本章的一半，至今为止我们执行的唯一 Docker Compose 命令是`docker-compose up`。如果你一直在跟着操作并运行`docker
    container ls -a`，你会看到类似以下终端画面的内容：
- en: '![Figure 5.8 – Output for docker container ls -a'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 执行 docker container ls -a 的输出'
- en: '](img/Figure_5.08_B15659.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.08_B15659.jpg)'
- en: Figure 5.8 – Output for docker container ls -a
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 执行 docker container ls -a 的输出
- en: As you can see, we have a lot of containers with the status of `Exited`. This
    is because when we used *Ctrl* + *C* to return to our Terminal, the Docker Compose
    containers were stopped.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有很多容器的状态是 `Exited`。这是因为当我们按下 *Ctrl* + *C* 返回到终端时，Docker Compose 容器被停止了。
- en: Choose one of the Docker Compose applications and change to the folder that
    contains the `docker-compose.yml` file, and we will work through some more Docker
    Compose commands. I will be using the **Example Vote** application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个 Docker Compose 应用，切换到包含 `docker-compose.yml` 文件的文件夹，我们将继续操作更多的 Docker Compose
    命令。我将使用 **Example Vote** 应用。
- en: up and ps
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: up 和 ps
- en: 'The first command is `docker-compose up`, but this time, we will be adding
    a flag. In your chosen application folder, run the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令是 `docker-compose up`，但这次我们将添加一个标志。在你选择的应用文件夹中，运行以下命令：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will start your application back up, this time in detached mode, which
    will return you to your Terminal prompt, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新启动你的应用，这次是以分离模式运行，它会将你带回终端提示符，如下所示：
- en: '![Figure 5.9 – Output for docker-compose up -d'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – 执行 docker-compose up -d 的输出'
- en: '](img/Figure_5.09_B15659.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.09_B15659.jpg)'
- en: Figure 5.9 – Output for docker-compose up -d
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 执行 docker-compose up -d 的输出
- en: 'Once control of your Terminal is returned to you, you should be able to check
    that the containers are running, using the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦终端控制权返回，你应该能够使用以下命令检查容器是否在运行：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see from the following Terminal output, all of the containers have
    the state of `Up`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如下终端输出所示，你会看到所有容器的状态都是 `Up`：
- en: '![Figure 5.10 – Output for docker-compose ps'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 执行 docker-compose ps 的输出'
- en: '](img/Figure_5.10_B15659.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B15659.jpg)'
- en: Figure 5.10 – Output for docker-compose ps
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 执行 docker-compose ps 的输出
- en: When running these commands, Docker Compose will only be aware of the containers
    defined in the `services` section of your `docker-compose.yml` file; all other
    containers will be ignored as they don't belong to our service stack.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这些命令时，Docker Compose 只会识别在 `docker-compose.yml` 文件的 `services` 部分中定义的容器；所有其他容器将被忽略，因为它们不属于我们的服务堆栈。
- en: config
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: config
- en: 'Running the following command will validate our `docker-compose.yml` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将验证我们的 `docker-compose.yml` 文件：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If there are no issues, it will print a rendered copy of your Docker Compose
    YAML file to screen; this is how Docker Compose will interpret your file. If you
    don''t want to see this output and just want to check for errors, then you can
    run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有问题，它将打印出 Docker Compose 解释您文件的渲染副本。如果您不想查看这个输出，只想检查是否有错误，那么您可以运行以下命令：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is shorthand for `--quiet`. If there are any errors (which the examples
    we have worked through so far shouldn''t have), they will be displayed as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `--quiet` 的简写。如果有任何错误（根据我们迄今为止的示例，应该没有），它们将如下所示：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: pull, build, and create
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pull、build 和 create
- en: 'The next two commands will help you prepare to launch your Docker Compose application.
    The following command will read your Docker Compose YAML file and pull any of
    the images it finds:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个命令将帮助您准备启动 Docker Compose 应用程序。以下命令将读取 Docker Compose YAML 文件并拉取它找到的任何镜像：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following command will execute any build instructions it finds in your
    file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将执行文件中找到的任何构建指令：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These commands are useful when you are first defining your Docker Compose-powered
    application and want to test it without launching your application. The `docker-compose
    build` command can also be used to trigger a build if there are updates to any
    of the Dockerfiles used to originally build your images.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次定义基于 Docker Compose 的应用程序并希望在不启动应用程序的情况下进行测试时，这些命令非常有用。`docker-compose
    build` 命令也可以用来触发构建，如果用于最初构建镜像的任何 Dockerfile 有更新的话。
- en: 'The `pull` and `build` commands only generate/pull the images needed for our
    application; they do not configure the containers themselves. For this, we need
    to use the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`pull` 和 `build` 命令只生成/拉取我们应用程序所需的镜像；它们不会配置容器本身。为此，我们需要使用以下命令：'
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will create but not launch the containers. As with the `docker container
    create` command, they will have an `Exited` state until you start them. The `create`
    command has a few useful flags you can pass, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建容器，但不会启动它们。与 `docker container create` 命令一样，容器将处于 `Exited` 状态，直到您启动它们。`create`
    命令有一些有用的标志可以传递，具体如下：
- en: '`--force-recreate`: This recreates the container even if there is no need to,
    as nothing within the configuration has changed.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force-recreate`：即使配置中没有变化，也会重新创建容器。'
- en: '`--no-recreate`: This doesn''t recreate a container if it already exists; this
    flag cannot be used with the preceding flag.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-recreate`：如果容器已经存在，它不会重新创建该容器；此标志不能与前面的标志一起使用。'
- en: '`--no-build`: This doesn''t build the images, even if an image that needs to
    be built is missing.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-build`：即使缺少需要构建的镜像，也不会构建镜像。'
- en: '`--build`: This builds the images before creating the containers.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build`：在创建容器之前构建镜像。'
- en: start, stop, restart, pause, and unpause
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: start、stop、restart、pause 和 unpause
- en: 'The following commands work in exactly the same way as their `docker container`
    counterparts, the only difference being that they effect change on all of the
    containers:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令的工作方式与其 `docker container` 对应命令完全相同，唯一的区别是它们对所有容器产生影响：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is possible to target a single service by passing its name; for example,
    to pause and unpause the `db` service, we would run the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递服务名称来定位单个服务；例如，要暂停和恢复 `db` 服务，我们可以运行以下命令：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we know how to stop and start all or part of our Docker Compose application,
    we can look at how we can see some more information on our application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何停止和启动整个或部分的 Docker Compose 应用程序，我们可以看看如何查看应用程序的更多信息。
- en: top, logs, events, exec, and run
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: top、logs、events、exec 和 run
- en: The next three commands all give us feedback on what is happening within our
    running containers and Docker Compose.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个命令都为我们提供有关正在运行的容器和 Docker Compose 的反馈信息。
- en: 'The following command, as with its `docker container` counterpart, displays
    information on the processes running within each of our Docker Compose-launched
    containers:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令，与其 `docker container` 对应命令一样，显示每个 Docker Compose 启动的容器内正在运行的进程信息：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see from the following Terminal output, each container is split
    into its own section:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，从终端输出中可以看到，每个容器被拆分到自己的区域：
- en: '![Figure 5.11 – Output for docker-compose top'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – docker-compose top 的输出'
- en: '](img/Figure_5.11_B15659.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B15659.jpg)'
- en: Figure 5.11 – Output for docker-compose top
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – docker-compose top 的输出
- en: 'If you would just like to see one of the services, you simply have to pass
    its name when running the command, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想查看其中一个服务，只需在运行命令时传递其名称，如下所示：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following command streams the logs from each of the running containers
    to screen:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令会将每个正在运行的容器的日志流式传输到屏幕：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As with the `docker container` command, you can pass flags such as `-f` or
    `--follow` to keep the stream flowing until you press *Ctrl* + *C*. Also, you
    can stream the logs for a single service by appending its name to the end of your
    command, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `docker container` 命令一样，您可以传递诸如 `-f` 或 `--follow` 的标志，保持流式传输直到按下 *Ctrl* +
    *C*。此外，您还可以通过将服务的名称附加到命令末尾，来流式传输单个服务的日志，如下所示：
- en: '![Figure 5.12 – Log stream'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 日志流'
- en: '](img/Figure_5.12_B15659.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B15659.jpg)'
- en: Figure 5.12 – Log stream
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 日志流
- en: 'The `events` command again works like the `docker container` equivalent; it
    streams events—such as the ones triggered by the other commands we have been discussing—in
    real time. For example, run this command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`events` 命令再次类似于 `docker container` 命令的功能；它实时流式传输事件——例如我们之前讨论的其他命令触发的事件。比如，运行以下命令：'
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running `docker-compose pause` in a second Terminal window gives the following
    output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个终端窗口中运行 `docker-compose pause`，将给出以下输出：
- en: '![Figure 5.13 – Output for docker-compose events'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13 – docker-compose events 的输出'
- en: '](img/Figure_5.13_B15659.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B15659.jpg)'
- en: Figure 5.13 – Output for docker-compose events
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – docker-compose events 的输出
- en: 'These two commands run similarly to their `docker container` equivalents. Run
    the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令的运行方式与其 `docker container` 等效命令类似。运行以下命令：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will launch a new process in the already running worker container and
    ping the `db` container three times, as seen here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在已经运行的 worker 容器中启动一个新进程，并向 `db` 容器发送三次 ping 请求，如下所示：
- en: '![Figure 5.14 – Output for docker-compose exec worker ping -c 3 db'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14 – docker-compose exec worker ping -c 3 db 的输出'
- en: '](img/Figure_5.14_B15659.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.14_B15659.jpg)'
- en: Figure 5.14 – Output for docker-compose exec worker ping -c 3 db
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – docker-compose exec worker ping -c 3 db 的输出
- en: 'The `run` command is useful if you need to run a containerized command as a
    one-off within your application. For example, if you use a package manager such
    as `composer` to update the dependencies of your project that is stored on a volume,
    you could run something like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 命令非常有用，如果您需要在应用程序中作为一次性任务运行一个容器化的命令。例如，如果您使用像 `composer` 这样的包管理器来更新存储在卷中的项目依赖关系，您可以运行如下命令：'
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This would run the `composer` container with the `install` command and mount
    the `data_volume` at the following path `/app` within the container.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 `composer` 容器，并使用 `install` 命令，并在容器内的 `/app` 路径挂载 `data_volume`。
- en: scale
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: scale
- en: 'The `scale` command will take the service you pass to the command and scale
    it to the number you define. For example, to add more `worker` containers, I just
    need to run the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale` 命令将接收您传递给命令的服务，并将其扩展到您定义的数量。例如，要添加更多的 `worker` 容器，我只需要运行以下命令：'
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, this actually gives the following warning:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这实际上会给出以下警告：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What we should now be using is the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该使用的是以下命令：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: While the `scale` command is in the current version of Docker Compose, it will
    be removed from future versions of the software.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `scale` 命令在当前版本的 Docker Compose 中可用，但它将在未来的版本中被移除。
- en: 'You will notice that I chose to scale the number of `worker` containers. There
    is a good reason for this, as you will see for yourself if you try running the
    following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我选择了扩展 `worker` 容器的数量。这是有原因的，如果您尝试运行以下命令，您将亲眼看到：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will notice that while Docker Compose creates the additional two containers,
    they fail to start, with the following error:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，尽管 Docker Compose 创建了另外两个容器，但它们未能启动，并出现以下错误：
- en: '![Figure 5.15 – Output for docker-compose up -d --scale vote=3'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15 – docker-compose up -d --scale vote=3 的输出'
- en: '](img/Figure_5.15_B15659.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B15659.jpg)'
- en: Figure 5.15 – Output for docker-compose up -d --scale vote=3
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – docker-compose up -d --scale vote=3 的输出
- en: That is because we cannot have three individual containers all trying to map
    to the same port on the host machine; because of this, you should always use the
    `scale` command on containers where you haven't explicitly defined a port mapping.kill,
    rm, and down
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们不能让三个独立的容器都尝试映射到主机上的相同端口；因此，你应该始终在未显式定义端口映射的容器上使用`scale`命令。
- en: 'The three Docker Compose commands we are going to look at last are the ones
    that remove/terminate our Docker Compose application. The first command stops
    our running containers by immediately stopping running container processes. This
    is the `kill` command, as illustrated here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要介绍的三个Docker Compose命令是删除/终止Docker Compose应用的命令。第一个命令通过立即停止正在运行的容器进程来停止我们的运行中的容器。这个命令是`kill`，如下面所示：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Be careful when running this as it does not wait for containers to gracefully
    stop, such as when running `docker-compose stop`, meaning that using the `docker-compose
    kill` command may result in data loss.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时请小心，因为它不会等待容器优雅地停止，例如在运行`docker-compose stop`时，这意味着使用`docker-compose kill`命令可能会导致数据丢失。
- en: 'Next up is the `rm` command; this removes any containers with the state of
    `exited`, and is shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`rm`命令；这个命令会删除状态为`exited`的容器，具体如下面所示：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we have the `down` command. This, as you might have already guessed,
    has the opposite effect of running `docker-compose up`, and is shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`down`命令。正如你可能已经猜到的，它与运行`docker-compose up`的效果相反，如下所示：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That will remove the containers and the networks created when running `docker-compose
    up`. If you want to remove everything, you can do so by running the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会删除在运行`docker-compose up`时创建的容器和网络。如果你想删除所有内容，可以通过运行以下命令来实现：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will remove all of the containers, networks, volumes, and images (both
    pulled and built) when you ran the `docker-compose up` command; this includes
    images that may be in use outside of your Docker Compose application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将删除你在运行`docker-compose up`命令时创建的所有容器、网络、卷和镜像（包括拉取和构建的镜像）；这包括可能在你的Docker Compose应用外部使用的镜像。
- en: 'There will, however, be an error if the images are in use, and those images
    will not be removed, as illustrated in the following screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果镜像正在使用中，将会出现错误，并且这些镜像不会被删除，如下图所示：
- en: '![Figure 5.16 – Output of docker-compose down --rmi all --volumes'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – `docker-compose down --rmi all --volumes`的输出'
- en: '](img/Figure_5.16_B15659.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B15659.jpg)'
- en: Figure 5.16 – Output of docker-compose down --rmi all --volumes
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – `docker-compose down --rmi all --volumes`的输出
- en: As you can see from the preceding output, there is a container using the `redis`
    image, the Moby counter application, so it was not removed. However, all other
    images used by the `Example Vote` application are removed, both the ones built
    as part of the initial `docker- compose up` command and the ones downloaded from
    Docker Hub.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，有一个使用`redis`镜像的容器，即Moby计数器应用，因此它没有被删除。然而，`Example Vote`应用使用的所有其他镜像都被删除了，包括通过初始的`docker-compose
    up`命令构建的镜像和从Docker Hub下载的镜像。
- en: Using Docker App
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker App
- en: 'Before we start this section, I should issue the following warning:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，我需要发出以下警告：
- en: Important note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The feature we are going to discuss is very much an experimental one. It is
    in its very early stages of development and should not be considered any more
    than a preview of an upcoming feature.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的这个功能非常实验性。它处于开发的初期阶段，不能被视为一个成熟的功能，而只能视为即将发布的功能的预览。
- en: Because of its experimental nature, I am only going to cover the usage of Docker
    App on macOS. However, before we enable it, let's discuss what exactly is meant
    by a Docker app. While Docker Compose files are really useful when it comes to
    sharing your environment with others, you may have noticed that there is one quite
    crucial element we have been missing so far in this chapter, and that is the ability
    to actually distribute your Docker Compose files in a similar way to how you can
    distribute your Docker images.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其实验性质，我只会介绍在macOS上使用Docker App。然而，在启用它之前，我们先来讨论什么是Docker应用。虽然Docker Compose文件在与他人共享环境时非常有用，但你可能已经注意到，在本章中有一个非常关键的元素我们至今还没有提到，那就是能够像分发Docker镜像一样分发你的Docker
    Compose文件的能力。
- en: Docker has acknowledged this and is currently working on a new feature called
    Docker App, which it hopes will fill this gap.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Docker已经意识到这个问题，并且目前正在开发一个名为Docker App的新功能，希望它能填补这个空白。
- en: 'Docker App is currently a command-line client plugin that helps you to create
    an application bundle that can be shared via Docker Hub or a Docker Enterprise
    Registry. The plugin is built in to Docker 19.03, and all you have to do is open
    the Docker desktop **Settings** and toggle on **Enable experimental features**,
    as illustrated in the following screenshot:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Docker App 当前是一个命令行客户端插件，可以帮助你创建可以通过 Docker Hub 或 Docker 企业注册表共享的应用程序包。该插件内置于
    Docker 19.03 中，你只需打开 Docker Desktop **设置**并切换开启 **启用实验性功能**，如下所示的屏幕截图：
- en: '![Figure 5.17 – Docker desktop Enable experimental features screen'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – Docker desktop 启用实验性功能屏幕'
- en: '](img/Figure_5.17_B15659.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.17_B15659.jpg)'
- en: Figure 5.17 – Docker desktop Enable experimental features screen
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – Docker desktop 启用实验性功能屏幕
- en: We are going to be using the Moby Counter application as its `docker-compose.yml`
    file already meets the pre-requisites for a Docker App bundle, as we are using
    a version of 3.6 and higher—3.7, in our case.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Moby Counter 应用程序，因为它的`docker-compose.yml`文件已经满足 Docker App 打包的前提要求，且我们正在使用
    3.6 及以上版本——在我们这个例子中是 3.7。
- en: Defining the application
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序
- en: 'Let''s begin by following these steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'We need to create our Docker App configuration. To do this, change to the `mobycounter`
    folder and run the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建 Docker App 配置。为此，请切换到 `mobycounter` 文件夹并运行以下命令：
- en: '[PRE50]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Version of the application
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的版本
- en: 'version: 0.1.0'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本：0.1.0
- en: Name of the application
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的名称
- en: 'name: mobycounterapp'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称：mobycounterapp
- en: A short description of the application
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的简短描述
- en: 'description:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 描述：
- en: List of application maintainers with name and email for each
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含每个维护者的姓名和邮箱的应用程序维护者列表
- en: 'maintainers:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 维护者：
- en: '- name: russ.mckendrick'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：russ.mckendrick'
- en: 'email:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 邮箱：
- en: '[PRE51]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s start by updating the `metadata.yml` file. I updated mine to read as
    follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从更新 `metadata.yml` 文件开始。我将我的更新为如下内容：
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding information will be used when we distribute the application. Initially,
    this will be via the Docker Hub, so please make sure that you are happy for the
    information to be accessible to other people.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述信息将用于我们分发应用程序。最初，我们将通过 Docker Hub 进行分发，因此请确保你同意这些信息对其他人可见。
- en: 'Now that we have our metadata, let''s add some parameters to the `parameters.yml`
    file, as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了元数据，接下来在 `parameters.yml` 文件中添加一些参数，如下所示：
- en: '[PRE53]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, update the `docker-compose.yml` file to make use of the parameters
    we have just defined, as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新 `docker-compose.yml` 文件，使用我们刚刚定义的参数，如下所示：
- en: '[PRE54]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, I have added `${port}` to the `docker-compose.yml` file. When
    we launch the application, the values will be populated from the `parameters.yml`
    file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我已将`${port}`添加到`docker-compose.yml`文件中。当我们启动应用程序时，值将从`parameters.yml`文件中填充。
- en: Validating and inspecting the application
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证和检查应用程序
- en: 'We can double-check that everything we have changed is OK by running the following
    commands:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来双重检查我们所做的更改是否正确：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If everything is OK, this should display something that looks like the following
    Terminal output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，终端输出应类似如下内容：
- en: '![Figure 5.19 – Output for docker app inspect mobycounterapp.dockerapp'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – docker app inspect mobycounterapp.dockerapp 输出'
- en: '](img/Figure_5.19_B15659.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.19_B15659.jpg)'
- en: Figure 5.19 – Output for docker app inspect mobycounterapp.dockerapp
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – docker app inspect mobycounterapp.dockerapp 输出
- en: Once we've validated the app, we can finally move on to launching it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了应用程序，就可以继续启动它了。
- en: Launching the app
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: 'For us to be able to launch the application natively, we need to be running
    a Docker Swarm cluster (we will be covering Docker Swarm in more detail in a future
    chapter). To achieve this, proceed as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够原生启动应用程序，我们需要运行一个 Docker Swarm 集群（我们将在未来的章节中详细讲解 Docker Swarm）。实现这一目标的步骤如下：
- en: 'Begin by running the following command:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始时运行以下命令：
- en: '[PRE56]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Ignore the output for now—we won't be creating a cluster just yet and only need
    a single node.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 暂时忽略输出——我们现在不需要创建集群，只需一个节点即可。
- en: 'Now that we have Docker Swarm enabled, we can install the application using
    the following command:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经启用了 Docker Swarm，现在可以使用以下命令安装应用程序：
- en: '[PRE57]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once installed, you can run the following command to check the status of the
    application:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，你可以运行以下命令来检查应用程序的状态：
- en: '[PRE58]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should see something like the following Terminal output:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似下面的终端输出：
- en: '![Figure 5.20 – Output for docker app install and docker app list'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.20 – docker app install 和 docker app list 输出'
- en: '](img/Figure_5.20_B15659.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.20_B15659.jpg)'
- en: Figure 5.20 – Output for docker app install and docker app list
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – docker app install和docker app list的输出
- en: The application should also be accessible on `http://localhost:8080`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序也应该可以通过`http://localhost:8080`访问。
- en: Pushing to Docker Hub
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送到Docker Hub
- en: 'While our application is running, we can publish it to the Docker Hub. To do
    this, proceed as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序运行时，我们可以将它发布到Docker Hub。为此，请按以下步骤操作：
- en: 'If you haven''t done so already, log in by running the following command:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有登录，请通过运行以下命令进行登录：
- en: '[PRE59]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Once logged in, run the following command, making sure that you update the
    Docker Hub ID (which is russmckendrick in my case) with your own:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，运行以下命令，确保更新Docker Hub ID（在我的情况下是russmckendrick），用你自己的ID替换：
- en: '[PRE60]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After a minute, you should see a message that the bundle has been successfully
    pushed, as illustrated in the following screenshot:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一分钟后，你应该会看到一条消息，提示包已成功推送，如下图所示：
- en: '![Figure 5.21 – hub.docker.com page'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.21 – hub.docker.com页面'
- en: '](img/Figure_5.21_B15659.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.21_B15659.jpg)'
- en: Figure 5.21 – hub.docker.com page
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 – hub.docker.com页面
- en: Opening https://hub.docker.com/ in your browser should show that the application
    is there, as seen in *Figure 5.21*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开https://hub.docker.com/应该会显示该应用程序，正如*图5.21*所示。
- en: Installing from Docker Hub
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Docker Hub安装
- en: 'First of all, let''s create a temporary folder and uninstall the application,
    as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个临时文件夹并卸载应用程序，如下所示：
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see from the output if you are following along, we don't have any
    applications running, and we have changed folders away from our original `docker-compose.yml`
    file and also the `mobycounterapp.dockerapp` folder, so we know that neither of
    them will be used.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果你正在跟随步骤进行操作，我们没有运行任何应用程序，而且我们已经改变了文件夹位置，远离了原来的`docker-compose.yml`文件和`mobycounterapp.dockerapp`文件夹，所以我们知道它们都不会被使用。
- en: 'Next, we can inspect the application directly from Docker Hub by running the
    following command (again, make sure to replace the Docker Hub ID with your own):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过运行以下命令直接从Docker Hub检查应用程序（再次，确保将Docker Hub ID替换为你自己的）：
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We should see information on our application similar to that shown when we
    last ran the command locally. First up, let''s create a new `docker-compose.yml`
    file using the Docker Hub-hosted version of the application. To do this, run the
    following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到与我们上次本地运行命令时相似的应用程序信息。首先，让我们使用Docker Hub托管版本的应用程序创建一个新的`docker-compose.yml`文件。为此，请运行以下命令：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will create a `docker-compose.yml` file in the current working folder;
    from there, we can then run the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在当前工作目录下创建一个`docker-compose.yml`文件；然后，我们可以运行以下命令：
- en: '[PRE64]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You will get a warning that the node is `running Swarm` mode; again, ignore
    this for now. You should see the two containers running, and your application
    will again be accessible at `http://localhost:8080`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你会收到一个警告，提示节点正在`运行Swarm`模式；目前可以忽略此警告。你应该能看到两个容器正在运行，并且你的应用程序再次可以通过`http://localhost:8080`访问。
- en: 'Next, let''s launch the application again natively, but this time alongside
    our Docker Compose-launched version. To do this, run the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重新本地启动应用程序，但这次是和我们通过Docker Compose启动的版本一起运行。为此，请运行以下命令：
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, we are launching an application named `mobycounterapp8181`.
    We are also using the `--set` command to override the default port of `8080`,
    which we originally set in the `parameters.yml` file, and changing it to `8181`.
    If everything went as planned, you should be able to access the application at
    `http://localhost:8181`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在启动一个名为`mobycounterapp8181`的应用程序。我们还使用了`--set`命令来覆盖我们在`parameters.yml`文件中最初设置的默认端口`8080`，将其更改为`8181`。如果一切顺利，你应该能够通过`http://localhost:8181`访问该应用程序。
- en: There is more functionality within Docker App. However, we are not quite ready
    to go into further details. We will return to Docker App in [*Chapter 8*](B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230)*,
    Docker Swarm* and [*Chapter 11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*,
    Docker and Kubernetes*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Docker App有更多功能。然而，我们还不准备深入探讨这些功能。我们将在[*第8章*](B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230)*,
    Docker Swarm* 和 [*第11章*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*, Docker和Kubernetes*中进一步介绍。
- en: As mentioned at the top of this section, this feature is still in active development,
    and it is possible that the commands and functionality we have discussed so far
    may change in the future. But even at this development stage, I hope you can see
    the advantages of Docker App and how it is building on the solid foundations laid
    by Docker Compose.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节顶部所提到的，这个功能仍在积极开发中，至今我们讨论的命令和功能可能会在未来有所变化。但即使在这个开发阶段，我希望你能看到Docker App的优势，以及它是如何建立在Docker
    Compose打下的坚实基础上的。
- en: Summary
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you have enjoyed this chapter on Docker Compose, and I hope that, like
    I did, you can see that it has evolved from being an incredibly useful third-party
    tool to an extremely important part of the core Docker experience.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢这一章关于Docker Compose的内容，我也希望像我一样，你能看到它是如何从一个极其有用的第三方工具，发展成为Docker核心体验中一个极其重要的部分。
- en: Docker Compose introduces some key concepts as to how you should approach running
    and managing your containers. We will be taking these concepts one step further
    in [*Chapter 8*](B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230)*, Docker Swarm*
    and [*Chapter 11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*, Docker and
    Kubernetes*, where we start to look at managing multiple Docker hosts and how
    we can distribute containers across them.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose介绍了一些关键概念，帮助你理解如何运行和管理容器。我们将在[*第8章*](B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230)*，Docker
    Swarm*和[*第11章*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*，Docker与Kubernetes*中进一步探讨这些概念，在这些章节中，我们将开始讨论如何管理多个Docker主机以及如何将容器分布到这些主机上。
- en: In the next chapter, we are going to move away from Linux-based containers and
    take a whistle-stop tour of Windows containers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将不再讨论基于Linux的容器，而是快速浏览一下Windows容器。
- en: Questions
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Docker Compose files use which open source format?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose文件使用哪种开源格式？
- en: In our initial Moby counter Docker Compose file, which was the only flag that
    works exactly the same as its Docker **command-line interface** (**CLI**) counterpart?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们最初的Moby反向Docker Compose文件中，哪一个标志的工作方式与Docker的**命令行接口**（**CLI**）完全相同？
- en: 'True or false: You can only use images from the Docker Hub with your Docker
    Compose files.'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对与错：你只能使用来自Docker Hub的镜像来搭建Docker Compose文件吗？
- en: By default, how does Docker Compose decide on the namespace to use?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Docker Compose如何决定使用哪个命名空间？
- en: Which flag do you add to docker-compose up to start the containers in the background?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使容器在后台启动，你需要在docker-compose up命令中添加哪个标志？
- en: What is the best way to run a syntax check on your Docker Compose files?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Docker Compose文件时，检查语法的最佳方法是什么？
- en: Explain the basic principle about how Docker App works.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释Docker App如何工作的基本原理。
- en: Further reading
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For details on Orchard Laboratories, see the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Orchard Laboratories的详细信息，请参见以下内容：
- en: 'Orchard Laboratories website: [https://web.archive.org/web/20171020135129/https://www.orchardup.com/](https://web.archive.org/web/20171020135129/https://www.orchardup.com/)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Orchard Laboratories官网：[https://web.archive.org/web/20171020135129/https://www.orchardup.com/](https://web.archive.org/web/20171020135129/https://www.orchardup.com/)
- en: 'Orchard Laboratories joins Docker: [https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/](https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Orchard Laboratories加入Docker：[https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/](https://www.docker.com/blog/welcoming-the-orchard-and-fig-team/)
- en: 'For a full Docker Compose compatibility matrix, see the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的Docker Compose兼容性矩阵，请参见以下内容：
- en: 'Compose file versions and upgrading: [https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compose文件版本和升级：[https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/)
- en: 'For more information on the Docker App project, see the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker App项目的更多信息，请参见以下内容：
- en: 'GitHub repository: [http://github.com/docker/app/](http://github.com/docker/app/)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub仓库：[http://github.com/docker/app/](http://github.com/docker/app/)
- en: 'Finally, here are some further links to a number of other topics that we have
    covered:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是我们所涵盖的其他主题的一些进一步链接：
- en: 'YAML project home page: [http://www.yaml.org/](http://www.yaml.org/)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML项目主页：[http://www.yaml.org/](http://www.yaml.org/)
- en: 'Docker sample repository: [https://github.com/dockersamples/](https://github.com/dockersamples/)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker示例仓库：[https://github.com/dockersamples/](https://github.com/dockersamples/)
