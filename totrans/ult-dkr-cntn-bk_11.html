<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-237"><a id="_idTextAnchor237"/>11</h1>
<h1 id="_idParaDest-238"><a id="_idTextAnchor238"/>Managing Containers with Docker Compose</h1>
<p>In the previous chapter, we learned a lot about how container networking works on a single Docker host. We introduced<a id="_idIndexMarker916"/> the <strong class="bold">Container Network Model</strong> (<strong class="bold">CNM</strong>), which forms the basis of all networking between Docker containers, and then we dove deep into different implementations of the CNM, specifically the bridge network. Finally, we introduced Traefik, a reverse proxy to enable sophisticated HTTP application-level routing between containers.</p>
<p>This chapter introduces the concept of an application consisting of multiple services, each running in a container, and how Docker Compose allows us to easily build, run, and scale such an application using a declarative approach.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Demystifying declarative versus imperative orchestration of containers</li>
<li>Running a multi-service application</li>
<li>Building images with Docker Compose</li>
<li>Running an application with Docker Compose</li>
<li>Scaling a service</li>
<li>Building and pushing an application</li>
<li>Using Docker Compose overrides</li>
</ul>
<p>After completing this chapter, you will be able to do the following:</p>
<ul>
<li>Explain, in a few short sentences, the main differences between an imperative and declarative approach for defining and running an application</li>
<li>Describe, in your own words, the difference between a container and a Docker Compose service</li>
<li>Author a Docker Compose YAML file for a simple multi-service application</li>
<li>Build, push, deploy, and tear down a simple multi-service application using Docker Compose</li>
<li>Use Docker Compose to scale an application service up and down</li>
<li>Define environment-specific Docker Compose files using overrides</li>
</ul>
<h1 id="_idParaDest-239"><a id="_idTextAnchor239"/>Technical requirements</h1>
<p>The code accompanying this chapter can be found at <a href="https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11">https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11</a>.</p>
<p>Before we start, let’s make sure we have a folder ready for the code you are going to implement in this chapter:</p>
<ol>
<li>Navigate to the folder in which you cloned the previously listed code repository accompanying this book. Normally, this is the <code>The-Ultimate-Docker-Container-Book</code> folder in your home folder:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book</pre></li> <li>Create a subfolder called <code>ch11</code> and navigate to it:<pre class="source-code">
$ mkdir ch11 &amp;&amp; cd ch11</pre></li> </ol>
<p>In the past, you needed to have a separate docker-compose tool installed on your system. This is not the case anymore as the Docker CLI has recently been extended such that it contains all the functionality and more than the docker-compose tool previously offered.</p>
<p>If you are curious, you can find detailed installation instructions for the old <code>docker-compose</code> tool here: <a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a>.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor240"/>Demystifying declarative versus imperative orchestration of containers</h1>
<p>Docker Compose <a id="_idIndexMarker917"/>is a tool <a id="_idIndexMarker918"/>provided by Docker that is mainly used when you need to run and orchestrate containers running on a single Docker host. This includes, but is not limited to, development, <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>), automated <a id="_idIndexMarker919"/>testing, manual QA, or demos. Since very recently, Docker Compose is embedded in the normal Docker CLI.</p>
<p>Docker Compose uses files formatted in YAML as input. By default, Docker Compose expects these files to be called <code>docker-compose.yml</code>, but other names are possible. The content of a <code>docker-compose.yml</code> file is said to be a declarative way of describing and running a containerized application potentially consisting of more than a single container.</p>
<p><em class="italic">So, what is the meaning </em><em class="italic">of declarative?</em></p>
<p>First of all, declarative is the antonym of imperative. Well, that doesn’t help much. Now that I have introduced another definition, I need to explain both:</p>
<ul>
<li><strong class="bold">Imperative</strong>: This is a way in<a id="_idIndexMarker920"/> which we can solve problems by specifying the exact procedure that has to be followed by the system.</li>
</ul>
<p>If I tell a system, such as the Docker daemon, imperatively how to run an application, then that means that I must describe, step by step, what the system has to do and how it must react if some unexpected situation occurs. I must be very explicit and precise in my instructions. I need to cover all edge cases and how they need to be treated.</p>
<ul>
<li><strong class="bold">Declarative</strong>: This is a way<a id="_idIndexMarker921"/> in which we can solve problems without requiring the programmer to specify an exact procedure to be followed.</li>
</ul>
<p>A declarative approach means that I tell the Docker engine what my desired state for an application is and it has to figure out on its own how to achieve this desired state and how to reconcile it if the system deviates from it.</p>
<p>Docker clearly recommends the declarative approach when dealing with containerized applications. Consequently, the <a id="_idIndexMarker922"/>Docker <a id="_idIndexMarker923"/>Compose tool uses this approach.</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor241"/>Running a multi-service app</h1>
<p>In most cases, applications <a id="_idIndexMarker924"/>do not consist of only one monolithic block, but rather of several application services that work together. When using Docker containers, each application service runs in its own container. When we want to run such a multi-service application, we can, of course, start all the participating containers with the well-known <code>docker container run</code> command, and we have done this in previous chapters. But this is inefficient at best. With the Docker Compose tool, we are given a way to define the application in a declarative way in a file that uses the YAML format.</p>
<p>Let’s create and analyze a simple <code>docker-compose.yml</code> file:</p>
<ol>
<li>Inside the chapter’s folder (<code>ch11</code>), create a subfolder called <code>step1</code> and navigate to it:<pre class="source-code">
$ mkdir step1 &amp;&amp; cd step1</pre></li> <li>Inside this folder, add a file called <code>docker-compose.yml</code> and add the following snippet to it:</li>
</ol>
<div><div><img alt="Figure 11.1 – Simple Docker Compose file" height="1039" src="img/Figure_11.01_B19199.jpg" width="798"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Simple Docker Compose file</p>
<p>The lines in the file are <a id="_idIndexMarker925"/>explained as follows:</p>
<ul>
<li>Line 1: <code>version</code> – On this line, we specify the version of the Docker Compose format we want to use. At the time of writing, this is version <code>3.8</code>.</li>
<li>Lines 2–21: <code>services</code> – In this section, we specify the services that make up our application in the <code>services</code> block. In our sample, we have two application services, and we call them <code>db</code> and <code>pgadmin</code>.</li>
<li>Lines 3–11: <code>db</code> – The <code>db</code> service is using the image name <code>postgres:alpine</code>, which is the latest version of the Alpine Linux-based PostgreSQL database:<ul><li>Line 4: <code>image</code> – Here, we define which Docker image to use for the service. As mentioned previously, we’re using the curated <code>postgres</code> image with a tag of <code>alpine</code>. Since we’re not specifying a version number, it will take the latest stable version of the Alpine-based PostgreSQL image.</li><li>Lines 5–8: <code>environment</code> – Here, we are defining the environment variables that <a id="_idIndexMarker926"/>will be accessible from within the running PostgreSQL service. In this case, we define the default username, password, and database name.</li><li>Lines 9–11: <code>volumes</code> – We are defining two volume mappings.</li><li>Line 10: We are mapping a volume called <code>pg-data</code> to the <code>/var/lib/postgresql/data</code> container folder. This is where PostgreSQL by default stores the data. This way, the data is persisted into the <code>pg-data</code> volume and will survive a restart of the <code>db</code> service.</li><li>Line 11: In this case, we are mapping the host folder, <code>./db</code>, into a container folder called <code>/docker-entrypoint-initdb.d</code>. This is the folder where PostgreSQL expects any initialization files that are run upon the first start of the database. In our case, we’ll use it to define a database initialization script called <code>init-db.sql</code>.</li></ul></li>
<li>Lines 13–21: <code>pgadmin</code> – The <code>pgadmin</code> service uses a Docker image containing the popular administration tool for PostgreSQL and similar databases called <code>Pg4Admin</code>. We are mounting a volume called <code>pgadmin-data</code> into the container of the <code>db</code> service:<ul><li>Line 14: <code>image</code> – This service is using the <code>dpage/pgadmin4</code> image. Note we’re not defining any tags for the image, so we’ll automatically work with the latest version.</li><li>Lines 15–16: <code>ports</code> – Here, we define which container ports we want to map to the host. In this case, we map the default <code>Pg4Admin</code> port <code>80</code> to the host port <code>5050</code>. This way, we can access the admin tool on this latter port from a browser window, as we will see shortly.</li><li>Lines 17–19: <code>environment</code> – Here, we are defining the environment variables that will be accessible from within the running <code>Pg4Admin</code> tool container. It is the email and password we will need to log in to the tool.</li><li>Lines 20–21: <code>volumes</code> – We are mapping a Docker volume called <code>pgadmin-data</code> to the <code>/var/lib/pgadmin</code> folder inside the container. This is the place where the tool stores its data and makes it possible to survive a restart of the tool container.</li></ul></li>
<li>Lines 23–25: <code>volumes</code> – The volumes used by any of the services must be declared in this <a id="_idIndexMarker927"/>section. In our sample, this is the last section of the file. The first time the application is run, volumes called <code>pg-data</code> and <code>pgadmin-data</code> will be created by Docker and then, in subsequent runs, if the volumes are still there, they will be reused. This could be important if the application, for some reason, crashes and must be restarted. Then, the previous data is still around and ready to be used by the restarted database service.</li>
</ul>
<ol>
<li value="3">Create a folder called <code>db</code> in the <code>step1</code> folder and add a file called <code>init-db.sql</code> to it with the following content:</li>
</ol>
<div><div><img alt="Figure 11.2 – Database initialization script" height="731" src="img/Figure_11.02_B19199.jpg" width="1051"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Database initialization script</p>
<p>If you don’t want to type in all of the preceding, you can find the file here: <a href="https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql">https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch11/step1/db/init-db.sql</a>. As you will see later, this file will <a id="_idIndexMarker928"/>be used to initialize our database with some initial schema and some data.</p>
<ol>
<li value="4">Next, let’s see how we can run the services with the help of Docker Compose. Execute the following command from within your <code>step1</code> folder where the <code>docker-compose.yml</code> file resides:<pre class="source-code">
$ docker compose up</pre></li> </ol>
<p>Let’s analyze the output generated by the preceding command:</p>
<ul>
<li>The first few lines are telling us that Docker is pulling the images for the <code>db</code> and <code>pgadmin</code> services</li>
<li>The next few lines indicate that Docker is automatically creating a new network called <code>step1_default</code></li>
<li>Two volumes called <code>step1_pgadmin-data</code> and <code>step1-pg-data</code></li>
<li>Two container instances called <code>step1-db-1</code> and <code>step1-pgadmin-1</code></li>
</ul>
<div><div><img alt="Figure 11.3 – Creating the resources for the Docker Compose application" height="183" src="img/Figure_11.03_B19199.jpg" width="780"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Creating the resources for the Docker Compose application</p>
<p>Note the <code>step1_</code> prefix <a id="_idIndexMarker929"/>added to all the preceding resources. This is the folder name within which the <code>docker-compose.yml</code> exists and from where the app was started, combined with the underscore character.</p>
<ul>
<li>Now, let’s look at the third part of the output in blue. Here, the database is started up:</li>
</ul>
<div><div><img alt="Figure 11.4 – Starting up the database" height="552" src="img/Figure_11.04_B19199.jpg" width="1232"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Starting up the database</p>
<ul>
<li>The second part of the initialization of the database looks like this:</li>
</ul>
<div><div><img alt="Figure 11.5 – Initializing the database using the provided script" height="686" src="img/Figure_11.05_B19199.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Initializing the database using the provided script</p>
<ul>
<li>We have shortened <a id="_idIndexMarker930"/>the second part of the output a bit. It shows us how the database finalizes its initialization. We can specifically see how our initialization script, <code>init-db.sql</code>, is applied, which defines a database and seeds it with some data.</li>
<li>The last line in the output tells us that the PostgreSQL database is now up and running and ready to accept an incoming connection. The connection is expected to happen at port <code>5432</code>, as indicated by the fourth and fifth last lines in the preceding output.</li>
</ul>
<p class="callout-heading">Hint</p>
<p class="callout">If for some reason your volume mapping does not work – you may have a typo or so in the volume mapping part – you can start over by using the <code>docker compose down -v</code> command, where the <code>-v</code> parameter instructs Docker to remove any volumes associated with this application.</p>
<ul>
<li>Lastly, we have the initialization of the <code>pgamin</code> tool, shown in yellow:</li>
</ul>
<div><div><img alt="Figure 11.6 – Starting up the pgadmin tool" height="228" src="img/Figure_11.06_B19199.jpg" width="1117"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Starting up the pgadmin tool</p>
<ol>
<li value="5">We are now ready<a id="_idIndexMarker931"/> to roll. Let’s open a new browser window and navigate to <code>http://localhost:5050</code>. When asked, log in using the username (email) and password defined for the <code>pgadmin</code> tool in the <code>docker-compose.yml</code> file, namely <code>admin@acme.com</code> for the email and <code>admin</code> for the password. Add a server called <code>demo</code> and fill out the connection details as follows:</li>
</ol>
<div><div><img alt="Figure 11.7 – Pg4Admin connection details" height="556" src="img/Figure_11.07_B19199.jpg" width="704"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Pg4Admin connection details</p>
<p>Note that the<a id="_idIndexMarker932"/> hostname/address, <code>db</code>, corresponds to the name of the database service in our docker-compose file. Port <code>5432</code> is the default port used by a PostgreSQL database and the username and password correspond to what we have defined in our docker-compose file for the database as well.</p>
<ol>
<li value="6">Once connected to the database, make sure that you can locate the <code>pets</code> database and within it the <code>images</code> table. Use the tool to retrieve all the records in the <code>images</code> table. You should find the 12 records that we defined in the <code>init-db.sql</code> initialization script.</li>
<li>Before you continue, you can stop the application by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal window where the application still runs. After that, run the following:<pre class="source-code">
$ docker compose down -v</pre></li> </ol>
<p>This is to make sure the application container, the network, and the volumes are removed. You should see the following output in your terminal:</p>
<pre class="source-code">
[+] Running 5/5⠿ Container step1-pgadmin-1    Removed             0.0s
⠿ Container step1-db-1         Removed             0.0s
⠿ Volume step1_pgadmin-data    Removed             0.0s
⠿ Volume step1_pg-data         Removed             0.1s
⠿ Network step1_default        Removed             0.1s</pre>
<p>Specifically, notice the use of the <code>-v</code> command-line parameter, which tells Docker to forcibly remove volumes that were created and used by the application. Use this parameter wisely as it will destroy all data that has been persisted into those volumes.</p>
<p>Great, that worked. You <a id="_idIndexMarker933"/>have learned how to use the <code>docker-compose.yml</code> file to declaratively define an application made up of more than one service and start it with a simple <code>docker compose </code><code>up</code> command.</p>
<p>Next, you will learn how you can use Docker Compose to build your own custom images.</p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor242"/>Building images with Docker Compose</h1>
<p>To demonstrate <a id="_idIndexMarker934"/>how to build a Docker image using<a id="_idIndexMarker935"/> Docker Compose, we need a small application. Proceed as follows:</p>
<ol>
<li>In the chapter’s folder (<code>ch11</code>), create a subfolder, <code>step2</code>, and navigate to it:<pre class="source-code">
mkdir step2 &amp;&amp; cd step2</pre></li> <li>From the previous exercise, copy the <code>db</code> folder containing the database initialization script to the <code>step2</code> folder and also copy the <code>docker-compose.yml</code> file:<pre class="source-code">
$ cp -r ../step1/db .$ cp ../docker-compose.yml .</pre></li> <li>Create a folder called <code>web</code> in the <code>step2</code> folder. This folder will contain a simple Express.js <a id="_idIndexMarker936"/>web<a id="_idIndexMarker937"/> application.</li>
<li>Add a file called <code>package.json</code> to the folder with this content:</li>
</ol>
<div><div><img alt="Figure 11.8 – The package.json file of the sample web application" height="649" src="img/Figure_11.08_B19199.jpg" width="1058"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – The package.json file of the sample web application</p>
<p class="callout-heading">Note</p>
<p class="callout">If you prefer not to type yourself, you can always download the files from the sample solution: <a href="https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2">https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2</a>.</p>
<ol>
<li value="5">Create a folder called <code>src</code> inside the <code>web</code> folder.</li>
<li>Add a <a id="_idIndexMarker938"/>file<a id="_idIndexMarker939"/> called <code>server.js</code> to the <code>src</code> folder with this content:</li>
</ol>
<div><div><img alt="Figure 11.9 – The server.js file of the sample web application" height="1072" src="img/Figure_11.09_B19199.jpg" width="853"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – The server.js file of the sample web application</p>
<p>This file contains the complete logic for our simple web application. Of interest is specifically the logic for the <code>/animal</code> endpoint on lines 32 to 40. Also note how we connect to the PostgreSQL database using a constant <code>pool</code> of type <code>Pool</code> (lines 15 to 21). The username, password, and database name should match the ones we define for the database.</p>
<ol>
<li value="7">Add another file called <code>index.xhtml</code> to the <code>src</code> folder with this content:</li>
</ol>
<div><div><img alt="Figure 11.10 – The index.xhtml file of the sample web application" height="392" src="img/Figure_11.10_B19199.jpg" width="1061"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – The index.xhtml file of the sample web application</p>
<p>This file serves <a id="_idIndexMarker940"/>as <a id="_idIndexMarker941"/>a template to display the image of a wild animal.</p>
<ol>
<li value="8">Add a folder called <code>public/css</code> to the <code>web</code> folder:<pre class="source-code">
mkdir -p public/css</pre></li> <li>Add a file called <code>main.css</code> to this <code>public/css</code> folder, which we will use to style our sample web application. Add this content to the file:</li>
</ol>
<div><div><img alt="Figure 11.11 – The main.css file of the sample web application" height="929" src="img/Figure_11.11_B19199.jpg" width="641"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – The main.css file of the sample web application</p>
<ol>
<li value="10">Now we need<a id="_idIndexMarker942"/> some <a id="_idIndexMarker943"/>real images to display. The easiest way is to copy our sample images from GitHub:<ol><li>Create a folder called <code>images</code> in the <code>public</code> folder.</li><li>Then, download all images into this <code>images</code> folder, which you can find here: <a href="https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images">https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch11/step2/web/public/images</a>.</li></ol></li>
<li>We now need to make a small addition to the <code>docker-compose.yml</code> file that we have copied from the <code>step1</code> folder. Locate the <code>docker-compose.yml</code> file in the <code>step2</code> folder, open it, and after line 4, add this snippet:<pre class="source-code">
ports:- 5432:5432</pre></li> </ol>
<p>The result should <a id="_idIndexMarker944"/>look <a id="_idIndexMarker945"/>like this:</p>
<div><div><img alt="Figure 11.12 – Add host port mapping to the db service" height="643" src="img/Figure_11.12_B19199.jpg" width="786"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Add host port mapping to the db service</p>
<p>This way, we can actually access the database from any application running on the host. We will use this possibility in the coming steps.</p>
<ol>
<li value="12">Now, we are ready to run and test this application:<ol><li>Run the database using the docker-compose file and this command:</li></ol><pre class="source-code">
<code>$ docker compose up db --detach</code></pre><p>We are telling Docker Compose to only start the db service and to run it in <code>detach</code> mode, indicated by the <code>--</code><code>detach</code> parameter.</p><ol><li value="2">Navigate<a id="_idIndexMarker946"/> to <a id="_idIndexMarker947"/>the <code>web</code> folder:</li></ol><pre class="source-code"><code>$ cd web</code></pre><ol><li value="3">Install all dependencies with the following:</li></ol><pre class="source-code"><code>$ npm install</code></pre><ol><li value="4">Run the application using the following:</li></ol><pre class="source-code"><code>$ npm run start</code></pre><p>You should see this:</p></li> </ol>
<div><div><img alt="Figure 11.13 – Running the web application natively" height="188" src="img/Figure_11.13_B19199.jpg" width="456"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Running the web application natively</p>
<ol>
<li value="13">Open a browser tab and navigate to <a href="http://localhost:3000/animal">http://localhost:3000/animal</a> and you should see something like this:</li>
</ol>
<div><div><img alt="Figure 11.14 – The web application running and displaying a wild animal" height="965" src="img/Figure_11.14_B19199.jpg" width="1072"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – The web application running and displaying a wild animal</p>
<ol>
<li value="14">Refresh the <a id="_idIndexMarker948"/>browser a few times and notice <a id="_idIndexMarker949"/>that each time, a new random animal is displayed.</li>
<li>Before you leave, make sure to stop the web application and stop the other containers with <code>docker </code><code>compose down</code>.</li>
</ol>
<p>Great, now we can move on to the next step, where we will Dockerize the web application and use Docker Compose to build the image:</p>
<ol>
<li>Add a file called <code>Dockerfile</code> to the <code>web</code> folder and add this snippet:</li>
</ol>
<div><div><img alt="Figure 11.15 – Dockerfile for the web application" height="524" src="img/Figure_11.15_B19199.jpg" width="1449"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Dockerfile for the web application</p>
<p>Analyze this <a id="_idIndexMarker950"/>Dockerfile and try to understand<a id="_idIndexMarker951"/> what it does exactly. Refer to what you learned in <a href="B19199_04.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating and Managing Container Images</em>, if needed.</p>
<ol>
<li value="2">Open the <code>docker-compose.yml</code> file from the <code>step2</code> folder and add the definition of the <code>web</code> service, right after the <code>db</code> and <code>pgadmin</code> services and before the <code>volumes</code> section (that is, after line 24). The snippet to add should look like this:</li>
</ol>
<div><div><img alt="Figure 11.16 – Defining the service called web in the docker-compose.yml file" height="555" src="img/Figure_11.16_B19199.jpg" width="1399"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Defining the service called web in the docker-compose.yml file</p>
<p>Make sure that <a id="_idIndexMarker952"/>on <a id="_idIndexMarker953"/>line 2, you replace the <code>gnschenker</code> username with your own Docker Hub username.</p>
<ol>
<li value="3">Build the image using this command:<pre class="source-code">
$ docker compose build web</pre></li> </ol>
<p>The preceding command assumes that you are in the <code>step2</code> folder and that there is a <code>docker-compose.yml</code> file located in that folder.</p>
<p>When building the image, Docker looks for and uses a Dockerfile in the <code>web</code> folder, as instructed by the <code>build: web</code> instruction on line 3 in the preceding snippet.</p>
<p>To build images using Docker Compose, use the following instructions:</p>
<ol>
<li>Open a terminal window.</li>
<li>Make sure that you are in the <code>ch11/step2</code> subfolder of the <code>The-Ultimate-Docker-Container-Book</code> folder:<pre class="source-code">
$ cd ~/ The-Ultimate-Docker-Container-Book/ch11/step2</pre></li> <li>Then, build the images:<pre class="source-code">
$ docker compose build</pre></li> </ol>
<p>If we enter the preceding command, then the tool will assume that there must be a file in the current directory called <code>docker-compose.yml</code> and it will use that one to run. In our case, this is indeed the case, and the tool will build the images.</p>
<ol>
<li value="4">Observe the<a id="_idIndexMarker954"/> output <a id="_idIndexMarker955"/>in your terminal window. You should see something like this:</li>
</ol>
<div><div><img alt="Figure 11.17 – Building the Docker image for the web service" height="367" src="img/Figure_11.17_B19199.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Building the Docker image for the web service</p>
<p>In the preceding screenshot, you can see that docker-compose first downloads the base image, <code>node:19.7-alpine</code>, for the <code>web</code> image we’re building from Docker Hub. Subsequently, it uses the Dockerfile found in the <code>web</code> folder to build the image and names it <code>gnschenker/ch11-web:2.0</code>.</p>
<p>After building the Docker image for the <code>web</code> service, we are ready to use Docker Compose to run the whole multi-service application.</p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor243"/>Running an application with Docker Compose</h1>
<p>Once we have<a id="_idIndexMarker956"/> built our images, we can start the<a id="_idIndexMarker957"/> application using Docker Compose:</p>
<pre class="source-code">
$ docker compose up</pre> <p>The output, similar to the output we discussed in the previous section for the <code>db</code> and <code>pgadmin</code> services, will look as follows for the <code>web</code> service:</p>
<pre class="source-code">
step2-web-1      | DB_HOST: dbstep2-web-1      | Application listening on port 3000</pre>
<p>This indicates that the containerized <code>web</code> service is ready and is listening on port <code>3000</code>. Coincidentally, we have mapped container port <code>3000</code> to the same port <code>3000</code> on the host in our <code>docker-compose.yml</code> file. Thus, we can just open a new browser tab and navigate to the URL <a href="http://localhost:3000/animal">http://localhost:3000/animal</a>; we should once again see a wild animal displayed.</p>
<p>Refresh the browser a few times to see other animal images. The application selects the current image randomly from a set of 12 images whose URLs are stored in the database.</p>
<p>As the application is running in interactive mode and, thus, the terminal where we ran Docker Compose is blocked, we can cancel the application by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. If we do so, we will see the following:</p>
<pre class="source-code">
^CGracefully stopping... (press Ctrl+C again to force)Aborting on container exit...
[+] Running 3/3
⠿ Container step2-pgadmin-1  Stopped                              1.4s
⠿ Container step2-web-1      Stopped                             10.2s
⠿ Container step2-db-1       Stopped                              0.1s
canceled</pre>
<p>We will notice that the <code>db</code> and <code>web</code> services stop immediately. Sometimes, though, some services will take about 10 seconds to do so. The reason for this is that the <code>db</code> and the <code>web</code> service listen, and react, to the <code>SIGTERM</code> signal sent by Docker, while other services might not, and so Docker kills them after a predefined timeout interval of 10 seconds.</p>
<p>If we run the application again with <code>docker compose up</code>, the startup will be much faster as the database didn’t have to initialize from scratch, but it was just reusing the data that was already present in the <code>pg-data</code> volume from the previous run.</p>
<p>We can also run the application in the background. All containers will run as daemons. For this, we just need to use the <code>-d</code> parameter, as shown in the following code:</p>
<pre class="source-code">
$ docker compose up -d</pre> <p>Docker Compose <a id="_idIndexMarker958"/>offers us many more commands<a id="_idIndexMarker959"/> than just <code>up</code>. We can also use the tool to list all services that are part of the application:</p>
<pre class="source-code">
$ docker compose ps</pre> <p>We should see this:</p>
<div><div><img alt="Figure 11.18 – Output of docker compose ps" height="71" src="img/Figure_11.18_B19199.jpg" width="1004"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Output of docker compose ps</p>
<p>This command is similar to <code>docker container ls</code>, with the only difference being that docker-compose only lists containers or services that are part of the application.</p>
<p>To stop and clean up the application, we use the <code>docker compose </code><code>down</code> command:</p>
<pre class="source-code">
$ docker compose down</pre> <p>This should result in an output similar to this:</p>
<pre class="source-code">
⠿ Container step2-web-1      Removed                             10.2s⠿ Container step2-pgadmin-1  Removed                              0.9s
⠿ Container step2-db-1       Removed                              0.1s
⠿ Network step2_default      Removed                              0.1s</pre>
<p>If we also want to remove the volumes for the database, then we can use the following command:</p>
<pre class="source-code">
$ docker volume rm step2_pd-data step2_pgadmin-data</pre> <p>Alternatively, instead of using the two commands, <code>docker compose down</code> and <code>docker volume rm &lt;volume name&gt;</code>, we can combine them into a single command:</p>
<pre class="source-code">
$ docker compose down -v</pre> <p>Here, the argument <code>-v</code> (or <code>--volumes</code>) removes named volumes declared in the <code>volumes</code> section of the Docker Compose file and anonymous volumes attached to containers.</p>
<p>Why is there a <code>step2</code> prefix in the name of the volume? In the <code>docker-compose.yml</code> file, we have called the volumes to use <code>pg-data</code> and <code>pgadmin-data</code>. But, as we have already mentioned, Docker Compose prefixes all names with the name of the <a id="_idIndexMarker960"/>parent<a id="_idIndexMarker961"/> folder of the <code>docker-compose.yml</code> file plus an underscore. In this case, the parent folder is called <code>step2</code>. If you don’t like this approach, you can define a project name explicitly, for example, as follows:</p>
<pre class="source-code">
$ docker compose  --project-name demo up --detach</pre> <p>This way, all resources (containers, networks, and volumes) will be prefixed by the project name, in this case, called <code>demo</code>.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor244"/>Scaling a service</h1>
<p>Now, let’s, for a moment, assume<a id="_idIndexMarker962"/> that our sample application has been live on the web and become very successful. Loads of people want to see our cute animal images. But now we’re facing a problem: our application has started to slow down. To overcome this problem, we want to run multiple instances of the <code>web</code> service. With Docker Compose, this is readily done.</p>
<p>Running more instances is also <a id="_idIndexMarker963"/>called scaling out. We can use this tool to scale our <code>web</code> service up to, say, three instances:</p>
<pre class="source-code">
$ docker compose up --scale web=3</pre> <p>If we do this, we are in for a surprise. The output will look as in the following screenshot:</p>
<div><div><img alt="Figure 11.19 – Output of docker-compose --scale" height="179" src="img/Figure_11.19_B19199.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – Output of docker-compose --scale</p>
<p>The second and third instances of the <code>web</code> service fail to start. The error message tells us why we cannot use the same host port, <code>3000</code>, more than once. When instances 2 and 3 try to start, Docker realizes that port <code>3000</code> is already taken by the first instance. What can we do? Well, we can just let Docker decide which host port to use for each instance.</p>
<p>If, in the <code>ports</code> section of the Docker Compose file, we only specify the container port and leave out the host <a id="_idIndexMarker964"/>port, then Docker automatically selects an ephemeral port. Let’s do exactly this:</p>
<ol>
<li>First, let’s tear down the application:<pre class="source-code">
$ docker compose down</pre></li> <li>Then, we modify the <code>docker-compose.yml</code> file. The port mapping of the <code>web</code> service originally looks like this:<pre class="source-code">
ports:- 3000:3000</pre></li> </ol>
<p>We change it to simply the following:</p>
<pre class="source-code">
ports:– 3000</pre>
<p>This way, Docker will allocate the host port dynamically.</p>
<ol>
<li value="3">Now, we can start the application again and scale it up immediately after that:<pre class="source-code">
$ docker compose up -d$ docker compose up -d --scale web=3</pre></li> </ol>
<p>And we should see this:</p>
<pre class="source-code">
[+] Running 5/5⠿ Container step2-pgadmin-1  Started                 0.3s
⠿ Container step2-db-1       Started                 0.3s
⠿ Container step2-web-1      Started                 0.6s
⠿ Container step2-web-3      Started                 0.8s
⠿ Container step2-web-2      Started                 1.0s</pre>
<ol>
<li value="4">If we now<a id="_idIndexMarker965"/> execute <code>docker compose ps</code>, we should see what is in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 11.20 – Output of the docker compose ps command" height="103" src="img/Figure_11.20_B19199.jpg" width="1030"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – Output of the docker compose ps command</p>
<p>Note that in your case, the host ports may be different than those shown in the preceding screenshot. There, we have a mapping to ports <code>590076</code>, <code>59078</code>, and <code>59077</code> for the three instances of <code>web</code>.</p>
<ol>
<li value="5">We can try to see whether those port mappings work, for example, using <code>curl</code>. Let’s test the third instance, <code>step2_web-3</code>:<pre class="source-code">
$ curl -4 localhost:59077</pre></li> </ol>
<p>We should see the following:</p>
<pre class="source-code">
Wild Animals of Massai Mara National Park%</pre> <p>The answer tells us that, indeed, our application is still working as expected. Try it out for the other two instances <a id="_idIndexMarker966"/>to be sure.</p>
<p>In the next section, we are going to learn how to build and subsequently push the application container images to an image registry.</p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor245"/>Building and pushing an application</h1>
<p>We saw earlier<a id="_idIndexMarker967"/> that we<a id="_idIndexMarker968"/> can also use the <code>docker-compose build</code> command to just build the images of an application defined in the underlying <code>docker-compose</code> file. But to make this work, we’ll have to add the build information to the <code>docker-compose</code> file:</p>
<ol>
<li value="1">Open a new browser window and navigate to the chapter’s folder (<code>ch11</code>):<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch11</pre></li> <li>Create a subfolder called <code>step3</code> and navigate to it:<pre class="source-code">
$ mkdir step3 &amp;&amp; cd step3</pre></li> <li>Copy the <code>docker-compose.yml</code> file from the <code>step2</code> folder to this new folder:<pre class="source-code">
$ cp ../step2/docker-compose.yml .</pre></li> <li>Open the copied file and please note the <code>build</code> key for the web service on line 3 in the following screenshot. The value of that key indicates the context or folder where Docker is expecting to find the Dockerfile to build the corresponding image.</li>
</ol>
<div><div><img alt="Figure 11.21 – The build key in the web service of the docker-compose.yml file" height="566" src="img/Figure_11.21_B19199.jpg" width="1383"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – The build key in the web service of the docker-compose.yml file</p>
<p>Please note the <code>depends_on</code> section on lines 8 and 9. This instructs Docker Compose<a id="_idIndexMarker969"/> to<a id="_idIndexMarker970"/> make sure that the <code>db</code> service is started before the <code>web</code> service.</p>
<ol>
<li value="5">If we wanted to use a Dockerfile that is named differently, say <code>Dockerfile.dev</code>, for the <code>web</code> service, then the <code>build</code> block in the <code>docker-compose</code> file would look like this:<pre class="source-code">
build:    context: web    dockerfile: Dockerfile.dev</pre><ol><li>Copy the <code>web</code> and the <code>db</code> folder and their contents from the <code>step2</code> folder into the <code>step3</code> folder:</li></ol><pre class="source-code"><code>$ cp -r ../step2/web .</code><code>$ cp -r ../step2/db .</code></pre><ol><li value="2">Create a file called <code>Dockerfile.dev</code> in the <code>web</code> folder, which is just a copy of the existing Dockerfile:</li></ol><pre class="source-code"><code>$ cp web/Dockerfile web/Dockerfile.dev</code></pre><ol><li value="3">To the <code>step3</code> folder, add a new file, <code>docker-compose.dev.yml</code>, which is a copy of the <code>docker-compose.yml</code> file:</li></ol><pre class="source-code"><code>$ cp ../step2/docker-compose.yml docker-compose.dev.yml</code></pre><ol><li value="4">Modify the <code>build</code> block according to the preceding snippet.</li></ol></li> <li>Let’s use<a id="_idIndexMarker971"/> that<a id="_idIndexMarker972"/> alternative <code>docker-compose.dev.yml</code> file now:<pre class="source-code">
$ docker-compose -f docker-compose.dev.yml build</pre></li> </ol>
<p>The <code>-f</code> parameter will tell the Docker Compose application which Docker Compose file to use.</p>
<ol>
<li value="7">To push all images to Docker Hub, we can use <code>docker </code><code>compose push</code>:<ol><li>We need to be logged in to Docker Hub so that this succeeds; otherwise, we get an authentication error while pushing. Thus, in my case, I do the following:</li></ol><pre class="source-code">
<code>$ docker login -u gnschenker -p &lt;password&gt;</code></pre><ol><li value="2">Assuming the login succeeds, I can then push the following code:</li></ol><pre class="source-code"><code>$ docker-compose -f docker-compose.dev.yml push</code></pre></li> </ol>
<p>This may take a while, depending on the bandwidth of your internet connection. While pushing, your screen may look like this:</p>
<div><div><img alt="Figure 11.22 – Pushing images with docker-compose to Docker Hub" height="356" src="img/Figure_11.22_B19199.jpg" width="1083"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – Pushing images with docker-compose to Docker Hub</p>
<p>The preceding command pushes the Docker image for the <code>web</code> service to the <code>gnschenker</code> account on Docker Hub. The other two services, <code>db</code> and <code>pgadmin</code>, in the Docker Compose file are ignored.</p>
<p class="callout-heading">Note</p>
<p class="callout">Make sure you are using your own Docker Hub account instead of <code>gnschenker</code>.</p>
<p>The last feature <a id="_idIndexMarker973"/>of<a id="_idIndexMarker974"/> Docker Compose we want to discuss is overrides.</p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor246"/>Using Docker Compose overrides</h1>
<p>Sometimes, we want<a id="_idIndexMarker975"/> to run our applications in different environments that need specific configuration settings. Docker Compose provides a handy capability to address exactly this issue.</p>
<p>Let’s illustrate the with a specific sample:</p>
<ol>
<li value="1">Open a new browser window and navigate to the chapter’s folder (<code>ch11</code>):<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch11</pre></li> <li>Create a subfolder called <code>step4</code> and navigate to it:<pre class="source-code">
$ mkdir step4 &amp;&amp; cd step4</pre></li> <li>Copy the <code>web</code> and <code>db</code> folder and their contents from the <code>step2</code> folder into the <code>step4</code> folder:<pre class="source-code">
$ cp -r ../step2/web .$ cp -r ../step2/db .</pre></li> <li>We can define a base Docker Compose file and then define environment-specific overrides. Let’s assume we have a file called <code>dockercompose.base.yml</code> with<a id="_idIndexMarker976"/> the following content:</li>
</ol>
<div><div><img alt="Figure 11.23 – Docker Compose file used as a base" height="955" src="img/Figure_11.23_B19199.jpg" width="1556"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – Docker Compose file used as a base</p>
<p>This only defines the part that should be the same in all environments. All specific settings have been taken out.</p>
<ol>
<li value="5">Now assume we want to run the application in <code>docker-compose.ci.yml</code> and <a id="_idIndexMarker977"/>add this snippet of code:</li>
</ol>
<div><div><img alt="Figure 11.24 – Docker Compose file for CI" height="966" src="img/Figure_11.24_B19199.jpg" width="1574"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – Docker Compose file for CI</p>
<ol>
<li value="6">We can run this application with the following command:<pre class="source-code">
$ docker compose -f docker-compose.base.yml \    -f docker-compose.ci.yml up \    -d --build</pre></li> </ol>
<p>Note that with the first <code>-f</code> parameter, we provide the base Docker Compose file, and with the second one, we provide the override. The <code>--build</code> parameter instructs Docker Compose to rebuild all Docker images before starting them.</p>
<p class="callout-heading">Warning</p>
<p class="callout">When using environment variables, note the following:</p>
<p class="callout">1) Declaring them in the Docker file defines a default value</p>
<p class="callout">2) Declaring the same variable in the Docker Compose file overrides the value from the Dockerfile</p>
<p>With this, we have reached the end of this chapter about Docker Compose. But before we finish, we have<a id="_idIndexMarker978"/> the following tip for you.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Had we followed the standard naming convention and called the base file just <code>docker-compose.yml</code> and the override file <code>docker-compose.overrid.yml</code> instead, then we could have started the application with <code>docker-compose up -d</code> without explicitly naming the Docker Compose files. In any other case, we need to use the following full and more verbose syntax:</p>
<p class="callout"><code>$ docker compose -f &lt;base compose file&gt; -f &lt;override compose </code><code>file&gt; up</code></p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor247"/>Summary</h1>
<p>In this chapter, we introduced the docker-compose tool. This tool is mostly used to run and scale multi-service applications on a single Docker host. Typically, developers and CI servers work with single hosts, and those two are the main users of Docker Compose. The tool uses YAML files as input, which contain the description of the application in a declarative way.</p>
<p>The tool can also be used to build and push images, among many other helpful tasks.</p>
<p>In the next chapter, we will discuss why logging and monitoring is important and show how container logs can be collected and shipped to a central location where the aggregated logs can then be parsed to gain useful information.</p>
<p>You will also learn how to instrument an application, so that it exposes metrics, and how those metrics can be scraped and shipped again to a central location. Finally, you will learn how to convert those collected metrics into graphical dashboards that can be used to monitor a containerized application.</p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor248"/>Further reading</h1>
<p>The following links provide additional information on the topics discussed in this chapter:</p>
<ul>
<li><em class="italic">The official YAML </em><em class="italic">website</em>: <a href="http://www.yaml.org/">http://www.yaml.org/</a></li>
<li><em class="italic">The Docker Compose </em><em class="italic">documentation</em>: <a href="http://dockr.ly/1FL2VQ6">http://dockr.ly/1FL2VQ6</a></li>
<li><em class="italic">Docker Compose file version 2 </em><em class="italic">reference</em>: <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/">https://docs.docker.com/compose/compose-file/compose-file-v2/</a></li>
<li><em class="italic">Docker Compose file version 3 </em><em class="italic">reference</em>: <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></li>
<li><em class="italic">Share Docker Compose configurations between files and </em><em class="italic">projects</em>: <a href="https://docs.docker.com/compose/extends/">https://docs.docker.com/compose/extends/</a></li>
</ul>
<h1 id="_idParaDest-249"><a id="_idTextAnchor249"/>Questions</h1>
<p>To assess your learning of Docker Compose, please answer the following questions:</p>
<ol>
<li>What is Docker Compose, and what is it used for?</li>
<li>What is a Docker Compose file, and what are some of the key elements it can contain?</li>
<li>How can you use Docker Compose to start and stop an application, and what are some of the key command-line options?</li>
<li>What are some of the benefits of using Docker Compose to manage multi-container applications?</li>
<li>How do you use docker-compose to run an application in daemon mode?</li>
<li>How do you use docker-compose to display the details of the running service?</li>
<li>How do you scale up a particular <code>web</code> service to, say, three instances?</li>
</ol>
<h1 id="_idParaDest-250"><a id="_idTextAnchor250"/>Answers</h1>
<p>Here are some sample answers to the questions of <a href="B19199_11.xhtml#_idTextAnchor237"><em class="italic">Chapter 11</em></a>:</p>
<ol>
<li>Docker Compose is a tool for defining and running multi-container Docker applications. It allows you to define the services that make up your application in a YAML file, and then run and manage those services with a single command.</li>
<li>A Docker Compose file is a YAML file that defines the services that make up a Docker application, along with any associated configuration options. Some of the key elements that a Docker Compose file can contain include the following:<ul><li><code>version</code>: The version of the Docker Compose file syntax to use. This field is mandatory.</li><li><code>services</code>: A list of the services that make up the application, along with any associated configuration options.</li><li><code>ports</code>: A list of ports that need to be opened for the respective service and mapped to a corresponding container port.</li><li><code>networks</code>: Any custom networks that need to be created for the application. Note that a service can be attached to more than one network at the same time.</li><li><code>volumes</code>: Any volumes that need to be created for the application.</li></ul></li>
</ol>
<p>Here is a (shortened) example <code>docker-compose.yml</code> file using more than one network:</p>
<pre class="source-code">
services:  web:
    image: &lt;some image&gt;
    network:
    - front
  accounting:
    image: &lt;some other image&gt;
    network:
    - front
    - back
  db:
    image: postgres:latest
    network:
    - back
networks:
  front:
  back:</pre>
<ol>
<li value="3">To start an application with Docker Compose, you can use the <code>docker compose up</code> command. This command reads the Docker Compose file, creates any necessary containers, and starts the services. To stop an application, you can use the <code>docker compose down</code> command. Some of the key command-line options that can be used with these commands include the following:<ul><li><code>-d</code> or <code>--detach</code>: Run containers in the background and print new container names</li><li><code>-p</code> or <code>--project-name</code>: Specify an alternate project name</li><li><code>--build</code>: Build images before starting containers</li></ul></li>
<li>Some of the benefits of using Docker Compose to manage multi-container applications include the following:<ul><li><strong class="bold">Simplifying the deployment process</strong>: Docker Compose allows you to define your application’s services and configurations in a single file, which can simplify the deployment process and make it easier to manage complex applications</li><li><strong class="bold">Enabling collaboration</strong>: By using a Docker Compose file to define an application, developers can easily share their development environments with others and collaborate more effectively</li><li><strong class="bold">Enabling portability</strong>: Docker Compose allows you to define an application’s environment and dependencies in a portable way, which can make it easier to move applications between different environments and infrastructure providers</li></ul></li>
<li>To run the application services in daemon (or <code>detach</code>) mode, use the following:<pre class="source-code">
$ docker compose up --detach</pre></li> <li>To display the details of the running services in a Docker Compose application, use the following:<pre class="source-code">
$ docker compose ps</pre></li> <li>To scale, for example, the <code>web</code> service of a Docker Compose application to three instances, use the following command:<pre class="source-code">
$ docker compose up web --scale 3</pre></li> </ol>
</div>
</div></body></html>