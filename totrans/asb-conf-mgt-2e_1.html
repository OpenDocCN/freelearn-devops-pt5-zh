<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Ansible</h1></div></div></div><p>
<strong>Ansible</strong> is profoundly different from other configuration management tools available today. It has<a id="id0" class="indexterm"/> been designed to make configuration easy in almost every way, from its simple English configuration syntax to its ease of setup. You'll find that Ansible allows you to stop writing custom configuration and deployment scripts and lets you simply get on with your job.</p><p>Ansible only needs to be installed on the machines that you use to manage your infrastructure. It does not need a client to be installed on the managed machine, nor does it need any server infrastructure to be set up before you can use it. You should even be able to use it merely minutes after it is installed, as we will show you in this chapter.</p><p>The following are the topics covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">Installing Ansible</li><li class="listitem">Configuring Ansible</li><li class="listitem">Using Ansible from the command line</li><li class="listitem">Using Ansible to manage Windows machines</li><li class="listitem">How to get help</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Hardware and software required</h1></div></div></div><p>You will be <a id="id1" class="indexterm"/>using Ansible from the command line on one<a id="id2" class="indexterm"/> machine, which we will call the <strong>controller machine</strong>, and <a id="id3" class="indexterm"/>use it to configure another machine, which we will call the <a id="id4" class="indexterm"/>
<strong>managed machine</strong>. Ansible currently only supports a Linux or OS X controller machine; however, the managed machine can be Linux, OS X, other Unix-like machines or Windows. Ansible does not place many requirements on the controller machine and even less on the managed machine.</p><p>The requirements for the controller machine are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Python 2.6 or higher</li><li class="listitem">paramiko</li><li class="listitem">PyYAML</li><li class="listitem">Jinja2</li><li class="listitem">httplib2</li><li class="listitem">Unix-based OS</li></ul></div><p>The managed<a id="id5" class="indexterm"/> machine needs Python 2.4 or higher and simplejson; however, if your Python is 2.5 or higher, you only need Python. Managed Windows<a id="id6" class="indexterm"/> machines will need Windows remoting turned on, and a version of Windows PowerShell greater than 3.0. While Windows machines do have more requirements, all the tools are freely available and the Ansible project even includes the script to help you easily set up the dependencies.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Installation methods</h1></div></div></div><p>If you want to use Ansible to manage a set of existing machines or infrastructure, you will likely <a id="id7" class="indexterm"/>want to use whatever package manager is included on those systems. This means that you will get updates for Ansible as your distribution updates it, which may lag several versions behind other methods. However, it means that you will be running a version that has been tested to work on the system you are using.</p><p>If you run an existing infrastructure, but need a newer version of Ansible, you can install Ansible via pip. <strong>Pip</strong> is<a id="id8" class="indexterm"/> a tool used to manage packages of Python software and libraries. Ansible releases are pushed to pip as soon as they are released, so if you are up to date with pip, you should always be running the latest version.</p><p>If you imagine yourself developing lots of modules and possibly contributing back to Ansible, you should be running a version installed from source code. As you will be running the latest and least-tested version of Ansible, you may experience a hiccup or two.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Installing from your distribution</h2></div></div></div><p>Most modern <a id="id9" class="indexterm"/>distributions include a package<a id="id10" class="indexterm"/> manager that automatically manages<a id="id11" class="indexterm"/> package dependencies and updates for you. This makes installing Ansible via your package manager by far the easiest way to get started with Ansible; usually it takes only a single command. It will also be updated as you update your machine, though it may be a version or two behind. The following are the commands to install Ansible on the most common distributions. If you are using something different, refer to the user guide of your package or your distribution's package lists:</p><div><ul class="itemizedlist"><li class="listitem">Fedora, RHEL, CentOS, and compatible:<div><pre class="programlisting">
<strong>$ yum install ansible</strong>
</pre></div></li><li class="listitem">Ubuntu, Debian, and <a id="id12" class="indexterm"/>compatible:<div><pre class="programlisting">
<strong>$ apt-get install ansible</strong>
</pre></div></li></ul></div><div><h3 class="title"><a id="note02"/>Note</h3><p>Note that RHEL and CentOS require the EPEL repository to be installed. Details on EPEL, including <a id="id13" class="indexterm"/>how to install it can be found at <a class="ulink" href="https://fedoraproject.org/wiki/EPEL">https://fedoraproject.org/wiki/EPEL</a>.</p><p>If you are<a id="id14" class="indexterm"/> on Ubuntu and wish to use the<a id="id15" class="indexterm"/> latest release instead of the one provided by your operating system, you can use the Ubuntu PPA provided by Ansible. Details on <a id="id16" class="indexterm"/>setting this up can be found at <a class="ulink" href="https://launchpad.net/~ansible/+archive/ubuntu/ansible">https://launchpad.net/~ansible/+archive/ubuntu/ansible</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Installing from pip</h2></div></div></div><p>Pip, like a distribution's package manager, will handle finding, installing, and updating the packages <a id="id17" class="indexterm"/>you ask for and its dependencies. This makes<a id="id18" class="indexterm"/> installing Ansible via pip as easy as installing from <a id="id19" class="indexterm"/>your package manager. It should be noted, however, that it will not be updated with your operating system. Additionally, updating your operating system may break your Ansible installation; however, this is unlikely. If you are a Python user, you might want to install Ansible in an isolated environment (virtual environment): This is not supported as Ansible tries to install its modules to the system. You should install Ansible system-wide using pip.</p><p>The following is the command to install Ansible via pip:</p><div><pre class="programlisting">
<strong>$ pip install ansible</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Installing from the source code</h2></div></div></div><p>Installing from<a id="id20" class="indexterm"/> the source code is a great way to get the<a id="id21" class="indexterm"/> latest version, but it may not be tested as<a id="id22" class="indexterm"/> correctly as the released versions. You also will need to take care of updating to newer versions yourself and making sure that Ansible will continue to work with your operating system updates. To clone the <code class="literal">git</code> repository and install it, run the following commands. You may need root access to your system to do this:</p><div><pre class="programlisting">
<strong>$ git clone git://github.com/ansible/ansible.git</strong>
<strong>$ cd ansible</strong>
<strong>$ sudo make install</strong>
</pre></div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up Ansible</h1></div></div></div><p>Ansible <a id="id23" class="indexterm"/>needs to be able to get an inventory of the machines that you want to configure in order to manage them. This can be done in many ways due to inventory plug-ins. Several different inventory plug-ins are included with the base install. We will go over these later in the book. For now, we will cover the simple host's file inventory.</p><p>The default Ansible inventory file is named hosts and is placed at <code class="literal">/etc/ansible</code>. It is formatted like an <code class="literal">INI</code> file. Group names are enclosed in square braces, and everything underneath it, down to the next group heading, gets assigned to that group. Machines can be in many groups at one time. Groups are used to allow you to configure many machines at once. You can use a group instead of a hostname as a host pattern in later examples, and Ansible will run the module on the entire group at once.</p><p>In the following example, we have three machines in a group named <code class="literal">webservers</code>, namely <code class="literal">site01</code>, <code class="literal">site02</code>, and <code class="literal">site01-dr</code>. We also have a <code class="literal">production</code> group that consists of <code class="literal">site01</code>, <code class="literal">site02</code>, <code class="literal">db01</code>, and <code class="literal">bastion</code>.</p><div><pre class="programlisting">
<strong>[webservers]</strong>
<strong>site01</strong>
<strong>site02</strong>
<strong>site01-dr</strong>

<strong>[production]</strong>
<strong>site01</strong>
<strong>site02</strong>
<strong>db01</strong>
<strong>bastion</strong>
</pre></div><p>Once you have placed your hosts in the Ansible inventory, you can start running commands against them. Ansible includes a simple module called <code class="literal">ping</code> that lets you test connectivity between yourself and the host. Let's use Ansible from the command line against one of our machines to confirm that we can configure them.</p><p>Ansible was designed to be simple, and one of the ways the developers have done this is by using SSH to connect to the managed machines. It then sends the code over the SSH connection <a id="id24" class="indexterm"/>and executes it. This means that you don't need to have Ansible installed on the managed machine. It also means that Ansible uses the same channels that you are already using to administer the machine. This makes is easier to setup, because in most cases there will be no setup required and no ports to open in a firewall.</p><p>First, we check connectivity to our server to be configured using the Ansible <code class="literal">ping</code> module. This module simply connects to the following server:</p><div><pre class="programlisting">
<strong>$ ansible site01 -u root -k -m ping</strong>
</pre></div><p>This should ask for the SSH password and then produce a result that looks like the following:</p><div><pre class="programlisting">
<strong>site01 | success &gt;&gt; {</strong>
<strong>  "changed": false,</strong>
<strong>  "ping": "pong"</strong>
<strong>}</strong>
</pre></div><p>If you have an SSH key set up for the remote system, you will be able to leave off the <code class="literal">-k</code> argument to skip the prompt and use the keys. You can also configure Ansible to use a particular username all the time by either configuring it in the inventory on a per host basis or in the global Ansible configuration.</p><p>To set the username globally, edit <code class="literal">/etc/ansible/ansible.cfg</code> and change the line that sets <code class="literal">remote_user</code> in the <code class="literal">[defaults]</code> section. You can also change <code class="literal">remote_port</code> to change the default port that Ansible will SSH to. This will change the default settings for all the machines, but they can be overridden in the inventory file on a per server or per group basis.</p><p>To set the username in the inventory file, simply append <code class="literal">ansible_ssh_user</code> to the line in the inventory. For example, the following code section shows an inventory where the <code class="literal">site01</code> host uses the username <code class="literal">root</code> and the <code class="literal">site02</code> host uses the username <code class="literal">daniel</code>. There are also other variables you can use. The <code class="literal">ansible_ssh_host</code> variable allows you to set a different hostname, and the <code class="literal">ansible_ssh_port</code> variable allows you to set a different port, which is demonstrated on the <code class="literal">site01-dr</code> host. Finally the <code class="literal">db01</code> host uses the username <code class="literal">fred</code> and also sets a private key using <code class="literal">ansible_ssh_private_key_file</code>.</p><div><pre class="programlisting">
<strong>[webservers]      #1</strong>
<strong>site01 ansible_ssh_user=root     #2</strong>
<strong>site02 ansible_ssh_user=daniel      #3</strong>
<strong>site01-dr ansible_ssh_host=site01.dr ansible_ssh_port=65422      #4</strong>
<strong>[production]      #5</strong>
<strong>site01      #6</strong>
<strong>site02      #7</strong>
<strong>db01 ansible_ssh_user=fred ansible_ssh_private_key_file=/home/fred/.ssh.id_rsa     #8</strong>
<strong>bastion      #9</strong>
</pre></div><p>If you aren't comfortable with giving Ansible direct access to the root account on the managed machines, or your machine does not allow SSH access to the root account (such as Ubuntu's default configuration), you can configure Ansible to obtain root access using <code class="literal">sudo</code>. Using Ansible with <code class="literal">sudo</code> means that you can enforce auditing the same way you would otherwise. Configuring Ansible to use <code class="literal">sudo</code> is as simple as it is to configure the port, except that it requires <code class="literal">sudo</code> to be configured on the managed machine.</p><p>The first<a id="id25" class="indexterm"/> step is to add a line to the <code class="literal">/etc/sudoers</code> file; on the managed node, this may already be set up if you choose to use your own account. You can use a password with <code class="literal">sudo</code>, or you can use a passwordless <code class="literal">sudo</code>. If you decide to use a password, you will need to use the <code class="literal">-k</code> argument to Ansible, or set the <code class="literal">ask_sudo_pass</code> value to <code class="literal">true</code> in <code class="literal">/etc/ansible/ansible.cfg</code>. To make Ansible use sudo, add <code class="literal">--sudo</code> to the command line like this:</p><div><pre class="programlisting">
<strong>ansible site01 -s -m command -a 'id -a'</strong>
</pre></div><p>If this works, it should return something similar to:</p><div><pre class="programlisting">
<strong>site01 | success | rc=0 &gt;&gt;</strong>
<strong>uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Setting it up on Windows</h2></div></div></div><p>Ansible<a id="id26" class="indexterm"/> recently added the ability to manage Windows<a id="id27" class="indexterm"/> machines. Now, you can use Ansible to easily manage Windows machines the same way you manage your Linux machines.</p><p>This uses the Windows PowerShell Remoting tools in the same way that SSH is used on a Linux machine to execute modules remotely. Several new modules have been added that explicitly support Windows, but some existing modules have also been given the ability to work with Windows-managed machines.</p><p>To get started with managing your Windows machine, you do have to perform a little bit of complex setup. You need to follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create some Windows machines in your inventory</li><li class="listitem">Install Python-winrm to allow Ansible to connect to the Windows machines</li><li class="listitem">Upgrade to PowerShell 3.0+ to support Windows modules</li><li class="listitem">Enable Windows remoting so that Ansible can connect</li></ol><div></div><p>Windows machines are created the same way as all the other machines that you have in your inventory. They are differentiated by the value of the <code class="literal">ansible_connection</code> variable. When <code class="literal">ansible_connection</code> is set to <code class="literal">winrm</code>, it will try to connect via winrm to Windows PowerShell on the remote machine. Ansible also uses the <code class="literal">ansible_ssh_user</code>, <code class="literal">ansible_ssh_pass</code>, and <code class="literal">ansible_ssh_port</code> values like it would on your other machine. Despite having the name ssh in them, they are used to provide the port and credentials that will be used to connect to the Windows PowerShell Remoting service. Here is what an example Windows machine might look like:</p><div><pre class="programlisting">
<strong>[windows]</strong>
<strong>dc.ad.example.com</strong>
<strong>web01.ad.example.com</strong>
<strong>web02.ad.example.com</strong>

<strong>[windows:vars]</strong>
<strong>ansible_connection=winrm</strong>
<strong>ansible_ssh_user=daniel</strong>
<strong>ansible_ssh_pass=s3cr3t</strong>
<strong>ansible_ssh_port=5986</strong>
</pre></div><p>For security <a id="id28" class="indexterm"/>reasons, you probably will not want to store the <a id="id29" class="indexterm"/>password in the inventory file. You can make Ansible prompt for the password the same way we showed previously for Unix systems by simply leaving off the <code class="literal">ansible_ssh_user</code> and <code class="literal">ansible_ssh_pass</code> variables and instead using the <code class="literal">-k</code> and <code class="literal">-u</code> arguments to Ansible if you wish. You might also choose to store them in an Ansible vault, which will be covered later in the book.</p><p>After you have created the inventory, you need to install the winrm Python library on the controller machine. This library will give Ansible the ability to connect to the Windows Remote Management service and configure a remote Windows system.</p><p>At the moment, this library is fairly experimental, and its connection to Ansible isn't quite perfect, so you have to install the particular version that matches the version of Ansible you are using. With the release of Ansible 1.8, this should sort things out a little bit. Most distributions do not have a packaged library yet, so you will probably want to install it via pip. As root, you need to run:</p><div><pre class="programlisting">
<strong>$ pip install https://github.com/diyan/pywinrm/archive/df049454a9309280866e0156805ccda12d71c93a.zip</strong>
</pre></div><p>However, for newer versions, you should simply be able to run:</p><div><pre class="programlisting">
<strong>pip install http://github.com/diyan/pywinrm/archive/master.zip</strong>
</pre></div><p>This will install the particular version of winrm that works with Ansible 1.7. For other newer versions of Ansible, you may need a different version, and eventually the winrm Python library should be packaged up by different distributions. Your machine will now be able to connect to and manage Windows machines with Ansible.</p><p>Next you have to perform a few setup steps on the machine you are going to manage. The first of these is to make sure that you have PowerShell 3.0 or later installed. You can check what version you have installed with the following command:</p><div><pre class="programlisting">
<strong>$PSVersionTable.PSVersion.Major</strong>
</pre></div><p>If the value you get back is not 3 or higher than 3, then you will need to upgrade your version of PowerShell. You can choose to do this manually by downloading and installing the latest Windows Management Framework for your system, or you can use a script provided by the Ansible project. To save space, we will be explaining the scripted installation here; the manual installation is left as an exercise for the reader.</p><div><pre class="programlisting">
<strong>Invoke-WebRequest https://raw.githubusercontent.com/ansible/ansible/release1.7.0/examples/scripts/upgrade_to_ps3.ps1 -OutFile upgrade_to_ps3.ps1</strong>
<strong>.\upgrade_to_ps3.ps1</strong>
</pre></div><p>The first<a id="id30" class="indexterm"/> command downloads the upgrade script from the <a id="id31" class="indexterm"/>Ansible project repository on GitHub and saves it to disk. The second command will detect your operating system to download the correct version of the Windows Management Framework and install it.</p><p>Next you need to configure the Windows Remote Management Service. The Ansible project provides a script that will configure Windows Remote Management automatically in the way that Ansible expects it to be configured. While you can set it up manually, it is highly recommended that you use this script instead to prevent misconfiguration. To download and run this script, open a PowerShell terminal and run the following commands:</p><div><pre class="programlisting">
<strong>Invoke-WebRequest https://raw.githubusercontent.com/ansible/ansible/release1.7.0/examples/scripts/ConfigureRemotingForAnsible.ps1 -OutFile ConfigureRemotingForAnsible.ps1</strong>
<strong>.\ConfigureRemotingForAnsible.ps1</strong>
</pre></div><p>The first command downloads the configuration script from the Ansible project on GitHub, and the second command runs it. You should receive the output <code class="literal">Ok</code> from the second script if everything worked correctly.</p><p>You should now be able to connect to your machine and configure it with Ansible. As we did earlier, let's run a ping command to confirm that Ansible is able to execute its modules remotely. While Unix machines can use the <code class="literal">ping</code> module, Windows machines use the <code class="literal">win_ping</code> module. The usage is almost exactly the same; however, as we've added the password to the inventory file, you don't need the <code class="literal">-k</code> option.</p><div><pre class="programlisting">
<strong>$ ansible web01.ad.example.com -u daniel -m win_ping</strong>
</pre></div><p>If everything works correctly, you should see the following output:</p><div><pre class="programlisting">
<strong>web01.ad.example.com | success &gt;&gt; {</strong>
<strong>    "changed": false,</strong>
<strong>    "ping": "pong"</strong>
<strong>}</strong>
</pre></div><p>The output indicates that Ansible was able to connect to the Windows Remote Management Service, login successfully, and execute a module on the remote host. If this works correctly, then you should be able to use all the other Windows modules to manage your machine.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>First steps with Ansible</h1></div></div></div><p>Ansible <a id="id32" class="indexterm"/>modules<a id="id33" class="indexterm"/> take arguments in key-value pairs that look similar to <code class="literal">key=value</code>, perform a job on the remote server, and return information about the job as <code class="literal">JSON</code>. The key-value pairs allow the module to know what to do when requested. They can be hardcoded values, or in playbooks they can use variables, which will be covered in <a class="link" title="Chapter 2. Simple Playbooks" href="part0020.xhtml">Chapter 2</a>, <em>Simple Playbooks</em>. The data returned from the module lets Ansible know if anything changed in the managed host or if any information kept by Ansible should be changed afterwards.</p><p>Modules are usually run within playbooks, as this lets you chain many together, but they can also be used on the command line. Previously, we used the <code class="literal">ping</code> command to check that Ansible had been correctly setup and was able to access the configured node. The <code class="literal">ping</code> module<a id="id34" class="indexterm"/> only checks that the core of Ansible is able to run on the<a id="id35" class="indexterm"/> remote machine, but effectively does nothing.</p><p>A slightly more useful module is named <code class="literal">setup</code>. This module connects to the configured node, gathers data about the system, and then returns those values. This isn't particularly handy for us while running from the command line. However, in a playbook, you can use the gathered values later in other modules.</p><p>To run Ansible from the command line, you need to pass two things, though usually three. First is a host pattern to match the machine that you want to apply the module to. Second you need to provide the name of the module that you wish to run and optionally any arguments that you wish to give to the module. For the host pattern, you can use a group name, a machine name, a glob, and a tilde (~), followed by a regular expression matching hostnames. Alternatively, to symbolize all of these, you can either use the word <code class="literal">all</code> or simply <code class="literal">*</code>. Running Ansible modules on the command line this way is referred to as an ad hoc Ansible command.</p><p>To run <a id="id36" class="indexterm"/>the <code class="literal">setup</code> module on one of your nodes, you need the following<a id="id37" class="indexterm"/> command line:</p><div><pre class="programlisting">
<strong>$ ansible machinename -u root -k -m setup</strong>
</pre></div><p>The <code class="literal">setup</code> module will then connect to the machine and give you a number of useful facts back. All the facts provided by the <code class="literal">setup</code> module itself are prepended with <code class="literal">ansible_</code> to differentiate them from variables.</p><p>This module will work on both Windows and Unix machines. Currently, Unix machines will give much more information than a Windows machine. However, as new versions of Ansible are released, you can expect to see more Windows functionality get included along with Ansible.</p><div><pre class="programlisting">
<strong>machinename | success &gt;&gt; {</strong>
<strong>    "ansible_facts": {</strong>
<strong>        "ansible_distribution": "Microsoft Windows NT 6.3.9600.0",</strong>
<strong>        "ansible_distribution_version": "6.3.9600.0",</strong>
<strong>        "ansible_fqdn": "ansibletest",</strong>
<strong>        "ansible_hostname": "ANSIBLETEST",</strong>
<strong>        "ansible_ip_addresses": [</strong>
<strong>            "100.72.124.51",</strong>
<strong>            "fe80::1fd:fc3b:1eff:350d"</strong>
<strong>        ],</strong>
<strong>        "ansible_os_family": "Windows",</strong>
<strong>        "ansible_system": "Win32NT",</strong>
<strong>        "ansible_totalmem": "System.Object[]"</strong>
<strong>    },</strong>
<strong>    "changed": false</strong>
<strong>}</strong>
</pre></div><p>The following is<a id="id38" class="indexterm"/> a table of the most common values you will use; not all of<a id="id39" class="indexterm"/> these will be available on all machines. Windows machines especially return a lot less data from the setup module.</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Field</p>
</th><th valign="bottom">
<p>Example</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">ansible_architecture</code>
</p>
</td><td valign="top">
<p>x86_64</p>
</td><td valign="top">
<p>This is <a id="id40" class="indexterm"/>the architecture of the managed machine</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_distribution</code>
</p>
</td><td valign="top">
<p>CentOS</p>
</td><td valign="top">
<p>This<a id="id41" class="indexterm"/> is the Linux or Unix distribution on the managed machine</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_distribution_version</code>
</p>
</td><td valign="top">
<p>6.3</p>
</td><td valign="top">
<p>This<a id="id42" class="indexterm"/> is the version of the preceding distribution</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_domain</code>
</p>
</td><td valign="top">
<p>example.com</p>
</td><td valign="top">
<p>This <a id="id43" class="indexterm"/>is the domain name part of the server's hostname</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_fqdn</code>
</p>
</td><td valign="top">
<p>machinename.example.com</p>
</td><td valign="top">
<p>This <a id="id44" class="indexterm"/>is the fully qualified domain name of the managed machine</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_interfaces</code>
</p>
</td><td valign="top">
<p>["lo", "eth0"]</p>
</td><td valign="top">
<p>This is<a id="id45" class="indexterm"/> a list of all the interfaces the machine has, including the loopback interface</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_kernel</code>
</p>
</td><td valign="top">
<p>2.6.32-279.el6.x86_64</p>
</td><td valign="top">
<p>This<a id="id46" class="indexterm"/> is the kernel version installed on the managed machine</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_memtotal_mb</code>
</p>
</td><td valign="top">
<p>996</p>
</td><td valign="top">
<p>This is <a id="id47" class="indexterm"/>the total memory in megabytes available on the managed machine</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_processor_count</code>
</p>
</td><td valign="top">
<p>1</p>
</td><td valign="top">
<p>These<a id="id48" class="indexterm"/> are the total number of CPUs available on the managed machine</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_virtualization_role</code>
</p>
</td><td valign="top">
<p>guest</p>
</td><td valign="top">
<p>This <a id="id49" class="indexterm"/>determines whether the machine is a guest or a host machine</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">ansible_virtualization_type</code>
</p>
</td><td valign="top">
<p>kvm</p>
</td><td valign="top">
<p>This<a id="id50" class="indexterm"/> is the type of virtualization setup on the managed machine</p>
</td></tr></tbody></table></div><p>On a Unix machine, these variables are gathered using Python from the managed machine; if you have facter or ohai installed on the remote node, the <code class="literal">setup</code> module will execute them and <a id="id51" class="indexterm"/>return their data as well. As with other facts, ohai facts are<a id="id52" class="indexterm"/> prepended with <code class="literal">ohai_</code> and facter facts with <code class="literal">facter_</code>. While the setup module doesn't appear to be too useful on the command line, it is useful once you start writing playbooks. Note that facter and ohai are not available in Windows hosts.</p><p>If all the modules in Ansible do as little as the <code class="literal">setup</code> and the <code class="literal">ping</code> module, we will not be able to change anything on the remote machine. Almost all of the other modules that Ansible provides, such as the <code class="literal">file</code> module, allow us to actually configure the remote machine.</p><p>The <code class="literal">file</code> module <a id="id53" class="indexterm"/>can be called with a single path argument; this will <a id="id54" class="indexterm"/>cause it to return information about the file in question. If you give it more arguments, it will try and alter the file's attributes and tell you if it has changed anything. Ansible modules will tell you if they have changed anything, which becomes more important when you are writing playbooks.</p><p>You can call the <code class="literal">file</code> module, as shown in the following command, to see details about <code class="literal">/etc/fstab</code>:</p><div><pre class="programlisting">
<strong>$ ansible machinename -u root -k -m file -a 'path=/etc/fstab'</strong>
</pre></div><p>The preceding command should elicit a response like the following:</p><div><pre class="programlisting">
<strong>machinename | success &gt;&gt; {</strong>
<strong>  "changed": false,</strong>
<strong>  "group": "root",</strong>
<strong>  "mode": "0644",</strong>
<strong>  "owner": "root",</strong>
<strong>  "path": "/etc/fstab",</strong>
<strong>  "size": 779,</strong>
<strong>  "state":</strong>
<strong>  "file"</strong>
<strong>}</strong>
</pre></div><p>Alternatively, the response could be something like the following command to create a new test directory in <code class="literal">/tmp</code>:</p><div><pre class="programlisting">
<strong>$ ansible machinename -u root -k -m file -a 'path=/tmp/teststate=directory mode=0700 owner=root'</strong>
</pre></div><p>The preceding command should return something like the following:</p><div><pre class="programlisting">
<strong>machinename | success &gt;&gt; {</strong>
<strong>  "changed": true,</strong>
<strong>  "group": "root",</strong>
<strong>  "mode": "0700",</strong>
<strong>  "owner": "root",</strong>
<strong>  "path": "/tmp/test",</strong>
<strong>  "size": 4096,</strong>
<strong>  "state": "directory"</strong>
<strong>}</strong>
</pre></div><p>We can see that the changed variable is set to <code class="literal">true</code> in the response, because the directory doesn't exist or has different attributes and changes were required to make it match the state given by the provided arguments. If it is run a second time with the same arguments, the value of changed will be set to <code class="literal">false</code>, which means that the module did not make any changes to the system.</p><p>There are <a id="id55" class="indexterm"/>several modules that accept similar arguments to the <code class="literal">file</code> module, and <a id="id56" class="indexterm"/>one such example is the <code class="literal">copy</code> module. The <code class="literal">copy</code> module takes a file on the controller machine, copies it to the managed machine, and sets the attributes as required. For example, to copy the <code class="literal">/etc/fstab</code> file to <code class="literal">/tmp</code> on the managed machine, you will use the following command:</p><div><pre class="programlisting">
<strong>$ ansible machinename -m copy -a 'src=/etc/fstab dest=/tmp/fstab'</strong>
</pre></div><p>The preceding command, when run the first time, should return something like the following:</p><div><pre class="programlisting">
<strong>machinename | success &gt;&gt; {</strong>
<strong>  "changed": true,</strong>
<strong>  "dest": "/tmp/fstab",</strong>
<strong>  "group": "root",</strong>
<strong>  "md5sum": "fe9304aa7b683f58609ec7d3ee9eea2f",</strong>
<strong>  "mode": "0700",</strong>
<strong>  "owner": "root",</strong>
<strong>  "size": 637,</strong>
<strong>  "src": "/root/.ansible/tmp/ansible-1374060150.96- 77605185106940/source",</strong>
<strong>  "state": "file"</strong>
<strong>}</strong>
</pre></div><p>There is also <a id="id57" class="indexterm"/>a module named <code class="literal">command</code> that will run any arbitrary command<a id="id58" class="indexterm"/> on the managed machine. This lets you configure it with any arbitrary command, such as a <code class="literal">preprovided</code> installer or a self-written script; it is also useful for rebooting machines. Note that this module does not run the command within the shell, so you cannot perform redirection, use pipes, expand shell variables, or background commands.</p><p>Ansible modules strive to prevent changes being made when they are not required. This is referred to as idempotency and can make running commands against multiple servers much faster. Unfortunately, Ansible cannot know if your command has changed anything or not, so to help it be more idempotent, you have to give it some help. It can do this either via the <code class="literal">creates</code> or the <code class="literal">removes</code> argument. If you give a <code class="literal">creates</code> argument, the command will not run if the filename argument exists. The opposite is true of the <code class="literal">removes</code> argument; if the filename exists, the command will run.</p><p>You can run the command as follows:</p><div><pre class="programlisting">
<strong>$ ansible machinename -m command -a 'rm -rf /tmp/testing removes=/tmp/testing'</strong>
</pre></div><p>If there is no file or directory named <code class="literal">/tmp/testing</code>, the command output will indicate that it was skipped, as follows:</p><div><pre class="programlisting">
<strong>machinename | skipped</strong>
</pre></div><p>Otherwise, if the file did exist, it will look like the following code:</p><div><pre class="programlisting">
<strong>ansibletest | success | rc=0 &gt;&gt;</strong>
</pre></div><p>Often it is better to use another module in place of the <code class="literal">command</code> module. Other modules offer more options and can better capture the problem domain they work in. For example, it would be much less work for Ansible and also the person writing the configurations to use the <code class="literal">file</code> module in this instance, since the <code class="literal">file</code> module will recursively delete something if the state is set to <code class="literal">absent</code>. So the preceding command would be equivalent to the following command:</p><div><pre class="programlisting">
<strong>$ ansible machinename -m file -a 'path=/tmp/testing state=absent'</strong>
</pre></div><p>If you need to use features usually available in a shell while running your command, you will need the <a id="id59" class="indexterm"/>
<code class="literal">shell</code> module. This way you can use redirection, pipes, or job<a id="id60" class="indexterm"/> back grounding. You can pick which shell to use with the executable argument. You can use the <code class="literal">shell</code> module as follows:</p><div><pre class="programlisting">
<strong>$ ansible machinename -m shell -a '/opt/fancyapp/bin/installer.sh &gt;/var/log/fancyappinstall.log creates=/var/log/fancyappinstall.log'</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Module help</h1></div></div></div><p>Unfortunately, we don't have enough space to cover every module that is available in Ansible; luckily though, Ansible includes a command name <code class="literal">ansible-doc</code> that can retrieve help<a id="id61" class="indexterm"/> information. All the modules included within <a id="id62" class="indexterm"/>Ansible have this data populated; however, with modules gathered from elsewhere you may find less help. The <code class="literal">ansible-doc</code> command also allows you to see a list of all modules available to you.</p><p>To get a list of all the modules that are available to you along with a short description of each type, use the following command:</p><div><pre class="programlisting">
<strong>$ ansible-doc -l</strong>
</pre></div><p>To see the help file for a particular module, you supply it as the single argument to <code class="literal">ansible-doc</code>. To see the help information for the <code class="literal">file</code> module, for example, use the following command:</p><div><pre class="programlisting">
<strong>$ ansible-doc file</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter, we have covered which installation type to choose for installing Ansible and how to build an inventory file to reflect your environment. After this we saw how to use Ansible modules in an ad hoc style for simple tasks. Finally we discussed how to learn which modules are available on your system and how to use the command line to get instructions for using a module.</p><p>In the next chapter, you will learn how to use many modules together in a playbook. This allows you to perform more complex tasks than you could do with single modules alone.</p></div></body></html>