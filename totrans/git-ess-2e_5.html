<html><head></head><body>
        

                            
                    <h1 class="header-title">Obtaining the Most - Good Commits and Workflows</h1>
                
            
            
                
<p>Now that we have acquired some familiarity with Git and versioning systems, it's time to look at the whole thing from a much higher perspective, to become aware of common patterns and procedures.</p>
<p>In this chapter, we will walk through some of the most common ways to organize and build meaningful commits and repositories, obtaining not only a well-organized code stack, but even a meaningful source of information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The art of committing</h1>
                
            
            
                
<p>While working with Git, committing seems the easiest part of the job: you add files, write a short comment, and then you're done. But it is just for its simplicity that often, especially at the very beginning of your experience, you acquire the bad habit of doing terrible commits: too late, too big, too short, or simply equipped with bad messages.</p>
<p>Now we will take some time to identify possible issues, like unmeaning or too large commits, drawing attention to tips and hints to get rid of those bad habits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the right commit</h1>
                
            
            
                
<p>One of the harder skills to acquire while programming in general is to <strong>split the work into small and meaningful tasks</strong>.</p>
<p>Too often, I have experienced this scenario: you start to fix a small issue in a file; then you see another piece of code that can be easily improved, even if it's not related to what you are working on now - you can't resist, and you fix it. At the end, and after some time, you find yourself with a ton of <strong>concurrent</strong> files and <strong>changes</strong> to commit.</p>
<p>At this point, <em>things get worse</em>, because usually <em>programmers are lazy people</em>, so they don't write all the important things to describe changes in the commit message. In commit messages, you start to write sentences like "<em>Some fixes to this and that</em>", "<em>Removed old stuff</em>", "<em>Tweaks</em>" and so on, without anything that helps other programmers to understand what you have done:</p>
<div><img height="185" width="325" class=" image-border" src="img/50475693-9b9d-4707-95e2-1c09c796c2a2.png"/></div>
<p>Courtesy of http://xkcd.com/1296/</p>
<p>At the end, you realize <em>your repository is only a dump</em>, where you empty your index only now and then. I have seen some people committing only at the end of the day (and not every day), only to keep a backup of the data or because someone else needed the changes reflected on their computer.</p>
<p>Another side effect is that the resulting <em>repository history becomes useless</em> for anything other than retrieving the contents at a given point in time.</p>
<p>The following tips can help you turn your VCS from a backup system into <em>a valuable tool for communication and documentation</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making only one change per commit</h1>
                
            
            
                
<p>After the routine morning coffee, you open your editor and then you start to work on a bug: <kbd>BUG42</kbd>. Working around fixing the bug in the code, you realize that fixing <kbd>BUG79</kbd> will require tweaking just a single line of code, so you fix it, but you not only change that awful class name, but also add a good-looking label to the form and make a few more changes. <em>The damage is done now</em>.</p>
<p>How can you now wrap up all that work in a <em>meaningful commit</em>? Maybe in the meantime you went home for lunch, talked to your boss about another project, and even you can't remember exactly all the little things you did.</p>
<p>In this scenario, there is only one way to <strong>limit the damage</strong>: <em>split files to commit in more than one commit</em>. Sometimes this helps to reduce the pain, but it is only a <em>palliative</em>: too often you modify the same file for <em>different reasons</em>, so doing that is quite difficult, if not impossible.</p>
<p>The only way to solve this problem completely is to <strong>only make one change per commit</strong>. It seems easy, I know, but is quite difficult to acquire this ability. There are no tools for it; no one but you can help, as it requires <strong>discipline</strong>, <em>the most lacking virtue in creative people</em> (like programmers).</p>
<p>There are some tips to pursue this aim; let's have a look at them together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Splitting up features and tasks</h1>
                
            
            
                
<p>As said before, breaking up things to do is a fine art. If you know and adopt some <strong>Agile Movement</strong> techniques, you have probably faced these problems already, so you have an advantage; otherwise you will need to make a little more effort, but it isn't anything you can't achieve.</p>
<p>Consider you have been assigned to add the Remember Me check in the login page of a web application, like the following one:</p>
<div><img height="291" width="255" class=" image-border" src="img/af4909e1-428d-43b8-815d-65279b2b290a.png"/></div>
<p>This feature is quite small, but implies changes at different levels. To accomplish this, you'll have to:</p>
<ol>
<li>Modify the UI to add the check control.</li>
<li>Pass the <em>is checked</em> information through different layers.</li>
<li>Store this information somewhere.</li>
<li>Retrieve this information when needed.</li>
<li>Invalidate (set it to false) following some kind of policy (after 15 days, after 10 logins, and so on).</li>
</ol>
<p>Do you think you can do all these things in a shot? Yes? You are wrong! Even if you estimate a couple of hours for an ordinary task, remember that Murphy's Law applies: you will receive four calls, your boss will look for you for three different meetings and your computer will go up in flames.</p>
<p>This is one of the first things to learn: <strong>break up every piece of work into small tasks</strong>. No matter if you use time-boxing techniques like the <em>Pomodoro Technique</em> or not, small things are easier to handle. I'm not talking about splitting hairs, but try to organize your tasks into things you can do in a defined amount of time, hopefully a bunch of half-hours, not days.</p>
<p>For more information on the Pomodoro Technique you can visit <a href="https://cirillocompany.de/pages/pomodoro-technique">https://cirillocompany.de/pages/pomodoro-technique</a><br/>
or Wikipedia <a href="https://en.wikipedia.org/wiki/Pomodoro_Technique">https://en.wikipedia.org/wiki/Pomodoro_Technique</a></p>
<p>So, <em>take paper and a pen and write down all the tasks</em>, as we did before with the login page example. Do you think now you can do all those things in a small amount of time? Maybe yes, maybe not: some tasks are bigger than others. That's okay, this is not a scientific method, <em>it's a matter of experience</em>; can you split a task, creating two other meaningful tasks? Do it.</p>
<p>Can you? No problem, <em>don't try to split tasks if they lose meaning</em>.</p>
<p>Make a little notebook, like the one in the following picture - it will become one of your most precious tools:</p>
<div><br/>
<img height="235" width="204" class="alignnone size-full wp-image-138 image-border" src="img/b995efc5-b09e-48be-a21d-469d020de539.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing commit messages before starting to code</h1>
                
            
            
                
<p>Now you have a list of tasks to do; pick the first and... Start to code? No! Take another piece of paper and <strong>describe every task's step with a sentence</strong>; magically you will realize that every sentence can be the message of a single commit, where you describe features you deleted, added, or changed in your software.</p>
<p>This kind of prior preparation helps you in <em>defining modifications to implement</em> (letting <em>better software design</em> emerge), <em>focusing on what matters,</em> and <em>lowering the stress</em> to think about the versioning part of the work during the coding session. While you are facing a programming problem, your brain floods with little implementation details related to the code you are working on, so the fewer distractions, the better.</p>
<p>This is one of the best versioning related hints I ever received: if you have just quarter of an hour of spare time, I recommend reading the <em>Preemptive commit comments</em> blog post at <a href="https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/">https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/</a> by <em>Arialdo Martini</em>, which is where I learnt this trick.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Including the whole change in one commit</h1>
                
            
            
                
<p>Making more than one change per commit is a bad thing, but even splitting a single change into more than one commit is considered harmful. As you may already know, in some trained teams you do not simply push your code to production; first you have to pass <em>code quality reviews</em>, where someone else tries to understand what you did to decide if your code is good or not (that is why there are <em>pull requests</em>, indeed). You can be the best developer in the world, but if the person at the other end can't get a sense of your commits, your work will probably be refused.</p>
<p>To avoid these unpleasant situations, you have to follow a simple rule: <strong>don't do partial commits</strong>. If time's up, if you have to go to that damn meeting (programmers hate meetings) or whatever, remember that you can save your work at any moment without committing, using the <kbd>git stash</kbd> command. If you want to close the commit, because you want to push it to the remote branch for backup purposes, remember that <em>Git is not a backup tool</em>: backup your stash on another disk, put it in the cloud, or simply end your work before leaving, but don't do commits like they are episodes of a TV series.</p>
<p>One more time, Git is a software tool like any other, and even it can fail: don't think that by using Git or other versioning systems you don't need backup strategies - backup local and remote repositories just the same as you backup all the other important things.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Describing the change, not what have you done</h1>
                
            
            
                
<p>Too often I read (and more often I wrote) commit messages like "<em>Removed this</em>", "<em>Changed that</em>", "<em>Added that one</em>" and so on.</p>
<p>Imagine you are going to work on the common "<em>lost password</em>" feature on your website; you'll probably find a message like this adequate: "<em>Added the lost password retrieval link to the login page</em>". This kind of commit message does not describe what modifications the feature brings to you, but what you did (and not everything you did). Try to answer sincerely: reading a repository history, do you want to read what every developer did? Or maybe it's better to read the feature implemented in every single commit?</p>
<p>Try to make the effort, and <strong>start writing sentences where the change itself is the subject</strong>, not what you did to implement it. <em>Use the imperative present tense</em> (for example, <em>fix</em>, <em>add</em>, or <em>implement</em>), describing the change in a small subject sentence, and then add some details (when needed) in other lines of text; "<em>Implement the password retrieval mechanism</em>" is a good commit message subject; if you find it useful then you can add some other information to get a well-formed message, like this:</p>
<pre>"Implement the password retrieval mechanism 
 
 - Add the "Lost password?" link into the login page<br/> - Send an email to the user with a link to renew the password" </pre>
<p>Have you ever written a <em>changelog</em> for software by hand? I did, and it's one of the most boring things to do. If you don't like writing changelogs, like me, think of the repository history as your changelog: if you take the right care of your commit messages, you will get a beautiful changelog for free!</p>
<p>In the next paragraph, I will cover some other useful hints about good commit messages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Don't be afraid to commit</h1>
                
            
            
                
<p>Fear is one of the most powerful of emotions; it can drive a person to do the craziest things on Earth. One of the most common reactions to fear is the <strong>breakdown</strong>: <em>you don't know what to do, so you end up doing nothing</em>.</p>
<p>This is a common reaction even when you begin to use a new tool like Git, where gaining confidence can be difficult; because of the fear of making a mistake, you don't commit until you are obligated. <strong>This is the real mistake: being scared</strong>. In Git, you don't have to be scared; maybe the solution is not obvious, and maybe you have to dig on the internet to find the right way, but you can get away with small or no consequences, ever (well, unless you are a hard user of the <kbd>--hard</kbd> option).</p>
<p>On the contrary, you have to make the effort to <strong>commit often</strong>, as soon as possible. The more frequently you commit, the smaller your commits; the smaller your commits, the easier it is to read and understand the changelog, and the easier it is to cherry-pick commits, and do code reviews. To help myself get used to committing this way, I followed this simple trick: write the commit message in Visual Studio before starting to write any code:</p>
<div><img height="151" width="327" class=" image-border" src="img/f6d93f81-a85c-4a64-8b10-7a339797c513.png"/></div>
<p>Try to do the same in your IDE or directly in the Bash shell, it helps a lot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Isolating meaningless commits</h1>
                
            
            
                
<p>The golden rule is to avoid them, but sometimes you need to commit <em>something that is not a real implementation</em>, but only a clean-up, like old comments deletion, formatting rearrangement, and so on.</p>
<p>In these cases, it is better to isolate these kind of code changes in separated commits. By doing this you prevent another team member from running towards you with a knife in his hand, frothing at the mouth. Don't commit meaningless changes, mixing them up with real ones, otherwise other developers (and you, after a couple of weeks) will not understand them while diffing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The perfect commit message</h1>
                
            
            
                
<p>Let me be honest: the perfect message does not exist. If you work alone, you probably find the best way for you, but when in a team there are different minds and different sensibilities, so what is good for me might not be as good for somebody else.</p>
<p>In this case you have to sit down around a table and make a retrospective, trying to end up with a shared standard; it may not be the one you prefer, but at least it's a way to find a common path.</p>
<p>Rules for a good commit message really depend on the way you and your team work day by day, but some common hints can be applied by everyone; here they are.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing a meaningful subject</h1>
                
            
            
                
<p>The subject of a commit is the most important part: its role is to make clear what the commit contains. Avoid technical details of other things - a common developer can understand opening the code, and focus on the big picture: remember that every commit is a sentence on the repository history. So, wear the hat of the changelog reader and try to write the most convenient sentence for him, not for you: use present tense, and write a 50 chars max sentence.</p>
<p>A good subject is one like this: "<em>Add the newsletter signup in homepage</em>".</p>
<p>As you can see, I used the <em>imperative past tense</em> and, more importantly, <em>I didn't say what I had done, but what the feature does</em>: it adds a newsletter signup box to my website.</p>
<p>The 50-char rule is due to the way you use Git from the shell or GUI tools; if you start to write long sentences, reviewing logs and so on can become a nightmare. So, don't try to be the <em>Stephen King</em> of commit messages: avoid adjectives and get straight to the point, you can then go more in-depth in the additional details lines.</p>
<p>One more thing: start with capital letters, and do not end sentences with periods - they are useless, and even dangerous.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding bulleted details lines when needed</h1>
                
            
            
                
<p>Often you can say all that you want in 50 chars; in that case, use details lines. In this situation, the common rule is to <em>leave a blank line after the subject</em>, use a dash and go no longer than 72 chars:</p>
<pre>"
Add the newsletter signup in homepage<br/>
- Add textbox and button on homepage
- Implement email address validation
- Save email in database"
  </pre>
<p>In these lines go a little bit in depth, but not too much; try to describe the original problem (if you fixed it) or the original need, why this functionality has been implemented (what problem has been solved) and any possible limitations or known issues.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tying other useful information</h1>
                
            
            
                
<p>If you use issue and project tracking systems, write down the issue number, bug id's, or anything else helpful:</p>
<pre><strong>"
Add the newsletter signup in homepage<br/>
- Add textbox and button on homepage
- Implement email address validation
- Save email in database <br/>
#FEAT-123: closed"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Special messages for releases</h1>
                
            
            
                
<p>Another useful thing is to write <em>special format</em> commit messages for releases, so it will be easier to find them. I usually decorate subjects with some special characters, but nothing more; for highlighting a particular commit, like a release one, there is the <kbd>git tag</kbd> command, remember?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conclusions</h1>
                
            
            
                
<p>At the end, my suggestion is to try to compose your personal commit message standard, following previous hints and looking at message strategies adopted by great projects and teams around the web, but especially by doing it. Your standard will change for sure, as you evolve as a software developer and Git user, so start as soon as possible and let the time help you find the perfect way to write a commit message.</p>
<p>At least, don't imitate this link: <a href="http://www.commitlogsfromlastnight.com">http://www.commitlogsfromlastnight.com</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adopting a workflow - a wise act</h1>
                
            
            
                
<p>Now that we learnt how to perform good commits, it's time to fly higher and think of <strong>workflows</strong>. Git is a tool for versioning, but as with other powerful tools like knives, you can cut tasty sashimi or get hurt.</p>
<p>The thing that separates a great repository from a junkyard is the way you manage releases, the way you react when there is a bug to fix in particular version of your software, and the way you act when you have to make users able to beta-test incoming features.</p>
<p>These kinds of actions belong to ordinary administration for a modern software project, but too often I see teams out of breath because of the poor versioning workflows.</p>
<p>In this second part of the chapter, we will take a quick look at some of the most used workflows together with the Git versioning system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Centralized workflows</h1>
                
            
            
                
<p>As we used to do in other VCS like Subversion or so, even in Git it is not uncommon to adopt a <em>centralized way of working</em>. If you work in a team, it is often necessary to share repositories with others, so a <em>common point of contact</em> becomes indispensable.</p>
<p>We can assume that if you are not alone in your office, you will adopt one of the variations of this workflow. As we know, we can configure to get all the computers of our co-workers as remote, in a sort of <em>peer-to-peer</em> configuration, but you usually don't do this, because it quickly becomes too difficult to keep every branch in every remote in sync.</p>
<p>The scenario is represented in the following picture:</p>
<div><img height="257" width="199" class="alignnone size-full wp-image-139 image-border" src="img/7029acee-f6e4-45e3-b620-d69820f66a9e.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How they work</h1>
                
            
            
                
<p>In this scenario, you usually follow these simple steps:</p>
<ol>
<li>Someone initializes the remote repository (in a local Git server, on GitHub, BitBucket, or so on)</li>
</ol>
<p> </p>
<ol start="2">
<li>Other team members clone the original repository on their computer and start working</li>
<li>When the work is done, you push it to the remote to make it available to other colleagues</li>
</ol>
<p>At this point, it is only a matter of internal rules and patterns.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Feature branch workflow</h1>
                
            
            
                
<p>At this point, you will probably choose at least a <em>feature branch</em> approach, where every single developer works on his branch. When the work is done, the feature branch is ready to be merged onto the master branch; you will probably have to merge back from the <kbd>master</kbd> before, because one of your other colleagues has merged a feature branch after you started your one, but after that you basically have finished.</p>
<p>The following picture represents the branches evolution within the repository:</p>
<div><img height="241" width="434" class="alignnone size-full wp-image-140 image-border" src="img/9b537cf9-9883-4150-a33c-db9160770c74.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Gitflow</h1>
                
            
            
                
<p>The <strong>Gitflow</strong> workflow comes from the mind of <strong>Vincent Driessen</strong>, a passionate software developer from the Netherlands; you can find his original blog post about it at <a href="http://nvie.com/posts/a-successful-git-branching-model">http://nvie.com/posts/a-successful-git-branching-model</a>.</p>
<p>His workflow has gained success over the years, to the point that many other developers (including me!), teams, and companies are starting to use it. <em>Atlassian</em>, a well-known company that offers Git related services like <em>BitBucket</em>, integrates the Gitflow directly in their GUI tool, the nice <em>SourceTree</em>.</p>
<p>Even the Gitflow work flow is a centralized one, and it is well described by the following image:</p>
<div><img height="537" width="405" class=" image-border" src="img/80773189-8611-42ac-8788-9edd27562f0e.png"/></div>
<p>This workflow is based on the use of some <strong>main branches</strong>; what makes these branches special is nothing other than the significance we attribute to them: there are no <em>special branches</em> with <em>special characteristics</em> in Git, but we can certainly use them for different purposes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Master branch</h1>
                
            
            
                
<p>In Gitflow the <kbd>master</kbd> branch represents the final stage; merging your work in it is equal to making a <em>new release</em> of your software. You usually don't start new branches from the <kbd>master</kbd>; you do it only if there are severe bugs you have to fix instantly, even if that bug has been found and fixed in another evolving branch. This way of operating is superfast when you need to react to a painful situation. Other than that, the <kbd>master</kbd> branch is where you tag your release.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hotfixes branches</h1>
                
            
            
                
<p><strong>Hotfixes branches</strong> are branches derived only from the <kbd>master</kbd>, as we said before; once you have fixed a bug, you merge the <kbd>hotfix</kbd> branch onto the <kbd>master</kbd>, to enable you to get a new release to ship. If the bug has not been resolved anywhere else in your repository, the strategy is to merge the <kbd>hotfix</kbd> branch into the <kbd>develop</kbd> branch. After that, you can delete the <kbd>hotfix</kbd> branch, as it has hit the mark.</p>
<p>In Git, there is <em>a trick to grouping similar branches</em>: you have to name them using a common prefix followed by a slash <kbd>/</kbd>; for the hotfix branches, the author recommends the <kbd>hotfix/&lt;branchName&gt;</kbd> prefix (for example <kbd>hotfix/LoginBug</kbd> or <kbd>hotfix/#123</kbd> for those using bug tracking systems, where <kbd>#123</kbd> is the bug ID).</p>
<p>These branches are usually not pushed to remote; you push them only if you need the help of other team members.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The develop branch</h1>
                
            
            
                
<p>The <kbd>develop</kbd> branch is a sort of <em>staging</em> branch. When you start to implement a new feature, you have to create a new branch starting from <kbd>develop</kbd>; you will continue to work in that branch until you complete your task.</p>
<p>After the task completion, you can merge back to <kbd>develop</kbd> and delete your <kbd>feature</kbd> branch: as hotfix branches, these are only temporary branches.</p>
<p>Like the master one, the <kbd>develop</kbd> branch is a <strong>long living branch</strong>: you will never close nor delete it.</p>
<p>This branch is pushed and shared to a remote Git repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The release branch</h1>
                
            
            
                
<p>At some point, you need to wrap up the next release, including some of the features you implemented in the last few weeks. To prepare an incoming release you have to branch from <kbd>develop</kbd>, assigning the branch a name composed by the <kbd>release</kbd> prefix, followed by the numeric form of choice for your release (for example <kbd>release/1.0</kbd>).</p>
<p>Pay attention: <strong>at this stage, no new feature is allowed</strong>! You can no longer merge <kbd>develop</kbd> onto the <kbd>release</kbd> branch; you can create new branches from that branch only for bug-fixing; the purpose of this intermediate branch is to give the software to beta testers, allowing them to try it and send you feedback and bug tickets.</p>
<p>In case you have fixed some bug onto the <kbd>release</kbd> branch, the only thing to remember is to merge them into the <kbd>develop</kbd> branch, just to avoid the loss of the bug fix - the <kbd>release</kbd> branch will not be merged back to <kbd>develop</kbd>.</p>
<p>You can keep this branch alive as long as you want, until you decide the software is both mature and tested sufficiently to go into production: at this point you merge the <kbd>release</kbd> branch onto the <kbd>master</kbd> branch, making a new release.</p>
<p>After the merge to the <kbd>master</kbd> you have a choice: keep the <kbd>release</kbd> branch open, if you need to keep different releases alive, otherwise you can delete it. Personally, I always delete the <kbd>release</kbd> branch (as Vincent suggests), because I generally do frequent, small, and incremental releases (so I rarely need to fix an already shipped release) and because, as you certainly remember, you can open a brand-new branch from a commit (a tagged one in this case) whenever you want so, at the most, I will open it from that point only when necessary.</p>
<p>This branch is pushed and shared to a common remote repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The feature branches</h1>
                
            
            
                
<p>When you have to start the implementation of a new feature, you have to create a new branch from the <kbd>develop</kbd> branch. Feature branches start with the <kbd>feature/</kbd> prefix (for example <kbd>feature/NewAuthenitcation</kbd> or <kbd>feature/#987</kbd> if you use some features tracking software, as <kbd>#987</kbd> is the feature ID).</p>
<p>You will work on the feature release until you finish your work; I suggest you <em>frequently merge back</em> from <kbd>develop</kbd>: in case of concurrent modifications to the same files, you will resolve conflicts faster if you will resolve them earlier; then it is easier to resolve one or two conflicts at a time, rather than dozens at the end of the feature work.<br/>
Once your work is done, you merge the feature onto <kbd>develop</kbd> and you are done; you can now delete the <kbd>feature</kbd> branch.</p>
<p>Feature branches are mainly private branches, but you can push them to the remote repository in case you have to collaborate on it with some other team mates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conclusion</h1>
                
            
            
                
<p>I really recommend taking a look at this workflow, as I can assure you there were no situations I have failed to solve using solve using it.<br/>
You can find a deeper explanation, with Git commands ready to use, on <strong>Vincent Driessen</strong><strong>'s</strong> already cited blog. You can even use the <em>gitflow commands</em> Vincent made to customize his Git experience; check these out on his GitHub account at <a href="https://github.com/nvie/gitflow">https://github.com/nvie/gitflow</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">GitHub flow</h1>
                
            
            
                
<p>The previously described <em>GitFlow</em> has tons of followers, but it's always a matter of taste; someone else found it too complex and rigid for their situation, and in fact there are other ways to manage software repositories that have gained consensus during the last few years.</p>
<p>One of these is the workflow used at GitHub for internal projects and repositories; this workflow takes the name of <strong>GitHub flow</strong> and it has been firstly described by the well-known <strong>Scott Chacon</strong>, former GitHubber and <em>ProGit</em> book author, on his blog at <a href="http://scottchacon.com/2011/08/31/github-flow.html">http://scottchacon.com/2011/08/31/github-flow.html</a>.</p>
<p>This workflow, compared to Gitflow, is better tailored for frequent releases, and when I say frequent, I mean very frequently, even twice a day. Obviously, this kind of flow works better on web projects, because to deploy you have to <em>only</em> put the new release on the production server; if you develop desktop solutions, you need a perfectly oiled update mechanism to do the same.</p>
<p>GitHub software basically doesn't have releases, because they deploy to production regularly, even more than once a day. This is possible due to a robust <em>Continuous Delivery</em> structure, which is not so easy to obtain; it requires some effort.</p>
<p>The GitHub flow is based on these simple rules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Anything in the master branch is deployable</h1>
                
            
            
                
<p>Similar to GitFlow, even here in GitHub flow, deploy is done from the <kbd>master</kbd> branch.<br/>
This is the only <em>main</em> branch in this flow; in Gitflow there are no <kbd>hotfix</kbd>, <kbd>develop,</kbd> or other particular branches. Bug fixes, new implementations and so on are constantly merged onto the <kbd>master</kbd> branch.</p>
<p>Other than this, code in the <kbd>master</kbd> branch is always in a <em>deployable</em> state; when you fix or add something new in a branch and then you merge it onto the <kbd>master</kbd>, you don't deploy automatically, but you can assume you changes will be up and running in a matter of hours.</p>
<p>Branching and merging constantly to the <kbd>master</kbd>, the production-ready branch, can be dangerous: you can easily introduce regressions or bugs, as no one other than you can check you have done a good job. This problem is avoided by a <em>social contract</em> commonly adopted by GitHub developers; in this contract, you promise to test your code before merging it to the <kbd>master</kbd>, assuring you that all automated tests have been successfully completed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating descriptive branches off of master</h1>
                
            
            
                
<p>In GitFlow you always branch from the <kbd>master</kbd>, so it's easy to get a forest of branches to look at when you have to pull one. To better identify them, in GitHub flow you have to use descriptive names to get meaningful <em>topic branches</em>. Even here it is a matter of good manners; if you start to create branches named <em>stuff-to-do</em> you will probably fail in adopting this flow. Some examples are <kbd>new-user-creation, most-starred-repositories,</kbd> and so on (note the use of the <strong>Kebab Case</strong>, <a href="http://wiki.c2.com/?KebabCase">http://wiki.c2.com/?KebabCase</a>); using a common way to define topics, you will easily find branches you are interested in by looking for topics' keywords.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pushing to named branches constantly</h1>
                
            
            
                
<p>Another great difference when comparing GitHub flow to Gitflow is that in GitHub flow you push feature branches to the remote regularly, even if you are the only developer involved and interested. This is done for continuous integration and testing, or maybe also for backup purposes; regarding the backup part, even if I already exposed my opinion in merit, I can't say this is a bad thing.</p>
<p>A thing I appreciate about Gitflow is that this habit of push every branch to the remote gives you the ability to see, with a simple <kbd>git fetch</kbd>, all the branches currently active, and so all the work in progress, even that of your team mates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Opening a pull request at any time</h1>
                
            
            
                
<p>In <a href="20e98db3-d248-436e-88d5-069be7808998.xhtml">Chapter 3</a>, <em>Git Fundamentals - Working Remotely,</em> we talked about GitHub and made a quick try with <em>Pull Requests</em>. We have seen that basically they are for <em>contributing</em>: you fork someone else's repository, create a new branch, make some modifications and then ask for a pull request from the original author.</p>
<p>In GitHub flow you use pull requests massively, even for asking another developer on your team to have a look at your work and help you, give you a hint, or review the work done. At this point you can start a discussion, using the GitHub pull request to chat and involving other people by putting in /CCing their username. In addition, the pull request feature lets you comment on even a single line of code in the diff view, making users involved able to discuss the work under revision.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Merging only after pull request review</h1>
                
            
            
                
<p>You can understand now that the <em>pull requested branch stage</em> we have seen above becomes a sort of <em>review stage</em>, where other users can take a look at the code and even simply leave a positive comment, just a <kbd>+1</kbd> to let other users know that they are confident about the job, and that they approve its merge into master.</p>
<p>After this step, when the CI server says the branch still passes all the automated tests, you are ready to merge the branch in <kbd>master</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deploying immediately after review</h1>
                
            
            
                
<p>At this stage, you merge your branch into <kbd>master</kbd> and the work is done. The deploy is not instantly fired, but at GitHub they have a very straight and robust deployment procedure, so they can do that easily. They deploy big branches with 50 commits but even branches with a single commit and a single line of code change, because deployment is very quick and cheap for them.</p>
<p>This is the reason why they can afford such a simple branching strategy, where you put on <kbd>master</kbd> and then you deploy without the need for passing through <kbd>develop</kbd> or <kbd>release</kbd> stage branches like in GitFlow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conclusions</h1>
                
            
            
                
<p>I consider this flow very responsive and effective for web based projects, where basically you deploy to production without much regard for the versions of your software. Using only the <kbd>master</kbd> branch to derive and integrate branches is faster than light, but this strategy can be applied only if you have these prerequisites:</p>
<ul>
<li>A centralized remote ready to manage pull requests (as GitHub does)</li>
<li>A good shared agreement about branch names and pull requests usage</li>
<li>A very robust deploy system</li>
</ul>
<p>This is a big picture of this flow, graphically represented in the following image; for more details, I recommend visiting the GitHub related page at <a href="https://guides.github.com/introduction/flow/index.html">https://guides.github.com/introduction/flow/index.html</a>:</p>
<div><img height="197" width="585" class=" image-border" src="img/a7c32beb-274c-427c-b1c7-1f76312b4207.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Trunk-based development</h1>
                
            
            
                
<p>These days, another strategy has regained a certain popularity among developers all around the world; its name says it all: <em>stop using branches</em>, use only the <em>master branch</em>!</p>
<p>In the picture below there's the essence of this flow:</p>
<div><img height="149" width="470" class="aligncenter size-full wp-image-84 image-border" src="img/6c32367b-6f99-4206-8add-3521d03c716a.png"/></div>
<p>This trend aims to fight the so called <em>merge hell</em>; this happens when branches diverge for too long, so merging them is a pain. Similar to the GitHub flow, here there aren't long living branches, but even feature branches are discouraged.</p>
<p>Continuous Integration and Continuous Delivery are under the light here, and this way of working really enforces these good practices we already know thanks to the <strong>eXtreme Programming</strong> (<a href="http://www.extremeprogramming.org/">http://www.extremeprogramming.org/</a>) mindset and practices.</p>
<p>This movement is too wide and deep to be discussed here in a couple of sentences, but it's worth reading its principles, as it makes you reflect on the topics a developer faces during his day by day work. So please take a minute and read more about it at <a href="http://trunkbaseddevelopment.com">trunkbaseddevelopment.com</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other workflows</h1>
                
            
            
                
<p>Obviously, there are many other workflows; I will spend just a moment on the one that (fortunately!) convinced Linus Torvalds to realize the Git VCS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Linux kernel workflow</h1>
                
            
            
                
<p>The <strong>Linux kernel</strong> uses a workflow that refers to the traditional way <strong>Linus Torvalds</strong> has driven its evolution during these years, based on a <em>military like hierarchy</em>.</p>
<p>Simple kernel developers work on their personal branches, rebasing the master branch on the reference repository, then push their branches to the <em>lieutenant developers </em><kbd>master</kbd> branch. Lieutenants are developers that Linus assigned to particular topics and areas of the kernel because of their experience. When a lieutenant has his work done, he pushes it to the <em>benevolent dictator </em><kbd>master</kbd> branch (Linus branch) and then if things are okay (it is not simple to cheat him), Linus pushes his master branch onto the <em>blessed repository</em>, the one the developers use to rebase from before starting their work.</p>
<p>This kind of workflow is not usual; Linus and the Linux kernel bandwagon crafted it as it exactly reflected the way they used to work on projects since the beginning, when developers used patches and email to forward their work to Linus Torvalds.</p>
<p>Having millions of lines of code to manage, and thousands of contributors, I find this hierarchy model to be a good compromise in terms of working scope, responsibility, and patches skimming.</p>
<p>The following picture helps you better understand this flow:</p>
<div><img height="290" width="389" class="aligncenter size-full wp-image-85 image-border" src="img/c336cf95-489a-415a-9efb-e0b763a79950.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we became aware of effective ways to use Git; I personally consider this chapter the most important for the <em>new Git user</em>, because it is only by applying some rules and discipline that you will obtain the most from this tool. So please pick up a good workflow (make your own, if necessary!), and pay attention to your commits: this is the only way to become a good versioning tool user, not only in Git.</p>
<p>In the next chapter, we will see some tips and tricks for using Git even if you have to deal with Subversion servers, and then we will take a quick look at migrating definitely from Subversion to Git.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>