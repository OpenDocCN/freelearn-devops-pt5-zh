- en: Extending Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible has matured over the years to support a wide variety of technologies,
    tools, operating systems, and processes. Its flexible architecture and modular
    implementation make it ideal for DevOps oriented groups with varying or diverse
    requirements. The extensible architecture that comprises Ansible was designed
    to support the creation of modules and expand the Ansible solution to fit the
    user's needs. As a result, Ansible itself and many of its now core modules derive
    from once available plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the years, Ansible's creators added numerous API hooks and architectures
    in an effort to support expanding Ansible itself via a wide variety of means.
    The end result of this effort was a highly extensible system, which was leveraged
    by developers to create a significant amounts of additional core functionality.
    A plugin system!
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, the Ansible plugin and module system have expanded out and taken
    a more central role in Ansible's core architecture. The once clumsily conglomerated
    extension system has been refined into a well-architected and implemented plugin
    solution. The once haphazardly implemented extension points have been refined
    to become a robust and highly capable module API. As a result of these improvements,
    the plugin and module systems have evolved significantly since its infantile stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to take a tour of the Ansible module and plugin
    architecture. We are going to explore the inner workings of the Ansible architecture
    and APIs. We are going to dive into Python development and leverage it to create
    some custom modules and plugin extensions that will enhance our Ansible implementations
    to support custom needs. Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ansible Plugins and its Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Up the Ansible Module Development Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a HelloWorld Ansible Module and Extending it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Up a Plugin Development Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Different Types of Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we embark on this quest to learn about the Ansible plugin system, take careful
    note of the syntax and formatting to ensure the code is kept clean and unambiguous.
    By following this general rule of thumb, you will learn how to create and deliver
    high-quality Ansible extensions. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ansible Plugins and its Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible''s implementation is highly modular. A modular architecture provides
    a high level of encapsulation (keeping concerns segregated and preventing them
    from cross-contaminating). The plugin solution within Ansible''s subsystems is
    architected in order to keep additions organized and encapsulated. This architecture
    is divided into distinct subsystems. The most critical subsystems for Ansible
    plugins and modules and modules are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Core modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible configs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible Python API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better describe the vague list just provided, the following diagram provides
    an illustrated view of the Ansible architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6ae4b76-d6a1-4f05-b680-91de26f31b8f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram highlights three of the most critical subsystems for Ansible
    plugin and module development. The **Core Modules**, the **Custom Modules**, and
    the **Ansible Python API**. This stack provides a comprehensive set of components
    for extending Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ansible, there are two distinct ways to extend the Ansible Core solution.
    These are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible plugins**: Plugins in Ansible extend the core functionality of the
    master system and provide additional functionality to the control server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible modules:** Modules in Ansible extend the capabilities of playbooks
    running on target systems. These would be the systems that Ansible runs its playbooks
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two distinctions are quite important as it defines the scope of the development.
    Let''s take a look at a simple Ansible playbook so we can better understand the
    role Ansible modules play within the Ansible architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding playbook, can you determine how modules are used? No?
    Let''s examine this playbook more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you guessed that the module name is `<yum>`, you would be correct. Tasks
    represented in the playbook form are simply module calls. If this is the case,
    then we would logically ask ourselves "When should I create my own modules?"
  prefs: []
  type: TYPE_NORMAL
- en: When should we create a module?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most obvious question at this point is when and why you would want to develop
    your own Ansible modules. The answer is most of the time you actually won''t want
    to. But there are cases where you may need to. Some examples of this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When communication with a specific API feels clumsy or arduous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do something custom that Ansible does not have native support for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To communicate with an internal process or software that does not have an already
    developed Ansible module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, if you want to write an Ansible module and the software solution
    was created by a third-party (open source, commercial, and so on), it makes sense
    to check the Ansible modules for out-of-the-box support before jumping in and
    writing code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how to set up the Ansible development
    environment, where the Ansible module code should be stored and how it should
    be organized. Let's proceed, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Ansible Module Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how to set up a local Linux environment for
    Ansible module development. In our specific implementation, we will look at how
    to do this in Ubuntu. However, the same set of configuration options should work
    under other Linux flavors as well. As new Ansible module developers, we will want
    to begin by understanding how to configure our system to best support Ansible
    development, how to setup the modules path, and how to configure the environment
    for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to getting a development environment up and running is to understand
    the Ansible library path on the system. This path is where Ansible will search
    for additional libraries. The default value for the library path is defined within
    the primary Ansible configuration file (`/etc/ansible/ansible.cfg`). The line
    item is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While the default path is defined within the Ansible configuration file, it
    can be manipulated at runtime by specifying the `--module-path` on the command
    line when launching Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `--module-path` switch, we can also override the default
    modules path via a system-level environment variable. An example of how to do
    this is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When developing and using Ansible modules, the most preferred location to store
    the modules is next to the playbook itself within a `./library` directory. This
    would involve creating a directory structure that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Within the preceding structure, we could leverage the tasks available within
    the playbook. Pretty nice, right? These are the basics of setting up the development
    environment using Ansible. From here, we should probably also set up some basic
    debugging and lint solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible module testing tool setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible developers have implemented and released a pretty helpful tool to debug
    syntax and format issues within Ansible plugins and modules. This linter is quite
    useful indeed. To install the linter, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing the preceding command, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1beefb9b-99fe-404a-9bac-22fac8eb609d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the lint tool installed, let''s check it out to make sure
    it''s installed. Try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By executing the preceding command, we should see the following output on the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c28eeb38-a9e2-4e7f-b55f-dee736c2cb72.png)'
  prefs: []
  type: TYPE_IMG
- en: Nice, right? From here, we will want to set up the Ansible module test solution.
    Let's proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Hello World Ansible Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic development environment setup, we are going to explore
    how to create Ansible modules by taking a look at the obligatory Hello World Ansible
    module implementation. By creating a Hello World module, we can get our feet wet
    in Ansible module development and learn the basic structures required for a successful
    implementation. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin our *Hello World* module, let''s create a directory structure that
    reflects the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc638bef-6a01-41c3-bd3b-4a25f775209a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this structure has been created, let''s begin filling in our Ansible Hello
    World module code. To accomplish this, alter the `helloworld.py` file to contain
    the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once the preceding code has been implemented, we will want an efficient way
    to test its functionality. Let's get that testing environment set up next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a developmental Ansible module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the primary Ansible module development environment has been set up, we
    will want to set up the Ansible module testing environment. This solution will
    provide us with the ability to validate our Python code without using Ansible
    directly. As such, it will make the development and validation of potential modules
    more efficient. To set this up, execute the following commands within the development
    modules directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing these commands, you should see something similar to the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47c213e3-20da-4046-bbb2-3e686f8ba237.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this has been completed, we should have access to a new command, which
    will enable our ability to test our partially developed Ansible modules. Let''s
    check that out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/651930f1-7efe-424b-b06c-b7bee6fa759b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If something were to go wrong (a typo or non-compilable script), we would see
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54ba8e03-b526-470f-9834-612c7f710b1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fundamental values that Ansible provides is its connection to the
    YAML playbooks. Developing modules is useful only if we can create playbooks that
    pass data parameters to the modules. In this section, you will learn how to expand
    our Hello World Ansible module to accept and process input parameters from playbooks.
    We will also look at how to structure our module so that it conforms to the Ansible
    boilerplate template system designed for module development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for our Hello World program to be able to read input parameters from
    an Ansible playbook, we will need to modify it a bit. Let''s update the `./library/HelloWorld.py`
    file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a simple playbook `myplaybook.yml` in the parent folder of the
    library folder with the contents defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once saved, let''s execute it and see the output. The following is the command
    to run and the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/269ee631-15ea-4e7f-a2e1-e182f8d097bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice, right? Next, let''s take a look at what each of these Hello World lines
    does. The following is a far more documented copy of the `helloworld.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding custom facts to a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible facts (as we mentioned in earlier chapters) provide informational data
    points about the systems that have run a playbook or task. At some point, we might
    need to set some Ansible facts and return them to the Ansible control server.
    In this section, we will discuss how to set Ansible facts within our Hello World
    module and some of the limitations of Ansible facts.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Ansible documentation ([https://docs.ansible.com/ansible/dev_guide/developing_modules_general.html](https://docs.ansible.com/ansible/dev_guide/developing_modules_general.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: The setup - Gathers facts about remote hosts module that ships with Ansible
    provides many variables about a system that can be used in playbooks and templates.
    However, it's possible to also add your own facts without modifying the system
    module. To do this, just have the module return a ansible_facts key, like so,
    along with other return data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will go over how to gather module-specific custom facts
    and return them to the Ansible control server. To begin, we will want to define
    a set of formatted facts. Let''s take a look at an example of the code that does
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Based on the previous code, we can see that Ansible facts can be set in the
    JSON dictionary form and then passed through the `module.exit_json` file. These
    facts can then be accessed later within the playbook but only after the task that
    sets the facts has been executed. Nice, right?
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Ansible Plugin Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible plugins, as we mentioned earlier, represent actions that are executed
    on the master (control server) instead of the target host. These plugins allow
    us to add additional functionality to the Ansible solution easily. Once the plugin
    has been written, the action is then available to be called via a traditional
    YAML playbook *action*. Before we start coding our action plugin, let's take a
    look at how to set up the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the modules'' development environment, action plugins must reside
    either in `./<type of plugin>_plugins` next to the playbook being executed *or*
    within one of the specified folders. For example, you might have a directory structure
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you may have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you might consider altering the `<type of plugin>_plugins` path in the
    config folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is important to uncomment in the configuration the type of plugin you wish
    to leverage within the config. Once the development environment has been created
    for the type of plugin we wish to create, it's time to start coding the plugin
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Different Types of Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides the option to create numerous types of plugins. Each plugin
    type interacts with the Ansible system in a different way. In this section, we
    will be looking at the different types of plugins available within the Ansible
    plugin architecture and discover how to code them. The different types of plugins
    available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Action plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vars plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming sections, we will take a look at how to code each plugin type
    and what they are capable of. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Action plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at action plugins and you will learn what
    action plugins do and some basic code examples on how to create new actions that
    are available within the Ansible subsystems. In Ansible, `action_plugins` are
    a special type of module that provide additional functionality to an existing
    module. As we mentioned earlier, `action_plugins` run on the master instead of
    on the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an action plugin represented via an Ansible playbook would look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for such an action plugin might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, as we can see, the plugin code simply adds functionality to the playbook
    by using a set of well-defined structured methods.
  prefs: []
  type: TYPE_NORMAL
- en: Callback plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callback plugins in Ansible provide additional functionality to Ansible when
    responding to various events within the system. Callback plugins also control
    most of the execution output that is displayed when running a command-line program.
    In this section, we will take a look at callback plugins and learn how to implement
    additional callbacks within the Ansible subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for callback plugins must be stored in the `callback` folder,
    as we talked about earlier. The code that needs to be overridden by the class
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The way Callback plugins work is similar to other plugins. They provide us with
    the ability to override various functionality developed within the initial Ansible
    implementation. Additional details on the specifics of overrides available can
    be found at [http://docs.ansible.com/ansible/dev_guide/developing_plugins.html](http://docs.ansible.com/ansible/dev_guide/developing_plugins.html).
  prefs: []
  type: TYPE_NORMAL
- en: Connection plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to callback and action plugins, connection plugins can also be added
    to enhance the capability of the Ansible subsystems. Out of the box, Ansible uses
    a `paramiko` SSH and a native SSH Protocol connection solution. In addition, there
    are some other minor libraries leveraged as well (`chroot`, `jail`, and so on.)
    These libraries can be leveraged via playbook's. It may become wanted to leverage
    an alternative connection type such as SNMP, or message for Ansible to use. It's
    really a simple procedure (for those with Python and programming knowledge) using
    the connection plugin option. To accomplish this, simply copy one of the formats
    of one of the existing connection types into a `plugins_connection` folder and
    modify it to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for this plugin type is not comprehensive, and it is not available
    publicly yet by the Ansible creators. As such, it's recommended that you take
    a look at the Ansible source code for the existing connection plugins, for example.
    These examples can be found at [https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/connection](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/connection).
  prefs: []
  type: TYPE_NORMAL
- en: Lookup plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a closer look at lookup plugins and learn what
    they are, where some examples can be found, and how to leverage them. To begin,
    let's better understand what a lookup plugin actually is. A lookup plugin is designed
    to retrieve information and datasets from external data sources. For example,
    the concept of Ansible iterations is developed using lookup plugins. More specifically,
    `with_fileglob` and `with_items` were implemented using the lookup plugin constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to implement a look-up plugin based on the official
    Ansible source code documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of how this lookup is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Distributing Ansible plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed this in some detail within each section of this chapter, but it
    deserves reiterating. The most effective way to enable and distribute an Ansible
    plugin is to create a subdirectory alongside the playbook, which will leverage
    the plugin, that is, to create one of the following directories along side your
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./action_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./lookup_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./callback_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./connection_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./filter_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./strategy_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./cache_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./test_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./shell_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to this methodology for the distribution of a plugin, we could also
    use RPM or PIP to package the plugin and distribute it to the proper Ansible installation
    directory. The traditional installation location is set in the `/etc/ansible/ansible.cfg`
    file and can be altered as required.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about extending Ansible. You learned that there are
    two types of extensions for Ansible. The first is an Ansible module, and the second
    one is an Ansible plugin. Ansible modules provide developers with the ability
    to add functionality to Ansible running on target hosts, whereas plugins extend
    the capabilities of the control server.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to set up a local development environment for both Ansible modules
    and Ansible plugins. Once we had the development environment taken care of, we
    looked at how to write modules using a Hello World example and how to extend Ansible
    with a new plugin that overrides functionality within the core Ansible plugin
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we explored the plugin architecture and learned the various extension
    points that can be leveraged. This included action plugins, controller plugins,
    var plugins, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will take a look at Ansible Galaxy. Ansible
    Galaxy is a user-managed distribution point for Ansible playbooks. It is a critical
    implementation for Ansible developers and makes the job of creating playbooks
    to perform common tasks a breeze. Let's get moving.
  prefs: []
  type: TYPE_NORMAL
