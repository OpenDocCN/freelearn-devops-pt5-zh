<html><head></head><body><div><div><p id="_idParaDest-131" class="chapter-number"><a id="_idTextAnchor216"/><em class="italic">Chapter 7</em></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor217"/>Moving from Linux to Windows Containers</h1>
			<p>In this chapter, we will discuss and take a look at Windows containers. Microsoft has embraced containers as a way of deploying older applications on new hardware. Unlike Linux containers, Windows containers are only available on Windows-based Docker hosts.</p>
			<p>We will be covering the following topics:</p>
			<ul>
				<li>An introduction to Windows containers</li>
				<li>Setting up your Docker host for Windows containers</li>
				<li>Running Windows containers</li>
				<li>A Windows container Dockerfile</li>
				<li>Windows containers and Docker Compose</li>
			</ul>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor218"/>Technical requirements</h1>
			<p>In this chapter, the containers we will be launching will only work on a Windows Docker host. We will be using VirtualBox and Vagrant on macOS- and Linux-based machines to assist in getting a Windows Docker host up and running.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/2DEwopT">https://bit.ly/2DEwopT</a></p>
			<p>An introduction to Windows containers</p>
			<p>As someone who has <a id="_idIndexMarker540"/>been using mostly macOS and Linux computers and laptops alongside Linux servers pretty much daily for the past 20 years, coupled with the fact that my only experience of running Microsoft Windows was the Windows XP and Windows 10 gaming PCs I have had (along with the odd Windows server I was unable to avoid at work), the advent of Windows containers was an interesting development.</p>
			<p>Now, I would never have classed myself as a Linux/Unix fanboy; however, Microsoft’s actions over the last few years have surprised even me. Back in 2014, at one of its Azure events, Microsoft declared “Microsoft Linux”, and it hasn’t looked back since.</p>
			<p>Some notable headlines since Microsoft’s declaration of love for Linux include the following:</p>
			<ul>
				<li>Linux is a first-class citizen in Microsoft Azure.</li>
				<li>.NET Core is cross-platform, meaning that you can run your .NET applications on Linux, macOS, and Windows.</li>
				<li>SQL Server<a id="_idIndexMarker541"/> has been available on Linux for a few years.</li>
				<li>You can run Linux shells, such as Ubuntu, on Windows 10 Professional machines.</li>
				<li>PowerShell has been ported to Linux and macOS.</li>
				<li>It has developed cross-platform tools, such as Visual Studio Code, and open sourced them.</li>
				<li>It acquired GitHub for $7.5 billion!!</li>
			</ul>
			<p>It is clear that the Microsoft <a id="_idIndexMarker542"/>of old, where former <strong class="bold">chief executive officer</strong> (<strong class="bold">CEO</strong>) Steve Ballmer famously roasted both the open source and Linux communities by calling them something that would not be appropriate to repeat here, has gone.</p>
			<p>Hence, the announcement made in October 2014, months after Microsoft publicly declared its love for Linux, that Docker and Microsoft were forming a partnership to drive the adoption of containers on Windows-based operating systems such as Windows 10 Professional and Windows Server 2016 came as no surprise to anyon<a id="_idTextAnchor219"/>e<a id="_idTextAnchor220"/>.</p>
			<p>So, what are Windows containers?</p>
			<p>Well, on the face of it, they are no different from Linux containers. The work by Microsoft on the <a id="_idIndexMarker543"/>Windows kernel has introduced the same process isolation as found on Linux. Also, like Linux containers, this isolation extends to a sandboxed filesystem and even a Windows registry.</p>
			<p>As each container is effectively a fresh Windows Core or Windows Nano installation, which, in turn, are cut-down Windows Server images (think Alpine Linux but for Windows), installation administrators can run multiple dockerized applications on the same host without having to worry about any custom registry changes or requirements clashing and causing problems.</p>
			<p>Couple this with the same ease of use supplied by the Docker command-line client, and administrators have a way to migrate their legacy applications to more modern hardware, and also <a id="_idIndexMarker544"/>to host operating systems without the worries and overhead of having to manage multiple <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>) running older unsupported versions of Windows.</p>
			<p>There is also another layer of isolation provided by Windows containers. <strong class="bold">Hyper-V isolation</strong> runs the <a id="_idIndexMarker545"/>container processes within a minimal hypervisor when the container is started. This further isolates the container processes from the host machine. However, there is a small cost of additional resources that are needed for each container running with Hyper-V isolation, while these containers will also have an increased start time as the hypervisor needs to be launched before the container can be started.</p>
			<p>While Hyper-V isolation does use Microsoft’s hypervisor, which can be found in both Windows Server and Desktop editions, as well as the Xbox One system software, you can’t manage Hyper-V isolated containers using the standard Hyper-V management tools. You have to use Docker.</p>
			<p>After all the work and effort Microsoft had to put into enabling containers in the Windows kernel, why did they choose Docker over just creating their own container management tool?</p>
			<p>Docker had already <a id="_idIndexMarker546"/>established itself as the go-to tool for managing containers with a set of proven <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) and a large community. Also, it was an open source application, which meant that Microsoft could not only adapt it for use on Windows but also contribute to its development.</p>
			<p>The following diagram gives an overview of how Docker on Windows works:</p>
			<div><div><img src="img/image_00_0011.jpg" alt="Figure 7.1 – Docker on Windows overview&#13;&#10;" width="1536" height="1164"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 7.1 – Docker on Windows overview</p>
			<p>Notice that I said <a id="_idIndexMarker547"/>Docker <em class="italic">on</em> Windows, not Docker <em class="italic">for</em> Windows; they are very different products. Docker on Windows is the native version of the Docker engine and client that interacts with the Windows kernel to provide Windows containers. Docker for Windows is a native-as-possible experience for developers to run both Linux and Windows containers on their desktops. </p>
			<p>Now, let’s look at preparing your host so that we can run Windows containers.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor221"/>Setting up your Docker host for Windows containers</h1>
			<p>As you may <a id="_idIndexMarker548"/>have guessed, you are <a id="_idIndexMarker549"/>going to need access to a Windows host running Docker. Don’t worry too much if you are not running a Windows 10 Professional machine; there are ways in which you can achieve this on macOS and Linux. Before we talk about those, let’s look at how you can run Windows containers on Windows 10 Professional with your Docker for Windows installation.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor222"/>Enabling Windows Container Support on Windows 10 Professional</h2>
			<p>Windows 10<a id="_idIndexMarker550"/> Professional<a id="_idIndexMarker551"/> supports Windows containers out of the box. By default, however, it is configured to run Linux containers. To switch from running Linux containers to Windows containers, right-click on the <strong class="bold">Docker</strong> icon in your system tray and select <strong class="bold">Switch to Windows containers…</strong> from the menu, as illustrated in the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0021.jpg" alt="Figure 7.2 – Switching to Windows containers&#13;&#10;" width="920" height="725"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Switching to Windows containers</p>
			<p>This will<a id="_idIndexMarker552"/> bring up the following <a id="_idIndexMarker553"/>prompt:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0031.jpg" alt="Figure 7.3 – An important note on what happens to your Linux containers&#13;&#10;" width="1242" height="498"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – An important note on what happens to your Linux containers</p>
			<p>Hit the <strong class="bold">Switch</strong> button <a id="_idIndexMarker554"/>and, after a<a id="_idIndexMarker555"/> few seconds, you will now be managing Windows containers. You can see this by opening up Command Prompt on your host and running the following command:</p>
			<pre>$ docker version</pre>
			<p>This can be seen from the following output:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0041.jpg" alt="Figure 7.4 – Checking the output of running docker version&#13;&#10;" width="874" height="860"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Checking the output of running docker version</p>
			<p>The Docker Engine has an <code>OS/Arch of windows/amd64</code> version, rather than the <code>linux/amd64</code> version <a id="_idIndexMarker556"/>we have been <a id="_idIndexMarker557"/>used to seeing up until now. So, that covers Windows 10 Professional. But what about people like me who prefer macOS or Linux?</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor223"/>Up and running on MacOS and Linux</h2>
			<p>To get access to Windows containers on macOS and Linux machines, we will be using the excellent<a id="_idIndexMarker558"/> resources put together by Stefan<a id="_idIndexMarker559"/> Scherer. In the <code>chapter07</code> folder of the<a id="_idIndexMarker560"/> repository that accompanies this book, there <a id="_idIndexMarker561"/>is a forked version of Stefan’s <code>docker-windows-box</code> repo as a Git submodule, which contains all of the files you need to get up and running with Windows containers on macOS.</p>
			<p>To check out the forked version, you will need to run the following command within the repository folder:</p>
			<pre>$ git submodule update --init --recursive</pre>
			<p>Finally, before we start to launch the VM, you will need the following tools: Vagrant by HashiCorp, and VirtualBox by Oracle, which we covered in the last chapter. </p>
			<p>We do, however, need to install a <code>vagrant</code> plugin. To do this, run the following command:</p>
			<pre>$ vagrant plugin install vagrant-reload</pre>
			<p>Once the plugin is installed, we can start using Docker on Windows by opening a Terminal, going to the <code>chapter07/docker-machine</code> repository folder, and running the following command:</p>
			<pre>$ vagrant up</pre>
			<p>This will download a VirtualBox Windows Server 2019 <code>Core Eval</code> image that contains everything needed to get you up and running with Windows containers. The download is just <a id="_idIndexMarker562"/>over 6 <strong class="bold">gigabytes</strong> (<strong class="bold">GB</strong>), so please make sure that you have the bandwidth and disk space needed to run the image.</p>
			<p>Vagrant will<a id="_idIndexMarker563"/> launch the image and configure Docker on the VM, along with a few other sensible defaults such as the Atom <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>), Docker Compose, Docker Machine, and Git. Once <a id="_idIndexMarker564"/>the VM has launched, open your preferred Microsoft <strong class="bold">Remote Desktop Protocol</strong> (<strong class="bold">RDP</strong>) client, and then run the following command:</p>
			<pre>$ vagrant rdp</pre>
			<p>If you are prompted for the password, enter <code>vagrant</code>, and you will be logged in to your newly launched Windows 2019 Server environment, with all of the tools you need to run Docker in Windows installed and ready to go.</p>
			<p>Also, if you don’t want to run something locally, a Windows 10 Professional instance in Azure has <a id="_idIndexMarker565"/>all of the necessary components<a id="_idIndexMarker566"/> enabled to be able to run Docker<a id="_idIndexMarker567"/> for Windows, which—as discussed in the <a id="_idIndexMarker568"/>previous section—allows you to run Windows containers, which we will be looking at next.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor224"/>Running Windows containers</h1>
			<p>As already hinted at in<a id="_idIndexMarker569"/> the first part of this chapter, launching and interacting with Windows containers using the Docker command-line client is no different from what we have been running so far. Let’s test this by running the <code>hello-world</code> container, as follows:</p>
			<pre>$ docker container run hello-world</pre>
			<p>Just as before, this will download the <code>hello-world</code> container and return a message, as illustrated in the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0051.jpg" alt="Figure 7.5 – Running the Windows-based hello-world container&#13;&#10;" width="724" height="694"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Running the Windows-based hello-world container</p>
			<p>The only difference on<a id="_idIndexMarker570"/> this occasion is that rather than the Linux image, Docker pulled the <code>windows-amd64</code> version of the image that is based on the <code>nanoserver-sac2016</code> image.</p>
			<p>Now, let’s look at running a container in the foreground, this time running PowerShell, as follows:</p>
			<pre>$ docker pull mcr.microsoft.com/windows/servercore
$ docker container run -it mcr.microsoft.com/windows/servercore:ltsc2019 powershell</pre>
			<p>Once your shell is active, running the following command will give you the computer name, which is the container ID:</p>
			<pre>$ Get-CimInstance -ClassName Win32_Desktop -ComputerName .</pre>
			<p>You can see the full <a id="_idIndexMarker571"/>Terminal output of the preceding commands in the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0061.jpg" alt="Figure 7.6 – Running PowerShell within a container&#13;&#10;" width="834" height="400"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Running PowerShell within a container</p>
			<p>Once you have exited PowerShell by running <code>exit</code>, you can see the container ID by running the following command:</p>
			<pre>$ docker container ls -a</pre>
			<p>You can see the expected output in the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0071.jpg" alt="Figure 7.7 – Checking the containers&#13;&#10;" width="831" height="209"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Checking the containers</p>
			<p>Now, let’s take a look <a id="_idIndexMarker572"/>at building an image that does something a little more adventurous than run PowerShell—instead, let’s install a web server.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor225"/>A Windows container Dockerfile</h1>
			<p>Windows container<a id="_idIndexMarker573"/> images use Dockerfile commands in the same format <a id="_idIndexMarker574"/>as for Linux containers. The following Dockerfile will download, install, and enable the <strong class="bold">Internet Information Services</strong> (<strong class="bold">IIS</strong>) web server on the container:</p>
			<pre># escape=`
FROM mcr.microsoft.com/windows/servercore:ltsc2019
RUN powershell -Command `
    Add-WindowsFeature Web-Server; `
    Invoke-WebRequest -UseBasicParsing -Uri “https://dotnetbinaries.blob.core.windows.net/servicemonitor/2.0.1.10/ServiceMonitor.exe” -OutFile “C:\ServiceMonitor.exe”
EXPOSE 80
ENTRYPOINT [“C:\\ServiceMonitor.exe”, “w3svc”]</pre>
			<p>You can build the image using the following command:</p>
			<pre>$ docker image build --tag local:dockerfile-iis .</pre>
			<p>Once built, running <code>docker image ls</code> should show you the following:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0081.jpg" alt="Figure 7.8 – Building and listing our image&#13;&#10;" width="840" height="436"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Building and listing our image</p>
			<p>The one immediate thing you will notice about Windows container images is that they are big. Running the container with the following command will start the IIS image:</p>
			<pre>$ docker container run -d --name dockerfile-iis local:dockerfile-iis</pre>
			<p>You can see your newly launched container in action by opening your browser. However, going to <code>http://localhost:8080/</code> won’t work as we have not provided any ports. If you remember, we are <a id="_idIndexMarker575"/>running Docker on Windows, so the containers are<a id="_idIndexMarker576"/> running directly on the host machine. Thus, there is no need to use<a id="_idIndexMarker577"/> localhost or mapped ports as we can access the container’s <strong class="bold">network address translation </strong>(<strong class="bold">NAT</strong>) <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) directly on the host machine of the container.</p>
			<p>To find the NAT IP address, you can use the following command:</p>
			<pre>$ docker container inspect --format=”{{.NetworkSettings.Networks.nat.IPAddress}}” dockerfile-iis</pre>
			<p>This should output something like the following:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0091.jpg" alt="Figure 7.9 – Running our Windows container image&#13;&#10;" width="846" height="188"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – Running our Windows container image</p>
			<p>This will give you an <a id="_idIndexMarker578"/>IP address. To access IIS, we simply need to put the IP address into a browser running on the Windows host. In this case, the <code>http://172.26.30.80/</code>. You should see the following default holding page:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0101.jpg" alt="Figure 7.10 – The IIS web server running in a container&#13;&#10;" width="858" height="635"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – The IIS web server running in a container</p>
			<p>To stop and remove the <a id="_idIndexMarker579"/>containers we have launched so far, run the following commands:</p>
			<pre>$ docker container stop dockerfile-iis
$ docker container prune</pre>
			<p>So far, I am sure you will agree that the experience is no different from using Docker with Linux-based containers.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor226"/>Windows containers and Docker Compose</h1>
			<p>In the final section <a id="_idIndexMarker580"/>of this chapter, we are going to look at using Docker<a id="_idIndexMarker581"/> Compose with our Windows Docker host. As you will have already guessed, there isn’t much change from the commands we ran in <a href="B15659_05_Final_JM_ePub.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Docker Compose</em>. </p>
			<p>In the <code>chapter07</code> folder in the repository, you will find a <code>docker-compose.yml</code> file that looks like the following:</p>
			<pre>version: ‘2.1’
services:
  db:
    image: microsoft/mssql-server-windows-express
    environment:
      sa_password: “${SA_PASSWORD}”
      ACCEPT_EULA: “${SQL_SERVER_ACCEPT_EULA}”
    healthcheck:
      test: [ “CMD”, “sqlcmd”, “-U”, “sa”, “-P”, “${SA_PASSWORD}”, “-Q”, “select 1” ]
      interval: 10s
      retries: 10
  octopus:
    image: octopusdeploy/octopusdeploy:${OCTOPUS_VERSION}
    environment:
      ADMIN_USERNAME: “${OCTOPUS_ADMIN_USERNAME}”
      ADMIN_PASSWORD: “${OCTOPUS_ADMIN_PASSWORD}”
      SQLDBCONNECTIONSTRING: “${DB_CONNECTION_STRING}”
      ACCEPT_EULA: “${OCTOPUS_ACCEPT_EULA}”
      ADMIN_EMAIL: “${ADMIN_EMAIL}”
    ports:
     - “1322:8080”
    depends_on:
      db:
        condition: service_healthy
    stdin_open: true
    volumes:
      - “./Repository:C:/Repository”
      - “./TaskLogs:C:/TaskLogs”
networks:
  default:
    external:
      name: nat</pre>
			<p>There is also a supporting <code>.env</code> file—this is used by Docker Compose to populate variables in the Docker Compose file and should be placed in the same folder as the <code>docker-compose.yml</code> file, as follows:</p>
			<pre>SA_PASSWORD=N0tS3cr3t!
OCTOPUS_VERSION=2019.13.4
DB_CONNECTION_STRING=Server=db,1433;Initial Catalog=Octopus;Persist Security Info=False;User ID=sa;Password=N0tS3cr3t!;MultipleActiveResultSets=False;Connection Timeout=30;
OCTOPUS_ADMIN_USERNAME=admin
OCTOPUS_ADMIN_PASSWORD=Passw0rd123
ADMIN_EMAIL=
OCTOPUS_ACCEPT_EULA=Y
SQL_SERVER_ACCEPT_EULA=Y</pre>
			<p>As you can see, it is <a id="_idIndexMarker582"/>using the same structure, flags, and commands as the<a id="_idIndexMarker583"/> previous Docker Compose files we have looked at, the only difference being that we are using images from the Docker Hub that are designed for Windows containers. The Docker <a id="_idIndexMarker584"/>Compose file will download Microsoft <code>database</code> and Octopus Deploy (<code>octopus</code>). To pull the required images, simply run the following command:</p>
			<pre>$ docker-compose pull</pre>
			<p>Then, once pulled, we need to create the folders required to launch Octopus Deploy, using the following commands in the same folder as the <code>docker-compose.yml</code> file:</p>
			<pre>$ mkdir Repository
$ mkdir TaskLogs</pre>
			<p>Finally, we can launch Octopus Deploy by running the following command:</p>
			<pre>$ docker-compose --project-name Octopus up -d</pre>
			<p>Octopus can take around 10 minutes to start up. I would recommend running the following command to watch the container logs, to be certain that Octopus Deploy is up and running:</p>
			<pre>$ docker-compose --project-name Octopus logs -f</pre>
			<p>You should see the message <code>Completed System Integrity Check. Overall Result: Passed</code> in the log output, which should look something similar to the following output:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0111.jpg" alt="Figure 7.11 – Watching the output of our containers&#13;&#10;" width="1254" height="528"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Watching the output of our containers</p>
			<p>As before, you <a id="_idIndexMarker585"/>can then use this command to find out the IP address on <a id="_idIndexMarker586"/>Windows:</p>
			<pre>$ docker inspect -f “{{ .NetworkSettings.Networks.nat.IPAddress }}” octopus_octopus_1</pre>
			<p>Once you have the IP address, which for me was <code>172.26.30.12</code>, open a browser and access the admin interface on port <code>81</code>. For me, that was <code>http://172.26.30.12:81/</code>. This should show you a login prompt—here, enter the username <code>admin</code>, with a password of <code>Passw0rd123</code>. Once logged in, you should see something like the following:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/image_00_0121.jpg" alt="Figure 7.12 – Octopus Deploy up and running&#13;&#10;" width="819" height="642"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – Octopus Deploy up and running</p>
			<p>When you are ready, you can remove the containers by running the following command:</p>
			<pre>$ docker-compose --project-name Octopus down --rmi all --volumes</pre>
			<p>Before we finish, there <a id="_idIndexMarker587"/>are a few things to note—the first is the use of a <code>.env</code> file. As<a id="_idIndexMarker588"/> already mentioned, this saves us having to use hard variables into our Docker Compose files; so, if you ever use them, don’t check them into a Git repo like I have done. Secondly, you may have noticed that when we ran the <code>docker-compose</code> command, we passed the <code>--project-name Octopus</code> parameter. This means that when we launch our project, rather than the application inheriting the name of the folder where the Docker Compose file is, it will be prefixed with <code>octopus</code>.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor227"/>Summary</h1>
			<p>In this chapter, we have briefly looked at Windows containers. As you have seen, thanks to Microsoft’s adoption of Docker as a management tool for Windows containers, the experience is familiar to anyone who has used Docker to manage Linux containers.</p>
			<p>In the next chapter, we are going to take a look at Docker Swarm. This will be the first time we have moved from single Docker hosts to a cluster of hosts.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor228"/>Questions</h1>
			<ol>
				<li>Docker on Windows introduces which additional layer of isolation?</li>
				<li>Which command would you use to find out the NAT IP address of your Windows container?</li>
				<li>True or false: Docker on Windows introduces an additional set of commands you need to use in order to manage your Windows containers.</li>
			</ol>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor229"/>Further reading</h1>
			<p>You can find more information on the topics mentioned in this chapter, as follows:</p>
			<ul>
				<li>Docker and Microsoft Partnership Announcement: <a href="https://blog.docker.com/2014/10/docker-microsoft-partner-distributed-applications/">https://blog.docker.com/2014/10/docker-microsoft-partner-distributed-applications/</a></li>
				<li>Windows Server and Docker – The Internals Behind Bringing Docker &amp; Containers to Windows: <a href="https://www.youtube.com/watch?v=85nCF5S8Qok">https://www.youtube.com/watch?v=85nCF5S8Qok</a></li>
				<li>Stefan Scherer on GitHub: <a href="https://github.com/stefanScherer/">https://github.com/stefanScherer/</a></li>
				<li>Octopus Deploy: <a href="https://octopus.com">https://octopus.com</a></li>
			</ul>
		</div>
	</div>



  </body></html>