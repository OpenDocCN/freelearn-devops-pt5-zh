- en: Chapter 6. Getting Notifications from Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the big advantages of Ansible compared to a bash script is its capability
    of running multiple times on the same system, ensuring that everything is in order.
    This is a very nice feature that not only assures you that nothing has changed
    the configurations on your server, but also those new configurations will be applied
    in a short time.
  prefs: []
  type: TYPE_NORMAL
- en: Due to these reasons, many people run their `master.yaml` once a day. When you
    do this (and probably you should!), you want some kind of feedback sent to you
    by Ansible itself. There are also many other cases where you may want Ansible
    to send messages to you or your team. For instance, if you use Ansible to deploy
    your application, you may want to send an IRC message (or other kinds of group
    chat messages) to your development team channel, so that they are all informed
    of the status of your system.
  prefs: []
  type: TYPE_NORMAL
- en: Other times, you want Ansible to notify Nagios that it's going to break something
    so that Nagios does not worry and does not start to shoot e-mails and messages
    to your sysadmins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mail notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible XMPP/Jabber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slack and Rocket Chat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a message to an IRC channel (community information and contributing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Simple Notification Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nagios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest and most common way of alerting people is to send e-mails. Ansible
    allows you to send e-mails from your playbook using a `mail` module. You can use
    this module in between any of your tasks and notify your user whenever required.
    Also, in some cases, you cannot automate each and every thing because either you
    lack the authority or it requires some manual checking and confirmation. If this
    is the case, you can notify the responsible user that Ansible has done its job
    and it''s time for him/her to perform his/her duty. Let''s see how you can use
    the `mail` module to notify your users with a very simple playbook called `uptime_and_email.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding playbook, we will first read the current machine uptime and
    then send it via e-mail to someone. This example is very easy and will allow us
    to keep the examples short, but obviously you can generate the e-mails in a similar
    way in very long and complex playbooks. If we focus on the `mail` task a little
    bit, we can see that we are using it with the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: An e-mail server to be used to send the e-mail (also with login information,
    which is required for this server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The receiver e-mail address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The e-mail subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The e-mail body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other interesting parameters that the `mail` module supports are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `attach` parameter: This is used to add attachments to the e-mail that
    will be generated. This is very useful when, for instance, you want to send a
    log via an e-mail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `port` parameter: This is used to specify which port is used by the e-mail
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interesting thing about this module is that the only mandatory field is `subject`,
    and not the body, as many people would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to execute the script to validate its functionality with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as expected, Ansible has sent me an e-mail with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This module can be used in many different ways. An example of a real world case
    that I've seen is a playbook that was created to automate a piece of a very long
    procedure done by multiple people. The procedure, historically, changed owners
    using the e-mails and every person involved in the procedure was supposed to do
    their part after an e-mail was received from the owner of the previous piece.
    They then sent an e-mail at the end of their piece to the next owner. When we
    started to automate that procedure, we did it for one specific piece and no one
    noticed that that part was automated. This is not the best way to handle procedures,
    but it's widely used in organizations and often you cannot change it.
  prefs: []
  type: TYPE_NORMAL
- en: XMPP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E-mails are slow, unreliable, and often people do not react to them immediately.
    There are cases where you want to send a real-time message to one of your users.
    Many organizations rely on XMPP/Jabber for their internal chat system and the
    great thing is that Ansible is able to directly send messages to XMPP/Jabber users
    and conference rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tweak the previous example to send uptime information to a user in the
    file `uptime_and_xmpp_user.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use the Ansible `jabber` task, you will need to have the library
    `xmpppy` installed on the system that will perform the task.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `jabber` module is very similar to the `mail` module and
    requires similar parameters. In the XMPP case, we don't need to specify the server
    host and port, since that information is automatically gathered by XMPP from the
    DNS. In cases where we would need to use a different server host or port, we can
    use respectively, the `host` and `port` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to execute the script to validate its functionality with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases where we want to send a message to a conference room instead of a
    single user, it is enough to just change the to parameter, adding the appropriate
    one, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Slack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few years, many new chat and collaboration platforms have appeared.
    One of the most used ones is Slack. Slack is a cloud-based team collaboration
    tool, and this allows even easier integration with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the following lines in the file `uptime_and_slack.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed, this module has an even simpler syntax than the XMPP one, in
    fact it only needs to know the token (which you can generate on the Slack website),
    the channel to send the message to, and the message itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since version 1.8 of Ansible, the new version of the Slack token is required,
    for instance: `G522SJP14/D563DW213/7Qws484asdWD4w12Md3avf4FeD`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the playbook with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Slack''s goal is to make communications more efficient, it allows us
    to tweak multiple aspects of the message. The most interesting points from my
    point of view are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This allows you to specify a color bar to be put in the beginning
    of the message to identify the following states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good**: Green bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal**: No bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning**: Yellow bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Danger**: Red bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icon_url`: This allows you to change the user image for that message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rocket Chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many companies like the functionality of Slack, but have problems to tradeoff
    the privacy that an on-premises service gives you for the Slack functionality.
    Rocket Chat is open source software that implements most of the features of Slack,
    as well as the majority of its interface. Being open source, every company can
    install it on-premises and manage it in a way that is compliant with their IT
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Rocket Chat''s goal is to be a drop-in replacement for Slack, from our point
    of view, very few changes need to be done, in fact, we can create the file `uptime_and_rocket.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only lines that changed are the 6th and 7th, where the word
    `slack` has been replaced by `rocketchat`. Also, we need to add the domain field
    specifying where our installation of Rocket Chat is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Internet Relay Chat (IRC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IRC is probably the most well-known and widely-used chat protocol of the 1990s
    and it''s still used today, mainly due to its use in open source communities and
    its simplicity. From an Ansible perspective, IRC is a pretty straightforward module
    and we can use it as in the following example (to be put in the `uptime_and_irc.yaml`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need the `socket` Python library installed to use the Ansible IRC module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the IRC module, the following fields are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This is to specify in which channel your message will be delivered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg`: This is the message you want to send'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other configurations you will usually specify are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server`: Select `server` to connect to, if not `localhost`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: Select `port` to connect to, if not `6667`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: This to specify the message `color`, if not `black`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nick`: This to specify the `nick` sending the message, if not `ansible`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_ssl`: Use SSL and TLS security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`: If you want to send your message with bold, italic, underline, or
    reverse style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Amazon Simple Notification Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you want your playbooks to be agnostic in the way you receive the
    alert. This has several advantages, mainly in terms of flexibility. In fact, in
    this model, Ansible will deliver the messages to a notification service and the
    notification service will then take care of delivering them. **Amazon Simple Notification
    Service** (**SNS**) is not the only notification service available, but it''s
    probably the most used. SNS has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messages**: Messages generated by publishers identified by a UUID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishers**: Programs generating messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topics**: Named groups of messages, which can be thought of in a similar
    way to chat channels or rooms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers**: Clients that will receive all messages published in the topics
    they have subscribed to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So in our case, we will have, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messages**: Ansible notifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishers**: Ansible itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topics**: Probably different topics to group messages based on the system
    and/or the kind of notification (for example, storage, networking, computing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers**: The people in your team that has to be notified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we said, one of the big advantages of SNS is that you can decouple between
    the way Ansible sends messages (SNS API) and the way your users will receive the
    messages. In fact, you will be able to choose different delivery systems per user
    and per topic rules, and eventually you can change them dynamically to ensure
    that the messages are sent in the best way possible for any situation. The five
    ways SNS can send messages, at the moment, are:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon **lambda** functions (serverless functions written in Python, Java, and
    JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Simple Queue Service** (**SQS**) (a message queueing system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP(S) call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how we can send SNS messages with Ansible. To do so, we can create
    a file called `uptime_and_sns.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using the `msg` key to set the message that will be
    sent, the `topic` to choose the most appropriate topic, and `subject` that will
    be used as the subject for e-mail deliveries. There are many other options you
    can set. Mainly, they are useful for sending different messages using different
    delivery methods. For instance, it would make sense to send a short message via
    SMS (in the end, the first S in SMS means **short**) and longer and more detailed
    messages via e-mails. To do so, the SNS module provides us with the following
    delivery-specific options:'
  prefs: []
  type: TYPE_NORMAL
- en: E-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This module allows us also to set three AWS-specific parameters that I''ve
    not specified because I have a configuration file for AWS credentials and options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aws_access_key`: AWS access key, if not specified the environmental variable,
    `aws_access_key` will be considered or the content of `~/.aws/credentials`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws_secret_key`: AWS secret key, if not specified the environmental variable,
    `aws_secret_key` will be considered or the content of `~/.aws/credentials`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`region`: AWS region to use, if not specified the environmental variable, `ec2_region`
    will be considered or the content of `~/.aws/config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Nagios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nagios is one of the most used tools for controlling the status of services
    and servers. Nagios is capable of regularly auditing the state of servers and
    services, and notifying users in case of problems. If you have Nagios in your
    environment, you need to be very careful when you administer your machines, because
    in cases where Nagios finds servers or services in an unhealthy state, it will
    start sending e-mails, SMS messages, and calls to your whole team. When you run
    Ansible scripts against nodes that are controlled by Nagios you have to be even
    more careful, because you risk e-mails, SMS messages, and calls being triggered
    during the night or other inappropriate times. To avoid this, Ansible is able
    to notify Nagios beforehand, so that Nagios does not send notifications in that
    time window even if some services are down (for instance, because they are rebooted)
    or other checks fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are going to stop a service, wait for 5 minutes, then start
    it again since this would actually create a Nagios failure in the majority of
    configurations. In fact, usually, Nagios is configured to accept up to two consecutive
    failures of a test (with usually one execution every minute) putting the service
    in a warning state before raising a critical state. We are going to create the
    file, `long_restart_service.yaml` which will trigger the Nagios critical state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This should trigger a Nagios alert and result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If no Nagios alert has been triggered, either your Nagios installation probably
    does not track that service, or 5 minutes is not enough to make it raise a critical
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a very similar playbook that will ensure that Nagios will
    not send any alerts. We are going to create a file called `long_restart_service_no_alert.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added two tasks. The first to inform Nagios not to send
    alerts for the HTTPd service on the given host, and the second to inform Nagios
    to start sending alerts for the service again. Even if you do not specify the
    service and therefore all alerts on that host are silenced, my advice is to disable
    only the alert you are going to break so that Nagios is still able to work normally
    on the majority of your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the playbook run fails before reaching the re-enablement of the alerts, your
    alerts will stay *disabled*.
  prefs: []
  type: TYPE_NORMAL
- en: This module's goal is to toggle the Nagios alerts as well as schedule downtime,
    and from Ansible 2.2 this module can also unscheduled downtimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This should trigger a Nagios alert and result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use the Nagios module, you need to delegate the action to your Nagios server.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, what you want to achieve with a Nagios integration is exactly the
    opposite, in fact, you are not interested to silentiate it, but you want Nagios
    to handle your test results. A common case is if you want to leverage your Nagios
    configuration to notify your administrators of the output of a task. To do so,
    we can use the Nagios `nsca` utility, integrating it into our playbooks. Ansible
    does not yet have a specific module for managing it, but you can always run it
    using the command module, leveraging the `send_nsca` CLI program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can teach Ansible how to send notifications
    to other systems and/or people.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create a module so that you can extend
    Ansible to perform any kind of task.
  prefs: []
  type: TYPE_NORMAL
