<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Security in OpenShift</h1>
                
            
            <article>
                
<p class="calibre2">Previously, we worked with advanced OpenShift resources, such as ImageStreams, ConfigMaps, and templates. Those resources allow you to simplify OpenShift resource management and the application delivery process.</p>
<p class="calibre2">In this chapter, we will introduce you to the realm of security in OpenShift. Any business' success depends on many factors, one of which is the company's ability to implement different security strategies for different users, departments, and applications. OpenShift is an enterprise-ready application platform that supports multiple security features, making it possible to integrate it into any corporate security landscape.</p>
<p class="calibre2"/>
<p class="calibre2">This chapter will provide you with an understanding of the following concepts:</p>
<p class="calibre2"/>
<ul class="calibre9">
<li class="calibre10">Authentication—users and identities, service accounts, and identity providers</li>
<li class="calibre10">Authorization and role-based access control</li>
<li class="calibre10">Admission controllers</li>
<li class="calibre10">Security context constraints</li>
<li class="calibre10">Storing sensitive data in OpenShift</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Technical requirements</h1>
                
            
            <article>
                
<p class="calibre2">For this section, we will have to make use of Vagrant to demonstrate the difference between these methods, as we will require two VMs: one for single-node OpenShift cluster, and the other for the FreeIPA server. Use the following Vagrantfile to spin up an environment:</p>
<p class="calibre2"/>
<pre class="calibre18"><strong class="calibre1">$ cat Vagrantfile</strong> <br class="title-page-name"/>$lab_idm = &lt;&lt;SCRIPT<br class="title-page-name"/>cat &lt;&lt;EOF &gt;&gt; /etc/hosts<br class="title-page-name"/>172.24.0.11 openshift.example.com openshift<br class="title-page-name"/>172.24.0.12 idm.example.com idm<br class="title-page-name"/>EOF<br class="title-page-name"/>sed -i '/^127.0.0.1.*idm.*$/d' /etc/hosts<br class="title-page-name"/>yum -y update<br class="title-page-name"/>yum -y install ipa-server<br class="title-page-name"/>systemctl restart dbus<br class="title-page-name"/>ipa-server-install -r IDM.EXAMPLE.COM -n idm.example.com -p idmsecret -a idmsecret --unattended<br class="title-page-name"/>echo idmsecret | kinit admin<br class="title-page-name"/>echo supersecret | ipa user-add alice --first Alice --last Springs --password<br class="title-page-name"/>SCRIPT<br class="title-page-name"/><br class="title-page-name"/>$lab_openshift = &lt;&lt;SCRIPT<br class="title-page-name"/>cat &lt;&lt;EOF &gt;&gt; /etc/hosts<br class="title-page-name"/>172.24.0.12 idm.example.com idm<br class="title-page-name"/>EOF<br class="title-page-name"/>yum -y update<br class="title-page-name"/>yum install -y epel-release git docker<br class="title-page-name"/>yum install -y ansible<br class="title-page-name"/>systemctl start docker<br class="title-page-name"/>systemctl enable docker<br class="title-page-name"/>git clone -b release-3.9 https://github.com/openshift/openshift-ansible /root/openshift-ansible<br class="title-page-name"/>ssh-keygen -f /root/.ssh/id_rsa -N ''<br class="title-page-name"/>cp /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys<br class="title-page-name"/>ssh-keyscan 172.24.0.11 &gt;&gt; .ssh/known_hosts<br class="title-page-name"/>cp .ssh/known_hosts /root/.ssh/known_hosts<br class="title-page-name"/>ssh-copy-id -i /root/.ssh/id_rsa root@172.24.0.11<br class="title-page-name"/>reboot<br class="title-page-name"/>SCRIPT<br class="title-page-name"/><br class="title-page-name"/>Vagrant.configure(2) do |config|<br class="title-page-name"/>  config.vm.define "openshift" do |conf|<br class="title-page-name"/>    conf.vm.box = "centos/7"<br class="title-page-name"/>    conf.vm.hostname = 'openshift.example.com'<br class="title-page-name"/>    conf.vm.network "private_network", ip: "172.24.0.11"<br class="title-page-name"/>    conf.vm.provider "virtualbox" do |v|<br class="title-page-name"/>       v.memory = 4096<br class="title-page-name"/>       v.cpus = 2<br class="title-page-name"/>    end<br class="title-page-name"/>    conf.vm.provision "shell", inline: $lab_openshift<br class="title-page-name"/>  end<br class="title-page-name"/><br class="title-page-name"/>  config.vm.define "idm" do |conf|<br class="title-page-name"/>    conf.vm.box = "centos/7"<br class="title-page-name"/>    conf.vm.hostname = 'idm.example.com'<br class="title-page-name"/>    conf.vm.network "private_network", ip: "172.24.0.12"<br class="title-page-name"/>    conf.vm.provider "virtualbox" do |v|</pre>
<pre class="calibre18"> v.memory = 2048<br class="title-page-name"/>       v.cpus = 1<br class="title-page-name"/>    end<br class="title-page-name"/>    conf.vm.provision "shell", inline: $lab_idm<br class="title-page-name"/>  end<br class="title-page-name"/>end</pre>
<p class="calibre2">The preceding file may seem complicated compared to the one from the <a target="_blank" href="part0129.html#3R0OI0-78aafb146b304cdeb9b3261a70edabde" class="calibre8">Chapter 6</a>, <em class="calibre17">OpenShift Installation</em>, but all it does is automates the steps, performed in that chapter manually, because the purpose of this chapter is to discuss security while building on the knowledge you gained up to this point. Also, it sets up FreeIPA server on another VM and creates a user that will be used later in this chapter.</p>
<div class="packt_infobox">The command <kbd class="calibre26">systemctl restart dbus</kbd> is necessary to prevent installation of FreeIPA from failing during restart of certification manager.<br class="title-page-name"/>
<br class="title-page-name"/>
<span>We used the same simple password for both the directory manager and IPA admin for simplicity, but in a production setup, make sure that you use complex and unique passwords!</span></div>
<p class="calibre2">Run <kbd class="calibre12">vagrant up</kbd> and wait until it finishes all the work. It may take up to 30 mins depending on your internet connectivity and compute resources:</p>
<pre class="calibre18"><strong class="calibre1">$ vagrant up</strong><br class="title-page-name"/>Bringing machine 'openshift' up with 'virtualbox' provider...<br class="title-page-name"/>Bringing machine 'idm' up with 'virtualbox' provider...<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Once it's done, open SSH session into the <kbd class="calibre12">openshift</kbd> VM and become root:</p>
<pre class="calibre18"><strong class="calibre1">$ vagrant ssh openshift</strong><br class="title-page-name"/>[vagrant@openshift ~]$ <strong class="calibre1">sudo -i</strong><br class="title-page-name"/>[root@openshift ~]#</pre>
<div class="packt_infobox">Do not be alarmed by some of the output in red produced by the command above. Many CentOS commands, like yum, send warning, errors, and even other information alike to the standard error, which all gets interpreted as errors by Vagrant.</div>
<p class="calibre2">Then use the following Ansible inventory file to install OpenShift on the<span class="calibre11"> </span><kbd class="calibre12">openshift</kbd> VM. If you went through the <a target="_blank" href="part0129.html#3R0OI0-78aafb146b304cdeb9b3261a70edabde" class="calibre8">Chapter 6</a>, <em class="calibre17">OpenShift Installation</em>, you will notice that this is the same file with added <kbd class="calibre12">openshift_master_identity_providers</kbd> variable:</p>
<pre class="calibre18"><strong class="calibre1"># cat /etc/ansible/hosts<br class="title-page-name"/></strong>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>[masters]<br class="title-page-name"/>172.24.0.11<br class="title-page-name"/><br class="title-page-name"/>[nodes]<br class="title-page-name"/>172.24.0.11 openshift_node_labels="{'region': 'infra', 'zone': 'default'}" openshift_schedulable=true<br class="title-page-name"/><br class="title-page-name"/>[etcd]<br class="title-page-name"/>172.24.0.11<br class="title-page-name"/><br class="title-page-name"/>[OSEv3:vars]<br class="title-page-name"/>openshift_deployment_type=origin<br class="title-page-name"/>openshift_disable_check=memory_availability,disk_availability<br class="title-page-name"/>openshift_ip=172.24.0.11<br class="title-page-name"/>ansible_service_broker_install=false<br class="title-page-name"/>openshift_master_cluster_hostname=172.24.0.11<br class="title-page-name"/>openshift_master_cluster_public_hostname=172.24.0.11<br class="title-page-name"/>openshift_hostname=172.24.0.11<br class="title-page-name"/>openshift_public_hostname=172.24.0.11<br class="title-page-name"/>openshift_master_identity_providers=[{'name': 'LDAP', 'challenge': 'true', 'login': 'true', 'kind': 'LDAPPasswordIdentityProvider', 'mappingMethod': 'claim', 'attributes': {'id': ['dn'], 'email': ['mail'], 'name': ['cn'], 'preferredUsername': ['uid']}, 'insecure': 'true', 'bindDN': 'uid=admin,cn=users,cn=accounts,dc=idm,dc=example,dc=com', 'bindPassword': 'idmsecret', 'url': 'ldap://idm.example.com/cn=users,cn=accounts,dc=idm,dc=example,dc=com?uid'}, {'name': 'PASSWORD_FILE', 'challenge': 'true', 'login': 'true', 'kind': 'HTPasswdPasswordIdentityProvider', 'mappingMethod': 'claim', 'filename': '/etc/origin/master/.users'}]<br class="title-page-name"/><br class="title-page-name"/>[OSEv3:children]<br class="title-page-name"/>masters<br class="title-page-name"/>nodes<br class="title-page-name"/>etcd</pre>
<div class="packt_infobox">Even though <kbd class="calibre26">openshift_schedulable</kbd> variable appears to be on a separate line, it's actually on the previous line. If you just copy this file as it is from the one provided with other materials on this book, it will work.</div>
<p class="calibre2">Run the following playbooks to perform prerequisites check and actual installation, respectively:</p>
<pre class="calibre18"><br class="title-page-name"/><strong class="calibre1"># cd openshift-ansible</strong><br class="title-page-name"/><strong class="calibre1"># ansible-playbook playbooks/prerequisites.yml</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1"># ansible-playbook playbooks/deploy_cluster.yml</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">In our exercise, we will be<span class="calibre11"> </span>using<span class="calibre11"> </span>two<span class="calibre11"> </span>identity<span class="calibre11"> </span>providers:<span class="calibre11"> </span><strong class="calibre4">LDAP</strong><span class="calibre11"> </span>and<span class="calibre11"> </span><strong class="calibre4">HTPasswd</strong>. We will discuss in more detail in subsequent subsections. Notice that we specified the <kbd class="calibre12">claim</kbd><span class="calibre11"> </span>mapping method for both of them to demonstrate how it works with multiple providers.</p>
<p class="calibre2">After OpenShift is installed, use the following command provided by the <kbd class="calibre12">httpd-tools</kbd><span class="calibre11"> </span>package to create an<span class="calibre11"> </span><kbd class="calibre12">htpasswd</kbd><span class="calibre11"> </span>file with the user<span class="calibre11"> </span><kbd class="calibre12">alice</kbd><span class="calibre11"> </span>and the hashed password<span class="calibre11"> </span><kbd class="calibre12">supersecret</kbd>:</p>
<pre class="calibre18"><strong class="calibre1"># htpasswd -c /etc/origin/master/.users alice</strong><br class="title-page-name"/>New password:<strong class="calibre1"> <kbd class="calibre26">redhat123</kbd></strong><br class="title-page-name"/>Re-type new password: <strong class="calibre1"><kbd class="calibre26">redhat123</kbd></strong><br class="title-page-name"/>Adding password for user alice</pre>
<p class="calibre2">Now we are ready to proceed further.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Authentication</h1>
                
            
            <article>
                
<p class="calibre2">The term authentication refers to the process of validating one's identity. Usually, users aren't created in OpenShift itself, but provided by an external entity, such as the LDAP server or GitHub. The only part where OpenShift steps in is authorization—determining roles and, therefore, permissions for a user. OpenShift supports integration with various identity management solutions used in corporate environments, such as FreeIPA/Identity Management, Active Directory, GitHub, Gitlab, OpenStack Keystone, and OpenID. For the purpose of brevity, we will only discuss the most commonly used ones, but you can refer to <a href="https://docs.openshift.org/latest/install_config/configuring_authentication.html" class="calibre8">https://docs.openshift.org/latest/install_config/configuring_authentication.html</a> for the complete documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Users and identities</h1>
                
            
            <article>
                
<p class="calibre2">A user is any human actor that can make requests to the OpenShift API to access resources and perform actions. Users are typically created in an external identity provider, usually a corporate identity management solution such as <span class="calibre11"><strong class="calibre4">Lightweight Directory Access Protocol</strong> (<strong class="calibre4">LDAP</strong>)</span> or Active Directory.</p>
<p class="calibre2">To support multiple identity providers, OpenShift relies on the concept of identities serving as a bridge between users and identity providers. By default, a new user and identity are created upon the first login. There are four ways to map users to identities:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Method</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Description</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">claim</p>
</td>
<td class="calibre25">
<p class="calibre2">If a user with the same name already exists and is mapped to another identity, creation of another identity and login will fail. This is useful when you want to maintain a clear separation between identities provided by several providers in the case of identical usernames. A potential use case for this method would be transitioning from one authentication scheme to another.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">add</p>
</td>
<td class="calibre25">
<p class="calibre2">If a user with the same name already exists and is mapped to another identity, another identity mapped to the same user is created. This is useful if you need to provide users from separate organizational entities that have their own identity management solutions with the ability to authenticate using mechanisms that are convenient for them.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">lookup</p>
</td>
<td class="calibre25">
<p class="calibre2">OpenShift looks up an existing user, identity, and mapping, but doesn't create any of them, so these entities must exist prior to the user being able to log in.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">generate</p>
</td>
<td class="calibre25">
<p class="calibre2">If a user with the same name already exists and is mapped to another identity, a separate user mapped to this identity is generated.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"><br class="calibre5"/>
Go to <kbd class="calibre12">https://172.24.0.11:8443</kbd> in your web browser and you will see the login page where you can choose from available identity providers:</p>
<p class="cdpaligncenter"><img class="alignnone49" src="../images/00059.jpeg"/></p>
<p class="calibre2">Log in via browser with the <kbd class="calibre12">LDAP</kbd> identity provider using the username <kbd class="calibre12">alice</kbd> and the password <kbd class="calibre12">supersecret</kbd>, and observe that the user was created using CLI:</p>
<pre class="calibre18"><strong class="calibre1"># oc get user</strong><br class="title-page-name"/>NAME    UID      FULL NAME     IDENTITIES<br class="title-page-name"/>alice bf11471e-47a8-11e8-8dee-525400daa710  Alice Springs   LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com</pre>
<div class="packt_infobox">Notice that identity's name is composed of its type and user locator, delimited by colon. Locator is provider-specific and specifies how to request a particular user from a specific provider.</div>
<p class="calibre2">You can also see that an identity was created as well and mapped to the user:</p>
<pre class="calibre18"><strong class="calibre1"># oc get identity</strong><br class="title-page-name"/>NAME  IDP  NAME  IDP  USER NAME                                             USER   NAME  USER UID<br class="title-page-name"/>LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com   LDAP            uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com   alice       bf11471e-47a8-11e8-8dee-525400daa710</pre>
<p class="calibre2">Let's try to log in with the <kbd class="calibre12">PASSWORD_FILE</kbd> provider using the same credentials:</p>
<p class="cdpaligncenter"><img class="alignnone50" src="../images/00060.jpeg"/></p>
<p class="calibre2">The credentials are correct, but OpenShift was unable to create a new identity and identity mapping to an existing user, as the user was already <kbd class="calibre12">claim</kbd>ed by the LDAP provider. This is exactly what the message <span class="calibre11">Could not create user</span> indicates.</p>
<p class="calibre2">Let's delete the user and its identity to provide a clean slate for the upcoming demonstrations:</p>
<pre class="calibre18"><strong class="calibre1"># oc delete user/alice</strong><br class="title-page-name"/>user "alice" deleted<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"># oc delete \<br class="title-page-name"/>identity/LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com</strong><br class="title-page-name"/><strong class="calibre1"><br class="title-page-name"/></strong>identity "LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com" deleted</pre>
<p class="calibre2">Change the mapping method for the <kbd class="calibre12">PASSWORD_FILE</kbd> provider to <kbd class="calibre12">add</kbd>:</p>
<pre class="calibre18"><strong class="calibre1"># cat /etc/origin/master/master-config.yaml</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/> - challenge: true<br class="title-page-name"/> login: true<br class="title-page-name"/> mappingMethod: add<br class="title-page-name"/> name: PASSWORD_FILE<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">And restart the master API service:</p>
<pre class="calibre18"><strong class="calibre1"># systemctl restart origin-master-api</strong></pre>
<p class="calibre2">Log in with <kbd class="calibre12">LDAP</kbd> using <kbd class="calibre12">alice:supersecret</kbd> again, just as you did the first time, and then with <kbd class="calibre12">PASSWORD_FILE</kbd>using <kbd class="calibre12">alice:redhat123</kbd> . Notice that the second identity was added to the existing one and mapped to the same user:</p>
<pre class="calibre18"><strong class="calibre1"># oc get user</strong><br class="title-page-name"/>NAME      UID     FULL NAME     IDENTITIES<br class="title-page-name"/>alice     bf11471e-47a8-11e8-8dee-525400daa710   Alice Springs   LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com, PASSWORD_FILE:alice</pre>
<div class="packt_infobox">The order in which you use identity providers to log in is important! As you specified the <kbd class="calibre26">add</kbd> method for the <kbd class="calibre26">PASSWORD_FILE</kbd> provider only, if you try to log in with it first, you won't be able to log in using <strong class="calibre1">LDAP</strong>, because it is still set up to <strong class="calibre1">claim</strong> non-existing users and return an error if they already exist.</div>
<p class="calibre2">In order to see that we now have two identities mapped to the same user more clearly, run the following command:</p>
<pre class="calibre18"><strong class="calibre1"># oc get identity</strong><br class="title-page-name"/>NAME IDP     NAME IDP USER NAME                                             USER  NAME   USER UID<br class="title-page-name"/>LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com   LDAP            uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com   alice       bf11471e-47a8-11e8-8dee-525400daa710<br class="title-page-name"/>PASSWORD_FILE:alice                                            PASSWORD_FILE   alice                                                     alice       bf11471e-47a8-11e8-8dee-525400daa7</pre>
<p class="calibre2">Had the username been different, the second identity would have been mapped to that separate user.</p>
<p class="calibre2">Delete the user and identities before continuing with the next demonstration:</p>
<pre class="calibre18"><strong class="calibre1"># oc delete user/alice</strong><br class="title-page-name"/>user "alice" deleted<br class="title-page-name"/><strong class="calibre1"><br class="title-page-name"/># oc delete \<br class="title-page-name"/>identity/LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com</strong><br class="title-page-name"/>identity </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<pre class="calibre18">"LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com" deleted<br class="title-page-name"/><strong class="calibre1"><br class="title-page-name"/># oc delete identity/PASSWORD_FILE:alice</strong><br class="title-page-name"/>identity "PASSWORD_FILE:alice" deleted</pre>
<p class="calibre2">Now, change the mapping method for the same provider to <kbd class="calibre12">lookup</kbd>:</p>
<pre class="calibre18"><strong class="calibre1"># cat /etc/origin/master/master-config.yaml</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/> - challenge: true<br class="title-page-name"/> login: true<br class="title-page-name"/> mappingMethod: lookup<br class="title-page-name"/> name: PASSWORD_FILE<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Restart the master API to apply changes:</p>
<pre class="calibre18"><strong class="calibre1"># systemctl restart origin-master-api</strong></pre>
<p class="calibre2">Now login with <kbd class="calibre12">LDAP</kbd> using <kbd class="calibre12">alice:supersecret</kbd> first. It should allow you to login. Then try to login with <kbd class="calibre12">PASSWORD_FILE</kbd>using <kbd class="calibre12">alice:redhat123</kbd>. You should see a new error provided below:</p>
<p class="cdpaligncenter"><img class="alignnone51" src="../images/00061.jpeg"/></p>
<p class="calibre2"><span class="calibre11">Could not find user</span> means that we didn't create an identity in OpenShift for this provider and didn't map it to any user, as <kbd class="calibre12">lookup</kbd> mapping method requires. Let's rectify this by creating the identity first:</p>
<pre class="calibre18"><strong class="calibre1"># oc create identity PASSWORD_FILE:alice</strong><br class="title-page-name"/>identity "PASSWORD_FILE:alice" created</pre>
<p class="calibre2">Then, map it to the pre-existing user:</p>
<pre class="calibre18"><strong class="calibre1"># oc create useridentitymapping PASSWORD_FILE:alice alice</strong><br class="title-page-name"/>useridentitymapping "PASSWORD_FILE:alice" created</pre>
<p class="calibre2">After that, the login attempt will be successful.</p>
<p class="calibre2">Once you verified that you can login with <kbd class="calibre12">alice:redhat123</kbd> , you can delete the user and both identities to proceed further.</p>
<pre class="calibre18"><strong class="calibre1"># oc delete user/alice</strong><br class="title-page-name"/>user "alice" deleted<br class="title-page-name"/><strong class="calibre1"># oc delete \<br class="title-page-name"/>identity/LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com</strong><br class="title-page-name"/><strong class="calibre1"><br class="title-page-name"/></strong>identity "LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com" deleted<br class="title-page-name"/><strong class="calibre1"># oc delete identity/PASSWORD_FILE:alice</strong><br class="title-page-name"/>identity "PASSWORD_FILE:alice" deleted</pre>
<div class="packt_infobox">We didn't have to run <kbd class="calibre26">oc get identity</kbd> command again to get the list of all identities, because you can delete an identity using its name, which depends on the provider's name and the user's locator; since they hadn't changed, we could just use the same command as before.</div>
<p class="calibre2">Lastly, change the mapping method to <kbd class="calibre12">generate</kbd>:</p>
<pre class="calibre18"><strong class="calibre1"># cat /etc/origin/master/master-config.yaml</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>  - challenge: true<br class="title-page-name"/>    login: true<br class="title-page-name"/>    mappingMethod: generate<br class="title-page-name"/>    name: PASSWORD_FILE<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Restart the master API:</p>
<pre class="calibre18"><strong class="calibre1"># systemctl restart origin-master-api</strong></pre>
<p class="calibre2">Just as before, log in with <kbd class="calibre12">LDAP</kbd> using <kbd class="calibre12">alice:supersecret</kbd> and then with <kbd class="calibre12">PASSWORD_FILE</kbd>using <kbd class="calibre12">alice:redhat123</kbd>. Let's see what users were created:</p>
<pre class="calibre18"><strong class="calibre1"># oc get user</strong><br class="title-page-name"/>NAME      UID       FULL NAME       IDENTITIES<br class="title-page-name"/>alice     97bd5ede-47b5-11e8-9f47-525400daa710   Alice Springs   LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com<br class="title-page-name"/>alice2    a145c96e-47b5-11e8-9f47-525400daa710                   PASSWORD_FILE:alice</pre>
<p class="calibre2">As you can see, this method creates a separate user with a <kbd class="calibre12">generate</kbd>d name using a separate identity mapping if the user with the same name already exists.</p>
<p class="calibre2">You can see that two identities are now mapped to different users:</p>
<pre class="calibre18"><strong class="calibre1"># oc get identity</strong><br class="title-page-name"/>NAME   IDP NAME IDP USER NAME  USER NAME   USER UID<br class="title-page-name"/>LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com   LDAP            uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com   alice       97bd5ede-47b5-11e8-9f47-525400daa710<br class="title-page-name"/>PASSWORD_FILE:alice                                            PASSWORD_FILE   alice                                                     alice2      a145c96e-47b5-11e8-9f47-525400daa710<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre2">Finally, let's delete the user and identities:</p>
<pre class="calibre18"><strong class="calibre1"># oc delete user/alice</strong><br class="title-page-name"/>user "alice" deleted<strong class="calibre1"><br class="title-page-name"/><br class="title-page-name"/># oc delete user/alice2<br class="title-page-name"/></strong>user "alice2" deleted<strong class="calibre1"><br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1"># oc delete \<br class="title-page-name"/>identity/LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com</strong><br class="title-page-name"/>identity "LDAP:uid=alice,cn=users,cn=accounts,dc=idm,dc=example,dc=com" deleted<br class="title-page-name"/><strong class="calibre1"># oc delete identity/PASSWORD_FILE:alice</strong><br class="title-page-name"/>identity "PASSWORD_FILE:alice" deleted<strong class="calibre1"><br class="title-page-name"/><br class="title-page-name"/># exit<br class="title-page-name"/>$ exit</strong></pre>
<p class="calibre2">Now that this exercise is over, we can stop our VMs from releasing system resources for MiniShift for the rest of the chapter:</p>
<pre class="calibre18"><strong class="calibre1">$ vagrant halt</strong><br class="title-page-name"/>==&gt; idm: Attempting graceful shutdown of VM...<br class="title-page-name"/>==&gt; openshift: Attempting graceful shutdown of VM...</pre>
<div class="packt_infobox">We suggest you to just  <kbd class="calibre26">halt</kbd> this lab, as it will be used in the section <em class="calibre28">Admission controllers</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service accounts</h1>
                
            
            <article>
                
<p class="calibre2">Service accounts give us flexibility to control access to API without sharing user’s credentials. In order to show you how it works we need to start the MiniShift VM:</p>
<pre class="calibre18"><strong class="calibre1">$ minishift start --openshift-version=v3.9.0 --vm-driver=virtualbox</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Next, <kbd class="calibre12">export PATH</kbd> to <kbd class="calibre12">oc</kbd> client:</p>
<pre class="calibre18"><strong class="calibre1">$ export PATH="/home/$USER/.minishift/cache/oc/v3.9.0/linux:$PATH"</strong></pre>
<p class="calibre2">Now, switch your Docker client to point to the docker daemon inside the MiniShift VM:</p>
<pre class="calibre18"><strong class="calibre1">$ eval $(minishift docker-env)</strong></pre>
<p class="calibre2">Finally, log in as the privileged user <kbd class="calibre12">system:admin</kbd> in order to be able to perform privileged operations, such as adding SCCs and roles:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u system:admin</strong></pre>
<p class="calibre2">Now, we are ready to get started.</p>
<p class="calibre2">Another type of user that we will be using is service accounts. They are used by pods and other non-human actors to perform various actions and are a central vehicle by which their access to resources is managed. By default, three service accounts are created in each project:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Name</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Description</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">builder</p>
</td>
<td class="calibre25">
<p class="calibre2">Used by build pods and assigned the system:image-builder role, which grants push capability into the internal registry to any image stream in the project.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">deployer</p>
</td>
<td class="calibre25">
<p class="calibre2">Used by deploy pods and assigned the system:deployer role, which allows modifying replication controllers in the project.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">default</p>
</td>
<td class="calibre25">
<p class="calibre2">Used by all other pods by default.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">You can see them by running the following command:</p>
<pre class="calibre18"><strong class="calibre1">$ oc get serviceaccounts</strong><br class="title-page-name"/>NAME               SECRETS   AGE<br class="title-page-name"/>builder            2         58s<br class="title-page-name"/>default            2         58s<br class="title-page-name"/>deployer           2         58s</pre>
<p class="calibre2">Each service account is represented by the <kbd class="calibre12">ServiceAccount</kbd> resource and is associated with two additional secrets—for access to the OpenShift API and the internal registry:</p>
<pre class="calibre18"><strong class="calibre1">$ oc describe serviceaccounts/default</strong><br class="title-page-name"/>Name: default<br class="title-page-name"/>Namespace: myproject<br class="title-page-name"/>Labels: &lt;none&gt;<br class="title-page-name"/>Annotations: &lt;none&gt;<br class="title-page-name"/>Image pull secrets:    default-dockercfg-wggrl<br class="title-page-name"/>Mountable secrets:     default-token-mg64x<br class="title-page-name"/>                       default-dockercfg-wggrl<br class="title-page-name"/>Tokens:                default-token-7cljg<br class="title-page-name"/>                       default-token-mg64x<br class="title-page-name"/>Events:                &lt;none&gt;</pre>
<p class="calibre2">The service account can be created with a simple command:</p>
<pre class="calibre18"><strong class="calibre1">$ oc create sa myserviceaccount</strong><br class="title-page-name"/>serviceaccount "myserviceaccount" created</pre>
<p class="calibre2">Let's delete it for now, as we will be creating it again later on in this chapter:</p>
<pre class="calibre18"><strong class="calibre1">$ oc delete sa/myserviceaccount</strong><br class="title-page-name"/>serviceaccount "myserviceaccount" deleted</pre>
<p class="calibre2">Every service account is also a member of two groups:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre12">system:serviceaccounts</kbd>, which includes all service accounts in the cluster</li>
<li class="calibre10"><kbd class="calibre12">system:serviceaccounts:&lt;project&gt;</kbd>, which includes all service accounts in the <kbd class="calibre12">project</kbd></li>
</ul>
<p class="calibre2">You can grant privileges to groups of service accounts, which will effectively grant those privileges to all accounts in the group. For example, to grant view privileges to all service accounts in the cluster in the project <kbd class="calibre12">myproject</kbd>, type the following command:</p>
<pre class="calibre18"><strong class="calibre1">$ oc adm policy add-role-to-group view system:serviceaccounts -n myproject</strong><br class="title-page-name"/>role "view" added: "system:serviceaccounts"</pre>
<p class="calibre2">We specified <kbd class="calibre12">-n</kbd> only as a demonstration; as your current project is <kbd class="calibre12">myproject</kbd>, you could have omitted it.</p>
<p class="calibre2">Let's revert our changes and learn how to remove a particular role from a user in the process:</p>
<pre class="calibre18"><strong class="calibre1">$ oc adm policy remove-role-from-group view system:serviceaccounts -n myproject</strong><br class="title-page-name"/>role "view" removed: "system:serviceaccounts"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Identity providers</h1>
                
            
            <article>
                
<p class="calibre2">Usually, users aren't created in OpenShift directly, but rather are supplied by an external identity management solution, which can be as complex as LDAP and Active Directory with a trust relationship set up between them, or as simple as a text password file with hashed passwords. Choosing a particular identity provider is influenced by factors such as:</p>
<ul class="calibre9">
<li class="calibre10">Your company's existing identity management solution</li>
<li class="calibre10">How often users are added and deleted</li>
<li class="calibre10">Whether you need a centralized management</li>
</ul>
<p class="calibre2">OpenShift implements the following identity providers:</p>
<ul class="calibre9">
<li class="calibre10">AllowAll</li>
<li class="calibre10">DenyAll</li>
<li class="calibre10">HTPasswd</li>
<li class="calibre10">LDAP</li>
<li class="calibre10">Keystone</li>
<li class="calibre10">BasicAuth</li>
<li class="calibre10">RequestHeader</li>
<li class="calibre10">GitLab</li>
<li class="calibre10">GitHub</li>
<li class="calibre10">OpenID</li>
<li class="calibre10">Google</li>
</ul>
<p class="calibre2">For the sake of brevity, we will limit demonstrations to the first four providers in the preceding list, while you can fill in the gaps by referring to <a href="https://docs.openshift.org/latest/install_config/configuring_authentication.html" class="calibre8">https://docs.openshift.org/latest/install_config/configuring_authentication.html</a> . These configurations are to be applied to the master configuration file located at <kbd class="calibre12">/etc/origin/master/master-config.yml</kbd>.</p>
<div class="packt_tip">You will need to bring your vagrant environment up if you want to test out the configuratins below because it won't work with minishift.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AllowAll</h1>
                
            
            <article>
                
<p class="calibre2">This is the default identity provider for MiniShift and OpenShift Origin, including when the master is started without its configuration file. It allows all users with all passwords, so no authentication is performed. It is only useful for debugging purposes when you integrate your cluster with a corporate identity solution.</p>
<p class="calibre2">A configuration snippet from the master configuration file for this provider is as follows:</p>
<pre class="calibre18">...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>... <br class="title-page-name"/> identityProviders:<br class="title-page-name"/>  - challenge: true<br class="title-page-name"/>    login: true<br class="title-page-name"/>    mappingMethod: claim<br class="title-page-name"/>    name: anypassword<br class="title-page-name"/>    provider:<br class="title-page-name"/>      apiVersion: v1<br class="title-page-name"/>      kind: AllowAllPasswordIdentityProvider<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>... </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DenyAll</h1>
                
            
            <article>
                
<p class="calibre2">This identity provider is the opposite of AllowAll, that is, it denies access to everyone. It is useful when you want to temporarily lock your cluster from everyone for maintenance or other purposes. This is the default provider for the Red Hat OpenShift Container Platform.</p>
<p class="calibre2">A configuration snippet of the master configuration file for this provider is as follows:</p>
<pre class="calibre18">...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>... <br class="title-page-name"/> identityProviders:        <br class="title-page-name"/>  - challenge: true   <br class="title-page-name"/>    login: true                        <br class="title-page-name"/>    mappingMethod: claim       <br class="title-page-name"/>    name: anypassword        <br class="title-page-name"/>    provider:            <br class="title-page-name"/>      apiVersion: v1<br class="title-page-name"/>      kind: DenyAllPasswordIdentityProvider<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>... </pre>
<p class="calibre2">As you can see, all it takes to enable it is changing <kbd class="calibre12">Allow</kbd> to <kbd class="calibre12">Deny</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">HTPasswd</h1>
                
            
            <article>
                
<p class="calibre2">This provider allows you to create a file with the a of users with hashed passwords, giving you granular access control. While certainly better than having your installation just either accept or deny everyone, this approach still has two disadvantages:</p>
<ul class="calibre9">
<li class="calibre10">In the case of HA installation with multiple masters, you will need to synchronize changes to the password file between all masters, which is prone to errors and inefficient. Sure, it can be automated using configuration management and the <strong class="calibre1">version control system</strong> (<strong class="calibre1">VCS</strong>), but there are very few use cases where you wouldn't want to integrate your cluster with the corporate identity management server.</li>
<li class="calibre10">It doesn't integrate with the corporate identity management solution, which requires you to either create all users in the password file directly, or to set up some sort of synchronization mechanism between your identity management server and OpenShift masters/configuration management server.</li>
</ul>
<p class="calibre2">To enable this identity provider, we need to create the password file first, which, in turn, requires the <kbd class="calibre12">httpd-tools</kbd> package to be installed:</p>
<pre class="calibre18"><strong class="calibre1"># sudo yum -y install httpd-tools</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>Complete!</pre>
<p class="calibre2">Next, create the file and add users to it. Specify the <kbd class="calibre12">-c</kbd> flag when creating the first user to create the file:</p>
<pre class="calibre18"><strong class="calibre1"># htpasswd -c /etc/origin/master/.htpasswd bob</strong><br class="title-page-name"/>New password: <br class="title-page-name"/>Re-type new password: <br class="title-page-name"/>Adding password for user bob<br class="title-page-name"/><strong class="calibre1"># htpasswd /etc/origin/master/.htpasswd alice</strong><br class="title-page-name"/>New password: <br class="title-page-name"/>Re-type new password: <br class="title-page-name"/>Adding password for user alice</pre>
<p class="calibre2">Now, we can enable this provider by changing AllowAll from the default configuration to <kbd class="calibre12">htpasswd</kbd> and specifying the location of the password file:</p>
<pre class="calibre18">...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>... <br class="title-page-name"/> identityProviders:        <br class="title-page-name"/>  - challenge: true   <br class="title-page-name"/>    login: true                        <br class="title-page-name"/>    mappingMethod: claim       <br class="title-page-name"/>    name: anypassword        <br class="title-page-name"/>    provider:            <br class="title-page-name"/>      apiVersion: v1<br class="title-page-name"/>      kind: HTPasswdPasswordIdentityProvider<br class="title-page-name"/>      file: /etc/origin/master/.htpasswd<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Lastly, restart master API service to have it pick up the changes:</p>
<pre class="calibre18"><strong class="calibre1"># systemctl restart origin-master-api</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">LDAP</h1>
                
            
            <article>
                
<p class="calibre2">This is the identity provider you will most likely use in your organization because of the popularity of LDAP (<span class="calibre11">Lightweight Directory Access Protocol)</span>. If you are building your OpenShift lab from scratch, you can use either FreeIPA or IdM—they are very easy to set up. Like other centralized identity management solutions, LDAP spares you the need to synchronize changes to password files between masters in the case of multiple masters setup.</p>
<p class="calibre2">A configuration snippet from the master configuration file for this provider could look like the following:</p>
<pre class="calibre18">...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>  identityProviders:        <br class="title-page-name"/>  - challenge: true   <br class="title-page-name"/>    login: true                        <br class="title-page-name"/>    mappingMethod: claim       <br class="title-page-name"/>    name: ldap               <br class="title-page-name"/>    provider:            <br class="title-page-name"/>      apiVersion: v1<br class="title-page-name"/>      kind: LDAPPasswordIdentityProvider   <br class="title-page-name"/>      attributes:        <br class="title-page-name"/>        id:                                  <br class="title-page-name"/>          - dn                               <br class="title-page-name"/>        email:                               <br class="title-page-name"/>          - mail                             <br class="title-page-name"/>        name:                                <br class="title-page-name"/>          - cn                               <br class="title-page-name"/>        preferredUsername:                   <br class="title-page-name"/>          - uid                              <br class="title-page-name"/>     insecure: true                          <br class="title-page-name"/>     bindDN: 'uid=openshift_admin,cn=users,cn=accounts,dc=example,dc=com'        <br class="title-page-name"/>     bindPassword: 'secretpassword'          <br class="title-page-name"/>     url: 'ldap://idm.example.com/cn=users,cn=accounts,dc=example,dc=com?uid'<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>... </pre>
<p class="calibre2">You can set the <kbd class="calibre12">insecure</kbd> parameter to <kbd class="calibre12">false</kbd> if your LDAP server supports the LDAPS secure protocol.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Authorization and role-based access control</h1>
                
            
            <article>
                
<p class="calibre2">Authorization in OpenShift is built around the following concepts:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Rules:</strong> Sets of actions allowed to be performed on specific resources.</li>
<li class="calibre10"><strong class="calibre1">Roles:</strong> Collections of rules that allow them to be applied to a user according to a specific usage profile. Roles can be applied either at the cluster or project level.</li>
<li class="calibre10"><strong class="calibre1">Role bindings:</strong> Associations between users/groups and roles. A given user or group can be associated with multiple roles.</li>
</ul>
<p class="calibre2">Let's return to our MiniShift environment. To see a list of all available cluster roles, run the following command:</p>
<pre class="calibre18"><strong class="calibre1">$ oc get clusterrole</strong><br class="title-page-name"/>NAME<br class="title-page-name"/>admin<br class="title-page-name"/>basic-user<br class="title-page-name"/>cluster-admin</pre>
<pre class="calibre18"><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>view</pre>
<p class="calibre2">Use the <kbd class="calibre12">describe</kbd> command to understand what rules are in a particular role:</p>
<pre class="calibre18"><strong class="calibre1">$ oc describe clusterrole/edit</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">You can see from the preceding output that, for example, users with this role can create and delete such resources as pods, configmaps, deploymentconfigs, imagestreams, routes, and services, but cannot do anything with projects, other than view them.</p>
<p class="calibre2">On the other hand, if you describe the view role, you will notice that the only actions allowed on resources are get, list, and watch, which makes it a perfect choice if, for example, you want to grant a development team the ability to view application resources in production, but not to modify any of them or create new resources:</p>
<pre class="calibre18"><strong class="calibre1">$ oc describe clusterrole/view</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using built-in roles</h1>
                
            
            <article>
                
<p class="calibre2">Let's see how we can use the <kbd class="calibre12">edit</kbd> pre-defined role to grant a user access to another user's project. First, login at MiniShift as <kbd class="calibre12">alice</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u alice</strong><strong class="calibre1"><br class="title-page-name"/></strong>Authentication required for https://192.168.99.100:8443 (openshift)<br class="title-page-name"/>Username: <strong class="calibre1">alice</strong><br class="title-page-name"/>Password: <strong class="calibre1">&lt;anypassword&gt;</strong><br class="title-page-name"/>Login successful.</pre>
<div class="packt_infobox">Just as with an OpenShift cluster deployed via Ansible, the default identity provider is AllowAll, which allows you to use any credentials.</div>
<p class="calibre2">Next, create a new project called <kbd class="calibre12">alice-project</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ oc new-project alice-project</strong><br class="title-page-name"/>Now using project "alice-project" on server "https://192.168.99.100:8443".<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre2">Login as <kbd class="calibre12">bob</kbd> and observe that they weren't added as a member to any project by default:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u bob</strong><br class="title-page-name"/>Username: <strong class="calibre1">bob</strong><br class="title-page-name"/>Password: <strong class="calibre1">&lt;anypassword&gt;</strong><br class="title-page-name"/>Login successful.<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ oc project alice-project</strong><br class="title-page-name"/>error: You are not a member of project "alice-project".<br class="title-page-name"/>You are not a member of any projects. You can request a project to be created with the 'new-project' command.<br class="title-page-name"/>To see projects on another server, pass '--server=&lt;server&gt;'.</pre>
<p class="calibre2">Let's correct this by granting <kbd class="calibre12">bob</kbd> the privilege to <kbd class="calibre12">edit</kbd> most of the resources in the <kbd class="calibre12">alice-project</kbd> project:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u alice</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>Using project "alice-project".<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ oc adm policy add-role-to-user edit bob</strong><br class="title-page-name"/>role "edit" added: "bob"</pre>
<p class="calibre2">You can use the following command to see the existing <kbd class="calibre12">rolebinding</kbd> in the current <kbd class="calibre12">alice-project</kbd> project:</p>
<pre class="calibre18"><strong class="calibre1">$ oc get rolebinding</strong><br class="title-page-name"/>NAME                    ROLE   USERS GROUPS  SERVICE ACCOUNTS   SUBJECTS<br class="title-page-name"/>admin                   /admin                  alice<br class="title-page-name"/>edit                    /edit                   bob<br class="title-page-name"/>system:deployers        /system:deployer                                                         deployer<br class="title-page-name"/>system:image-builders   /system:image-builder                                                    builder<br class="title-page-name"/>system:image-pullers    /system:image-puller              system:serviceaccounts:alice-project</pre>
<p class="calibre2">Notice that there are always two local bindings for the <kbd class="calibre12">deployer</kbd> and <kbd class="calibre12">builder</kbd> service accounts, as well as one binding granting all service accounts in the <kbd class="calibre12">alice-project</kbd> project the ability to pull images from the internal registry. Another two bindings make <kbd class="calibre12">alice</kbd> the admin of her project and grant <kbd class="calibre12">bob</kbd> the privilege of editing most of the resources in the project.</p>
<p class="calibre2">Let's see the details of the <kbd class="calibre12">edit</kbd> role binding:</p>
<pre class="calibre18"><strong class="calibre1">$ oc describe rolebinding edit</strong><br class="title-page-name"/>Name:                          edit<br class="title-page-name"/>Namespace:                     alice-project<br class="title-page-name"/>Created:                       17 hours ago<br class="title-page-name"/>Labels:                        &lt;none&gt;<br class="title-page-name"/>Annotations:                   &lt;none&gt;<br class="title-page-name"/>Role:                          /edit<br class="title-page-name"/>Users:                         bob<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">The preceding output tells us that the user <kbd class="calibre12">bob</kbd> is bound to the <kbd class="calibre12">edit</kbd> role in the project <kbd class="calibre12">alice-project</kbd>. The omitted output is the same as in the details of the <kbd class="calibre12">edit</kbd> role.</p>
<p class="calibre2">Log back in as <kbd class="calibre12">bob</kbd> and see that now you have access to Alice's project:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u bob</strong><br class="title-page-name"/>Logged into "https://192.168.99.100:8443" as "bob" using existing credentials.<br class="title-page-name"/><br class="title-page-name"/>You have one project on this server: "alice-project"<br class="title-page-name"/><br class="title-page-name"/>Using project "alice-project".</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating custom roles</h1>
                
            
            <article>
                
<p class="calibre2">If pre-defined roles aren't sufficient for you, you can always create custom roles with just the specific rules you need. Let's create a custom role that can be used instead of the <kbd class="calibre12">edit</kbd> role to create and get pods:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u system:admin</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc create clusterrole alice-project-edit --verb=get,list,watch --</strong></pre>
<pre class="calibre18"><strong class="calibre1">resource=namespace,project</strong><br class="title-page-name"/>clusterrole "alice-project-edit" created</pre>
<p class="calibre2">Notice that we had to log in as cluster administrator to create a cluster role. A cluster role is required to make its users members of a particular project.</p>
<p class="calibre2">OpenShift's <kbd class="calibre12">create clusterrole</kbd> command is limited to creating only one set of resources and verbs, so we couldn't add different verbs for pods. We can work around this limitation by editing the role directly:</p>
<pre class="calibre18"><strong class="calibre1">$ oc edit clusterrole/alice-project-edit</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>- apiGroups:<br class="title-page-name"/>  - ""  <span class="underline"># DO NOT MISS THIS LINE OR IT IS NOT GOING TO WORK  </span><br class="title-page-name"/>  attributeRestrictions: null<br class="title-page-name"/>  resources:<br class="title-page-name"/>  - pods<br class="title-page-name"/>  verbs:<br class="title-page-name"/>  - create<br class="title-page-name"/>  - get<br class="title-page-name"/>  - list<br class="title-page-name"/>  - watch<br class="title-page-name"/><br class="title-page-name"/>clusterrole "alice-project-edit" edited</pre>
<p class="calibre2">Next, delete the <kbd class="calibre12">edit</kbd> role from bob:</p>
<pre class="calibre18"><strong class="calibre1">$ oc adm policy remove-role-from-user edit bob</strong><br class="title-page-name"/>role "edit" removed: "bob"</pre>
<p class="calibre2">Assign the new role to <kbd class="calibre12">bob</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ oc adm policy add-role-to-user alice-project-edit bob</strong><br class="title-page-name"/>role "alice-project-edit" added: "bob"</pre>
<p class="calibre2">Login as <kbd class="calibre12">bob</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u bob</strong><br class="title-page-name"/>...</pre>
<p class="calibre2">And start a new pod, just as we did before:</p>
<pre class="calibre18"><strong class="calibre1">$ cat nginx-pod.yml</strong><br class="title-page-name"/>apiVersion: v1<br class="title-page-name"/>kind: Pod<br class="title-page-name"/>metadata:<br class="title-page-name"/>  name: nginx<br class="title-page-name"/>  labels:<br class="title-page-name"/>    role: web<br class="title-page-name"/>spec:<br class="title-page-name"/>  containers:<br class="title-page-name"/>  - name: nginx<br class="title-page-name"/>    image: nginx<br class="title-page-name"/>    resources:<br class="title-page-name"/>      requests:<br class="title-page-name"/>        cpu: 100m<br class="title-page-name"/>        memory: 128Mi<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ oc create -f nginx-pod.yml</strong><br class="title-page-name"/>pod "nginx" created<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ oc get po</strong><br class="title-page-name"/>NAME  READY STATUS RESTARTS AGE<br class="title-page-name"/>nginx 0/1   Error  0        2h</pre>
<p class="calibre2"><span class="calibre11">What happened? Let's take a look into the pod's logs:</span></p>
<pre class="calibre18"><strong class="calibre1">$ oc logs -f nginx</strong> <br class="title-page-name"/>Error from server (Forbidden): pods "nginx" is forbidden: User "bob" cannot get pods/log in the namespace "alice-project": User "bob" cannot get pods/log in project "alice-project"</pre>
<p class="calibre2">This is expected, because we didn't grant our custom role <kbd class="calibre12">alice-project-edit</kbd> access to pods' logs. If you look closely, this error message actually contains a suggestion on what we need to do - grant access to <kbd class="calibre12">pods/log</kbd> resource. Let's fix that by logging as <kbd class="calibre12">system:admin</kbd> user, adding required section to the role's definition, and log back in as <kbd class="calibre12">bob</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u system:admin</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc edit clusterrole/alice-project-edit</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>- apiGroups:<br class="title-page-name"/>  - ""<br class="title-page-name"/>  attributeRestrictions: null<br class="title-page-name"/>  resources:<br class="title-page-name"/>  - pods<br class="title-page-name"/>  - pods/log<br class="title-page-name"/>  verbs:<br class="title-page-name"/>  - get</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<pre class="calibre18"><br class="title-page-name"/><strong class="calibre1">$ oc login -u bob</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Try listing the pod's logs again:</p>
<pre class="calibre18"><strong class="calibre1">$ oc logs -f nginx</strong> <br class="title-page-name"/>2018/07/18 02:44:31 [warn] 1#1: the "user" directive makes sense only if the master process runs with super-user privileges, ignored in /etc/nginx/nginx.conf:2<br class="title-page-name"/>nginx: [warn] the "user" directive makes sense only if the master process runs with super-user privileges, ignored in /etc/nginx/nginx.conf:2<br class="title-page-name"/>2018/07/18 02:44:31 [emerg] 1#1: mkdir() "/var/cache/nginx/client_temp" failed (13: Permission denied)<br class="title-page-name"/>nginx: [emerg] mkdir() "/var/cache/nginx/client_temp" failed (13: Permission denied)</pre>
<p class="calibre2">This time it works and you are able to see <span class="calibre11">that the container is having </span>problems<span class="calibre11"> with permissions. For now, run the following command to correct this, but we will address this problem in more detail in the <em class="calibre17">Security context constraints</em> section:</span></p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u system:admin</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ oc delete po/nginx</strong> <br class="title-page-name"/>pod "nginx" deleted<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ oc adm policy add-scc-to-user anyuid -z default</strong><br class="title-page-name"/>scc "anyuid" added to: ["system:serviceaccount:alice-project:default"]<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ oc login -u bob</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">And now it works:</p>
<pre class="calibre18"><strong class="calibre1">$ oc create -f nginx-pod.yml</strong><br class="title-page-name"/>pod "nginx" created<strong class="calibre1"><br class="title-page-name"/></strong><strong class="calibre1"><br class="title-page-name"/>$ oc get po</strong> <br class="title-page-name"/>NAME  READY STATUS  RESTARTS AGE<br class="title-page-name"/>nginx 1/1   Running 0        2h</pre>
<p class="calibre2">We just created a custom role that we can use to grant its users the ability to only create pods. It's not very useful as it is, as it won't let you create a service, for example:</p>
<pre class="calibre18"><strong class="calibre1">$ oc expose po/nginx --port=80</strong><br class="title-page-name"/>Error from server (Forbidden): User "bob" cannot create services in the namespace "alice-project": User "bob" cannot create services in project "alice-project" (post services)</pre>
<p class="calibre2">Now that this exercise is over, let's clean everything up:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u system:admin</strong><br class="title-page-name"/><strong class="calibre1">...<br class="title-page-name"/></strong>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc delete po/nginx</strong><br class="title-page-name"/>pod "nginx" deleted<br class="title-page-name"/><strong class="calibre1">$ oc adm policy remove-role-from-user alice-project-edit bob</strong><br class="title-page-name"/>role "alice-project-edit" removed: "bob"<br class="title-page-name"/><strong class="calibre1">$ oc delete clusterrole alice-project-edit</strong><br class="title-page-name"/>clusterrole "alice-project-edit" deleted</pre>
<div class="packt_infobox">We had to login as <kbd class="calibre26">system:admin</kbd> to delete our pod as we didn't grant the <kbd class="calibre26">alice-project-edit</kbd> role ability to delete pods, only to create them. This is yet another example of how granular RBAC can be in OpenShift.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Admission controllers</h1>
                
            
            <article>
                
<p class="calibre2">Due to the specific nature of this section, we won't be using MiniShift, so let's stop it for now:</p>
<pre class="calibre18"><strong class="calibre1">$ minishift stop</strong><br class="title-page-name"/>...</pre>
<p class="calibre2">Then, start the Vagrant VMs instead:</p>
<pre class="calibre18"><strong class="calibre1">$ vagrant up</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Finally, open a session in the <kbd class="calibre12">openshift</kbd> VM:</p>
<pre class="calibre18"><strong class="calibre1">$ vagrant ssh openshift<br class="title-page-name"/>$ sudo -i</strong></pre>
<p class="calibre2">An Admission Controller is a subroutine that's invoked after a request to the API is authenticated and authorized, but before it's persisted to etcd. Admission Controller serve the purpose of mutating and validating resources to be persisted, such as adding various annotations and defaults and making sure that they conform to specific restrictions. All admission controllers are chained, so that mutating controllers are applied first and then validating ones.</p>
<p class="calibre2">The following diagram illustrates the overall resource admission process:</p>
<p class="cdpaligncenter"><img class="alignnone52" src="../images/00062.jpeg"/></p>
<div class="cdpaligncenter1"> OpenShift resource admission chain</div>
<p class="calibre2">As you can see from the diagram above, the admission chain generally consists of the following types of admission controller:</p>
<ul class="calibre9">
<li class="calibre10">Default admission plugins that can be enabled in the <kbd class="calibre12">admissionConfig</kbd> section of the master configuration file</li>
<li class="calibre10">Mutating admission webhooks</li>
<li class="calibre10">Validating admission webhooks</li>
</ul>
<p class="calibre2">The following are default admission controllers that are present in the master configuration file, unless configured otherwise during installation via the openshift_master_admission_plugin_config variable:</p>
<pre class="calibre18"><strong class="calibre1"># cat /etc/origin/master/master-config.yaml</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>admissionConfig:<br class="title-page-name"/>  pluginConfig:<br class="title-page-name"/>    BuildDefaults:<br class="title-page-name"/>      configuration:<br class="title-page-name"/>        apiVersion: v1<br class="title-page-name"/>        env: []</pre>
<pre class="calibre18"><br class="title-page-name"/>        kind: BuildDefaultsConfig<br class="title-page-name"/>        resources:<br class="title-page-name"/>          limits: {}<br class="title-page-name"/>          requests: {}<br class="title-page-name"/>    BuildOverrides:<br class="title-page-name"/>      configuration:<br class="title-page-name"/>        apiVersion: v1<br class="title-page-name"/>        kind: BuildOverridesConfig<br class="title-page-name"/>    PodPreset:<br class="title-page-name"/>      configuration:<br class="title-page-name"/>        apiVersion: v1<br class="title-page-name"/>        disable: false<br class="title-page-name"/>        kind: DefaultAdmissionConfig<br class="title-page-name"/>    openshift.io/ImagePolicy:<br class="title-page-name"/>      configuration:<br class="title-page-name"/>        apiVersion: v1<br class="title-page-name"/>        executionRules:<br class="title-page-name"/>        - matchImageAnnotations:<br class="title-page-name"/>          - key: images.openshift.io/deny-execution<br class="title-page-name"/>            value: 'true'<br class="title-page-name"/>          name: execution-denied<br class="title-page-name"/>          onResources:<br class="title-page-name"/>          - resource: pods<br class="title-page-name"/>          - resource: builds<br class="title-page-name"/>          reject: true<br class="title-page-name"/>          skipOnResolutionFailure: true<br class="title-page-name"/>        kind: ImagePolicyConfig<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<div class="packt_infobox">You won't find those admission plugins in the MiniShift master API configuration, even if you ssh into the MiniShift VM and look at the master configuration file. This is why we use our own installation of OpenShift.</div>
<p class="calibre2">OpenShift supports the following admission control plugins out-of-the-box:</p>
<div class="title-page-name">
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="cdpaligncenter"><strong class="calibre4">Admission Control Plugin</strong></p>
</td>
<td class="calibre25">
<p class="cdpaligncenter"><strong class="calibre4">Description</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">ProjectRequestLimit</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Limits the number of self-provisioned projects per user.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">BuildDefaults</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Defines default configuration parameters, such as a git proxy server or node to run builder pods on, for BuildConfigs.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">BuildOverrides</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Can be used to override settings defined in a BuildConfig.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">RunOnceDuration</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Limits the amount of time that builder and deployer pods may run.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">PodPreset</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Enables use of PodPresets to supply pods with such resources as Secrets, ConfigMaps, and volumes.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">PodNodeConstraints</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Confines pods to nodes with particular labels.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">PodNodeSelector</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Confines pods to projects with particular labels.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">openshift.io/ImagePolicy</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Controls which images can be used in the cluster based on their registry and annotations.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="cdpalignleft2">openshift.io/IngressAdmission</p>
</td>
<td class="calibre25">
<p class="cdpalignleft2">Disables host name collision prevention for routes and ingress objects, allowing users without the <kbd class="calibre12">cluster-admin</kbd> cluster role to change host names in these objects after they have been created.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="calibre2"><br class="calibre5"/>
Let's use the <kbd class="calibre12">ProjectRequestLimit</kbd> admission plugin to demonstrate how admission controllers are configured.</p>
<ol start="1" class="calibre13">
<li value="1" class="calibre10">Add the <kbd class="calibre12">ProjectRequestLimit</kbd> section to the end of the admission chain in the master configuration file:</li>
</ol>
<pre class="calibre19">admissionConfig:<br class="title-page-name"/>  pluginConfig:<br class="title-page-name"/>    ProjectRequestLimit:<br class="title-page-name"/>      configuration:<br class="title-page-name"/>        apiVersion: v1<br class="title-page-name"/>        kind: ProjectRequestLimitConfig<br class="title-page-name"/>        limits:<br class="title-page-name"/>        - selector:<br class="title-page-name"/>            department: ops<br class="title-page-name"/>          maxProjects: 2<br class="title-page-name"/>        - maxProjects: 3<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre27">In this particular example we are creating 2 different limits. One is for 'ops' department limiting the maximum number of projects to 2 , and another limitation for everyone esle that limits number of projects to 3.</p>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Restart the master API to apply the changes:</li>
</ol>
<pre class="calibre19"><strong class="calibre1"># systemctl restart origin-master-api</strong></pre>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Log in as <kbd class="calibre12">alice</kbd> using password <kbd class="calibre12">supersecret</kbd>, so that the user itself and its identity are created:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ oc login -u alice<br class="title-page-name"/></strong>Username:<strong class="calibre1"> alice</strong><br class="title-page-name"/>Password:<strong class="calibre1"> supersecret</strong><br class="title-page-name"/>Login successful</pre>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Log in as the cluster administrator to be able to create labels:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ oc login -u system:admin</strong></pre>
<p class="calibre27">Now, we need to <kbd class="calibre12">label</kbd> <kbd class="calibre12">alice</kbd> with a key/value pair that matches the selector specified in the admission plugin's configuration:</p>
<pre class="calibre19"><strong class="calibre1">$ oc label user/alice department=ops</strong><br class="title-page-name"/>user "alice" labeled</pre>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">Log back in as <kbd class="calibre12">alice</kbd>:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ oc login -u alice</strong></pre>
<p class="calibre27">And try to create several projects:</p>
<pre class="calibre19"><strong class="calibre1">$ oc new-project alice-project-1</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc new-project alice-project-2</strong><br class="title-page-name"/><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">$ oc new-project alice-project-3</strong><br class="title-page-name"/>Error from server (Forbidden): projectrequests.project.openshift.io "alice-project-3" is forbidden: user alice cannot create more than 2 project(s).</pre>
<p class="calibre2">As you can see, the request to create a third project was intercepted by the admission plugin and rejected due to failed validation.</p>
<p class="calibre2">Let's see how a global limit for all users works by creating a new user with no labels associated with it.</p>
<ol class="calibre13">
<li value="1" class="calibre10">First, create a new user called bob. You can use the same password <kbd class="calibre12">supersecret</kbd> for simplicity:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ htpasswd /etc/origin/master/.users bob</strong><br class="title-page-name"/>New password:<strong class="calibre1"> supersecret</strong><br class="title-page-name"/>Re-type new password:<strong class="calibre1"> supersecret</strong><br class="title-page-name"/>Adding password for user bob</pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Next, log in as the newly created user. This time, we will not associated it with any labels:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ oc login -u bob<br class="title-page-name"/></strong>Username:<strong class="calibre1"> bob<br class="title-page-name"/></strong>Password:<strong class="calibre1"> supersecret<br class="title-page-name"/></strong>Login successful</pre>
<p class="calibre27">Let's try to create projects until we hit the limit:</p>
<pre class="calibre19"><strong class="calibre1">$ oc new-project bob-project-1</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc new-project bob-project-2</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc new-project bob-project-3</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc new-project bob-project-4</strong><br class="title-page-name"/>Error from server (Forbidden): projectrequests.project.openshift.io "bob-project-4" is forbidden: user bob cannot create more than 3 project(s).</pre>
<p class="calibre2">As you can see, <kbd class="calibre12">bob</kbd> wasn't able to create more than three projects, just as was specified for unlabeled users in the admission plugin's configuration.</p>
<p class="calibre2">Now that this exercise is over, let's do a clean-up:</p>
<pre class="calibre18"><strong class="calibre1">$ oc delete project bob-project-{1..3}</strong><br class="title-page-name"/>project "bob-project-1" deleted<br class="title-page-name"/>project "bob-project-2" deleted<br class="title-page-name"/>project "bob-project-3" deleted<br class="title-page-name"/><strong class="calibre1">$ oc login -u alice</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">$ oc delete project alice-project-{1,2}</strong><br class="title-page-name"/>project "alice-project-1" deleted<br class="title-page-name"/>project "alice-project-2" deleted</pre>
<p class="calibre2">Also, delete the admission plugin's section from the master configuration file and restart the master API:</p>
<pre class="calibre18"><strong class="calibre1"># sed -i '/ProjectRequestLimit/,+8d' /etc/origin/master/master-config.yaml</strong><br class="title-page-name"/><strong class="calibre1"># systemctl restart origin-master-api<br class="title-page-name"/># exit <br class="title-page-name"/>$ exit<br class="title-page-name"/></strong></pre>
<p class="calibre2">The first command in the preceding snippet deletes eight lines after the matching string and the string itself.</p>
<p class="calibre2">As we won't need Vagrant for the remainder of this chapter, let's stop its VMs to prepare for the following exercises:</p>
<pre class="calibre18"><strong class="calibre1">$ vagrant halt</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<div class="packt_infobox">If you are finished experimenting with your Vagrant environment, you can run <kbd class="calibre26">vagrant destroy</kbd> to wipe it clean.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Security context constraints</h1>
                
            
            <article>
                
<p class="calibre2">Before we start, let's bring up MiniShift environment again:</p>
<pre class="calibre18"><strong class="calibre1">$ minishift start --openshift-version 3.9.0 --vm-driver virtualbox</strong><br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">Another mechanism for controlling the behavior of pods is <strong class="calibre4">security context constraints</strong> (<strong class="calibre4">SCCs</strong>). These cluster-level resources define what resources can be accessed by pods and provide an additional level of control. By default, OpenShift supports seven SCCs:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u system:admin<br class="title-page-name"/></strong>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<strong class="calibre1"><br class="title-page-name"/>$ oc get scc</strong><br class="title-page-name"/>anyuid                ...<br class="title-page-name"/>hostaccess            ...<br class="title-page-name"/>hostmount-anyuid      ...<br class="title-page-name"/>hostnetwork           ...<br class="title-page-name"/>nonroot               ...<br class="title-page-name"/>privileged            ...<br class="title-page-name"/>restricted            ...</pre>
<p class="calibre2">You may notice <kbd class="calibre12">anyuid</kbd> SCC we used in the subsection "Creating custom roles" to solve the problem with container's permissions.</p>
<p class="calibre2">By default, all pods, except those for builds and deployments, use a <kbd class="calibre12">default</kbd> service account assigned by the <kbd class="calibre12">restricted</kbd> SCC, which doesn't allow privileged containers <span class="calibre11">–</span> that is, those running under the root user and listening on privileged ports (&lt;1024).</p>
<p class="calibre2">Use <kbd class="calibre12">docker inspect</kbd> to see what user is specified in the <kbd class="calibre12">nginx</kbd> image metadata:</p>
<pre class="calibre18"><strong class="calibre1">$ docker inspect nginx</strong><br class="title-page-name"/>[<br class="title-page-name"/>    {<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>            "User": "",<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>    }<br class="title-page-name"/>]</pre>
<p class="calibre2">Coincidentally, the metadata doesn't specify the user, which makes the image run as root. This is exactly what restricted SCC is designed to prevent.</p>
<p class="calibre2">Previously, we just assigned the <kbd class="calibre12">anyuid</kbd> SCC to a default service account, which means that ALL containers get to run as privileged, and that is a big security risk. A good practice is to create a dedicated service account for our pod/container, so let's do this the right way:</p>
<pre class="calibre18"><strong class="calibre1">$ oc create sa myserviceaccount</strong><br class="title-page-name"/>serviceaccount "myserviceaccount" created</pre>
<p class="calibre2">Next, we have to assign the <kbd class="calibre12">anyuid</kbd> SCC to this account, but to do so we must login as the cluster administrator first:</p>
<pre class="calibre18"><strong class="calibre1">$ oc adm policy add-scc-to-user anyuid -z myserviceaccount<br class="title-page-name"/></strong>scc "anyuid" added to: ["system:serviceaccount:myproject:myserviceaccount"]<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre2">Now, add our service account to the pod's definition:</p>
<pre class="calibre18"><strong class="calibre1">$ cat nginx-pod2.yml </strong><br class="title-page-name"/>apiVersion: v1<br class="title-page-name"/>kind: Pod<br class="title-page-name"/>metadata:<br class="title-page-name"/>  name: nginx<br class="title-page-name"/>  labels:<br class="title-page-name"/>    role: web<br class="title-page-name"/>spec:<br class="title-page-name"/>  containers:<br class="title-page-name"/>  - name: nginx<br class="title-page-name"/>    image: nginx<br class="title-page-name"/>    resources:<br class="title-page-name"/>      requests:<br class="title-page-name"/>        cpu: 100m<br class="title-page-name"/>        memory: 128Mi<br class="title-page-name"/>  <strong class="calibre1">serviceAccountName: myserviceaccount</strong></pre>
<p class="calibre2">Let's try to create the pod again:</p>
<pre class="calibre18"><strong class="calibre1">$ oc create -f nginx-pod2.yml</strong> <br class="title-page-name"/>pod "nginx" created<br class="title-page-name"/><strong class="calibre1">$ oc get po</strong><br class="title-page-name"/>NAME      READY     STATUS    RESTARTS   AGE<br class="title-page-name"/>nginx     1/1       Running   0          15s</pre>
<p class="calibre2">As you can see, now that we have added the appropriate SCC to the service account used by the pod, it started successfully.</p>
<div class="packt_infobox">Instead of allowing your image to run as the root, an even better practice would be to optimize it to run as an arbitrary user by specifying an unprivileged USER, setting the appropriate permissions on files and directories, and configuring your application to listen on unprivileged ports.</div>
<p class="calibre2">Clean up after our exercise, but leave <kbd class="calibre12">myserviceaccount</kbd> with the <kbd class="calibre12">anyuid</kbd> SCC assigned in place <span class="calibre11">–</span> we will need it later on to run privileged pods:</p>
<pre class="calibre18"><strong class="calibre1">$ oc delete po/nginx</strong><br class="title-page-name"/>pod "nginx" deleted</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Storing sensitive data in OpenShift</h1>
                
            
            <article>
                
<p class="calibre2">In the modern world, applications are so complex that they are made up of multitudes of services interacting with each other via REST/SOAP APIs, binary protocols, message brokers, integration buses, and so on. An example of this is a backend application in an e-store; managing client orders means that you need to have access to the database with the products' details. Another example includes a payment processing application that must have access to international payment networks, such as SWIFT, in order to verify the card's details and process the payment. These examples are very different in terms of the scope and the technologies that are used, but they have a common trait—all services need some kind of authenticating piece of data to introduce themselves to each other and this data has to be stored somewhere.</p>
<p class="calibre2">An obvious, but the most insecure, strategy would be to pass this data to pods as plain text via config maps, like any other data. With this approach, sensitive data can be viewed by anyone who has view access to project resources, so you cannot implement granular access control.</p>
<p class="calibre2">Being an enterprise-grade PaaS solution, OpenShift incorporates a dedicated security mechanism to secure such data against unwarranted disclosure—<kbd class="calibre12">Secret</kbd>.</p>
<div class="packt_infobox">While providing an adequate level of protection for sensitive information, OpenShift is not a replacement for a specialized security solution. For example, if you need to store encryption/decryption keys in a secure location, you might want to consider using a <strong class="calibre1">Hardware Security Module</strong> (<strong class="calibre1">HSM</strong>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What data is considered sensitive?</h1>
                
            
            <article>
                
<p class="calibre2">Generally speaking, any data that must be protected against unauthorized access is treated as sensitive. This includes login credentials, tokens, encryption keys, smart cards, classified documents, and so on. Protection for various types of sensitive data is regulated by many government-approved security information standards and corporate policies, thus being the subject of an entire separate field of Information Security. In the context of applications and microservices, we are mostly interested in a subset of sensitive data, such as:</p>
<ul class="calibre9">
<li class="calibre10">Login credentials (username/password)</li>
<li class="calibre10">API tokens</li>
<li class="calibre10">Encryption keys</li>
<li class="calibre10">X.509 certificate/key pairs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Secrets</h1>
                
            
            <article>
                
<p class="calibre2">Secrets are similar to config maps, which we discussed in the previous chapter, in that they are also used to pass data to pods, but that's where their similarities end. A secret's only use case is to store sensitive data consumed by applications—API tokens, credentials, X.509 certificates/keys, and so on. They are backed by tmpfs (an in-memory temporary filesystem) which prevents them from being stored on persistent storage. Secrets are different from config maps in the following ways:</p>
<ul class="calibre9">
<li class="calibre10">Many secrets are created automatically on OpenShift startup (so that pods are able to access the OpenShift API and internal registry, for example)</li>
<li class="calibre10">Secret values are base64-encoded by default, which makes them impossible to see until they are injected into a container</li>
</ul>
<p class="calibre2">OpenShift supports three types of secret:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Type</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Description</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">generic</p>
</td>
<td class="calibre25">
<p class="calibre2">Arbitrary data, like the contents of a file, directory, or string.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">docker-registry</p>
</td>
<td class="calibre25">
<p class="calibre2">Docker registry credentials stored in the <kbd class="calibre12">.dockercfg</kbd> file.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">tls</p>
</td>
<td class="calibre25">
<p class="calibre2">X.509 certificate and its corresponding key. We will use this type of secret as an example later in this section.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"><br class="calibre5"/>
First, login as <kbd class="calibre12">system:admin</kbd> user if you haven't already done so:</p>
<pre class="calibre18"><strong class="calibre1">$ oc login -u system:admin</strong><br class="title-page-name"/>..<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2"><br class="calibre5"/>
Use the familiar <kbd class="calibre12">get</kbd> command to see all secrets in the current project:</p>
<pre class="calibre18"><strong class="calibre1">$ oc get secret</strong><br class="title-page-name"/>NAME                               TYPE                                  DATA      AGE<br class="title-page-name"/>builder-dockercfg-2bpc7            kubernetes.io/dockercfg               1         4d<br class="title-page-name"/>builder-token-2cdj5                kubernetes.io/service-account-token   4         4d<br class="title-page-name"/>builder-token-8lhrx                kubernetes.io/service-account-token   4         4d<br class="title-page-name"/>default-dockercfg-wggrl            kubernetes.io/dockercfg               1         4d<br class="title-page-name"/>default-token-7cljg                kubernetes.io/service-account-token   4         4d<br class="title-page-name"/>default-token-mg64x                kubernetes.io/service-account-token   4         4d<br class="title-page-name"/>deployer-dockercfg-kd88d           kubernetes.io/dockercfg               1         4d<br class="title-page-name"/>deployer-token-5rf6f               kubernetes.io/service-account-token   4         4d<br class="title-page-name"/>deployer-token-k8lwh               kubernetes.io/service-account-token   4         4d<br class="title-page-name"/>myserviceaccount-dockercfg-n6lg7   kubernetes.io/dockercfg               1         4d<br class="title-page-name"/>myserviceaccount-token-fxwpn       kubernetes.io/service-account-token   4         4d<br class="title-page-name"/>myserviceaccount-token-k4d5g       kubernetes.io/service-account-token   4         4d</pre>
<p class="calibre2">Notice that there are three secrets for every service account in the project, as was stated in the subsection on service accounts. Let's see what data the <kbd class="calibre12">dockercfg</kbd> token for the default service account actually has:</p>
<pre class="calibre18"><strong class="calibre1">$ oc edit secret/</strong><strong class="calibre1">default-dockercfg-wggrl<br class="title-page-name"/></strong><br class="title-page-name"/># Please edit the object below. Lines beginning with a '#' will be ignored,<br class="title-page-name"/># and an empty file will abort the edit. If an error occurs while saving this file will be<br class="title-page-name"/># reopened with the relevant failures.<br class="title-page-name"/>#<br class="title-page-name"/>apiVersion: v1<br class="title-page-name"/>data:<br class="title-page-name"/> .dockercfg: ... &lt;output omitted&gt; ...<br class="title-page-name"/>kind: Secret<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">You will see that the <kbd class="calibre12">data</kbd> attribute contains a long base64-encoded string, representing docker client credentials for accessing the internal registry. Use the following Python one-liner to decode the contents of <kbd class="calibre12">.dockercfg</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ python -c "import base64, json; secret_json = base64.b64decode('...&lt;base64-encoded value of .dockercfg from the secret&gt;...'); parsed = json.loads(secret_json); print json.dumps(parsed, indent=4, sort_keys=True)"</strong><br class="title-page-name"/><strong class="calibre1">$ </strong>{<br class="title-page-name"/>    "172.30.1.1:5000": {<br class="title-page-name"/>        "auth": "c2Vydmlj...&lt;output omitted&gt;...ZkFRTEE=", <br class="title-page-name"/>        "email": "serviceaccount@example.org", <br class="title-page-name"/>        "password": "eyJhbGci...&lt;output omitted&gt;...wVBfAQLA", <br class="title-page-name"/>        "username": "serviceaccount"<br class="title-page-name"/>    }, <br class="title-page-name"/>    "docker-registry.default.svc:5000": {<br class="title-page-name"/>        "auth": "c2Vydmlj...&lt;output omitted&gt;...ZkFRTEE=", <br class="title-page-name"/>        "email": "serviceaccount@example.org", <br class="title-page-name"/>        "password": "eyJhbGci...&lt;output omitted&gt;...wVBfAQLA", <br class="title-page-name"/>        "username": "serviceaccount"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Notice that the <kbd class="calibre12">auth</kbd> and <kbd class="calibre12">password</kbd> values are the same for the two sections of the document, as they specify credentials for the same registry. Let's drill further down and decode the value of the <kbd class="calibre12">auth</kbd> field:</p>
<pre class="calibre18"><strong class="calibre1">$ python -c "import base64; print base64.b64decode('c2Vydmlj...&lt;output omitted&gt;...ZkFRTEE=')"</strong><br class="title-page-name"/><strong class="calibre1">$ </strong>serviceaccount:eyJhbGci...&lt;output omitted&gt;...wVBfAQLA</pre>
<p class="calibre2">You may have noticed that the string after the colon is actually the password from the JSON document we decoded earlier. You may use the same one-liner to decode it as well, but we haven't provided the output here, as it contains non-unicode characters.</p>
<p class="calibre2">Now, we get to practice and create our own secret and use it in a pod. One of the most typical use cases for secrets is a web server that's configured with SSL/TLS support, where a secret is used to store a certificate/key pair.</p>
<p class="calibre2">First, we need to create an X.509 certificate and its key:</p>
<pre class="calibre18"><strong class="calibre1">$ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ssl.key -out ssl.crt</strong><br class="title-page-name"/>Generating a 2048 bit RSA private key<br class="title-page-name"/>.............+++<br class="title-page-name"/>..............+++<br class="title-page-name"/>writing new private key to 'ssl.key'<br class="title-page-name"/>-----<br class="title-page-name"/>You are about to be asked to enter information that will be incorporated<br class="title-page-name"/>into your certificate request.<br class="title-page-name"/>What you are about to enter is what is called a Distinguished Name or a DN.<br class="title-page-name"/>There are quite a few fields but you can leave some blank<br class="title-page-name"/>For some fields there will be a default value,<br class="title-page-name"/>If you enter '.', the field will be left blank.<br class="title-page-name"/>-----<br class="title-page-name"/>Country Name (2 letter code) [XX]:<strong class="calibre1">US</strong><br class="title-page-name"/>State or Province Name (full name) []:<strong class="calibre1">AZ</strong><br class="title-page-name"/>Locality Name (eg, city) [Default City]:<strong class="calibre1">Phoenix</strong><br class="title-page-name"/>Organization Name (eg, company) [Default Company Ltd]:<strong class="calibre1">ACME</strong><br class="title-page-name"/>Organizational Unit Name (eg, section) []:<strong class="calibre1">IT</strong><br class="title-page-name"/>Common Name (eg, your name or your server's hostname) []:<strong class="calibre1">localhost</strong><br class="title-page-name"/>Email Address []:</pre>
<p class="calibre2">It doesn't matter what you specify in the certificate's fields, as it will only be used to demonstrate a working Nginx server with SSL configured.</p>
<p class="calibre2">Next, create a custom Nginx virtual host that's listening on TCP port <kbd class="calibre12">443</kbd> and configured with the locations of the certificate and key:</p>
<pre class="calibre18"><strong class="calibre1">$ cat nginx_custom_default.conf</strong> <br class="title-page-name"/>server {<br class="title-page-name"/>    listen       80;<br class="title-page-name"/>    listen       443 ssl;</pre>
<pre class="calibre18"><br class="title-page-name"/>    server_name  localhost;<br class="title-page-name"/>    ssl_certificate     ssl/..data/tls.crt;<br class="title-page-name"/>    ssl_certificate_key ssl/..data/tls.key;<br class="title-page-name"/>    location / {<br class="title-page-name"/>        root   /usr/share/nginx/html;<br class="title-page-name"/>        index  index.html index.htm;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<div class="packt_infobox">TLS secrets are mounted at subdirectory <kbd class="calibre26">..data</kbd> inside the mountPath of the container <span>–</span> that's why the path to both the certificate and the key contains <kbd class="calibre26">..data</kbd>.</div>
<p class="calibre2">Use the preceding configuration file to create a config map that will be used later by the pod:</p>
<pre class="calibre18"><strong class="calibre1">$ oc create cm nginx --from-file nginx_custom_default.conf</strong> <br class="title-page-name"/>configmap "nginx" created</pre>
<p class="calibre2">The next step is to create the secret using the certificate and key:</p>
<pre class="calibre18"><strong class="calibre1">$ oc create secret tls nginx --cert ssl.crt --key ssl.key</strong> <br class="title-page-name"/>secret "nginx" created</pre>
<p class="calibre2">Let's take a look at the newly created secret's definition:</p>
<pre class="calibre18"><strong class="calibre1">$ oc export secret/nginx</strong><br class="title-page-name"/>apiVersion: v1<br class="title-page-name"/>data:<br class="title-page-name"/>  tls.crt: ...&lt;base64-encoded certificate&gt;...<br class="title-page-name"/>  tls.key: ...&lt;base64-encoded key&gt;...<br class="title-page-name"/>kind: Secret<br class="title-page-name"/>metadata:<br class="title-page-name"/>  creationTimestamp: null<br class="title-page-name"/>  name: nginx<br class="title-page-name"/>type: kubernetes.io/tls</pre>
<p class="calibre2">Notice that the secret's keys <kbd class="calibre12">tls.crt</kbd> and <kbd class="calibre12">tls.key</kbd> store the certificate and key, respectively. When a TLS secret is mounted on the pod, the certificate and key are decrypted and placed in the files with the names of these keys <span class="calibre11">–</span> that's why in the virtual host's configuration we had to specify key names and not the file names as we created them with the <kbd class="calibre12">openssl</kbd> command.</p>
<p class="calibre2">The last building block we have to create is the pod itself. Use the appropriate directives to mount the config map and secret as volumes in it:</p>
<pre class="calibre18"><strong class="calibre1">$ cat nginx-pod3.yml</strong> <br class="title-page-name"/>apiVersion: v1<br class="title-page-name"/>kind: Pod<br class="title-page-name"/>metadata:<br class="title-page-name"/>  name: nginx<br class="title-page-name"/>  labels:<br class="title-page-name"/>    role: web<br class="title-page-name"/>spec:<br class="title-page-name"/>  containers:<br class="title-page-name"/>  - name: nginx<br class="title-page-name"/>    image: nginx<br class="title-page-name"/>    resources:<br class="title-page-name"/>      requests:<br class="title-page-name"/>        cpu: 100m<br class="title-page-name"/>        memory: 128Mi<br class="title-page-name"/>    volumeMounts:<br class="title-page-name"/>      - name: conf<br class="title-page-name"/>        mountPath: /etc/nginx/conf.d<br class="title-page-name"/>      - name: tls<br class="title-page-name"/>        mountPath: /etc/nginx/ssl<br class="title-page-name"/>  volumes:<br class="title-page-name"/>    - name: conf<br class="title-page-name"/>      configMap:<br class="title-page-name"/>        name: nginx<br class="title-page-name"/>        items:<br class="title-page-name"/>          - key: nginx_custom_default.conf<br class="title-page-name"/>            path: default.conf<br class="title-page-name"/>    - name: tls<br class="title-page-name"/>      secret:<br class="title-page-name"/>        secretName: nginx<br class="title-page-name"/>  serviceAccountName: myserviceaccount</pre>
<p class="calibre2">Now, it's time to create the pod:</p>
<pre class="calibre18"><strong class="calibre1">$ oc create -f nginx-pod3.yml</strong> <br class="title-page-name"/>pod "nginx" created</pre>
<p class="calibre2">Observe it being created:</p>
<pre class="calibre18"><strong class="calibre1">$ oc get po</strong><br class="title-page-name"/>NAME    READY   STATUS            RESTARTS   AGE</pre>
<pre class="calibre18"><br class="title-page-name"/>nginx    0/1    ContainerCreating   0         3s<br class="title-page-name"/>nginx    1/1    Running   0         7s</pre>
<p class="calibre2">Out of curiosity, let's take a look inside the container to see how the certificate and key are accessible:</p>
<pre class="calibre18"><strong class="calibre1">$ oc rsh nginx ls -l /etc/nginx/ssl</strong><br class="title-page-name"/>total 0<br class="title-page-name"/>lrwxrwxrwx 1 root root 14 Apr 25 11:21 tls.crt -&gt; ..data/tls.crt<br class="title-page-name"/>lrwxrwxrwx 1 root root 14 Apr 25 11:21 tls.key -&gt; ..data/tls.key</pre>
<p class="calibre2">Use the following command to see that the secret isn't stored on the file system (even though it's ephemeral, in our case), but mounted in memory using <kbd class="calibre12">tmpfs</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ oc rsh nginx df -h</strong><br class="title-page-name"/>Filesystem Size Used Avail Use% Mounted on<br class="title-page-name"/>overlay 19G 2.0G 17G 11% /<br class="title-page-name"/>tmpfs 1000M 0 1000M 0% /dev<br class="title-page-name"/>tmpfs 1000M 0 1000M 0% /sys/fs/cgroup<br class="title-page-name"/>/dev/sda1 19G 2.0G 17G 11% /etc/hosts<br class="title-page-name"/>shm 64M 0 64M 0% /dev/shm<br class="title-page-name"/><strong class="calibre1">tmpfs 1000M 8.0K 1000M 1% /etc/nginx/ssl</strong><br class="title-page-name"/>tmpfs 1000M 16K 1000M 1% /run/secrets/kubernetes.io/serviceaccount<br class="title-page-name"/>tmpfs 1000M 0 1000M 0% /proc/scsi<br class="title-page-name"/>tmpfs 1000M 0 1000M 0% /sys/firmware</pre>
<p class="calibre2">Create a service for the pod:</p>
<pre class="calibre18"><strong class="calibre1">$ oc expose po/nginx --port 443</strong><br class="title-page-name"/>service "nginx" exposed</pre>
<p class="calibre2">Then, <kbd class="calibre12">expose</kbd> the service to create an externally available route:</p>
<pre class="calibre18"><strong class="calibre1">$ oc expose svc/nginx</strong><br class="title-page-name"/>route "nginx" exposed</pre>
<p class="calibre2">The route was created:</p>
<pre class="calibre18"><strong class="calibre1">$ oc get route</strong><br class="title-page-name"/>NAME   HOST/PORT  PATH   SERVICES  PORT   TERMINATION  WILDCARD<br class="title-page-name"/>nginx     nginx-myproject.192.168.42.43.nip.io             nginx      443                     None</pre>
<p class="calibre2">As a final touch, we have to add TLS termination to the route and set its type to <kbd class="calibre12">passthrough</kbd> so that the OpenShift router accepts encrypted traffic to the service and doesn't alter it in any way. One cannot create a secure route via the <kbd class="calibre12">expose</kbd> CLI command, so we have to <kbd class="calibre12">patch</kbd> the route's definition directly:</p>
<pre class="calibre18"><strong class="calibre1">$ oc patch route/nginx -p '{"spec" : {"tls": {"termination": "passthrough"}}}'</strong><br class="title-page-name"/>route "nginx" patched</pre>
<p class="calibre2">To verify that our Nginx server was configured with TLS support correctly, open your favorite web browser, go to the URL representing the route, and confirm the security exception, as we used a self-signed certificate:</p>
<p class="cdpaligncenter"><img class="alignnone53" src="../images/00063.jpeg"/></p>
<p class="calibre2">Notice the little lock icon at the left end of the URL, indicating that a secure connection has been established. The warning about invalid certificate, indicated by the yellow triangle (as in Mozilla Firefox), is totally fine in our lab environment.</p>
<div class="packt_infobox">In Google Chrome and Chromium web browsers you will see the <span>Not secure</span> warning to the left of the URL field, which is the same.</div>
<p class="calibre2">Now that this exercise is over, let's clean up the current project:</p>
<pre class="calibre18"><strong class="calibre1">$ oc delete all --all</strong><br class="title-page-name"/>route "nginx" deleted<br class="title-page-name"/>pod "nginx" deleted<br class="title-page-name"/>service "nginx" deleted<strong class="calibre1"><br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1">$ oc delete cm/nginx secret/nginx</strong><br class="title-page-name"/>configmap "nginx" deleted<br class="title-page-name"/>secret "nginx" deleted</pre>
<div class="packt_tip">You can specify unencoded data in plain text using the <kbd class="calibre26">stringData</kbd> section instead of <kbd class="calibre26">data</kbd>. This can be useful for templates so that you can parameterize various generated secrets, such as webhook keys.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you learned about various identity providers that implement authentication in OpenShift, service accounts, and gained an understanding of the connection between users and identities. We also discussed the process of authorization and granting privileges to users, admission controllers, and security context constraints. Lastly, we talked about secrets and learned how they can be used by applications.</p>
<p class="calibre2"><span class="calibre11">In the next chapter, we will deal with networking on the upper level—OpenShift SDN.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Questions</h1>
                
            
            <article>
                
<ol class="calibre13">
<li value="1" class="calibre10">What mapping methods can be used to prevent the mapping of multiple identities to the same user? choose two:
<ol class="calibre14">
<li value="1" class="calibre10">lookup</li>
<li value="2" class="calibre10">generate</li>
<li value="3" class="calibre10">add</li>
<li value="4" class="calibre10">claim</li>
</ol>
</li>
<li value="2" class="calibre10">What service account is used to run application pods?
<ol class="calibre14">
<li value="1" class="calibre10">all</li>
<li value="2" class="calibre10">builder</li>
<li value="3" class="calibre10">deployer</li>
<li value="4" class="calibre10">default</li>
</ol>
</li>
<li value="3" class="calibre10">What roles can be assigned to a user to grant the ability to create and delete resources in a particular project? choose two:
<ol class="calibre14">
<li value="1" class="calibre10">create</li>
<li value="2" class="calibre10">admin</li>
<li value="3" class="calibre10">view</li>
<li value="4" class="calibre10">edit</li>
</ol>
</li>
<li value="4" class="calibre10">What admission control plugin can be used to limit the number of self-provisioned projects per user?
<ol class="calibre14">
<li value="1" class="calibre10">PodPreset</li>
<li value="2" class="calibre10">ProjectRequestNumber</li>
<li value="3" class="calibre10">ProjectRequestLimit</li>
<li value="4" class="calibre10">SelfProvisionedProjects</li>
</ol>
</li>
</ol>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">What SCCs can be used to run containers as root? choose 2:
<ol class="calibre14">
<li value="1" class="calibre10">anyuid</li>
<li value="2" class="calibre10">restricted</li>
<li value="3" class="calibre10">hostmount-anyuid</li>
<li value="4" class="calibre10">privileged</li>
</ol>
</li>
<li value="6" class="calibre10">What secret's attribute stores base64-encoded data?
<ol class="calibre14">
<li value="1" class="calibre10">stringData</li>
<li value="2" class="calibre10">data</li>
<li value="3" class="calibre10">base64</li>
<li value="4" class="calibre10">spec</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Further reading</h1>
                
            
            <article>
                
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Users</strong>: <a href="https://docs.openshift.org/latest/admin_guide/manage_users.html" class="calibre8">https://docs.openshift.org/latest/admin_guide/manage_users.html</a></li>
<li class="calibre10"><strong class="calibre1">Service accounts</strong>: <a href="https://docs.openshift.org/latest/admin_guide/service_accounts.html" class="calibre8">https://docs.openshift.org/latest/admin_guide/service_accounts.html</a></li>
<li class="calibre10"><strong class="calibre1">RBAC</strong>: <a href="https://docs.openshift.org/latest/admin_guide/manage_rbac.html" class="calibre8">https://docs.openshift.org/latest/admin_guide/manage_rbac.html</a></li>
<li class="calibre10"><strong class="calibre1">Identity providers</strong>: <a href="https://docs.openshift.org/latest/install_config/configuring_authentication.html" class="calibre8">https://docs.openshift.org/latest/install_config/configuring_authentication.html</a></li>
<li class="calibre10"><strong class="calibre1">Admission Controllers</strong>: <a href="https://docs.openshift.org/latest/architecture/additional_concepts/admission_controllers.html" class="calibre8">https://docs.openshift.org/latest/architecture/additional_concepts/admission_controllers.html</a></li>
<li class="calibre10"><strong class="calibre1">Security context constraints</strong>: <a href="https://docs.openshift.org/latest/admin_guide/manage_scc.html" class="calibre8">https://docs.openshift.org/latest/admin_guide/manage_scc.html</a></li>
<li class="calibre10"><strong class="calibre1">Secrets</strong>: <a href="https://docs.openshift.org/latest/dev_guide/secrets.html" class="calibre8">https://docs.openshift.org/latest/dev_guide/secrets.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>