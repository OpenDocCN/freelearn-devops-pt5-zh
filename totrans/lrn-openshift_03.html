<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">CRI-O Overview</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we briefly discussed Kubernetes concepts and the Kubernetes architecture, and the main differences between Kubernetes and Docker Swarm.    </p>
<p class="calibre2">The goal of this chapter is to give you a basic understanding of an alternative container runtime technology for Kubernetes—CRI-O. This chapter provides a basic understanding of the Container Runtime Interface, Open Container Initiative, and CRI-O, and describes how to manage containers using that technology.</p>
<p class="calibre2">After reading this chapter, you will have a solid understanding of the following topics:</p>
<p class="calibre2"/>
<ul class="calibre9">
<li class="calibre10">The Container Runtime Interface and Open Container Initiative</li>
<li class="calibre10">How CRI-O works with Kubernetes</li>
<li class="calibre10">Installing and working with CRI-O </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Technical requirements</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we are going to use the following technologies and software:</p>
<ul class="calibre9">
<li class="calibre10">Minikube</li>
<li class="calibre10">Bash Shell</li>
<li class="calibre10">GitHub</li>
<li class="calibre10">Kubernetes</li>
<li class="calibre10">Docker</li>
<li class="calibre10">Firefox</li>
</ul>
<p class="calibre2">You will be required to install Minikube on your laptop or any other virtual environment you are going to use. All the instructions<span class="calibre11"> </span><span class="calibre11">for installing Minikube </span>can be found at <a href="https://kubernetes.io/docs/tasks/tools/install-minikube/" class="calibre8">https://kubernetes.io/docs/tasks/tools/install-minikube/</a>.</p>
<p class="calibre2"><span class="calibre11">Bash Shell will be used as part of your virtual environment.</span></p>
<p class="calibre2">Firefox or any other browser can be used to navigate through Docker Hub. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Container Runtime and Container Runtime Interface</h1>
                
            
            <article>
                
<p class="calibre2">Before we start with CRI-O, we need talk about the basics. The best place to start will be container runtimes. We already know what containers, Docker, and Kubeknetes are. But how does this all work on a low level? The following diagram illustrates a high-level overview of the communications between Kubernetes and containers:</p>
<p class="cdpaligncenter"><img class="alignnone26" src="../images/00031.jpeg"/></p>
<div class="cdpaligncenter1">Kubernetes-to-container communications</div>
<p class="calibre2">As you can see, it is not just Kubernetes talking to the container directly. There are two additional layers in the diagram. Let's discuss why we actually need them:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Container Runtime</strong>: Each and every container technology, such as Docker, Rkt, or Windows Containers, has its own runtime. <span>In short, Container Runtime is a set of scripts and software tools to run and maintain the work of a container.</span></li>
<li class="calibre10"><strong class="calibre1">Container Runtime Interface (CRI)</strong>: As the name implies, CRI is an interface, or a shim layer between Kubernetes and Container Runtime, if you like.</li>
</ul>
<p class="calibre2">You may ask yourself, <em class="calibre17">Why do I need CRI? Why can't Kubernetes talk directly to Container Runtime?</em>. Imagine that Kubernetes and Container Runtime are a manager and an employee that speak English. No issues here. But imagine that there's a new employee—he's an expert in his field and has been contracted by an organization, so now they have to work with each other. However, this new employee speaks only Russian. Now we have a problem. Now, we need to start adding more and more employees speaking languages other than English. You can see where I'm going. In our case, we have a few solutions to this problem:</p>
<ol class="calibre13">
<li value="1" class="calibre10">The manager has to learn a new language every time there is a new employee speaking a new language</li>
<li value="2" class="calibre10">An employee has to learn English</li>
<li value="3" class="calibre10">Hire an interpreter for every language that new employees speak</li>
<li value="4" class="calibre10">Hire an interpreter that speaks a universal language</li>
</ol>
<p class="calibre2">Try to answer this question—what are the most efficient options out of the four that have been listed? I hope it makes sense that option 4 is the most efficient one. For the same reason, CRI and then CRI-O was born. Following the preceding analogy, CRI is option 3 and CRI-O is option 4 in the preceding example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">CRI-O and Open Container Initiative</h1>
                
            
            <article>
                
<p class="calibre2">Kubernetes initially worked with Docker only, but some time later Rkt by CoreOS came into the picture and they wanted to be supported by Kubernetes as well. Therefore, you have to develop a CRI for every additional Container Runtime. <span class="calibre11">Nowadays, different container technologies are often introduced. </span>This solution is not really scalable and adds a lot of complexity and instability to the whole solution.</p>
<p class="calibre2">That is how CRI-O was brought into the picture. CRI-O stands for <strong class="calibre4">OCI-compliant Container Runtime Interface</strong>, and OCI stands for <strong class="calibre4">Open Container Initiative</strong>. The Open Container Initiative is an Open Source community project that designs open standards for Linux Containers. This is what allows Kubernetes to use any other OCI-compliant Container Runtime to run pods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How CRI-O works with Kubernetes</h1>
                
            
            <article>
                
<p class="calibre2">When you want to start or stop a container with Kubernetes, Kubernetes talks to CRI-O, and CRI-O talks to an OCI-compliant container runtime such as runc for Docker to start a container. CRI-O can also pull OCI-compliant container images and manage them on a disk. Good news for Container Developers—they do not need to work with CRI-O directly, as Kubernetes handles that automatically. But it is important to understand the concept and overall architecture:</p>
<p class="cdpaligncenter"><img class="alignnone27" src="../images/00032.gif"/></p>
<div class="cdpaligncenter1">CRI-O architecture</div>
<p class="calibre2">To sum this up, there are a few things to note before we go to the hands-on part and install CRI-O in our lab:</p>
<ul class="calibre9">
<li class="calibre10">Kubernetes is configured to talk to CRI-O to launch a new Pod in a container environment</li>
<li class="calibre10">CRI-O pulls the OCI-compliant Container Image, if necessary, from a registry and manages it locally</li>
<li class="calibre10">CRI-O talks to OCI-compliant Container Runtime (<kbd class="calibre12">runc</kbd>, by default) to run it on a Kubernetes Node</li>
<li class="calibre10">Container Runtime starts the container from a container image that's talking to a Linux Kernel</li>
<li class="calibre10">Linux Kernel starts Container Processes such as an inappropriate namespace, group, context, and so on</li>
</ul>
<ul class="calibre9">
<li class="calibre10">Each container is monitored and logged by a separate process controlled by Linux Kernel</li>
<li class="calibre10">The networking part for containers is controlled by a <strong class="calibre1">Container Network Interface</strong> (<strong class="calibre1">CNI</strong>) that can be used by CRI-O as well</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing and working with CRI-O</h1>
                
            
            <article>
                
<p class="calibre2">It's time to get hands-on with CRI-O. We are not going to explore CRI-O in depth, but rather show you how to bring up a development environment with CRI-O configured with some basic functionality. </p>
<div class="packt_infobox"><span>At the time of writing, CRI-O is still under development. Therefore, the setup instructions in your case might be a bit different and you will need to refer to the official Minikube documentation.  </span></div>
<p class="calibre2">In order to start Kubernetes with CRI-O as a Container Runtime Interface, we are going to use Minikube with an additional <kbd class="calibre12">--container-runtime crio</kbd> option:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube start --container-runtime crio</strong><br class="title-page-name"/>Starting local Kubernetes v1.9.0 cluster...<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>Loading cached images from config file.</pre>
<p class="calibre2">Check Minikube's status and make sure that it is up and running:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube status</strong><br class="title-page-name"/>minikube: Running<br class="title-page-name"/>cluster:  Running<br class="title-page-name"/>kubectl:  Correctly Configured: pointing to minikube-vm at 192.168.99.106</pre>
<p class="calibre2">It looks pretty standard, but if we take a look at the Minikube logs, we will see that Minikube is initializing CRI-O Runtime:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube logs | grep cri-o</strong><br class="title-page-name"/>Jul 08 21:11:36 minikube localkube[3098]: I0708 21:11:36.333484 3098 kuberuntime_manager.go:186] Container runtime <strong class="calibre1">cri-o </strong>initialized, version: 1.8.4, apiVersion: v1alpha1</pre>
<p class="calibre2">Let's create a pod using a Docker image with the <kbd class="calibre12">kubectl run</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl run httpd --image=docker.io/httpd</strong><br class="title-page-name"/>deployment "httpd" created</pre>
<div class="packt_infobox">We need to specify a full path to a Docker image since CRI-O is a universal Runtime Interface and it does not know whether we want to use Docker or any other container technology registry. </div>
<p class="calibre2">Wait for a minute or so while Kubernetes Note downloads the <kbd class="calibre12">httpd</kbd> image and then verify that we have a httpd pod up and running:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl get pods</strong><br class="title-page-name"/>NAME                   READY STATUS RESTARTS  AGE<br class="title-page-name"/>httpd-7dcb9bd6c4-x5dhm 1/1   Running  0       4m</pre>
<p class="calibre2">Again, from this point of view, it looks pretty standard, but if we run the <kbd class="calibre12">kubectl describe</kbd> command, we will see that the container ID starts with <kbd class="calibre12">cri-o://</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ kubectl describe pods/httpd-7dcb9bd6c4-x5dhm</strong><br class="title-page-name"/>Name: httpd-7dcb9bd6c4-x5dhm<strong class="calibre1"><br class="title-page-name"/></strong>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...<br class="title-page-name"/>IP: 10.1.0.4<br class="title-page-name"/>Container ID: <strong class="calibre1">crio://</strong>3f2c2826318f1526bdb9710050a29b5d4a3de78d61e0...<br class="title-page-name"/>Image: docker.io/httpd<br class="title-page-name"/>...<br class="title-page-name"/>&lt;output omitted&gt;<br class="title-page-name"/>...</pre>
<p class="calibre2">At this point, this shows us that Kubernetes is using the CRI-O runtime interface. This means that Kubernetes is talking to CRI-O. CRI-O (the crio daemon, to be specific) is handling the image pulling and container creating processes. Let's verify this by running the <kbd class="calibre12">docker images</kbd> and <kbd class="calibre12">docker ps</kbd> commands inside the Minikube VM:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube ssh docker images</strong><br class="title-page-name"/>REPOSITORY TAG IMAGE ID CREATED SIZE<br class="title-page-name"/>gcr.io/k8s-minikube/storage-provisioner v1.8.0 4689081edb10 4 months ago 80.8MB<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ minikube ssh docker ps</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</pre>
<p class="calibre2">As you can see, there are no images or containers named <kbd class="calibre12">httpd</kbd>. We mentioned earlier that CRI-O is using <kbd class="calibre12">runc</kbd> Container Runtime behind the scenes. To help us further with the verification process, we are going to use the <kbd class="calibre12">runc</kbd> command inside the Minikube VM. <kbd class="calibre12">runc</kbd> is a CLI command for running containers packaged according to the OCI format. The<span class="calibre11"> syntax of the <kbd class="calibre12">runc</kbd> command is very similar to the <kbd class="calibre12">docker</kbd> command we used in <a target="_blank" href="part0021.html#K0RQ0-78aafb146b304cdeb9b3261a70edabde" class="calibre8">Chapter 1</a>, <em class="calibre17">Containers and Docker Overview</em>.</span></p>
<pre class="calibre18"><strong class="calibre1">$ minikube ssh "sudo runc ps \<br class="title-page-name"/>3f2c2826318f1526bdb9710050a29b5d4a3de78d61e07ac9d83cedb9827c62e4</strong>"<br class="title-page-name"/>UID PID PPID C STIME TTY TIME CMD<br class="title-page-name"/>root 5746 5695 0 02:39 ? 00:00:00 httpd -DFOREGROUND<br class="title-page-name"/>daemon 5788 5746 0 02:39 ? 00:00:00 httpd -DFOREGROUND<br class="title-page-name"/>daemon 5792 5746 0 02:39 ? 00:00:00 httpd -DFOREGROUND<br class="title-page-name"/>daemon 5793 5746 0 02:39 ? 00:00:00 httpd -DFOREGROUND</pre>
<div class="packt_tip">Note that <kbd class="calibre26">3f2c2826318f1526bdb9710050a29b5d4a3de78d61e07ac9d83cedb9827c62e4</kbd> is the container ID from the <kbd class="calibre26">kubectl describe pods/httpd-7dcb9bd6c4-x5dhm</kbd> command we ran previously.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stopping your virtual environment</h1>
                
            
            <article>
                
<p class="calibre2">Before you move on to the next chapter, bring down your virtual environment:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube stop</strong><br class="title-page-name"/>Stopping local Kubernetes cluster...<br class="title-page-name"/>Machine stopped.</pre>
<p class="calibre2">And delete the Minikube VM:</p>
<pre class="calibre18"><strong class="calibre1">$ minikube delete</strong><br class="title-page-name"/>Deleting local Kubernetes cluster...<br class="title-page-name"/>Machine deleted.</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we briefly covered the Container Runtime and Container Runtime Interface basics, followed by what CRI-O is and how it works. Finally, we installed the Kubernetes cluster with CRI-O as a Container Runtime Interface and ran a few simple commands to verify that Kubernetes was working through CRI-O. </p>
<p class="calibre2">In the next chapter, we are going to talk about the OpenShift architecture, different OpenShift flavors, and OpenShift in general. We will also look at a comparison between OpenShift and Kubernetes so that you have an understanding of why we actually need OpenShift and what is so unique about it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Questions</h1>
                
            
            <article>
                
<ol class="calibre13">
<li value="1" class="calibre10">Which of the following Kubernetes kubelet services directly communicates with in order to run a pod? choose 1:
<ol class="calibre14">
<li value="1" class="calibre10">OCI</li>
<li value="2" class="calibre10">CRI</li>
<li value="3" class="calibre10">Docker</li>
<li value="4" class="calibre10">Linux kernel</li>
</ol>
</li>
<li value="2" class="calibre10">What container technologies are supported by CRI-O? choose 2:
<ol class="calibre14">
<li value="1" class="calibre10">Docker</li>
<li value="2" class="calibre10">Minishift</li>
<li value="3" class="calibre10">Rkt</li>
<li value="4" class="calibre10">Minikube</li>
</ol>
</li>
<li value="3" class="calibre10"><span>Originally, CRI-O was designed to work with the Kubernetes Container Management Platform</span>:
<ol class="calibre14">
<li value="1" class="calibre10">True</li>
<li value="2" class="calibre10">False</li>
</ol>
</li>
<li value="4" class="calibre10">What is the command to verify the CRI-O Container ID? choose 1:
<ol class="calibre14">
<li value="1" class="calibre10">kubectl describe pods/httpd</li>
<li value="2" class="calibre10">kubectl show pods/httpd</li>
<li value="3" class="calibre10">docker ps </li>
<li value="4" class="calibre10">docker images</li>
</ol>
</li>
</ol>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">Which two statements are true about CRI-O? choose 2:
<ol class="calibre14">
<li value="1" class="calibre10">CRI-O talks directly to Linux Kernel</li>
<li value="2" class="calibre10">CRI-O talks directly to Container Runtime</li>
<li value="3" class="calibre10">CRI-O is OCI-compliant</li>
<li value="4" class="calibre10">CRI-O is the only Container Runtime Interface available for Kubernetes</li>
</ol>
</li>
</ol>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">CRI-O uses the runc Container Runtime by default:
<ol class="calibre14">
<li value="1" class="calibre10">True</li>
<li value="2" class="calibre10">False</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Further reading</h1>
                
            
            <article>
                
<p class="calibre2">There is not a lot of information on the internet about CRI-O in comparison to other technologies. Here are a number of links if you are interested in learning more about CRI-O: </p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">The CRI-O project's website</strong>: <a href="http://cri-o.io/" class="calibre8">http://cri-o.io/</a></li>
<li class="calibre10"><strong class="calibre1">CRI-O blog</strong>: <a href="https://medium.com/cri-o" class="calibre8">https://medium.com/cri-o</a></li>
<li class="calibre10"><span><strong class="calibre1">CRI-O GitHub repository</strong>: </span><a href="https://github.com/kubernetes-incubator/cri-o" class="calibre8">https://github.com/kubernetes-incubator/cri-o</a></li>
<li class="calibre10"><strong class="calibre1">OCI website</strong>: <a href="https://www.opencontainers.org/" class="calibre8">https://www.opencontainers.org/</a></li>
<li class="calibre10"><strong class="calibre1"><span>CRI-O</span> dashboard on Trello</strong>: <a href="https://trello.com/b/xMCopwZm/containers" class="calibre8">https://trello.com/b/xMCopwZm/containers</a></li>
</ul>


            </article>

            
        </section>
    </body></html>