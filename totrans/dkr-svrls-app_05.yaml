- en: The Fn Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces an FaaS platform, *the Fn Project*. It is another great
    FaaS framework developed by a team at Oracle Inc. Fn is one of the easiest projects
    that allows us to deploy an FaaS platform on a plain Docker infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with a discussion of what the Fn Project is. It then moves
    on to look at how its components are organized and what its overall architecture
    is. We will then learn how to use the Fn CLI to prepare and deploy functions.
    The chapter then ends with a discussion of how to use Fn subprojects for its UI,
    scaling, and monitoring of the Fn cluster itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Fn Project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Fn's architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Fn CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a local function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Fn on Docker Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring Fn with its built-in UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log analysis with a familiar tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Fn Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fn Project was originally devised by the team at *Iron.io* ([https://www.iron.io/](https://www.iron.io/))
    under the name of Iron function. After that, the two founders joined Oracle and
    forked Iron function into the new project, Fn.
  prefs: []
  type: TYPE_NORMAL
- en: Fn is a framework and system designed to develop and deploy serverless/FaaS
    applications. In contrast to OpenFaaS, Fn does not use any of the orchestrator-level
    features to manage function containers.
  prefs: []
  type: TYPE_NORMAL
- en: Fn does not only support deployment via its own infrastructure; it also allows
    you to deploy the same functions to AWS Lambda. However, we will scope only for
    deploying functions to its own infrastructure, which is, of course, Docker-based.
  prefs: []
  type: TYPE_NORMAL
- en: There are several design reasons behind Fn.
  prefs: []
  type: TYPE_NORMAL
- en: The Fn Project is committed to be open source. It natively supports Docker,
    which means that we could use a Docker container as its deployment unit—**a function**.
    Fn supports development in any programming language. The Fn infrastructure is
    written in the Go programming language and aims to be able to deploy everywhere,
    including the public cloud, a private cloud, and even the hybrid infrastructure.
    Fn allows for the importing of the Lambda functions from AWS and then deploying
    them to its own infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, the serverless/FaaS infrastructure with Docker is basically
    designed to effect a balance between controlling the whole system and the ease
    of maintenance and administration of the infrastructure. Fn also has the design
    goals that align with this concept too.
  prefs: []
  type: TYPE_NORMAL
- en: Fn's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest setup of an Fn Server is just bringing up a standalone Fn container;
    however, the more complete architecture will be as shown here. A cluster implementation
    will be demonstrated at the end of this chapter. The following diagram shows the
    overview of the Fn architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31b1eb88-ecb6-4b85-9faf-6251d64d41ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The architecture of the Fn FaaS cluster'
  prefs: []
  type: TYPE_NORMAL
- en: As is the case with the common FaaS architecture, Fn also has the *API gateway*,
    which is **Fn LB** in the previous diagram. Fn LB is basically a load balancer.
    It passes through requests from the client to each **Fn Server**. In the Fn Server
    implementation, there is no separation concept of *initiator* and *executor* as
    there is no event bus at the core of the Fn's architecture. So, an Fn Server also
    acts as an executor to execute functions on its associate Docker engine.
  prefs: []
  type: TYPE_NORMAL
- en: Fn Servers connect to a **Log Store**, which could be a standalone or a cluster
    of DBMS. All data sent from an Fn function to the standard error is logged to
    the **Log Store**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fn UI** and **Fn LB** are extra components to help make the Fn Project better
    in terms of production. The Fn UI is the user interface server, such as dashboard,
    for Fn, while Fn LB is the load balancer to round robin among Fn nodes in the
    cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a concept of an *Executor Agent* inside the Fn Server. The agent is
    responsible for controlling the runtime. In the case of Fn, the runtime is Docker.
    So, the executor agent is also referred as a *Docker agent* in this chapter. With the
    default configuration, the Docker agent inside an Fn Server connects to the local
    Docker engine and starts Fn functions via a local Unix socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e846299-3e5e-4981-9e49-1368f4711128.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: A diagram showing an Fn cluster over a Swarm-scoped network'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous diagram shows a running Fn cluster over a Swarm-scoped overlay
    network. To form a cluster, we will use an attachable Swarm-scoped network. Each
    Fn Server instance has to attach to the network. When a request is made to the
    gateway or directly to the server, it will be passed through to the **EntryPoint**.
    The EntryPoint is a language-specific program that wraps around the real function
    program. For example, in the case of an Fn function built with Java, the EntryPoint
    is the class `com.fnproject.fn.runtime.EntryPoint`. There is a code inside this
    Java class to invoke the real function via Java''s reflection technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2280d72-5efe-49de-8417-07de9a774c2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: An Fn function interacting with STDIN, STDOUT, and writing logs
    to STDERR, where it delegates logs to the store'
  prefs: []
  type: TYPE_NORMAL
- en: The Fn Server sends the request body in the form of **STDIN** to the **Function**
    container. After the **EntryPoint** receives the **STDIN** stream, it converts
    the data content to match the type of function signature. In the previous diagram,
    the signature is **String**. So the function body is converted to a string. Output
    sent to **STDOUT** will be forwarded to the **Fn Server** and sent out as the
    result, while output sent to **STDERR** will be captured and stored in the **Log
    Store**.
  prefs: []
  type: TYPE_NORMAL
- en: Using Fn CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will discuss how to use the basics of the Fn CLI, a command line
    to control Fn. Let''s start with the installation of the Fn CLI. Make sure that
    the `curl` command exists on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the previous command, check its version and help by typing
    `fn`. The current version of the command line is `0.4.43` at the time of writing.
    Things move fast, so you can expect to use the different version anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several sub-commands provided by `fn`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fn start` is a thin wrapper around the `docker run` command. This subcommand
    starts the new Fn Server instance. The default address will be `http://localhost:8080`.
    The Fn CLI will however be trying to connect to the address defined in `FN_API_URL`,
    if set as an environment variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn update` is the command for pulling the latest version of the Fn Server
    to a local Docker image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn init` is the command for initializing a skeleton to develop a new function.
    It accepts the `--runtime` parameter to generate the template for a specific language,
    such as Go, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn apps` contains subcommands for creating, updating, and deleting an application,
    and is a kind of namespace or package to group functions together. It is required
    that a function must be defined under an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn routes` is a set of commands to define a route pointing to a function container.
    For example, we have the application `demo`, then we can define the route, `hello`
    and point it to the Docker container image, `test/hello:v1`. An application may
    be many routes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2f66488b-55b8-42eb-941a-17a11968e653.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: The relation between an Fn application and its routes'
  prefs: []
  type: TYPE_NORMAL
- en: Here's how Fn organizes routes under an application. For example, an Fn's API
    URL is `http://localhost:8080`. We may have an application named `demo` containing
    a route named `hello` created for the container image, `test/hello:v1`. All these
    together form a fully qualified URL for accessing the function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's deploy a local function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, carry out `fn start` to up a standalone Fn Server instance. The server
    is started by setting up the log level to be `info`, the default setting. The
    Fn Server then connects to the datastore, the Log Store. The current implementation
    is SQLite3\. After that, the agent will be started. The Docker agent connects
    to the local Docker engine with its default configuration. Finally, the Fn starts
    listening to port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether Docker started the Fn Server properly, we can use `docker
    ps` to see the running container. This would be done in another Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: OK, now we have the Fn Server running on port `8080` as we see the mapping `0.0.0.0:8080->8080/tcp`
    from `docker ps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the current directory that started the `fn start` command, the container
    mapped its `data` directory to the host''s `$PWD/data`. The directory contains
    SQLite3 database files to store logs and information. In the production environment,
    we will replace this with MySQL DBMS, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the list of applications, simply use the `fn apps list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, there is no newly created application as we have just started the server
    instance. We will create one. Name it `demo` and use `fn apps list` command again
    to double-check the created app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we will start developing a function. In this example, we use the Java runtime
    and later on, we will try another runtime for Go.
  prefs: []
  type: TYPE_NORMAL
- en: Let's initialize the new function. We use `fn init` to create a new function
    project. This command takes `--runtime` to specify a language runtime we would
    like to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `func.yaml` is our function descriptor. It contains the version number,
    runtime, and the EntryPoint of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will try to learn how to build and deploy a function. So let's build it without
    modifying anything first. To build the function, simply use `fn build`. And to
    deploy the function, we have `fn deploy` to take care of the process for us.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the Fn build behavior. After calling the `fn build` command, the build
    process starts by using the generated Dockerfile. The resulting image will be
    tagged and stored locally by the Docker engine. For example, the image in the
    example will be tagged as `hello:0.0.1` locally. Then, with the `fn deploy` command,
    it requires `--registry` to store the image remotely on Docker Hub. In this example,
    my Docker's ID is used. Please do not forget to change it to yours.
  prefs: []
  type: TYPE_NORMAL
- en: The `fn deploy` command works like this.
  prefs: []
  type: TYPE_NORMAL
- en: First, it increases the version number of the function. Second, it pushes the
    function's image onto Docker Hub using the `--registry` as the repository name.
    So, `hello:0.0.2` becomes `chanwit/hello:0.0.2` on the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the `fn deploy` will register a new route under the application specified
    by `--app` using the newly built image''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the newly registered route. We use the `fn routes list <app>` command 
    to list all routes under the application `<app>`. In the following example, all
    routes of `demo` were listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The previous command also listed the endpoint of each route. With the endpoint,
    we could basically use `curl` to interact with it, just like a normal HTTP endpoint.
    Do not forget to set the `-v` verbose option to `curl`. With this option, we can
    examine what is hidden inside the HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the lines marked bold in the HTTP response headers. There are some
    extra entries, `Fn_call_id` and `Xxx-Fxlb-Wait`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header,  `Fn_call_id`, is the identifier for each call. This ID will also
    be used when we enable distributed tracing within Fn. The header, `Xxx-Fxlb-Wait`
    is the information collectible by the Fn LB, so it knows the wait time of this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Trying again with Golang
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try creating the next function with another runtime, Go. Unlike Java,
    Go codes inside an Fn function do not have a proper concept of EntryPoint. Fortunately,
    the execution model of Fn is simple enough, so this matter is extremely trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the list of files for the Go Fn function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The file, `func.go` is, of course, the *function program* itself, while `func.yaml`
    is the Fn's function *descriptor*. And the one interesting file here is `test.json`
    – a file containing test fixtures for functional tests. Currently, we can use
    the `fn test` command to test the positive paths, but not the negative results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at `func.yaml` to see what''s inside it first. The `version`
    will be automatically increased every time it is deployed. The `runtime` here
    is `go` as we specified it as the `--runtime` parameter of `fn init`. The `entrypoint`
    here should not be touched. Just leave it there, trust me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Go codes could consume the STDIN directly. The best way is to pass the
    input as a JSON and use Go''s `encoding/json` package to process the data. Here''s
    the example adapted from the original Fn example. This program was modified to
    simplify the output process and add error checking and logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In every program, we need to check errors and handle them. As shown in the previous
    example, we check errors occurring during encoding and then print the error message
    to `os.Stderr`, the standard error file in Go. Then we just exit the process with
    code `> 0`. Here, we use `250`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's summarize error handling and logging in Fn. First, write messages to STDERR
    and they will be stored in the logs. Second, exit the process with an error code,
    that is, `> 0`. Fn will then mark the container execution as *error*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action. Make sure we have the previous code example inside
    `func.go` and deploy it with the `fn deploy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the last line of `fn deploy` is saying that the route is updated, it will
    be good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use the `fn call` command to invoke the function, which is now
    registered as a route under the app `demo`. Try calling it without parameters
    to cause the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is what we would expect. It was a call without input. So the `encoding/json`
    raised the error and the program wrote a log message in STDERR (not shown in the
    previous code). Finally, the function returns `250`. With the message, we saw
    the `fn call` printed out, saying the function container exited with code `250`.
    So the error was handled properly.
  prefs: []
  type: TYPE_NORMAL
- en: No log messages here, but we will get back to them later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will make a successful call. To make it green, just pass the JSON body
    using the `echo` command. The JSON body will be piped to `fn call`  and turned
    into a HTTP request, then it will be received by the Fn Server and serialized
    again to be STDIN for the function program.
  prefs: []
  type: TYPE_NORMAL
- en: The success JSON chuck is what we would expect for a program working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of calling a remote function via `fn call` is that we need to pass
    the *application name* and the *route name* for it to invoke:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Examining call logs and errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see all call logs, use the `fn calls` command. Please note that it''s the
    `calls` command with an *s*. The `fn calls list` command accepts the name of the
    application. The attributes to focus on are `ID`, and `Status`. The following
    example shows two call logs, the first one is `error` and the second one is `success`,
    in reverse chronological order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we pick the second call ID to get the log messages. The command used for 
    retrieving logs is `fn logs get`. It requires the application name and the call
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous log message is the one printed out to `os.Stderr` by the Go program.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Fn on Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we start an Fn cluster on a Swarm-scoped network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with deploying a network, we use `weaveworks/net-plugin` as the backbone
    network for stability reasons. Please note that the network must be attachable
    and the subnet must be inside the scope of  `10.32.0.0/16`. So, `10.32.3.0/24`
    is just fine here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then we prepare a volume for the datastore. As this section also wanted to demonstrate
    a product-grade setup, we use MySQL as the store rather than the default SQLite3\.
    Using MySQL allows us to horizontally scale the number of Fn Servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The volume will be created using the `docker volume create` command. If we''d
    like to set up a MySQL cluster, the setups would be a bit more complex than this,
    but it will not be covered by this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `docker run` command to start an instance of MySQL. We just attach
    the instance to the network `fn_net` created previously. We specify the network
    alias here to ensure that the service must be accessible by the name `mysql`.
    All environment variables are designed to set up a username, password, and the
    default database, `fn_db`. Do not forget to bind the volume, `mysql_vol`, to `/var/lib/mysql`
    inside the container. This is designed to enable the data survive to when the
    container is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to start the Fn Servers. This section demonstrates how to start
    two Fn Servers pointing to the same Log Store (MySQL). Each Fn Server attaches
    to the `fn_net`. This first instance is named `fn_0`. An Fn Server requires `FN_DB_URL`
    to point to an external Log Store, which may be PostgreSQL or MySQL. Just put
    the complete URL as shown in the following command. We also call the container
    `fn_0` to make it easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'When having a setting such as this, the Fn Server becomes completely stateless,
    where all states will be stored externally to the database. So it is now safe
    to completely remove the Fn Server containers when things go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start another one, `fn_1`. Basically, this should be done on a separate
    node (physical or virtual):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Well, after setting all Fn Server instances, now it's time to aggregate them.
    We use Fn LB to act as the load balancer in front of all the Fn Servers. Similar
    to other containers, we just create and attach it to the `fn_net`. As it is the
    FaaS gateway, we also expose its port to `8080` (from its internal port `8081`)
    to make the Fn CLI able to connect to the Fn cluster without any special setting.
    The network alias is just used when we need other services to connect to this
    gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Next, send a list of Fn Server nodes as the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the node list configuration is allowed to pass directly to the container
    only. Just put them in `<name>:<port>` format, separated by a *comma*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, now it''s time to verify that everything is up and running. We double-check
    all containers with the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next two sections, we will cover how to monitor what's happening with
    Fn UI and how to see and maybe further analyze the logs stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring with Fn UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fn UI is the user interface project created for Fn. It provides a simple dashboard
    with easy-to-use time series graphs to monitor how functions are doing in near
    real time. To start the Fn UI, we create and attach the container to the `fn_net,`
    also with the port published to `4000`. The Fn UI requires the URL of an Fn Server.
    But all of them are behind the Fn LB, so we just set `FN_API_URL` to the Fn LB
    location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that they are all connected to each other inside the `fn_net` network,
    so the URL appears to be `http://fnlb:8081`, using the real name and port of `fnlb`
    inside the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting up the Fn UI instance, browse to `localhost:8080` to open the
    dashboard. We will see all applications listed there, as shown in the following
    screenshot. An application could be managed, such as creating or deleting, there
    too. If you do not want the screen to be always auto refreshing, uncheck Auto
    refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b661769f-08bb-4570-b7ea-b308152d87e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: An Fn dashboard showing the list of Fn applications'
  prefs: []
  type: TYPE_NORMAL
- en: After selecting an application, you can execute a function within the dashboard
    by clicking the Run Function button, as in the following screenshot. If an error
    occurs when executing the function and it fails, for example, a notification will
    pop up as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the function, put the Payload in the form of JSON and press the
    Run button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba0c4b6d-cf17-4869-8495-81fc624414f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: A dialog for invoking functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function invocation is completed, its name and count will appear in
    the Completed graph. Here''s the `curl` command to invoke the function. Run it
    multiple times to see the graph change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also the Running graph that displays the number of functions still
    running in parallel. The following screenshot shows these graphs in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fd504f0-5a58-4c7c-a6c0-cb593dc8fd26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Graphs displaying different states of Fn''s functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what will happen when we run a number of requests with invalid inputs.
    Here''s the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, the `hello_go` function will exit with code `250` and appear in
    the Failed graph. We run it repeatedly to make the number of failure going up,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9df97d8e-b9fd-4735-bf73-159286be42c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: The bottom right-hand graph showing the increment numbers of failed
    functions'
  prefs: []
  type: TYPE_NORMAL
- en: We now already know how to use the Fn UI to monitor the function invocation.
    Next, we will use a simple DBMS UI to help browse the logs collected by Fn Servers.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing call logs with MyAdmin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With MySQL as the central Log Store, we can simply access MySQL with any tool
    to query or event analyze the logs. In this example, we use a simple MyAdmin UI
    to connect to the MySQL backend. Here's the `docker run` command to start MyAdmin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just simply attach an instance of MyAdmin to the same network and tell MyAdmin
    to connect to `mysql`, the service name of the backend DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to the exposed port, in this example port number `9000` , and log in
    using Username and Password, set during the setup of MySQL (`func`/`funcpass`).
    The following screenshot shows the login page of phpMyAdmin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2484860b-e84b-4181-b0b9-006df403a81a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: The login page of phpMyAdmin that will connect to the Fn''s log
    database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the phpMyAdmin panel, take a look at the `fn_db` parameter and we will
    see all the tables for storing Fn information, as shown in the following screenshot.
    The data of the table `apps` are created by the command `fn apps create`, for
    example. What we''d like to see are table `calls` and table `logs`*.* The content
    of table `calls` can be retrieved by the `fn calls list`, and the content of table
    `logs` can also be retrieved in a similar way using `fn logs get`. But when we
    are able to access the `logs` directly, we can even do some analysis directly
    with the available data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/244670aa-29fb-4a4c-abc4-125ad310557d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: The list of all Fn''s tables in phpMyAdmin'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the content of table `calls`. There is a status
    column, which allows us to effectively filter to see what the call (status) is: success
    or error. There is also the stats column, which contains some temporal information
    to be retrieved and displayed by the Fn UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dd3299e-c9ad-4236-aee5-b6e38705ae9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Fn calls log data in table calls'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows table `logs`. In the `logs` table, it just stamps
    each entry with the call ID. The column log shows the log message we printed out
    to the STDERR. We can see that there are different incorrect behaviors just by
    trying to send some invalid inputs to our `hello_go` function. With this table
    being so accessible, we can troubleshoot the Fn functions effectively without
    installing other extra tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54b6697b-726d-40d1-b74b-9a9c5ed215cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Fn logs data captured from a function''s STDERR'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, it seems everything is working correctly if we could get MyAdmin to show
    the logs data. Finally, to confirm that all containers are running and what they
    should look like, just use the `docker ps` command again to check all running
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to review all the things in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the Fn architecture look like?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the architecture different from other FaaS platforms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of the Fn Server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we configure an Fn Server to use an external data store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the techniques used by the Fn's Java runtime
    and Go runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are an application and routes organized?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of Fn LB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of the Fn UI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we see the results of previous calls?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we examine the log messages of a failed invocation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe how an Fn function interacts with STDIN, STDOUT, and STDERR?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed the Fn Project, its components, and architecture. We
    started using Fn with its command line, the Fn CLI.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed the structure of an Fn function, such as how it interacts
    with STDIN, STDOUT, and STDERR. We learned how to build and deploy Fn functions,
    both with Java and Go runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Then we formed an Fn cluster on Docker Swarm and linked the Fn Server instances
    to an external DB store, MySQL. We load balanced the Fn instances using Fn LB,
    a load balancer specifically implemented by the same team.
  prefs: []
  type: TYPE_NORMAL
- en: With the Fn UI, we learned how to use it to monitor invocations for Fn. With
    MyAdmin, we used it to browse calls and error logs directly in MySQL. A simple
    tool like MyAdmin could be used to achieve the same analytical result without
    preparing a complex toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce OpenWhisk, another serverless stack from the
    Apache project, and those used by IBM to offer serverless services in their cloud.
  prefs: []
  type: TYPE_NORMAL
