- en: The Fn Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fn 项目
- en: This chapter introduces an FaaS platform, *the Fn Project*. It is another great
    FaaS framework developed by a team at Oracle Inc. Fn is one of the easiest projects
    that allows us to deploy an FaaS platform on a plain Docker infrastructure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一个 FaaS 平台，*Fn 项目*。它是由 Oracle Inc. 团队开发的另一个出色的 FaaS 框架。Fn 是其中一个最简单的项目，允许我们在纯
    Docker 基础设施上部署 FaaS 平台。
- en: This chapter begins with a discussion of what the Fn Project is. It then moves
    on to look at how its components are organized and what its overall architecture
    is. We will then learn how to use the Fn CLI to prepare and deploy functions.
    The chapter then ends with a discussion of how to use Fn subprojects for its UI,
    scaling, and monitoring of the Fn cluster itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从讨论 Fn 项目是什么开始。然后我们将继续探讨它的组件如何组织，以及它的整体架构。接下来，我们将学习如何使用 Fn CLI 准备和部署函数。本章最后将讨论如何使用
    Fn 子项目来管理其 UI、扩展和监控 Fn 集群本身。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: The Fn Project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fn 项目
- en: The Fn's architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fn 的架构
- en: Using Fn CLI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Fn CLI
- en: Deploying a local function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署本地函数
- en: Deploying Fn on Docker Swarm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker Swarm 上部署 Fn
- en: Monitoring Fn with its built-in UI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置 UI 监控 Fn
- en: Log analysis with a familiar tool
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用熟悉的工具进行日志分析
- en: The Fn Project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fn 项目
- en: The Fn Project was originally devised by the team at *Iron.io* ([https://www.iron.io/](https://www.iron.io/))
    under the name of Iron function. After that, the two founders joined Oracle and
    forked Iron function into the new project, Fn.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 项目最初由*Iron.io*团队（[https://www.iron.io/](https://www.iron.io/)）在 Iron function
    名称下构思。此后，两位创始人加入了 Oracle，并将 Iron function 分支为新的项目 Fn。
- en: Fn is a framework and system designed to develop and deploy serverless/FaaS
    applications. In contrast to OpenFaaS, Fn does not use any of the orchestrator-level
    features to manage function containers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 是一个框架和系统，用于开发和部署无服务器/FaaS 应用程序。与 OpenFaaS 不同，Fn 不使用任何编排器级别的功能来管理函数容器。
- en: Fn does not only support deployment via its own infrastructure; it also allows
    you to deploy the same functions to AWS Lambda. However, we will scope only for
    deploying functions to its own infrastructure, which is, of course, Docker-based.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 不仅支持通过其自身基础设施进行部署；它还允许你将相同的函数部署到 AWS Lambda。然而，我们这里只讨论如何将函数部署到其自身的基础设施，当然，这个基础设施是基于
    Docker 的。
- en: There are several design reasons behind Fn.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 背后有几个设计原因。
- en: The Fn Project is committed to be open source. It natively supports Docker,
    which means that we could use a Docker container as its deployment unit—**a function**.
    Fn supports development in any programming language. The Fn infrastructure is
    written in the Go programming language and aims to be able to deploy everywhere,
    including the public cloud, a private cloud, and even the hybrid infrastructure.
    Fn allows for the importing of the Lambda functions from AWS and then deploying
    them to its own infrastructure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 项目致力于开源。它原生支持 Docker，这意味着我们可以将 Docker 容器作为其部署单元——**一个函数**。Fn 支持任何编程语言的开发。Fn
    基础设施是用 Go 编程语言编写的，旨在能够在各处部署，包括公共云、私有云，甚至混合基础设施。Fn 还支持从 AWS 导入 Lambda 函数并将它们部署到自身的基础设施中。
- en: As previously mentioned, the serverless/FaaS infrastructure with Docker is basically
    designed to effect a balance between controlling the whole system and the ease
    of maintenance and administration of the infrastructure. Fn also has the design
    goals that align with this concept too.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，基于 Docker 的无服务器/FaaS 基础设施基本上旨在平衡控制整个系统与基础设施的维护和管理的便利性。Fn 也有与这一理念相一致的设计目标。
- en: Fn's architecture
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fn 的架构
- en: 'The easiest setup of an Fn Server is just bringing up a standalone Fn container;
    however, the more complete architecture will be as shown here. A cluster implementation
    will be demonstrated at the end of this chapter. The following diagram shows the
    overview of the Fn architecture:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 服务器的最简单设置只是启动一个独立的 Fn 容器；然而，更完整的架构将如图所示。本章最后将演示集群实现。下图展示了 Fn 架构的概览：
- en: '![](img/31b1eb88-ecb6-4b85-9faf-6251d64d41ca.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31b1eb88-ecb6-4b85-9faf-6251d64d41ca.png)'
- en: 'Figure 5.1: The architecture of the Fn FaaS cluster'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：Fn FaaS 集群的架构
- en: As is the case with the common FaaS architecture, Fn also has the *API gateway*,
    which is **Fn LB** in the previous diagram. Fn LB is basically a load balancer.
    It passes through requests from the client to each **Fn Server**. In the Fn Server
    implementation, there is no separation concept of *initiator* and *executor* as
    there is no event bus at the core of the Fn's architecture. So, an Fn Server also
    acts as an executor to execute functions on its associate Docker engine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与常见的 FaaS 架构一样，Fn 也有*API 网关*，在前面的图示中为**Fn LB**。Fn LB 基本上是一个负载均衡器。它将来自客户端的请求转发到每个**Fn
    Server**。在 Fn Server 的实现中，没有像 Fn 架构核心中的事件总线那样的*发起者*和*执行者*的分离概念。因此，Fn Server 也充当执行者，在其关联的
    Docker 引擎上执行函数。
- en: Fn Servers connect to a **Log Store**, which could be a standalone or a cluster
    of DBMS. All data sent from an Fn function to the standard error is logged to
    the **Log Store**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 服务器连接到一个**Log Store**，它可以是一个独立的数据库系统或一个数据库管理系统的集群。所有从 Fn 函数发送到标准错误的数据显示都会记录到**Log
    Store**。
- en: '**Fn UI** and **Fn LB** are extra components to help make the Fn Project better
    in terms of production. The Fn UI is the user interface server, such as dashboard,
    for Fn, while Fn LB is the load balancer to round robin among Fn nodes in the
    cluster.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fn UI** 和 **Fn LB** 是额外的组件，有助于在生产环境中改进 Fn 项目。Fn UI 是用户界面服务器，如仪表盘，用于 Fn，而
    Fn LB 是负载均衡器，用于在集群中的 Fn 节点之间进行轮询。'
- en: 'There is a concept of an *Executor Agent* inside the Fn Server. The agent is
    responsible for controlling the runtime. In the case of Fn, the runtime is Docker.
    So, the executor agent is also referred as a *Docker agent* in this chapter. With the
    default configuration, the Docker agent inside an Fn Server connects to the local
    Docker engine and starts Fn functions via a local Unix socket:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fn Server 中有一个*执行者代理*的概念。该代理负责控制运行时环境。在 Fn 中，运行时是 Docker。因此，在本章节中，执行者代理也称为*Docker
    代理*。在默认配置下，Fn Server 中的 Docker 代理连接到本地 Docker 引擎，并通过本地 Unix 套接字启动 Fn 函数：
- en: '![](img/1e846299-3e5e-4981-9e49-1368f4711128.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e846299-3e5e-4981-9e49-1368f4711128.png)'
- en: 'Figure 5.2: A diagram showing an Fn cluster over a Swarm-scoped network'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：显示 Fn 集群在 Swarm 范围网络上的示意图
- en: 'The previous diagram shows a running Fn cluster over a Swarm-scoped overlay
    network. To form a cluster, we will use an attachable Swarm-scoped network. Each
    Fn Server instance has to attach to the network. When a request is made to the
    gateway or directly to the server, it will be passed through to the **EntryPoint**.
    The EntryPoint is a language-specific program that wraps around the real function
    program. For example, in the case of an Fn function built with Java, the EntryPoint
    is the class `com.fnproject.fn.runtime.EntryPoint`. There is a code inside this
    Java class to invoke the real function via Java''s reflection technique:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示展示了一个在 Swarm 范围覆盖网络上的运行 Fn 集群。为了组成一个集群，我们将使用一个可附加的 Swarm 范围网络。每个 Fn Server
    实例都需要连接到该网络。当请求被发送到网关或直接发送到服务器时，它将被传递到**EntryPoint**。EntryPoint 是一个特定语言的程序，它包装了真正的函数程序。例如，在使用
    Java 构建的 Fn 函数中，EntryPoint 是类 `com.fnproject.fn.runtime.EntryPoint`。这个 Java 类内部的代码通过
    Java 的反射技术调用真正的函数：
- en: '![](img/b2280d72-5efe-49de-8417-07de9a774c2e.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2280d72-5efe-49de-8417-07de9a774c2e.png)'
- en: 'Figure 5.3: An Fn function interacting with STDIN, STDOUT, and writing logs
    to STDERR, where it delegates logs to the store'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：一个 Fn 函数与 STDIN、STDOUT 交互并将日志写入 STDERR，且将日志委托给存储
- en: The Fn Server sends the request body in the form of **STDIN** to the **Function**
    container. After the **EntryPoint** receives the **STDIN** stream, it converts
    the data content to match the type of function signature. In the previous diagram,
    the signature is **String**. So the function body is converted to a string. Output
    sent to **STDOUT** will be forwarded to the **Fn Server** and sent out as the
    result, while output sent to **STDERR** will be captured and stored in the **Log
    Store**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 服务器将请求主体以**STDIN**的形式发送到**Function**容器。当**EntryPoint**接收到**STDIN**流后，它会将数据内容转换为匹配函数签名类型的格式。在前面的图示中，签名是**String**。因此，函数体被转换为字符串。发送到**STDOUT**的输出将被转发到**Fn
    Server**并作为结果发送出去，而发送到**STDERR**的输出将被捕获并存储在**Log Store**中。
- en: Using Fn CLI
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Fn CLI
- en: 'This section will discuss how to use the basics of the Fn CLI, a command line
    to control Fn. Let''s start with the installation of the Fn CLI. Make sure that
    the `curl` command exists on your system:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论如何使用 Fn CLI 的基本功能，这是一个控制 Fn 的命令行工具。我们先从 Fn CLI 的安装开始。确保你的系统中存在`curl`命令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installing the previous command, check its version and help by typing
    `fn`. The current version of the command line is `0.4.43` at the time of writing.
    Things move fast, so you can expect to use the different version anyway:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完前面的命令后，通过输入`fn`检查其版本和帮助信息。撰写时，命令行的当前版本是`0.4.43`。由于变化迅速，你可以预期使用不同版本的情况：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are several sub-commands provided by `fn`, for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn`提供了几个子命令，例如：'
- en: '`fn start` is a thin wrapper around the `docker run` command. This subcommand
    starts the new Fn Server instance. The default address will be `http://localhost:8080`.
    The Fn CLI will however be trying to connect to the address defined in `FN_API_URL`,
    if set as an environment variable.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn start`是`docker run`命令的一个简单包装器。此子命令启动新的Fn Server实例。默认地址将是`http://localhost:8080`。然而，Fn
    CLI将尝试连接到在环境变量中定义的`FN_API_URL`地址（如果已设置）。'
- en: '`fn update` is the command for pulling the latest version of the Fn Server
    to a local Docker image.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn update`是用于将最新版本的Fn Server拉取到本地Docker镜像的命令。'
- en: '`fn init` is the command for initializing a skeleton to develop a new function.
    It accepts the `--runtime` parameter to generate the template for a specific language,
    such as Go, for example.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn init`是用于初始化一个骨架以开发新函数的命令。它接受`--runtime`参数，用于生成特定语言的模板，例如Go语言。'
- en: '`fn apps` contains subcommands for creating, updating, and deleting an application,
    and is a kind of namespace or package to group functions together. It is required
    that a function must be defined under an application.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn apps`包含用于创建、更新和删除应用程序的子命令，是一种命名空间或包，用于将多个函数组合在一起。要求函数必须在一个应用程序下定义。'
- en: '`fn routes` is a set of commands to define a route pointing to a function container.
    For example, we have the application `demo`, then we can define the route, `hello`
    and point it to the Docker container image, `test/hello:v1`. An application may
    be many routes:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn routes`是一组用于定义指向函数容器的路由的命令。例如，我们有一个名为`demo`的应用程序，然后可以定义路由`hello`并将其指向Docker容器镜像`test/hello:v1`。一个应用程序可以有多个路由：'
- en: '![](img/2f66488b-55b8-42eb-941a-17a11968e653.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f66488b-55b8-42eb-941a-17a11968e653.png)'
- en: 'Figure 5.4: The relation between an Fn application and its routes'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：Fn应用程序及其路由之间的关系
- en: Here's how Fn organizes routes under an application. For example, an Fn's API
    URL is `http://localhost:8080`. We may have an application named `demo` containing
    a route named `hello` created for the container image, `test/hello:v1`. All these
    together form a fully qualified URL for accessing the function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Fn如何在应用程序下组织路由的示例。例如，Fn的API URL是`http://localhost:8080`。我们可能有一个名为`demo`的应用程序，其中包含一个名为`hello`的路由，该路由为容器镜像`test/hello:v1`创建。所有这些组合在一起形成了一个访问该函数的完整URL。
- en: Let's deploy a local function
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们部署一个本地函数
- en: 'Firstly, carry out `fn start` to up a standalone Fn Server instance. The server
    is started by setting up the log level to be `info`, the default setting. The
    Fn Server then connects to the datastore, the Log Store. The current implementation
    is SQLite3\. After that, the agent will be started. The Docker agent connects
    to the local Docker engine with its default configuration. Finally, the Fn starts
    listening to port `8080`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行`fn start`以启动一个独立的Fn Server实例。服务器通过设置日志级别为`info`（默认设置）启动。Fn Server然后连接到数据存储，即日志存储。当前的实现是SQLite3。之后，代理将启动。Docker代理使用其默认配置连接到本地Docker引擎。最后，Fn开始监听端口`8080`：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To check whether Docker started the Fn Server properly, we can use `docker
    ps` to see the running container. This would be done in another Terminal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查Docker是否正确启动了Fn Server，我们可以使用`docker ps`查看正在运行的容器。可以在另一个终端执行此操作：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: OK, now we have the Fn Server running on port `8080` as we see the mapping `0.0.0.0:8080->8080/tcp`
    from `docker ps`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经看到Fn Server正在端口`8080`上运行，并且通过`docker ps`看到映射`0.0.0.0:8080->8080/tcp`。
- en: 'At the current directory that started the `fn start` command, the container
    mapped its `data` directory to the host''s `$PWD/data`. The directory contains
    SQLite3 database files to store logs and information. In the production environment,
    we will replace this with MySQL DBMS, for example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动`fn start`命令的当前目录中，容器将其`data`目录映射到主机的`$PWD/data`。该目录包含SQLite3数据库文件，用于存储日志和信息。在生产环境中，我们将用MySQL
    DBMS替换它，例如：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To see the list of applications, simply use the `fn apps list` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用程序列表，只需使用`fn apps list`命令：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Well, there is no newly created application as we have just started the server
    instance. We will create one. Name it `demo` and use `fn apps list` command again
    to double-check the created app:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，由于我们刚刚启动了服务器实例，因此没有新创建的应用程序。我们将创建一个，命名为`demo`，然后再次使用`fn apps list`命令来双重确认创建的应用：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we will start developing a function. In this example, we use the Java runtime
    and later on, we will try another runtime for Go.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始开发一个函数。在这个示例中，我们使用Java运行时，稍后我们将尝试使用Go的另一种运行时。
- en: Let's initialize the new function. We use `fn init` to create a new function
    project. This command takes `--runtime` to specify a language runtime we would
    like to use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们初始化新函数。我们使用`fn init`来创建一个新的函数项目。此命令需要`--runtime`来指定我们希望使用的语言运行时。
- en: 'The `func.yaml` is our function descriptor. It contains the version number,
    runtime, and the EntryPoint of the function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`func.yaml`是我们的函数描述文件。它包含版本号、运行时和函数的入口点：'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will try to learn how to build and deploy a function. So let's build it without
    modifying anything first. To build the function, simply use `fn build`. And to
    deploy the function, we have `fn deploy` to take care of the process for us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试学习如何构建和部署一个函数。所以让我们先不修改任何内容，直接构建它。要构建函数，只需使用`fn build`。而要部署函数，我们有`fn deploy`来为我们处理整个过程。
- en: Here's the Fn build behavior. After calling the `fn build` command, the build
    process starts by using the generated Dockerfile. The resulting image will be
    tagged and stored locally by the Docker engine. For example, the image in the
    example will be tagged as `hello:0.0.1` locally. Then, with the `fn deploy` command,
    it requires `--registry` to store the image remotely on Docker Hub. In this example,
    my Docker's ID is used. Please do not forget to change it to yours.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Fn的构建行为。在调用`fn build`命令后，构建过程开始，使用生成的Dockerfile。生成的镜像将被打标签并由Docker引擎本地存储。例如，示例中的镜像将被本地标记为`hello:0.0.1`。然后，使用`fn
    deploy`命令时，需要`--registry`来将镜像远程存储在Docker Hub上。在此示例中，使用的是我的Docker ID，请记得将其更改为您的ID。
- en: The `fn deploy` command works like this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn deploy`命令的工作方式如下。'
- en: First, it increases the version number of the function. Second, it pushes the
    function's image onto Docker Hub using the `--registry` as the repository name.
    So, `hello:0.0.2` becomes `chanwit/hello:0.0.2` on the Docker Hub.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它增加了函数的版本号。其次，它使用`--registry`将函数的镜像推送到Docker Hub，作为仓库名称。因此，`hello:0.0.2`在Docker
    Hub上变成了`chanwit/hello:0.0.2`。
- en: 'Then the `fn deploy` will register a new route under the application specified
    by `--app` using the newly built image''s name:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`fn deploy`将使用新构建镜像的名称，在`--app`指定的应用程序下注册一个新路由：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s check the newly registered route. We use the `fn routes list <app>` command 
    to list all routes under the application `<app>`. In the following example, all
    routes of `demo` were listed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下新注册的路由。我们使用`fn routes list <app>`命令来列出应用程序`<app>`下的所有路由。在下面的示例中，列出了`demo`的所有路由：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous command also listed the endpoint of each route. With the endpoint,
    we could basically use `curl` to interact with it, just like a normal HTTP endpoint.
    Do not forget to set the `-v` verbose option to `curl`. With this option, we can
    examine what is hidden inside the HTTP headers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令还列出了每个路由的端点。通过端点，我们基本上可以像普通HTTP端点一样使用`curl`与其交互。不要忘记为`curl`设置`-v`详细选项。通过此选项，我们可以检查HTTP头部中隐藏的内容。
- en: Let's see the lines marked bold in the HTTP response headers. There are some
    extra entries, `Fn_call_id` and `Xxx-Fxlb-Wait`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下HTTP响应头中标记为粗体的行。这里有一些额外的条目，`Fn_call_id`和`Xxx-Fxlb-Wait`。
- en: 'The header,  `Fn_call_id`, is the identifier for each call. This ID will also
    be used when we enable distributed tracing within Fn. The header, `Xxx-Fxlb-Wait`
    is the information collectible by the Fn LB, so it knows the wait time of this
    function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 头部信息，`Fn_call_id`，是每次调用的标识符。此ID在我们启用Fn的分布式追踪时也将使用。头部信息，`Xxx-Fxlb-Wait`，是Fn LB收集的信息，它可以知道此函数的等待时间：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Trying again with Golang
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再试一次使用Golang
- en: 'Let''s try creating the next function with another runtime, Go. Unlike Java,
    Go codes inside an Fn function do not have a proper concept of EntryPoint. Fortunately,
    the execution model of Fn is simple enough, so this matter is extremely trivial:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用另一种运行时Go创建下一个函数。与Java不同，Go语言代码在Fn函数内没有明确的入口点概念。幸运的是，Fn的执行模型足够简单，因此这个问题非常微不足道：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the list of files for the Go Fn function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go Fn函数的文件列表：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The file, `func.go` is, of course, the *function program* itself, while `func.yaml`
    is the Fn's function *descriptor*. And the one interesting file here is `test.json`
    – a file containing test fixtures for functional tests. Currently, we can use
    the `fn test` command to test the positive paths, but not the negative results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`func.go`当然就是*函数程序*本身，而`func.yaml`是Fn的函数*描述符*。其中一个有趣的文件是`test.json`——它是包含功能测试的测试数据文件。目前，我们可以使用`fn
    test`命令来测试正向路径，但无法测试负向结果。
- en: 'We will take a look at `func.yaml` to see what''s inside it first. The `version`
    will be automatically increased every time it is deployed. The `runtime` here
    is `go` as we specified it as the `--runtime` parameter of `fn init`. The `entrypoint`
    here should not be touched. Just leave it there, trust me:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下`func.yaml`，了解它的内容。每次部署时，`version`会自动增加。这里的`runtime`是`go`，因为我们在`fn init`时指定了`--runtime`参数。这里的`entrypoint`不应修改。就保持原样，信任我：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Go codes could consume the STDIN directly. The best way is to pass the
    input as a JSON and use Go''s `encoding/json` package to process the data. Here''s
    the example adapted from the original Fn example. This program was modified to
    simplify the output process and add error checking and logging:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Go代码可以直接消费STDIN。最好的方法是将输入作为JSON传递，并使用Go的`encoding/json`包来处理数据。以下是从原始Fn示例修改的程序。这个程序被修改为简化输出过程，并添加了错误检查和日志记录：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In every program, we need to check errors and handle them. As shown in the previous
    example, we check errors occurring during encoding and then print the error message
    to `os.Stderr`, the standard error file in Go. Then we just exit the process with
    code `> 0`. Here, we use `250`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个程序中，我们都需要检查错误并处理它们。如前面的示例所示，我们检查编码时发生的错误，然后将错误消息打印到Go中的标准错误文件`os.Stderr`。然后我们只需使用代码`>
    0`退出进程。在这里，我们使用`250`。
- en: Let's summarize error handling and logging in Fn. First, write messages to STDERR
    and they will be stored in the logs. Second, exit the process with an error code,
    that is, `> 0`. Fn will then mark the container execution as *error*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下Fn中的错误处理和日志记录。首先，写入STDERR的消息将被存储在日志中。其次，使用错误代码退出进程，即`> 0`。Fn随后会将容器执行标记为*错误*。
- en: 'Let''s see this in action. Make sure we have the previous code example inside
    `func.go` and deploy it with the `fn deploy` command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下实际操作。确保我们在`func.go`中有之前的代码示例，并使用`fn deploy`命令将其部署：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the last line of `fn deploy` is saying that the route is updated, it will
    be good to go.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`fn deploy`的最后一行显示路由已更新，那就表示已经准备好。
- en: 'Next, we will use the `fn call` command to invoke the function, which is now
    registered as a route under the app `demo`. Try calling it without parameters
    to cause the error:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`fn call`命令来调用该函数，该函数现在已经注册为`demo`应用程序下的一个路由。尝试在没有参数的情况下调用它，这会导致错误：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is what we would expect. It was a call without input. So the `encoding/json`
    raised the error and the program wrote a log message in STDERR (not shown in the
    previous code). Finally, the function returns `250`. With the message, we saw
    the `fn call` printed out, saying the function container exited with code `250`.
    So the error was handled properly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的结果。它是一次没有输入的调用。因此，`encoding/json`抛出了错误，程序将日志消息写入了STDERR（在之前的代码中没有显示）。最后，函数返回了`250`。通过这个消息，我们看到`fn
    call`打印出函数容器以`250`代码退出。所以错误得到了正确处理。
- en: No log messages here, but we will get back to them later.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有日志消息，但我们稍后会回到它们。
- en: Next, we will make a successful call. To make it green, just pass the JSON body
    using the `echo` command. The JSON body will be piped to `fn call`  and turned
    into a HTTP request, then it will be received by the Fn Server and serialized
    again to be STDIN for the function program.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行一次成功的调用。为了使其显示为绿色，只需使用`echo`命令传递JSON主体。JSON主体将通过管道传递给`fn call`，并转换为HTTP请求，然后它将被Fn服务器接收并再次序列化为函数程序的STDIN。
- en: The success JSON chuck is what we would expect for a program working correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的JSON块是我们对一个正常工作的程序的预期输出。
- en: 'The syntax of calling a remote function via `fn call` is that we need to pass
    the *application name* and the *route name* for it to invoke:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fn call`调用远程函数的语法是，我们需要传递*应用程序名称*和*路由名称*，这样它才能被调用：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Examining call logs and errors
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查呼叫日志和错误
- en: 'To see all call logs, use the `fn calls` command. Please note that it''s the
    `calls` command with an *s*. The `fn calls list` command accepts the name of the
    application. The attributes to focus on are `ID`, and `Status`. The following
    example shows two call logs, the first one is `error` and the second one is `success`,
    in reverse chronological order:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有调用日志，请使用`fn calls`命令。请注意，命令是带有 *s* 的`calls`。`fn calls list`命令接受应用程序的名称。需要关注的属性是`ID`和`Status`。以下示例显示了两个调用日志，第一个是`error`，第二个是`success`，按时间倒序排列：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we pick the second call ID to get the log messages. The command used for 
    retrieving logs is `fn logs get`. It requires the application name and the call
    ID:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们选择第二个调用 ID 来获取日志消息。用于检索日志的命令是`fn logs get`。它需要应用程序名称和调用 ID：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous log message is the one printed out to `os.Stderr` by the Go program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的日志消息是 Go 程序输出到`os.Stderr`的内容。
- en: Deploying Fn on Docker Swarm
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Docker Swarm 上部署 Fn
- en: In this example, we start an Fn cluster on a Swarm-scoped network.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在 Swarm 范围内的网络上启动一个 Fn 集群。
- en: 'Starting with deploying a network, we use `weaveworks/net-plugin` as the backbone
    network for stability reasons. Please note that the network must be attachable
    and the subnet must be inside the scope of  `10.32.0.0/16`. So, `10.32.3.0/24`
    is just fine here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从部署网络开始，我们使用`weaveworks/net-plugin`作为骨干网络，以确保稳定性。请注意，网络必须是可附加的，并且子网必须位于`10.32.0.0/16`的范围内。所以，`10.32.3.0/24`在这里完全合适：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then we prepare a volume for the datastore. As this section also wanted to demonstrate
    a product-grade setup, we use MySQL as the store rather than the default SQLite3\.
    Using MySQL allows us to horizontally scale the number of Fn Servers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为数据存储准备一个卷。由于本节还希望展示一个产品级的设置，我们使用 MySQL 作为存储，而不是默认的 SQLite3。使用 MySQL 使我们能够横向扩展
    Fn 服务器的数量。
- en: 'The volume will be created using the `docker volume create` command. If we''d
    like to set up a MySQL cluster, the setups would be a bit more complex than this,
    but it will not be covered by this book:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 卷将使用`docker volume create`命令创建。如果我们想要设置一个 MySQL 集群，设置会比这个稍微复杂一些，但这本书不会涉及：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the `docker run` command to start an instance of MySQL. We just attach
    the instance to the network `fn_net` created previously. We specify the network
    alias here to ensure that the service must be accessible by the name `mysql`.
    All environment variables are designed to set up a username, password, and the
    default database, `fn_db`. Do not forget to bind the volume, `mysql_vol`, to `/var/lib/mysql`
    inside the container. This is designed to enable the data survive to when the
    container is removed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启动 MySQL 实例的`docker run`命令。我们将实例连接到先前创建的网络`fn_net`。我们在此指定网络别名，以确保服务必须通过名称`mysql`来访问。所有环境变量的设计是为了设置用户名、密码和默认数据库`fn_db`。不要忘记将卷`mysql_vol`绑定到容器内的`/var/lib/mysql`。这是为了确保数据在容器被移除时仍然存活：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The next step is to start the Fn Servers. This section demonstrates how to start
    two Fn Servers pointing to the same Log Store (MySQL). Each Fn Server attaches
    to the `fn_net`. This first instance is named `fn_0`. An Fn Server requires `FN_DB_URL`
    to point to an external Log Store, which may be PostgreSQL or MySQL. Just put
    the complete URL as shown in the following command. We also call the container
    `fn_0` to make it easier to manage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是启动 Fn 服务器。本节展示了如何启动两个指向相同日志存储（MySQL）的 Fn 服务器。每个 Fn 服务器都连接到`fn_net`。第一个实例命名为`fn_0`。Fn
    服务器需要`FN_DB_URL`来指向外部日志存储，可能是 PostgreSQL 或 MySQL。只需像以下命令中所示，输入完整的 URL。我们还将容器命名为`fn_0`，以便于管理。
- en: 'When having a setting such as this, the Fn Server becomes completely stateless,
    where all states will be stored externally to the database. So it is now safe
    to completely remove the Fn Server containers when things go wrong:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当有这样的设置时，Fn 服务器变得完全无状态，所有状态将被存储在数据库外部。所以，当出现问题时，完全可以安全地移除 Fn 服务器容器：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s start another one, `fn_1`. Basically, this should be done on a separate
    node (physical or virtual):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动另一个，`fn_1`。基本上，这应该在一个单独的节点（物理或虚拟）上完成：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Well, after setting all Fn Server instances, now it's time to aggregate them.
    We use Fn LB to act as the load balancer in front of all the Fn Servers. Similar
    to other containers, we just create and attach it to the `fn_net`. As it is the
    FaaS gateway, we also expose its port to `8080` (from its internal port `8081`)
    to make the Fn CLI able to connect to the Fn cluster without any special setting.
    The network alias is just used when we need other services to connect to this
    gateway.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在设置好所有 Fn Server 实例后，现在是时候将它们聚合在一起了。我们使用 Fn LB 作为所有 Fn Servers 前面的负载均衡器。与其他容器类似，我们只需创建并将其附加到
    `fn_net`。作为 FaaS 网关，我们还将其端口暴露到 `8080`（从其内部端口 `8081`），使 Fn CLI 可以连接到 Fn 集群而无需任何特殊设置。网络别名仅在我们需要其他服务连接到该网关时使用。
- en: Next, send a list of Fn Server nodes as the command line.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，发送一个 Fn Server 节点列表作为命令行参数。
- en: 'Currently, the node list configuration is allowed to pass directly to the container
    only. Just put them in `<name>:<port>` format, separated by a *comma*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，节点列表配置仅允许直接传递给容器。只需以 `<name>:<port>` 格式输入它们，并用 *逗号* 分隔：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'OK, now it''s time to verify that everything is up and running. We double-check
    all containers with the `docker ps` command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候验证一切是否正常运行了。我们使用 `docker ps` 命令仔细检查所有容器：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next two sections, we will cover how to monitor what's happening with
    Fn UI and how to see and maybe further analyze the logs stored in the database.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两部分中，我们将介绍如何通过 Fn UI 监控 Fn 的运行情况，以及如何查看并可能进一步分析存储在数据库中的日志。
- en: Monitoring with Fn UI
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Fn UI 进行监控
- en: Fn UI is the user interface project created for Fn. It provides a simple dashboard
    with easy-to-use time series graphs to monitor how functions are doing in near
    real time. To start the Fn UI, we create and attach the container to the `fn_net,`
    also with the port published to `4000`. The Fn UI requires the URL of an Fn Server.
    But all of them are behind the Fn LB, so we just set `FN_API_URL` to the Fn LB
    location.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Fn UI 是为 Fn 创建的用户界面项目。它提供了一个简单的仪表盘，并配备易于使用的时间序列图表，以便实时监控函数的运行情况。要启动 Fn UI，我们创建并将容器附加到
    `fn_net`，同时将端口发布到 `4000`。Fn UI 需要一个 Fn Server 的 URL。但是它们都位于 Fn LB 后面，因此我们只需将 `FN_API_URL`
    设置为 Fn LB 的位置。
- en: 'Please note that they are all connected to each other inside the `fn_net` network,
    so the URL appears to be `http://fnlb:8081`, using the real name and port of `fnlb`
    inside the network:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它们都在 `fn_net` 网络内部相互连接，因此 URL 显示为 `http://fnlb:8081`，使用的是 `fnlb` 在网络中的实际名称和端口：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After setting up the Fn UI instance, browse to `localhost:8080` to open the
    dashboard. We will see all applications listed there, as shown in the following
    screenshot. An application could be managed, such as creating or deleting, there
    too. If you do not want the screen to be always auto refreshing, uncheck Auto
    refresh:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好 Fn UI 实例后，浏览到 `localhost:8080` 打开仪表盘。我们将看到列出的所有应用程序，如以下截图所示。也可以在此管理应用程序，例如创建或删除。如果不希望屏幕一直自动刷新，可以取消选中“自动刷新”：
- en: '![](img/b661769f-08bb-4570-b7ea-b308152d87e0.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b661769f-08bb-4570-b7ea-b308152d87e0.png)'
- en: 'Figure 5.5: An Fn dashboard showing the list of Fn applications'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：显示 Fn 应用程序列表的 Fn 仪表盘
- en: After selecting an application, you can execute a function within the dashboard
    by clicking the Run Function button, as in the following screenshot. If an error
    occurs when executing the function and it fails, for example, a notification will
    pop up as in the following example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个应用程序后，您可以通过单击仪表盘中的“运行函数”按钮来执行函数，如以下截图所示。如果在执行函数时发生错误并且执行失败，例如，将弹出通知，如以下示例所示。
- en: 'To execute the function, put the Payload in the form of JSON and press the
    Run button:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行该函数，请将有效载荷以 JSON 形式放入并按下运行按钮：
- en: '![](img/ba0c4b6d-cf17-4869-8495-81fc624414f3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba0c4b6d-cf17-4869-8495-81fc624414f3.png)'
- en: 'Figure 5.6: A dialog for invoking functions'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：用于调用函数的对话框
- en: 'When a function invocation is completed, its name and count will appear in
    the Completed graph. Here''s the `curl` command to invoke the function. Run it
    multiple times to see the graph change:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数调用完成时，它的名称和计数将出现在已完成的图表中。以下是调用函数的 `curl` 命令。多次运行它以查看图表变化：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is also the Running graph that displays the number of functions still
    running in parallel. The following screenshot shows these graphs in action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个运行图表，显示了仍在并行运行的函数数量。以下截图展示了这些图表的运行情况：
- en: '![](img/8fd504f0-5a58-4c7c-a6c0-cb593dc8fd26.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fd504f0-5a58-4c7c-a6c0-cb593dc8fd26.png)'
- en: 'Figure 5.7: Graphs displaying different states of Fn''s functions'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：显示 Fn 函数不同状态的图表
- en: 'Let''s see what will happen when we run a number of requests with invalid inputs.
    Here''s the command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行一些无效输入的请求时会发生什么。以下是命令：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this, the `hello_go` function will exit with code `250` and appear in
    the Failed graph. We run it repeatedly to make the number of failure going up,
    as seen in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`hello_go` 函数将以代码 `250` 退出，并出现在失败图表中。我们反复运行它，以使失败次数增加，如下图所示：
- en: '![](img/9df97d8e-b9fd-4735-bf73-159286be42c6.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9df97d8e-b9fd-4735-bf73-159286be42c6.png)'
- en: 'Figure 5.8: The bottom right-hand graph showing the increment numbers of failed
    functions'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：右下方显示失败函数增量的图表
- en: We now already know how to use the Fn UI to monitor the function invocation.
    Next, we will use a simple DBMS UI to help browse the logs collected by Fn Servers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经知道如何使用 Fn UI 来监控函数调用。接下来，我们将使用一个简单的 DBMS 界面来帮助浏览 Fn 服务器收集的日志。
- en: Viewing call logs with MyAdmin
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MyAdmin 查看呼叫日志
- en: With MySQL as the central Log Store, we can simply access MySQL with any tool
    to query or event analyze the logs. In this example, we use a simple MyAdmin UI
    to connect to the MySQL backend. Here's the `docker run` command to start MyAdmin.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以 MySQL 作为中央日志存储，我们可以通过任何工具轻松访问 MySQL 以查询或分析日志。在这个例子中，我们使用一个简单的 MyAdmin 界面连接到
    MySQL 后端。以下是启动 MyAdmin 的 `docker run` 命令。
- en: 'We just simply attach an instance of MyAdmin to the same network and tell MyAdmin
    to connect to `mysql`, the service name of the backend DB:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将 MyAdmin 实例附加到相同的网络，并告诉 MyAdmin 连接到 `mysql`，即后端数据库的服务名称：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Browse to the exposed port, in this example port number `9000` , and log in
    using Username and Password, set during the setup of MySQL (`func`/`funcpass`).
    The following screenshot shows the login page of phpMyAdmin:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到暴露的端口，在这个例子中是端口号 `9000`，并使用在 MySQL 设置期间设置的用户名和密码（`func`/`funcpass`）登录。以下截图显示了
    phpMyAdmin 的登录页面：
- en: '![](img/2484860b-e84b-4181-b0b9-006df403a81a.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2484860b-e84b-4181-b0b9-006df403a81a.png)'
- en: 'Figure 5.9: The login page of phpMyAdmin that will connect to the Fn''s log
    database'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：将连接到 Fn 日志数据库的 phpMyAdmin 登录页面
- en: 'Inside the phpMyAdmin panel, take a look at the `fn_db` parameter and we will
    see all the tables for storing Fn information, as shown in the following screenshot.
    The data of the table `apps` are created by the command `fn apps create`, for
    example. What we''d like to see are table `calls` and table `logs`*.* The content
    of table `calls` can be retrieved by the `fn calls list`, and the content of table
    `logs` can also be retrieved in a similar way using `fn logs get`. But when we
    are able to access the `logs` directly, we can even do some analysis directly
    with the available data:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 phpMyAdmin 面板内，查看 `fn_db` 参数，我们将看到用于存储 Fn 信息的所有表，如下图所示。表 `apps` 的数据是通过命令 `fn
    apps create` 创建的。例如，我们想要查看的是 `calls` 表和 `logs` 表。`calls` 表的内容可以通过 `fn calls list`
    检索，`logs` 表的内容也可以通过类似的方式使用 `fn logs get` 检索。但是，当我们能够直接访问 `logs` 时，我们甚至可以直接使用可用数据进行一些分析：
- en: '![](img/244670aa-29fb-4a4c-abc4-125ad310557d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/244670aa-29fb-4a4c-abc4-125ad310557d.png)'
- en: 'Figure 5.10: The list of all Fn''s tables in phpMyAdmin'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：phpMyAdmin 中所有 Fn 表的列表
- en: 'The following screenshot shows the content of table `calls`. There is a status
    column, which allows us to effectively filter to see what the call (status) is: success
    or error. There is also the stats column, which contains some temporal information
    to be retrieved and displayed by the Fn UI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `calls` 表的内容。表中有一个状态列，允许我们有效地筛选出呼叫的状态：成功或错误。还有一个 `stats` 列，包含一些时间信息，将由
    Fn UI 检索并显示：
- en: '![](img/0dd3299e-c9ad-4236-aee5-b6e38705ae9f.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dd3299e-c9ad-4236-aee5-b6e38705ae9f.png)'
- en: 'Figure 5.11: Fn calls log data in table calls'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：`calls` 表中的 Fn 呼叫日志数据
- en: 'The following screenshot shows table `logs`. In the `logs` table, it just stamps
    each entry with the call ID. The column log shows the log message we printed out
    to the STDERR. We can see that there are different incorrect behaviors just by
    trying to send some invalid inputs to our `hello_go` function. With this table
    being so accessible, we can troubleshoot the Fn functions effectively without
    installing other extra tools:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `logs` 表。在 `logs` 表中，它只是为每个条目打上呼叫 ID 的标记。`log` 列显示了我们打印到 STDERR 的日志消息。我们可以通过尝试向
    `hello_go` 函数发送一些无效输入来查看不同的错误行为。由于这个表如此易于访问，我们可以有效地排除 Fn 函数的问题，而不需要安装其他额外的工具：
- en: '![](img/54b6697b-726d-40d1-b74b-9a9c5ed215cf.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54b6697b-726d-40d1-b74b-9a9c5ed215cf.png)'
- en: 'Figure 5.12: Fn logs data captured from a function''s STDERR'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：从函数的 STDERR 捕获的 Fn 日志数据
- en: 'OK, it seems everything is working correctly if we could get MyAdmin to show
    the logs data. Finally, to confirm that all containers are running and what they
    should look like, just use the `docker ps` command again to check all running
    containers:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果我们能够让MyAdmin显示日志数据，看来一切正常。最后，为了确认所有容器是否都在运行以及它们的状态，只需再次使用`docker ps`命令检查所有正在运行的容器：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Exercise
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Now it''s time to review all the things in this chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回顾本章的所有内容了：
- en: What does the Fn architecture look like?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fn架构是什么样的？
- en: How is the architecture different from other FaaS platforms?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该架构与其他FaaS平台有何不同？
- en: What is the role of the Fn Server?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fn服务器的角色是什么？
- en: How can we configure an Fn Server to use an external data store?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何配置Fn服务器以使用外部数据存储？
- en: What is the difference between the techniques used by the Fn's Java runtime
    and Go runtime?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fn的Java运行时和Go运行时所使用的技术有何不同？
- en: How are an application and routes organized?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序和路由是如何组织的？
- en: What is the role of Fn LB?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fn LB的角色是什么？
- en: What is the role of the Fn UI?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fn UI的角色是什么？
- en: How can we see the results of previous calls?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何查看之前调用的结果？
- en: How can we examine the log messages of a failed invocation?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何检查失败调用的日志信息？
- en: Describe how an Fn function interacts with STDIN, STDOUT, and STDERR?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一个Fn函数如何与STDIN、STDOUT和STDERR交互？
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter discussed the Fn Project, its components, and architecture. We
    started using Fn with its command line, the Fn CLI.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Fn项目、其组件和架构。我们开始使用Fn及其命令行工具Fn CLI。
- en: We then discussed the structure of an Fn function, such as how it interacts
    with STDIN, STDOUT, and STDERR. We learned how to build and deploy Fn functions,
    both with Java and Go runtimes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们讨论了Fn函数的结构，例如它如何与STDIN、STDOUT和STDERR交互。我们学习了如何构建和部署Fn函数，包括使用Java和Go运行时。
- en: Then we formed an Fn cluster on Docker Swarm and linked the Fn Server instances
    to an external DB store, MySQL. We load balanced the Fn instances using Fn LB,
    a load balancer specifically implemented by the same team.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在Docker Swarm上形成了一个Fn集群，并将Fn服务器实例与外部数据库存储（MySQL）连接。我们使用Fn LB（由同一团队专门实现的负载均衡器）对Fn实例进行了负载均衡。
- en: With the Fn UI, we learned how to use it to monitor invocations for Fn. With
    MyAdmin, we used it to browse calls and error logs directly in MySQL. A simple
    tool like MyAdmin could be used to achieve the same analytical result without
    preparing a complex toolchain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fn UI，我们学会了如何利用它监控Fn的调用。通过MyAdmin，我们能够直接在MySQL中浏览调用和错误日志。像MyAdmin这样的简单工具可以在不准备复杂工具链的情况下实现相同的分析结果。
- en: The next chapter will introduce OpenWhisk, another serverless stack from the
    Apache project, and those used by IBM to offer serverless services in their cloud.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍OpenWhisk，这是Apache项目中的另一个无服务器技术栈，以及IBM在其云中提供无服务器服务所使用的技术栈。
