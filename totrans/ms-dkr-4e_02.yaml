- en: '*Chapter 2*'
  prefs: []
  type: TYPE_NORMAL
- en: Building Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will start building container images. We will look at five
    different ways you can define and build images using native Docker tools.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the recommended ways that you can define and build your own
    images, as well as one way that is not considered to be a best practice but does
    have its uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Dockerfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using our Docker installation to build images. Some
    of the supporting commands, which will be few and far between, may only be applicable
    to macOS and Linux-based operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3h7oDX5](https://bit.ly/3h7oDX5)'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: While the screenshots in this chapter will be from my preferred operating system,
    which is macOS, the Docker commands we will be running will work on all three
    operating systems we have installed Docker on so far.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Dockerfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover Dockerfiles in depth, along with the best practices
    when it comes to their use. So, what is a Dockerfile?
  prefs: []
  type: TYPE_NORMAL
- en: A `docker image build` command, which we will look at next, it is used to assemble
    a container image.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Dockerfile looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even with no explanation, it is quite easy to get an idea of
    what each step of the Dockerfile instructs the build command to do. Before we
    move on and work our way through the previous file, we should quickly touch upon
    Alpine Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '`grsecurity/PaX`, which is patched into its kernel. This port offers proactive
    protection against dozens of potential zero-day threats and other vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alpine Linux, due to both its size and how powerful it is, has become the default
    image base for the official container images supplied by Docker. Because of this,
    we will be using it throughout this book. To give you an idea of just how small
    the official image for Alpine Linux is, let’s compare it to some of the other
    distributions available at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Comparing the size of popular base images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Comparing the size of popular base images
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding Terminal output, Alpine Linux weighs in at
    only 5.59 MB, as opposed to the biggest image, which is CentOS, at 237 MB. A bare-metal
    installation of Alpine Linux comes in at around 130 MB, which is still almost
    half the size of the CentOS container image.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Dockerfiles in depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the instructions we used in the preceding Dockerfile example.
    We will look at them in the order they appeared in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LABEL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY` and `ADD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` and `CMD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Dockerfile instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FROM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FROM` instruction tells Docker which base you would like to use for your
    image. As we already mentioned, we are using Alpine Linux, so we simply have to
    state the name of the image and the release tag we wish to use. In our case, to
    use the latest official Alpine Linux image, we simply need to add `alpine:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: LABEL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LABEL` instruction can be used to add extra information to the image. This
    information can be anything from a version number to a description. It’s also
    recommended that you limit the number of labels you use. A good label structure
    will help others who will use our image later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, using too many labels can cause the image to become inefficient as
    well, so I would recommend using the label schema detailed at [http://label-schema.org](http://label-schema.org%20).
    You can view the containers’ labels with the following `docker inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following command to filter just the labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see the labels present for the CentOS
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Checking image label'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Checking image label
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example Dockerfile, we have added two labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maintainer=”Russ McKendrick <russ@mckendrick.io>”`: Adds a label that helps
    the end user of the image identify who is maintaining it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`description=”This example Dockerfile installs NGINX.”`: Adds a brief description
    of what the image is.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it is better to define your labels when you create a container from
    your image, rather than at build time, so it is best to keep labels down to just
    metadata about the image and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: RUN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RUN` instruction is where we interact with our image to install software
    and run scripts, commands, and other tasks. As you can see from the following
    `RUN` instruction, we are actually running three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of our three commands is the equivalent of running the following
    command if we had a shell on an Alpine Linux host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command installs NGINX using Alpine Linux’s package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `&&` operator to move on to the next command if the previous
    command was successful. This makes it more obvious which commands we are running
    in the Dockerfile. We are also using **\**, which allows us to split the command
    over multiple lines, making it even easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command in our chain removes any temporary files to keep the
    size of our image to a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final command in our chain creates a folder with a path of `/tmp/nginx/`
    so that NGINX will start correctly when we run the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have also used the following in our Dockerfile to achieve the same
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, much like adding multiple labels, this is considered inefficient as
    it can add to the overall size of the image, which we should try to avoid. There
    are some valid use cases for this as some commands do not work well when they
    are stringed together using `&&`. However, for the most part, this approach to
    running commands should be avoided when your image is being built.
  prefs: []
  type: TYPE_NORMAL
- en: COPY and ADD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At first glance, `COPY` and `ADD` look like they are doing the same task in
    that they are both used to transfer files to the image. However, there are some
    important differences, which we will discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `COPY` instruction is the more straightforward of the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have probably guessed, we are copying two files from the `files` folder
    on the host we are building our image on. The first file is `nginx.conf`, which
    is a minimal NGINX configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will overwrite the NGINX configuration that was installed as part of the
    APK installation in the `RUN` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next file, `default.conf`, is the simplest virtual host that we can configure,
    and contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, this will overwrite any existing files. So far, so good! So, why might
    we use the `ADD` instruction?
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example Dockerfile, the `ADD` instruction looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are adding a file called `html.tar.gz`, but we are not actually
    doing anything with the archive to uncompress it in our Dockerfile. This is because
    `ADD` automatically uploads, uncompresses, and adds the resulting folders and
    files to the path we request it to, which in our case is `/usr/share/nginx/`.
    This gives us our web root of `/usr/share/nginx/html/`, as we defined in the virtual
    host block in the `default.conf` file that we copied to the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ADD` instruction can also be used to add content from remote sources.
    For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command line would download `html.tar.gz` from `https://raw.githubusercontent.com/PacktPublishing/Mastering-Docker-Fourth-Edition/master/chapter02/dockerfile-example/files/`
    and place the file in the `/usr/share/nginx/` folder on the image.
  prefs: []
  type: TYPE_NORMAL
- en: Archive files from a remote source are treated as files and are not uncompressed,
    which you will have to take into account when using them. This means that the
    file will have to be added before the `RUN` instruction so that we can manually
    unarchive the folder and also remove the `html.tar.gz` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPOSE`: The `EXPOSE` instruction lets Docker know that when the image is
    executed, the port and protocol defined will be exposed at runtime. This instruction
    does not map the port to the host machine; instead, it opens the port to allow
    access to the service on the container network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our Dockerfile, we are telling Docker to open port `80` every
    time the image runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of using `ENTRYPOINT` over `CMD` is that you can use them in conjunction
    with each other. `ENTRYPOINT` can be used by itself but remember that you would
    only want to use `ENTRYPOINT` by itself if you wanted your container to be executable.
  prefs: []
  type: TYPE_NORMAL
- en: For reference, if you think of some of the `CLI` commands you might use, you
    must specify more than just the `CLI` command. You might have to add extra parameters
    that you want the command to interpret. This would be the use case for using `ENTRYPOINT`
    only.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to have a default command that you want to execute
    inside a container, you could do something similar to the following example. Be
    sure to use a command that keeps the container alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What this means is that whenever we launch a container from our image, the
    NGINX binary is executed, which, as we have defined, is our entry point. Then,
    whatever we have as `CMD` is executed, giving us the equivalent of running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of how `ENTRYPOINT` can be used is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be the equivalent of running the following command on our host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn’t have to tell Docker to use NGINX. Since we have the NGINX
    binary as our entry point, any command we pass overrides the `CMD` instruction
    that has been defined in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: This would display the version of NGINX we have installed and our container
    would stop, as the NGINX binary would only be executed to display the version
    information. We will look at this once we have built and launched a container
    using our image. Before we move on, we should look at some of the instructions
    that are not included in our Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Other Dockerfile instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some instructions that we have not included in our example Dockerfile.
    Let’s take a look at them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USER`: The `USER` instruction lets you specify the username to be used when
    a command is run. The `USER` instruction can be used on the `RUN` instruction,
    the `CMD` instruction, or the `ENTRYPOINT` instruction in the Dockerfile. Also,
    the user defined in the `USER` instruction must exist, or your image will fail
    to build. Using the `USER` instruction can also introduce permission issues, not
    only on the container itself, but also if you mount volumes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR`: The `WORKDIR` instruction sets the working directory for the same
    set of instructions that the `USER` instruction can use (`RUN`, `CMD`, and `ENTRYPOINT`).
    It will allow you to use the `CMD` and `ADD` instructions as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONBUILD`: The `ONBUILD` instruction lets you stash a set of commands to be
    used when the image is used in the future, as a base image for another container
    image. For example, if you want to give an image to developers and they all have
    a different code base that they want to test, you can use the `ONBUILD` instruction
    to lay the groundwork ahead of the fact of needing the actual code. Then, the
    developers will simply add their code to the directory you ask them to, and when
    they run a new Docker build command, it will add their code to the running image.The
    `ONBUILD` instruction can be used in conjunction with the `ADD` and `RUN` instructions,
    such as in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This would run an update and package upgrade every time our image is used as
    a base for another container image.
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV`: The `ENV` instruction sets ENVs within the image both when it is built
    and when it is executed. These variables can be overridden when you launch your
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfiles – best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have covered Dockerfile instructions, let’s take a look at a few
    tips that are considered best practices for writing our own Dockerfiles. Following
    these will ensure that your images are lean, consistent, and easy for others to
    follow:'
  prefs: []
  type: TYPE_NORMAL
- en: You should try to get into the habit of using a `.dockerignore` file. We will
    cover the `.dockerignore` file in the *Building Docker images* section of this
    chapter; it will seem very familiar if you are used to using a `.gitignore` file.
    It will essentially ignore the items you specified in the file during the build
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to only have one Dockerfile per folder to help you organize your containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a version control system, such as Git, for your Dockerfile; just like any
    other text-based document, version control will help you move not only forward,
    but also backward, as necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the number of packages you need to install per image. One of the biggest
    goals you want to achieve while building your images is to keep them as small
    and secure as possible. Not installing unnecessary packages will greatly help
    in achieving this goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure there is only one application process per container. Every time you
    need a new application process, it is good practice to use a new container to
    run that application in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep things simple; over-complicating your Dockerfile will add bloat and potentially
    cause you issues down the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn by example! Docker themselves have quite a detailed style guide for publishing
    the official images they host on Docker Hub. You can find a link to this in the
    *Further reading* section at the end of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the `docker image build` command. This is where
    the rubber meets the road, as they say. It’s time for us to build the base upon
    which we will start building our future images. We will be looking at different
    ways to accomplish this goal. Consider this as a template that you may have created
    earlier with virtual machines. This will help save you time as this will complete
    the hard work for you; you will just have to create the application that needs
    to be added to the new images.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of switches that you can use while using the `docker build`
    command. So, let’s use the one that is always handy. Here, we will use the `--help`
    switch on the `docker image build` command to view what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of different flags listed that you can pass when building your
    image. Now, it may seem like a lot to digest, but out of all these options, we
    only need to use `--tag`, or its shorthand, `-t`, to name our image.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the other options to limit how much CPU and memory the build process
    will use. In some cases, you may not want the `build` command to take as much
    CPU or memory as it can have. The process may run a little slower, but if you
    are running it on your local machine or a production server and it’s a long build
    process, you may want to set a limit. There are also options that affect the network
    configuration of the container that was launched to build our image.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you don’t use the `--file` or `-f` switch since you run the `docker
    build` command from the same folder that the Dockerfile is in. Keeping the Dockerfile
    in separate folders helps sort the files and keeps the naming convention of the
    files the same.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth mentioning that, while you are able to pass additional ENVs
    as arguments at build time, they are used at build time and your container image
    does not inherit them. This is useful for passing information such as proxy settings,
    which may only be applicable to your initial build/test environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `.dockerignore` file, as we discussed earlier, is used to exclude those
    files or folders we don’t want to be included in the Docker build since, by default,
    all the files in the same folder as the Dockerfile will be uploaded. We also discussed
    placing the Dockerfile in a separate folder, and the same applies to `.dockerignore`.
    It should go in the folder where the Dockerfile was placed.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping all the items you want to use in an image in the same folder will help
    you keep the number of items, if any, in the `.dockerignore` file to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have spent the last few sections of this chapter looking at Dockerfiles,
    let’s start building images using the example file we have covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first method that we are going to look at for building our base container
    images is creating a Dockerfile. In fact, we will be using the Dockerfile from
    the previous section and then executing a `docker image build` command against
    it to get ourselves an NGINX image.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start off by looking at the Dockerfile once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget that you will also need the `default.conf`, `html.tar.gz`, and
    `nginx.conf` files in the `files` folder. You can find these in the accompanying
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there are two ways we can go about building our image. The first way would
    be by specifying the `--file` switch when we use the `docker image build` command.
    We will also utilize the `--tag` switch to give the new image a unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, `<REPOSITORY>` is typically the username you sign up for on Docker Hub.
    We will look at this in more detail in [*Chapter 3*](B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109),
    *Storing and Distributing Images*, but for now, we will be using `local`. `<TAG>`
    is a unique value that allows you to identify a container. Typically, this will
    be a version number or an other descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have a file called Dockerfile, we can also skip using the `--file` switch.
    This is the second way of building an image. The following is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important thing to remember is the dot (or period) at the very end.
    This is to tell the `docker image build` command to build in the current folder.
    When you build your image, you should see something similar to the following Terminal
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Building an image from our Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Building an image from our Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it’s built, you should be able to run the following command to check whether
    the image is available, as well as the size of your image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, my image size is 7.15 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Checking the size of the container image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Checking the size of the container image
  prefs: []
  type: TYPE_NORMAL
- en: 'You can launch a container with your newly built image by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch a container called `dockerfile-example`. You can check whether
    it is running by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening your browser and going to `http://localhost:8080/` should show you
    an extremely simple web page that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Checking the container in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Checking the container in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we will quickly run a few of the commands we covered in the *Introducing
    Dockerfiles* section of this chapter, starting with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, we are currently running
    NGINX version 1.16.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Checking the version of NGINX'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Checking the version of NGINX
  prefs: []
  type: TYPE_NORMAL
- en: The next command we will look at running displays the labels that we embedded
    at build time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view this information, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, this displays the information we
    entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Checking the labels of our newly built image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Checking the labels of our newly built image
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, you can stop and remove the containers we launched with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will go into more detail about Docker container commands in [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133),
    *Managing Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Using an existing container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to build a base image is to start off by using one of the official
    images from Docker Hub. Docker also keeps the Dockerfile for these official builds
    in their GitHub repositories. So, there are at least two choices you have for
    using existing images that others have already created. By using the Dockerfile,
    you can see exactly what is included in the build and add what you need. You can
    then version control that Dockerfile if you want to change or share it later.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to achieve this; however, it is not recommended or considered
    to be good practice, and I would strongly discourage you from using it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: I would only use this method during a prototyping phase to check that the commands
    you are running work as expected in an interactive shell before putting them in
    a Dockerfile. You should always use a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should download the image we want to use as our base; as we did previously,
    we will be using Alpine Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to run a container in the foreground so that we can interact
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once the container runs, you can add the packages as necessary using the `apk`
    command, or whatever the package management commands are for your Linux flavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following commands would install NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After you have installed the packages you require, you need to save the container.
    The `exit` command at the end of the preceding set of commands will stop the running
    container since the shell process we are detaching ourselves from just happens
    to be the process keeping the container running in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Checking the Terminal output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Checking the Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is at this point that you should really stop; I do not recommend that you
    use the preceding commands to create and distribute images, apart from the one
    use case we will discuss in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to save our stopped container as an image, you need to do something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, I ran the following command to save a copy of the container we
    launched and customized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Noticed how I called my image `broken-container`? Since one of the use cases
    for taking this approach is that if, for some reason, you have a problem with
    a container, then it is extremely useful to save the failed container as an image,
    or even export it as a `TAR` file to share with others if you need some assistance
    in getting to the root of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save the image file, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for our example, I ran the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This gave me a 7.9 MB file called `broken-container.tar`. Since we have this
    file, we can uncompress it and have a look around. It will have the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Collection of JSON files, folders, and TAR files'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Collection of JSON files, folders, and TAR files
  prefs: []
  type: TYPE_NORMAL
- en: The image is made up of a collection of JSON files, folders, and other TAR files.
    All the images follow this structure, so you may be thinking to yourself, **why
    is this method so bad?**
  prefs: []
  type: TYPE_NORMAL
- en: The biggest reason is trust (as we’ve already mentioned). Your end user will
    not be able to easily see what is in the image they are running. Would you randomly
    download a prepackaged image from an unknown source to run your workload, without
    checking how the image was built? Who knows how it was configured and what packages
    have been installed!
  prefs: []
  type: TYPE_NORMAL
- en: With a Dockerfile, you can see exactly what was executed to create the image,
    but with the method described here, you have zero visibility of this.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is that it is difficult for you to build in a good set of defaults.
    For example, if you were to build your image this way, then you would not really
    be able to take advantage of features such as `ENTRYPOINT` and `CMD`, or even
    the most basic instructions, such as `EXPOSE`. Instead, the user would have to
    define everything required while running their `docker container run` command.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of Docker, distributing images that had been prepared in this
    way was common practice. In fact, I was guilty of it myself since, coming from
    an operations background, it made perfect sense to launch a **machine**, bootstrap
    it, and then create a gold master. Luckily, over the last few years, Docker has
    extended the build functionality to the point where this option is not even considered
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Using scratch as a base
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been using prepared images from Docker Hub as our base images.
    However, it is best to avoid this altogether (sort of) and roll out your own images
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you usually hear the phrase from scratch, it literally means that
    you start from nothing. That’s what we have here – you get absolutely nothing
    and have to build upon it. Now, this can be a benefit because it will keep the
    image size very small, but it can also be detrimental if you are fairly new to
    Docker as it can get complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has done some of the hard work for us already and created an empty `TAR`
    file on Docker Hub named `scratch`; you can use it in the `FROM` section of your
    Dockerfile. You can base your entire Docker build on this, and then add parts
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we’ll be using Alpine Linux as our base operating system for the image.
    The reasons for doing this include not only the fact that it is distributed as
    an ISO, Docker image, and various virtual machine images, but also that the entire
    operating system is available as a compressed `TAR` file. You can find the download
    in this book’s GitHub repository, or on the Alpine Linux download page.
  prefs: []
  type: TYPE_NORMAL
- en: To download a copy, just select the appropriate download from the downloads
    page, which can be found at [https://www.alpinelinux.org/downloads/](https://www.alpinelinux.org/downloads/).
    The one I used was `x86_64` from the **MINI ROOT FILESYSTEM** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it’s finished downloaded, you need to create a Dockerfile that uses `scratch`
    and then add the `tar.gz` file, making sure to use the correct file, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You might be thinking, why did I just download the `alpine-minirootfs-3.11.3-x86_64.tar.gz`
    file? Could I have not had used `http://dl-cdn.alpinelinux.org/alpine/v3.11/releases/x86_64/alpine-minirootfs-3.11.3-x86_64.tar.gz`
    instead?
  prefs: []
  type: TYPE_NORMAL
- en: Remember, remote archives are treated as files and are just downloaded. Normally,
    that wouldn’t be a problem as we could just add a `RUN` command to uncompress
    the file, but since we are using `scratch`, an operating system hasn’t been installed,
    which means that there are no commands available for `RUN` to be able to execute
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our Dockerfile, we can build our image as we would have done
    on any other Docker image – by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Building from scratch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Building from scratch
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compare the image size to the other container images we have built
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, the image I built is exactly the
    same size as the Alpine Linux image we have been using from Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Reviewing the image sizes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Reviewing the image sizes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our own image has been built, we can test it by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you get an error, then you may already have a container called `alpine-test`
    created or running. Remove it by running `docker container stop alpine-test`,
    followed by `docker container rm alpine-test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should launch us into a shell on the Alpine Linux image. You can check
    this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display information on the release the container is running. To get
    an idea of what this entire process looks like, see the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Running the image from scratch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Running the image from scratch
  prefs: []
  type: TYPE_NORMAL
- en: While everything appears straightforward, this is only thanks to the way Alpine
    Linux packages their operating system. It can start to get more complicated when
    you choose to use other distributions who package their operating systems in a
    different way.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools that can be used to generate a bundle of an operating
    system. We are not going to go into any details regarding how to use any of these
    tools here because, if you must consider this approach, you probably have some
    pretty specific requirements. You can check the list of tools in the *Further
    reading* section at the end of this chapter for more details.
  prefs: []
  type: TYPE_NORMAL
- en: So, what could those requirements be? For most people, it will be legacy applications;
    for example, what happens if you have an application that requires an operating
    system that is no longer supported or available from Docker Hub, but you need
    a more modern platform to support the application? Well, you should be able to
    spin your image and install the application there, thus allowing you to host your
    old legacy application on a modern, supportable operating system/architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Using ENVs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover a very powerful set of variables known as **ENVs**
    (**ENVs**), as you will be seeing a lot of them. You can use ENVs for a lot of
    things in your Dockerfile. If you are familiar with coding, these will probably
    be familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: For others like myself, at first, they seemed intimidating, but don’t get discouraged.
    They will become a great resource once you get the hang of them. They can be used
    to set information when running the container, which means that you don’t have
    to go and update lots of the commands in your Dockerfile or in the scripts that
    you run on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use ENVs in your Dockerfile, you can use the `ENV` instruction. The structure
    of the `ENV` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can always place an equals sign between the key and the
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, the question is, why are there two ways that you can define them, and what
    are the differences?
  prefs: []
  type: TYPE_NORMAL
- en: With the first example, you can only set one ENV per line; however, it is easy
    to read and follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the second ENV example, you can set multiple environmental variables on
    the same line, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view which ENVs are set on an image using the `docker inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how they need to be set in our Dockerfile, let’s take a look
    at them in action. So far, we have been using a Dockerfile to build a simple image
    with just NGINX installed. Now, let’s look at building something a little more
    dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Alpine Linux, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set an ENV to define which version of PHP we would like to install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Apache2 and our chosen PHP version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the image so that Apache2 starts without issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the default `index.html` file and add an `index.php` file that displays
    the results of the `phpinfo` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose port 80 on the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set Apache so that it is the default process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please note that PHP5 is no longer supported. Because of that, we are having
    to use an older version of Alpine Linux, 3.8, as that is the last version that
    supports the PHP5 packages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have chosen to install PHP7; we can build the image by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we have changed the command slightly. This time, we are calling
    the `local/apache-php` image and tagging the version as `7`. The full output that
    we obtained by running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding output, the `PHPVERSION` ENV has been set
    to the number `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have only referred to the ENV. As shown by the following output,
    the necessary `php7` packages will start to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the packages have been installed, the build can do some housekeeping
    and then complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether everything ran as expected by running the following command
    to launch a container using the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s launched, open a browser and go to `http://localhost:8080/`. You
    should see a page showing that PHP7 is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Checking the PHP version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – Checking the PHP version
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be confused by the next part; there is no PHP6\. You can find out more
    about this at the following RFC and the results of the vote for skipping PHP6
    at https://wiki.php.net/rfc/php6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in your Dockerfile, change `PHPVERSION` from `7` to `5` and then run the
    following command to build a new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, the majority of the output
    is the same, apart from the packages that are being installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that `5` has been set as the value of the `PHPVERSION` ENV.
    From here, the build will continue just like the previous build did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is where the PHP5 packages are installed. This is the only difference
    between our two builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, now that the packages have been installed, the build will progress as
    it did previously until we have our complete image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can launch a container, this time on port 9090, by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening your browser again, but this time going to `http://localhost:9090/`,
    should show that we are running PHP5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Running PHP5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Running PHP5
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can compare the size of the images by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Comparing the image sizes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Comparing the image sizes
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the PHP7 image is a lot smaller than the PHP5 one. Let’s discuss
    what actually happened when we built the two different container images.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happened? Well, when Docker launched the Alpine Linux image to create
    our image, the first thing it did was set the ENVs we defined, making them available
    to all the shells within the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, the naming scheme for PHP in Alpine Linux simply substitutes
    the version number and maintains the same name for the packages we need to install,
    meaning that we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is actually interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For PHP5, it is interpreted as the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This means that we do not have to go through the whole Dockerfile, manually
    substituting version numbers. This approach is especially useful when installing
    packages from remote URLs, such as software release pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is a more advanced example: a Dockerfile that installs and configures
    Consul by *HashiCorp*. In this Dockerfile, we are using ENVs to define the version
    numbers and the SHA256 hash of the file we downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Dockerfiles can get quite complex, and using ENVs can help with
    maintenance. Whenever a new version of Consul is released, I simply need to update
    the `ENV` line and commit it to GitHub, which will trigger a new image being built.
    Well – it would have done if we had configured it to do so. We will look at this
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You might have also noticed we are using an instruction within the Dockerfile
    that we have not covered here. Don’t worry – we will look at the `VOLUME` instruction
    in [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133), *Managing Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Using multi-stage builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, which is the final part of our journey into using Dockerfiles
    and building container images, we will look at using a relatively new method for
    building an image. In the previous sections, we looked at adding binaries directly
    to our images either via a package manager, such as Alpine Linux’s APK, or, in
    the previous example, by downloading a precompiled binary from the software vendor.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to compile our own software as part of the build? Historically,
    we would have had to use a container image containing a full build environment,
    which can be very big. This means that we probably would have had to cobble together
    a script that ran through something like the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the build environment container image and start a `build` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the source code to the `build` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the source code on the `build` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the compiled binary outside of the `build` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `build` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a pre-written Dockerfile to build an image and copy the binary to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is a lot of logic – in an ideal world, it should be part of Docker. Luckily,
    the Docker community thought so, and the functionality to achieve this, called
    a multi-stage build, was introduced in Docker 17.05.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile contains two different build stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, named `builder`, uses the official Go container image from Docker
    Hub. Here, we are installing a prerequisite, downloading the source code directly
    from GitHub, and then compiling it into a static binary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Notice here we are using `ADD` with a URL since we want to download an uncompressed
    version of the source code rather than a zipped archive.
  prefs: []
  type: TYPE_NORMAL
- en: As our static binary has a built-in web server, we do not really need anything
    else to be present from an operating system point of view. Because of this, we
    are able to use `scratch` as the base image, meaning that all our image will contain
    is the static binary that we have copied from the builder image, and won’t contain
    any of the `builder` environment at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, we just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be found in the following code block.
    The interesting bits happen between *steps 5* and *6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the build environment container image has been pulled, we can prepare
    the environment to build our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With the environment prepared, we can download the source code from GitHub
    and compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have our compiled code as a single executable binary, which means that
    we can create a new build image using `scratch` and copy the binary from the previous
    build image across to the new build image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our binary has been compiled and the container that contains
    the build environment has been removed, leaving us with an image storing our binary.
    If you were to run the following command, you would get an idea of why it is a
    good idea not to ship an application with its build environment intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that the `golang` image is `809MB`; with our source
    code and prerequisites added, the size increases to `862MB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Checking the image sizes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Checking the image sizes
  prefs: []
  type: TYPE_NORMAL
- en: However, the final image is just `7.41MB`. I am sure you will agree that this
    is quite a dramatic amount of space that’s been saved. It also adheres to the
    best practices by only having content relevant to our application shipped within
    the image, as well as being really, really small.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the application by launching a container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The application is accessible over a browser and simply increments a counter
    each time the page is loaded. To test it on macOS and Linux, you can use the `curl`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Running the container and calling the page using curl'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – Running the container and calling the page using curl
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows users can simply visit `http://localhost:8000/` in a browser. To stop
    and remove the running container, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using a multi-stage build is a relatively simple process and
    is in keeping with the instructions that should already be starting to feel familiar
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at Dockerfiles, which I am sure you will agree are
    a straightforward way of defining you own Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Once we finished our in-depth look at Dockerfiles, we then looked at five ways
    in which we can build your images. We started by looking at **using a Dockerfile**
    as this is the most common way you will be building your images and we will be
    using it throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Then we discussed **using an existing container** as when Docker first came
    on the scene, this was the way most people originally built their images. It is
    no longer considered a best practice and should only ever be used if you need
    to create a snapshot of a running or crashed container for debug purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Next up we talked about **using scratch as a base.** This is probably the most
    streamlined way of creating an image as you are literally starting from zero.
  prefs: []
  type: TYPE_NORMAL
- en: We moved onto discussing **using environmental variables**. Here, we looked
    at the ways we can start to introduce variables such as version numbers into our
    Dockerfile in a way that means we don’t have to update the file in several places.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered `scratch` container, giving us the smallest usable images
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, now that we know how to build images using Dockerfiles,
    we will be taking a look at Docker Hub and all of the advantages that using a
    registry service brings.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at the Docker registry, which is open source, so that you
    can create and configure your own place to store images, as well as third-party
    hosted registry services, all of which can be used to distribute you own container
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True or false: the `LABEL` instruction tags your image once it has been built.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between the `ENTRYPOINT` and `CMD` instructions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: when using the `ADD` instruction, you can’t download and automatically
    uncompress an externally hosted archive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a valid use for using an existing container as the base of your image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `EXPOSE` instruction expose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the guidelines for the official Docker container images at [https://github.com/docker-library/official-images/](https://github.com/docker-library/official-images/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the tools to help you create containers from existing installations
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'debootstrap: [https://wiki.debian.org/Debootstrap](https://wiki.debian.org/Debootstrap)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'yumbootstrap: [http://dozzie.jarowit.net/trac/wiki/yumbootstrap](http://dozzie.jarowit.net/trac/wiki/yumbootstrap)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'rinse: [https://packages.debian.org/sid/admin/rinse](https://packages.debian.org/sid/admin/rinse)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Docker contrib scripts: [https://github.com/moby/moby/tree/master/contrib](https://github.com/moby/moby/tree/master/contrib)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The full GitHub repository for the Go HTTP Hello World application can be found
    at [https://github.com/geetarista/go-http-hello-world](https://github.com/geetarista/go-http-hello-world).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
