- en: Using ConfigMaps to Inject Configuration Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ConfigMaps allow us to keep configurations separate from application images.
    Such separation is useful when other alternatives are not a good fit.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every application can be fine-tuned through configuration. Traditional
    software deployment methods fostered the use of configuration files. However,
    we are not discussing traditional, but advanced, distributed, and immutable deployments
    through Kubernetes schedulers. Usage of fundamentally new technology often requires
    new processes and different architecture, if we are to leverage its potential
    to its maximum. On the other hand, we cannot just throw away everything we have
    and start anew.
  prefs: []
  type: TYPE_NORMAL
- en: We'll have to try to balance new principles and the legacy needs.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to start developing a new application today, it would be, among other
    things, distributed, scalable, stateless, and fault tolerant. Those are some of
    the today's needs. While we might question how many of us know how to design an
    application with those quality attributes in mind, hardly anyone would argue against
    having any of them. What is often forgotten is the configuration. Which mechanism
    should your new application use to configure itself? How about environment variables?
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables fit well into distributed systems. They are easy to define,
    and they are portable. They are the ideal choice for configuration mechanism of
    new applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, the configuration might be too complex for environment
    variables. In such situations, we might need to fall back to files (hopefully
    YAML). When those cases are combined with legacy applications which are almost
    exclusively using file-based configuration, it is evident that we cannot rely
    only on environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: When a configuration is based on files, the best approach we can take is to
    bake the configuration into a Docker image. That way, we are going down the fully-immutable
    road. Still, that might not be possible when our application needs different configuration
    options for various clusters (for example, testing and production). I'll ignore
    my internal need to convert this into a discussion that ends with "you do NOT
    need a different configuration for different environments". Rather just assume
    that you might have an excellent reason for something like that. In such a case,
    baking config files into images will not do the trick. That's where ConfigMaps
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMap allows us to "inject" configuration into containers. The source of
    the configs can be files, directories, or literal values. The destination can
    be files or environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMap takes a configuration from a source and mounts it into running containers
    as a volume.
  prefs: []
  type: TYPE_NORMAL
- en: That's all the theory you'll get up-front. Instead of a lengthy explanation,
    we'll run some examples, and comment on the features we experience. We'll be learning
    by doing, instead of learning by memorizing theory.
  prefs: []
  type: TYPE_NORMAL
- en: Let's prepare the cluster and see ConfigMaps in action.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's still the same process as before, so let's get over with it silently.
  prefs: []
  type: TYPE_NORMAL
- en: All the commands from this chapter are available in the `09-config-map.sh` ([https://gist.github.com/vfarcic/717f8418982cc5ec1c755fcf7d4255dd](https://gist.github.com/vfarcic/717f8418982cc5ec1c755fcf7d4255dd))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we can try out the first variation of a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting configurations from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its purest, and probably the most common form, a ConfigMap takes a single
    file. For example, we can create one from the `cm/prometheus-conf.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We created a **ConfigMap** (`cm`) called `my-config`. The data of the map is
    the content of the `cm/prometheus-conf.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's describe it, and see what we'll get.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The important part is located below `Data`. We can see the key which, in this
    case, is the name of the file (`prometheus-conf.yml`). Further down you can see
    the content of the file. If you execute `cat cm/prometheus-conf.yml`, you'll see
    that it is the same as what we saw from the ConfigMap's description.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMap is useless by itself. It is yet another Volume which, like all the
    others, needs a mount.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a Pod specification defined in `cm/alpine.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The essential sections are `volumeMounts` and `volumes`. Since `volumeMounts`
    are the same no matter the type of the Volume, there's nothing special about it.
    We defined that it should be based on the volume called `config-vol` and that
    it should mount the path `/etc/config`. The `volumes` section uses `configMap`
    as the type and, in this case, has a single item `name`, that coincides with the
    name of the ConfigMap we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the Pod and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please confirm that the Pod is indeed running before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the content of the `/etc/config` directory inside the Pod's only container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `/etc/config` now has a single file that coincides with the file we stored
    in the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: If you add `-l` to the `ls` command we executed a moment ago, you'll see that
    `prometheus-conf.yml` is a link to `..data/prometheus-conf.yml`. If you dig deeper,
    you'll see that `..data` is also a link to the directory named from a timestamp.
    And so on, and so forth. For now, the exact logic behind all the links and the
    actual files is not of great importance. From the functional point of view, there
    is `prometheus-conf.yml`, and our application can do whatever it needs to do with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s confirm that the content of the file inside the container is indeed
    the same as the source file we used to create the ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output should be the same as the contents of the `cm/prometheus-conf.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw one combination of ConfigMap. Let''s see what else we can do with it.
    We''ll remove the objects we created thus far and start over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are not limited to a single `--from-file` argument. We can specify as many
    as we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we execute the commands that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a ConfigMap with two files, and we created the same Pod based on
    the `alpine.yml` definition. Finally, we output the list of files from the `/etc/config`
    directory inside the Pod''s only container. The output of the latter command is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can see that both files are present in the container. That leads us to the
    conclusion that a ConfigMap can contain multiple files, and all will be created
    inside containers that mount it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's delete the objects (again), and explore one more option behind the `--from-file`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `--from-file` argument might lead you to the conclusion that you can specify
    only a file path as its value. It works with directories as well. We can, for
    example, add all files from the `cm` directory to a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We created `my-config` ConfigMap with the directory `cm`. Let's describe it,
    and see what's inside.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output is as follows (content of the files is removed for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see that all six files from the `cm` directory are now inside the `my-config`
    ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure you already know what will happen if we create a Pod that mounts
    that ConfigMap. We''ll check it out anyways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the latter command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All the files are there, and the time has come to move away from files and directories.
    So, let's remove the objects first, and discuss the other sources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Injecting configurations from key/value literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, even when our applications need different configs to work in distinct
    clusters, the differences are limited. Often, they should be limited to only a
    few key/value entries. In such cases, it might be easier to create ConfigMaps
    using `--from-literal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the latter command is as follows (`metadata` is removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see that two entries were added, one for each literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a Pod with the ConfigMap mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the latter command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's confirm that the content of one of the files is correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `--from-literal` argument is useful when we're in need to set a relatively
    small set of configuration entries in different clusters. It makes more sense
    to specify only the things that change, than all the configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that most of the existing applications are not designed to read
    separate configuration entries from different files. On the other hand, if you're
    sketching a new application, you might not choose this option either since you'd
    be able to develop it in a way that it reads environment variables. When faced
    with a choice between ConfigMap and environment variables, the latter wins most
    of the time.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, I'm not sure how often you'll be using the `--from-literal` argument.
    Maybe a lot, more likely not at all.
  prefs: []
  type: TYPE_NORMAL
- en: There's one more config source left to explore, so let's delete the objects
    we're currently running, and move on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Injecting configurations from environment files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `cm/my-env-file.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The file has the same key/value pairs as those we used in the example with
    `--from-literal`:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what happens if we create a ConfigMap using that file as the source.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We created the ConfigMap using the `--from-env-file` argument, and we retrieved
    the ConfigMap in `yaml` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the latter command is as follows (`metadata` is removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there are two entries, each corresponding to key/value pairs
    from the file. The result is the same as when we created a ConfigMap using `--from-literal`
    arguments. Two different sources produced the same outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used `--from-file` argument, the result would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All in all, `--from-file` reads the content of a one or more files, and stores
    it using file names as keys. `--from-env-file`, assumes that content of a file
    is in key/value format, and stores each as a separate entry.
  prefs: []
  type: TYPE_NORMAL
- en: Converting ConfigMap output into environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the examples we've seen so far are differing only in the source. The destination
    is always the same. No matter whether ConfigMap is created from a file, from a
    directory, from literal values, or from an environment file, it perpetually resulted
    in one or more files being injected into a container.
  prefs: []
  type: TYPE_NORMAL
- en: This time we'll try something different. We'll see how we can convert a ConfigMap
    into environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a sample definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The output is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The major difference, when compared with `cm/alpine.yml`, is that `volumeMounts`
    and `volumes` sections are gone. This time we have `env` section.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a `value` field, we have `valueFrom`. Further on, we declared that
    it should get values from a ConfigMap (`configMapKeyRef`) named `my-config`. Since
    that ConfigMap has multiple values, we specified the `key` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the Pod and executed the `env` command inside its only container.
    The output of the latter command, limited to the relevant parts, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s another, often more useful way to specify environment variables from
    a ConfigMap. Before we try it, we''ll remove the currently running Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at yet another definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The difference is only in the way environment variables are defined. This time,
    the syntax is much shorter. We have `envFrom`, instead of the `env` section. It
    can be either `configMapRef` or `secretRef`. Since we did not yet explore Secrets,
    we'll stick with the prior. Inside `configMapRef` is the name reference to the
    `my-config` ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the Pod and retrieved all the environment variables from inside
    its only container. The output of the latter command, limited to the relevant
    parts, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same as before. The difference is only in the way we define
    environment variables. With `env.valueFrom.configMapKeyRef` syntax, we need to
    specify each ConfigMap key separately. That gives us control over the scope and
    the relation with the names of container variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `envFrom.configMapRef` converts all ConfigMap's data into environment variables.
    That is often a better and simpler option if you don't need to use different names
    between ConfigMap and environment variable keys. The syntax is short, and we don't
    need to worry whether we forgot to include one of the ConfigMap's keys.
  prefs: []
  type: TYPE_NORMAL
- en: Defining ConfigMaps as YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All ConfigMaps we created so far were done through `kubectl create cm` commands.
    It would be a shame if we could not specify them through YAML definitions, just
    like other Kubernetes resources and objects. Fortunately, we can. Everything in
    Kubernetes can be defined as YAML, and that includes ConfigMaps as well.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we have not yet specified ConfigMaps as YAML, we have seen the format
    quite a few times throughout this chapter. Since I cannot be sure whether you
    can create a ConfigMap YAML file from memory, let's make things easy on ourselves
    and use `kubectl` to output our existing `my-config` ConfigMap in YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Just as with any other Kubernetes object, ConfigMap has `apiVersion`, `kind`,
    and `metadata`. The data is where the maps are defined. Each must have a key and
    a value. In this example, there's the key `weather` with the value `sunny`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to translate that knowledge into the objects we'd need to deploy Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, limited to the relevant parts, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `Deployment` object defines the `volumeMount` that references the `prom-conf`
    Volume, which is a `configMap`. We saw quite a few similar examples before.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConfigMap` object's `data` section has only one key (`prometheus.yml`).
    Once this ConfigMap is mounted as a volume, the name of the file will be the same
    as the key (`prometheus.yml`). The value has a bit of "special" syntax. Unlike
    the previous example where the value was a single word written directly after
    the colon, the structure of the value is now a bit more complex. To be more precise,
    it contains multiple lines. When working with a large value, we can start with
    the pipe sign (`|`). Kubernetes will interpret the value as "everything that follows,
    as long as it is indented." You'll notice that all the lines of the value are
    at least two spaces to the right of the beginning of the key (`prometheus.yml`).
    If you'd like to insert an additional key, all you'd need to do is to add it on
    the same level (indentation), as the other `prometheus.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the application and confirm that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We created the objects (with the help of `sed` transformations), we waited until
    the Deployment rolled out, and, finally, we opened the Prometheus targets screen
    in a browser. The result should be a green target towards Prometheus internal
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: A plea NOT to use ConfigMaps!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ConfigMaps, in my experience, are overused.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a configuration that is the same across multiple clusters, or if
    you have only one cluster, all you should do is include it in your Dockerfile
    and forget it ever existed. When there are no variations of a config, there's
    no need to have a configuration file. At least, not outside an immutable image.
    Unfortunately, that is not always the case. Heck, it's almost never the case.
    We tend to make things more complicated than they should be. That, among other
    things, often means an endless list configuration options hardly anyone ever uses.
    Still, some things usually do change, from one cluster to another, and we might
    need to look into alternatives to configurations baked into images.
  prefs: []
  type: TYPE_NORMAL
- en: Design your new applications to use a combination of configuration files and
    environment variables. Make sure that the default values in a configuration file
    are sensible and applicable in most use-cases. Bake it into the image. When running
    a container, declare only the environment variables that represent the differences
    of a specific cluster. That way, your configuration will be portable and simple
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: What if your application is not new and it does not support configuration through
    environment variables? Refactor it so that it does. It shouldn't be hard to add
    the ability to read a few environment variables. Keep in mind that you don't need
    all the settings, but only those that differ from one cluster to another. It would
    be hard to imagine that such a trivial request would be complex or time-consuming.
    If it is, you might have more significant issues to fix before even thinking about
    putting your application into a container.
  prefs: []
  type: TYPE_NORMAL
- en: Still, configuration files will not disappear. No matter which strategy we choose,
    each image should have a copy of them with sensible default values. Maybe, we
    can put in an extra effort and change the application, so that configuration entries
    are loaded from two locations. That way, we can load the default values from one,
    and only the differences from the other. That would, at least, reduce the need
    to have to specify more than the minimum required for each cluster. In such a
    case, ConfigMap's `--from-literal` and `--from-env-file` sources are an excellent
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: When everything else fails, the `--from-file` source is your friend. Just make
    sure that ConfigMap is not defined in the same file as the objects that mount
    it. If it is, it would mean that they could be used only inside one cluster. Otherwise,
    we'd be deploying the same config, and we should go back to the initial idea of
    having it baked into the image together with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Do not let this pessimism discourage you from using ConfigMaps. They are very
    handy, and you should adopt them. My intent to discourage you from doing so had
    the intention of making you think of alternatives, not to tell you never to use
    ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: What now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next chapter will explore something very similar to ConfigMaps. The significant
    difference is that we'll be more secretive this time.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll destroy the cluster we used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you'd like to know more about ConfigMaps, please explore ConfigMap v1 core
    ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#configmap-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#configmap-v1-core))
    API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b59369c1-925f-4718-ac20-8ccb2113093f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: The components explored so far'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes ConfigMaps compared to Docker Swarm configs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mechanisms behind Kubernetes ConfigMaps and Docker Swarm Configs are almost
    the same. At least, from the functional perspective. Both allow us to store some
    literal texts in the scheduler's internal data store, and both enable us to add
    them to containers. The syntax is equally simple and straightforward in both cases.
    Still, there are a few differences.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is good at preventing people from doing silly things (the politically
    correct version of the word *stupid*). An example would be an attempt to delete
    a configuration. It cannot be deleted if there are Docker services that reference
    the configuration. Only after all the services that reference it are removed,
    are we allowed to remove the configuration source. Kubernetes, on the other hand,
    will let us delete a ConfigMap object without even a hint about the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes ConfigMap, on the other hand, provides a wider variety of options.
    While a Docker Swarm configuration can be created only from a file or `stdin`,
    the Kubernetes equivalent can be generated from a file, from a directory, from
    a literal value, and from files with environment variables. Each of those sources
    can be used multiple times. We can even combine them. Further on, Kubernetes ConfigMaps
    can be converted not only to files, but also to environment variables. Flexibility
    and extra functionalities are available both at the source and the destination
    end-points.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm wins a user experience point. Kubernetes gains a star for providing
    more choices. Neither has a significant difference that would warrant a win, so
    I'm proclaiming it a *tie*.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more features worthwhile comparing. We're not yet finished. Stay
    tuned for more.
  prefs: []
  type: TYPE_NORMAL
