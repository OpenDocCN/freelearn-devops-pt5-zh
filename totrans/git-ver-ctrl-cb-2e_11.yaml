- en: Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'his chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using git stash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and applying stashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with git bisect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the blame command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring the UI in the prompt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocompletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash prompt with status information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive add
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive add with Git gui
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignoring files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing and cleaning ignored files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will find some tips and tricks that can be useful in everyday
    Git work; from stashing away your changes when you get interrupted while doing
    an important task, to efficient bug hunting with `bisect` and `blame`, to finding
    color and status information in your prompt. We'll also look at aliases, how you
    can create clean commits by selecting which lines should be included in the commit
    and, finally, how you can ignore files.
  prefs: []
  type: TYPE_NORMAL
- en: Using git stash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll explore the `git stash` command and learn how we can
    use it to quickly `stash` away uncommitted changes and retrieve them again. This
    can be useful when you are interrupted while doing an urgent task and you are
    not yet ready to commit the work you currently have in your working directory.
    With the `git stash` command, you can save the state of your current working directory
    with/without a staging area and restore the working tree to a clean state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we''ll use the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` repository.
    We''ll use the `master` branch, but before we are ready to try the `stash` command,
    we need to create some changes in the working directory and the staging area,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Make some changes to `foo` and add them to the staging area, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Make some changes to `bar` and create a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have one file added to the staging area, `foo`, one modified
    file, `bar`, and an untracked file in the work area as well, `new_file`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the preceding state of our repository, we can stash away the changes so
    that we can work on something else. The basic command will put away changes from
    the staging area and changes made to tracked files. It leaves untracked files
    in the working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now work on something else and create and commit those changes. We''ll
    change the first line of the `foo` file and create a commit with this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the current work we have stashed away with the `git stash list`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the changes we stashed away back, we can pop them from the `stash` stack,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, the stashed changes are available again in the working repository and the
    `stash` entry has been deleted. Note that the changes are applied only to the
    working directory, although one of the files was staged when we created the `stash`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created two commits: one for the index and one for the work area. In
    `gitk`, we can see the commits that `stash` creates to put the changes away (`gitk
    stash`), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7406e649-8999-4398-bac9-ed3f94ad2f21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also see the state of the branches after we created the commit (`gitk
    --reflog`), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9daab906-9007-41b7-9006-3bb61e821a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Git actually creates two commits under the `refs/stash` namespace. One commit
    contains the contents of the staging area. This commit is called `index on master`.
    The other commit is the work in progress in the working directory, `WIP on master`.
    When Git puts away changes by creating commits, it can use its normal resolution
    methods to apply the stashed changes back to the working directory. This means
    that if a conflict arises when applying the stash, you need it to be solved in
    the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we saw only the very basic usage of the `stash` command,
    putting away changes to untracked files and changes added to the staging area.
    It is also possible to include untracked files in the `stash` command. This can
    be done with the `--include-untracked` option. We can add `foo` to the staging
    area; firstly, to have the same state as when we created the `stash` earlier and
    then to create a `stash` that includes untracked files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see that `new_file` has disappeared from the working directory.
    It''s included in the stash, and we can check this with Gitk. It will show up
    as another commit of untracked files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Gitk shows the stash with its untracked files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67d05fc8-ab3b-45f1-a62c-3e33ff4c3bf0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also make sure that the changes we added to the staging area are added
    back to the staging area after we apply the `stash`, so we end up with the exact
    same state as before we stashed our changes away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to put away only the changes in the working directory,
    while keeping the changes in the staging area. We can do this either for only
    the tracked files or by stashing away untracked files ( `--include-untracked`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Saving and applying stashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When stashing away work, we can easily have more than one state stashed away
    at a time. However, the default names for stashed away changes aren't always helpful.
    In this example, we'll see how we can save stashes and name them so that it is
    easy to identify them again when listing the content of the stash. We'll also
    learn how to apply a stash without deleting it from the stash list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same repository as in the previous example, continuing from
    the state we left it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save the current state to a stash with a description we can remember at
    a later point in time, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `stash` list now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change `bar` and create a new `stash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the stashes back to the working tree (and staging area with the
    `--index option`) without deleting them from the `stash` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The stashes are still in the `stash` list, and they can be applied in any order
    and referred to with the `stash@{stash-no}` syntax. The `--quiet` option suppresses
    the status output after the stashes have been applied.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For stashes applied with `git stash apply`, the `stash` needs to be deleted
    with `git stash drop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the stashes in the `stash` list by using `stash apply` and explicitly
    deleting them with `git stash drop` has some advantages over just using `stash
    pop`. When using the `pop` option, the stashes in the list are automatically deleted
    if they can be successfully applied. But if it fails and triggers the conflict
    resolution mode, the stash applied is not dropped from the list and continues
    to exist on the `stash` stack. This might later lead to accidentally using the
    wrong `stash` because it was thought to have been removed. By consistently using
    `git stash apply` and `git stash drop`, you can avoid this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git stash` command can also be used to apply debug information to an application.
    Let''s pretend you have been bug hunting and have added a lot of debug statements
    to your code in order to track down a bug. Instead of deleting all those debug
    statements, you can save them as a Git `stash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ git stash save "Debug info stash"`'
  prefs: []
  type: TYPE_NORMAL
- en: Then, if you need debug statements later, you can just apply the stash and you'll
    be ready to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with git bisect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git bisect` command is an excellent tool to find which commit caused a
    bug in the repository. The tool is particularly useful if you are looking at a
    long list of commits that may contain the bug. The `bisect` command performs a
    binary search through the commit history to find the commit that introduced the
    bug as fast as possible. The binary search method, or bisection method, as it
    is also called, is a search method where an algorithm finds the position of a
    key in a sorted array. In each step of the algorithm, the key is compared to the
    middle value of the array and if they match, the position is returned. Otherwise,
    the algorithm repeats its search in the subarray to the right or left of the middle
    value, depending on whether the middle value was greater or less than the key.
    In the Git context, the list of commits in the history makes up for the array
    of values to be tested, and the key can be a test if the code can be compiled
    successfully at the given commit. The binary search algorithm has a performance
    of *O(log n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same repository as seen in the last example, but from a clean
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bug_hunting` branch contains 23 commits, since it branched off from the
    `master` branch. We know that the tip of the `bug_hunting` branch contains the
    bug and that it was introduced in a commit, since it branched off from `master`.
    The bug was introduced in the following commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The bug is clearly visible in the `map.txt` file, in the middle of Australia.
    The following snippet of the file shows the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0523183-60dc-4d83-b8af-a6f02eb395b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, all we need is some way to reproduce/detect the bug so that we can test
    the different commits. This could, for example, simply be to compile the code,
    run tests, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''ll create a test script to check for bugs in the code
    (a simple `grep` for `oo` should do it in this example; see for yourself if you
    can find the bug in the `map.txt` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It's better to create this test script outside the repository to prevent interactions
    between checkouts, compilation, and so on in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin bisecting, we simply type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To mark the current commit (`HEAD -> bug_hunting`) as bad, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to mark the last known good commit (`master`) as good:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, something happened. Git did a checkout of `9d2cd13`, which it wants
    us to test and mark as either good or bad. It also tells us there are 11 revisions
    to test after this, and it can be done in approximately four steps. This is how
    the bisecting algorithm works: every time a commit is marked as good or bad, Git
    will `checkout` the one between the commit that has just been marked and the current
    commit of opposite value. In this way, Git quickly narrows down the number of
    commits to check. It also knows that there are approximately four steps, and this
    makes sense since, with 11 revisions left, the maximum number of tries is *log[2](11)
    = 3.46* before the faulty commit is found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test with the `test.sh` script we created previously, and based on the
    return value, mark the commit as good or bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The test marks the commit as good and Git checks out the next commit to be
    marked, until we hit the commit that introduces the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After four steps, Git has identified the `83c22a3` commit as the first bad
    commit. We can end the `bisect` session and take a closer look at the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, a bug was introduced with this commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following annotated screenshot shows the steps taken by the `bisect` session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e06b301-474f-479b-a48f-628a01617960.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the bisection algorithm actually hits the faulty commit in the third
    step, but it needs to look further to make sure that the commit isn't just a child
    commit of the faulty commit, and is in fact the commit that introduced the bug.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of running all the bisecting steps manually, it''s possible to do it
    automatically by passing Git a script, makefile, or test to run on each commit.
    The script needs to exit with a **zero-status** to mark a commit as good and a
    **non-zero** status to mark it as bad. We can use the `test.sh` script we created
    at the beginning of this chapter for this. First, we set up the good and bad commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we tell Git to run the `test.sh` script and automatically mark the commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Git found the same commit and we can now exit the bisecting session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using the blame command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bisect` command is good when you don't know where in your code there is
    a bug, but you can test for it and thereby find the commit that introduced it.
    If you already know where in the code the bug is but want to find the commit that
    introduced it, you can use `git blame`. The `blame` command will annotate every
    line in the file with the commit that most recently touched that line, making
    it easy to find the commit ID and then the full context of the commit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same repository and branch as in the bisect example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that the bug is in `map.txt` on lines 37-39\. To annotate each line
    in the file with the commit ID and author, we''ll run `git blame` on the file.
    We can further limit the search to specific lines with the `-L <from>,<to>` option,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a9c27d8-3809-483d-86c7-3458e6067a63.png)'
  prefs: []
  type: TYPE_IMG
- en: From the output, it can clearly be seen that the commit with the ID `83c22a39`
    by `HAL 9000` introduced the bug.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `blame` command can be used even if the file has been refactored and the
    code has been moved around. With the `-M` option, the `blame` command can detect
    lines that have been moved within the file, and with the `-C` option, Git can
    detect lines that were moved or copied from other files in the same commit. If
    the `-C` option is used three times `-CCC`, the `blame` command will find lines
    that were copied from other files in any commit.
  prefs: []
  type: TYPE_NORMAL
- en: Coloring the UI in the prompt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Git has no colors when displaying information in the terminal. However,
    displaying colors is a feature of Git that is only a configuration away.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks`
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll edit and add `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `foo` some more, but don''t add it to the staging area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git status` command will show us the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the `color.ui` configuration to `auto` or `true` to get color in
    the UI when required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `color.ui` configuration works with a long range of Git commands, `diff`,
    `log`, and `branch` included. The following is an example of `git log` when setting
    `color.ui` to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Autocompletion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git comes with built-in support for the autocompletion of Git commands for the
    `bash` and `zsh` shells. If you use either of these shells, you can enable the
    autocompletion feature and let the `<tab>` option help you complete commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, the autocompletion feature is distributed with the Git installation,
    but it is not enabled by default on all platforms or distributions. To enable
    it, we need to find the `git-completion.bash` file distributed/installed with
    the Git installation.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Linux users, the location may vary depending on the distribution. Generally,
    the file can be found at `/etc/bash_completion.d/git-completion.bash`.
  prefs: []
  type: TYPE_NORMAL
- en: Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Mac users, it can generally be found at `/Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash`.
  prefs: []
  type: TYPE_NORMAL
- en: If you installed Git from Homebrew, it can be found at `/usr/local/Cellar/git/2.15.0/etc/bash_completion.d/git-completion.bash`.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the **Msysgit** installation on Windows, the completion functions are already
    enabled in the Git Bash shell it bundles.
  prefs: []
  type: TYPE_NORMAL
- en: If you can't find the file on your system, you can obtain the latest version
    from [https://github.com/git/git/blob/master/contrib/completion/git-completion.bash](https://github.com/git/git/blob/master/contrib/completion/git-completion.bash)
    and install it in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable the completion feature, you need to run the `source` command on the
    completion file, which you can do by adding the following lines to your `.bashrc`
    or `.zshrc` file, depending on your shell and the location of the Git completion
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you are ready to try this. Switch to an existing Git repository, for example,
    `cookbook-tips-tricks`, and type the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can add another `c<tab>` and the command will autocomplete to `checkout`.
    But the autocompletion feature doesn't only complete commands; it can also help
    you complete branch names, and so on. This means that you can continue with the
    checkout and write `mas<tab>`. You should be able to see the output completed
    to the `master` branch, unless you are in a repository where there are several
    branches starting with `mas`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The completion feature also works with options. This is quite useful if you
    can''t remember the exact option but you may remember some of it, for example,
    when using `git branch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Bash prompt with status information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another cool feature Git provides is having the prompt display status information
    if the current working directory is a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the status information prompt to work, we also need to source another file, `git-prompt.sh`,
    which is usually distributed with the Git installation and located in the same
    directory as the completion file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your `.bashrc` or `.zshrc` file, add the following code snippet, again depending
    on your shell and the location of the `git-prompt.sh` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make use of the Command Prompt, we must change the `PS1` variable; usually
    this is set to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command shows the current user, an `@` sign, the hostname, the
    current working directory relative to the user''s home directory, and finally,
    the `$` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change this to add a branch name after the working directory by adding
    `$(__git_ps1 " (%s)")` to the `PS1` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our prompt will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to show the state of the working tree, the index, and so
    on. We can enable these features by exporting some environment variables in the
    `.bashrc` file that `git-prompt.sh` picks up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following environment variables can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Value** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| `GIT_PS1_SHOWDIRTYSTATE` | Nonempty | Shows `*` for unstaged changes and
    `+` for staged changes. |'
  prefs: []
  type: TYPE_TB
- en: '| `GIT_PS1_SHOWSTASHSTATE` | Nonempty | Shows the `$` character if something
    is stashed. |'
  prefs: []
  type: TYPE_TB
- en: '| `GIT_PS1_SHOWUNTRACKEDFILES` | Nonempty | Shows the `%` character if there
    are untracked files in the repository. |'
  prefs: []
  type: TYPE_TB
- en: '| `GIT_PS1_SHOWUPSTREAM` | autoverbosenamelegacyGitsvn | Auto shows whether
    you are behind (`<`) or ahead (`>`) of the upstream branch. A `<>` value is displayed
    if the branch is diverged and `=` if it is up to date. Verbose shows the number
    of commits behind/ahead. Name shows the upstream name. Legacy is verbose for old
    versions of Git. Git compares `HEAD` to `@{upstream}`. SVN compares `HEAD` to
    `svn upstream`. |'
  prefs: []
  type: TYPE_TB
- en: '| `GIT_PS1_DESCRIBE_STYLE` | containsbranchdescribedefault | Displays extra
    information when on a detached `HEAD`. Contains is relative to a newer annotated
    tag (`v1.6.3.2~35`). Branch is relative to a newer tag or branch (`master~4`).
    Describe is relative to an older annotated tag (`v1.6.3.1-13-gdd42c2f`). Default
    is the tag that matches exactly. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s try to set some of the variables in the `~/.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the `~/.bashrc` file in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When using the `__git_ps1` option, Git will also display information when merging,
    rebasing, bisecting, and so on. This is very useful and a lot of `git status`
    commands suddenly become unnecessary, as you have the information right there
    in the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a terminal without some colors these days? The `git-prompt.sh` script
    also supports this. All we need to do is set the `GIT_PS1_SHOWCOLORHINTS` variable
    to a nonempty value and, instead of using `PS1`, we need to use `PROMPT_COMMAND`.
    Let''s change `~/.bashrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we redo the same scenario as the previous one, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cae11322-952c-4fc9-a382-1d4686e8155a.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using `zsh` or just want to try something new with many features,
    such as completion, Git support, and so on, you should take a look at the `oh-my-zsh`
    framework, available for `zsh` at: [https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh).
  prefs: []
  type: TYPE_NORMAL
- en: More aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](dfad614d-7bef-4396-824c-7bdfcbd22802.xhtml), *Configuration*,
    we saw how we can create aliases and looked at a few examples of them. In this
    section, we will look at some more examples of useful aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have to clone the `cookbook-tips-tricks` repository and check out the
    `aliases` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we'll see some examples of aliases, with a short description of each of
    them and an example of how to use them. The aliases are just made for the local
    repository; use `--global` to make them available for all the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with an alias to show the current branch only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To show a compact graph history view with colors, the following alias will
    save you many keystrokes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows you a typical output, where commits are colored
    red, committers are colored blue, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18966b27-700f-41ae-8672-01228039f358.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When resolving a conflicted merge, it can be useful to get a list of the conflicted/unmerged
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the previous alias in action by merging the `origin/conflict` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'First, check the output of `git status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the unmerged path mentioned in the output. Let''s use the `unmerged`
    alias to get a simple list of unmerged files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can abort the merge as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'During a work day, you will type `git status` many times. Adding a shorthand
    status can be helpful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'An even shorter status with branch and file information can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To try it out, first modify `foo` and create an untracked `test` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try your new `s` alias:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, you''ll just want to show the latest commit with some stats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'But sometimes, you need a bit more context. The following alias is the same 
    as the previous but for the five latest commits (the output is not shown):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'A commit listing with statistics on the changed files in color can be displayed
    using the following alias:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As the next screenshot shows, committers are colored blue, their age in green,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/feb33e0e-c000-4819-8d9e-f0bf8d3ea163.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you work in many repositories, remember that the `upstream/tracking` branch
    can be difficult. The following alias is shorthand for showing this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can show the details of ID/SHA-1 (commit, tag, tree, blob) with the `details`
    alias. Not that you save many keystrokes, but `details` is easier to remember:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A repository will grow, and the directory tree will become large. You can show
    the number of `cd-ups` and, `../`, needed to go to the repository root using the
    following alias, which can be useful in shell scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The path of the repository on the filesystem can easily be viewed with the
    following alias:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to abandon whatever changes we have in the index, working tree,
    and also possibly the commits, and reset the working tree to a known state (commit
    ID) but we don''t want to touch the untracked files, all we need is a `ref` to
    a state of the repository to be restored, for example, `HEAD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Interactive add
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exposed staging area Git offers sometimes leads to confusion, especially
    when adding a file, changing it a bit, and then adding the file again to be able
    to commit the changes made after the first add. While it can seem a bit cumbersome
    to add the file after every little change, it is also a big advantage that you
    can stage and unstage changes. With the `git add` command, it's even possible
    to only add some changes to a file in the staging area. This comes in handy, especially
    if you make a lot of changes to a file and, for example, want to split the changes
    into bug fixes, refactoring, and features. This example will show how you can
    easily do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we''ll use the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks`
    repository. Clone it and check out the interactive branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need some changes to be added; we do this by resetting the latest
    commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a modified file. To start the interactive add, we can either run
    the `git add -i` or `git add -p` filename. The `-i` option brings up an interface
    where all the different files in the modified state can be added interactively
    one at a time. The `add -p/--patch` option is simpler and just gives you the option
    to add parts of the file specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Git asks you whether you want to stage the previous change (the hunk), but
    also shows quite a lot of options, which can be expanded a little bit if you type
    `?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a lot of options, but with the help text, they are quite self-explanatory.
    Let''s add the current hunk, `y`, and look at the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoa! It looks like there is a debug line there that we should not add. Let''s
    split the hunk, `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want the output to be staged, use `n`, but we''ll stage the next
    hunk and all the hunks later, in the `a` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the current status and the difference between the working directory
    and staging area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! We got all the changes staged except the debug line, so the result
    can be committed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, it''s also possible to use `git add -i` to interactively
    add files. If we do this after resetting our branch, we will get the following
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The eight options pretty much do what they say. We can choose the patch option
    to get into the patch menu, as we saw previously, but first we have to choose
    which files to add patches for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Once we have chosen the files, we want to add patches so they get a `*` character
    in the menu. To begin patching, just click on `<return>`. When you're done, you'll
    return to the menu and can quit, review, revert, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive add with Git gui
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The interactive features of `git add` are really powerful for creating clean
    commits that only contain a single logical change, even though it was coded as
    a mix of feature adding and bug fixing. The downside of the interactive `git add`
    feature is that it is hard to get an overview of all the changes that exist in
    the file when only being showed one hunk at a time. To get a better overview of
    the changes and still be able to only add selected hunks (and even single lines),
    we can use `git gui`. Git GUI is normally distributed with the Git installation
    (MsysGit on Windows) and can be launched from the command line: `git gui`. If
    your distribution doesn''t have Git GUI available, you can probably install it
    from the package manager called `git-gui`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same repository as in the last example and reset it to the same
    state so that we can perform the same adds with Git GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load Git GUI in the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks`
    repository. Here, you can see the unstaged changes (files) at the top-left and
    the staged changes (files) underneath. The main window will display the unstaged
    changes in the current marked file. You can right-click on a hunk and see a context
    menu with options for staging and so on. The first hunk shown by Git GUI is much
    larger than what we saw before with `git add -p`. Choose Show Less Context to
    split the hunk, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55c0e5df-e123-4224-aaa7-63201d610cb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we get a smaller hunk like before, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e6d22e8-3fd6-4ea9-af5f-a53ecb20cee0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the first hunk, we just choose to add Stage Hunk For Commit, and the next
    hunk moves to the top of the screen, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96088c69-0258-4cc8-9e54-478d70566145.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can select the lines we want to add, instead of performing another
    split, and stage those lines: Stage Lines For Commit. We can add the rest of the
    hunks except the one with the debug line. Now, we are ready to create a commit
    and we can do so from the Git GUI. We can just write the commit message in the
    field at the bottom of the screen and hit Commit, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0d83a40-b60e-41ab-b619-bdda1bde49f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Ignoring files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For every repository, there are usually certain types of files you don't want
    tracked in the repository. The files can be configuration files, build output,
    or just backup files created by the editor when editing the file. To avoid these
    files showing up in the untracked files section of the `git status` output, it's
    possible to add them to a file called `.gitignore`. Entries in this file that
    match files in the working directory will not be considered by `git status`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clone the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` repository
    and check out the `ignore` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll create some files and directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the output of `git status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the `test.txt` file showed up in the output. This is because the rest
    of the files are ignored by Git. We can check the content of `.gitignore` to see
    how this happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This means that `*.bak`, `*.class`, `*.config`, and everything in the `bin`
    directory are being ignored by Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to add files in a path ignored by Git, for example `bin`, it will
    complain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'But, it also gives us the option to use `-f` if we really want to add it, which
    is `-f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ignore the `foo` file, which is already tracked, and modify it, it still
    shows up in the status, since tracked files are not ignored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add and commit `foo`, `.gitignore`, and the contents of the current
    staging area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s also possible to ignore files of a repository without the `.gitignore`
    files. You can put your ignored files in a global ignore file, for example `~/.gitignore_global`, and
    globally configure Git to also consider entries in this file to be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also do it per repository in the `.git/info/exclude` file. If you use
    either of these options, you won''t be able to easily share the ignored file;
    they can''t be added to the repository as they are stored outside it. Sharing `.gitignore`
    files is much easier; you just add and commit them to Git. But, let''s see how
    the other options work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `.test` file didn't show up in the `status` output and that
    the ignored files exist in the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wide range of files are commonly ignored, for example, to avoid accidentally
    adding text editor backup files, `*.swp`, `*~.`, and `*.bak` are commonly ignored.
    If you are working on a Java project, you might add `*.class`, `*.jar`, and `*.war`
    to your `.gitignore` and `*.o`, `*.elf`, and `*.lib` if you are working on a C
    project. GitHub has a repository dedicated to collect Git ignore files for different
    programming languages and editors/IDEs. You can find it at: [https://github.com/github/gitignore](https://github.com/github/gitignore).
  prefs: []
  type: TYPE_NORMAL
- en: Showing and cleaning ignored files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ignoring files is useful for filtering noise from the output of `git status`.
    But sometimes, it's necessary to check which files are ignored. This example will
    show you how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll continue in the repository from the last example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To show the files we have ignored, we can use the `clean` command. Normally,
    the `clean` command will remove the untracked files from the working directory,
    but it is possible to run this in dry-run mode, `-n`, which just shows what would
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The options used in the preceding command specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-n`, `--dry-run`: Only lists what will be removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-X`: Removes only the files ignored by Git'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: Removes the untracked directories in addition to the untracked files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ignored files can also be listed with the `ls-files` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Where the `-o` option, `--others`, shows the untracked files, the `-i` option, `--ignored`,
    shows only the ignored files, and `--exclude-standard` uses the standard exclusion
    files `.git/info/exclude` and `.gitignore` in each directory, and the user's global
    exclusion file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need to remove the ignored files, we can of course use `git clean` to
    do this; instead of the dry-run option, we pass the force option, `-f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: To remove all the untracked files and not just the ignored files, use `git clean
    -xfd`. The lowercase `x` means we don't use the ignore rules, we just remove everything
    that is not tracked by Git.
  prefs: []
  type: TYPE_NORMAL
