<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Running Kubernetes Cluster Locally</h1>
                </header>
            
            <article>
                
<p>One of my goals in this book is to limit the learning expense to a minimum. True to that spirit, we'll run local Kubernetes clusters for as long as possible. At one point we'll have to switch to a hosted, multi-node Kubernetes cluster. I'll do my best to postpone that for as long as possible without limiting your learning experience. For now, we'll create a local Kubernetes cluster on your laptop.</p>
<p>There are quite a few ways to set up a local Kubernetes cluster. We could, for example, create a few nodes with Vagrant (<a href="https://www.vagrantup.com/" target="_blank"><span class="URLPACKT">https://www.vagrantup.com/</span></a>) and execute quite a few shell commands that would convert them into a Kubernetes cluster. We could go even further and create a VirtualBox image that would have all the required software pre-installed and use it to create Vagrant VMs. We could also use Ansible to run provisioning of those images as well as to execute all the commands required to join VMs into a cluster. There are many other things that we could do, but we won't.</p>
<p>At this point, the idea is not to teach you all the intricacies of setting up a Kubernetes cluster. Instead, I want to get you up to speed as fast as possible and let you experience Kubernetes without sidelining that experience with installation details.</p>
<p>If the subject of this book would be Docker Swarm (as it was in <em>The DevOps 2.1 Toolkit: Docker Swarm</em>), we'd have Docker for Mac or Windows (or run it natively on Linux) and execute a single <kbd>docker swarm init</kbd> command. That's all that's needed to create a local Docker Swarm cluster. Can we accomplish the same simplicity with Kubernetes?</p>
<p>In October of 2017, Docker announced initial support for Kubernetes in Docker for Mac and Windows. At the time of this writing, it is available only for Mac in the edge channel.</p>
<p>Minikube creates a single-node cluster inside a VM on your laptop. While that is not ideal since we won't be able to demonstrate some of the features Kubernetes provides in a multi-node setup, it should be more than enough to explain most of the concepts behind Kubernetes. Later on, we'll move into a more production-like environment and explore the features that cannot be demonstrated in Minikube.</p>
<div class="packt_infobox"><span class="packt_screen">A note to Windows users<br/></span>Please run all the examples from <em>GitBash</em> (installed through <em>Git</em>). That way the commands you'll see throughout the book will be same as those that should be executed on <em>MacOS</em> or any <em>Linux</em> distribution. If you're using Hyper-V instead of VirtualBox, you may need to run the <em>GitBash</em> window as an Administrator.</div>
<p>Before we dive into Minikube installation, there are a few prerequisites we should set up. The first in line is <kbd>kubectl</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing kubectl</h1>
                </header>
            
            <article>
                
<p>Kubernetes' command-line tool, <kbd>kubectl</kbd>, is used to manage a cluster and applications running inside it. We'll use <kbd>kubectl</kbd> a lot throughout the book, so we won't go into details just yet. Instead, we'll discuss its commands through examples that will follow shortly. For now, think of it as your interlocutor with a Kubernetes cluster.</p>
<p>Let's install <kbd>kubectl</kbd>.</p>
<div class="packt_infobox">All the commands from this chapter are available in the <kbd>02-minikube.sh</kbd> (<a href="https://gist.github.com/vfarcic/77ca05f4d16125b5a5a5dc30a1ade7fc" target="_blank"><span class="URLPACKT">https://gist.github.com/vfarcic/77ca05f4d16125b5a5a5dc30a1ade7fc</span></a>) Gist.</div>
<div class="packt_tip">Feel free to skip the installation steps if you already have <kbd>kubectl</kbd>. Just make sure that it is version 1.8 or above.</div>
<p>If you are a <strong>MacOS user</strong>, please execute the commands that follows:</p>
<pre><strong>curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/darwin/amd64/kubectl</strong>
    
<strong>chmod +x ./kubectl</strong>
    
<strong>sudo mv ./kubectl /usr/local/bin/kubectl</strong>  </pre>
<p>If you already have Homebrew (<a href="https://brew.sh/" target="_blank"><span class="URLPACKT">https://brew.sh/</span></a>) package manager installed, you can "brew" it with the command that follows:</p>
<pre><strong>brew install kubectl</strong>  </pre>
<p>If, on the other hand, you're a <strong>Linux user</strong>, the commands that will install <kbd>kubectl</kbd> are as follows:</p>
<pre><strong>curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s <br/> https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</strong>
    
<strong>chmod +x ./kubectl</strong>
    
<strong>sudo mv ./kubectl /usr/local/bin/kubectl</strong>  </pre>
<p>Finally, <strong>Windows users</strong> should download the binary through the command that follows.</p>
<pre><strong>curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/windows/amd64/kubectl.exe</strong>
  </pre>
<p>Feel free to copy the binary to any directory. The important thing is to add it to your <kbd>PATH</kbd>.</p>
<p>Let's check <kbd>kubectl</kbd> version and, at the same time, validate that it is working correctly. No matter which OS you're using, the command is as follows:</p>
<pre><strong>kubectl version</strong></pre>
<p>The output is as follows:</p>
<pre><strong>Client Version: version.Info{Major:"1", Minor:"9", GitVersion:"v1.9.0", <br/>GitCommit:"925c127ec6b946659ad0fd596fa959be43f0cc05", <br/>GitTreeState:"clean", BuildDate:"2017-12-15T21:07:38Z", GoVersion:"go1.9.2", <br/>Compiler:"gc", Platform:"darwin/amd64"}</strong>  </pre>
<p>The connection to the server <kbd>localhost:8080</kbd> was refused-did you specify the right host or port?</p>
<p>That is a very ugly and unreadable output. Fortunately, <kbd>kubectl</kbd> can use a few different formats for its output. For example, we can tell it to output the command in <kbd>yaml</kbd> format</p>
<pre><strong>kubectl version --output=yaml<br/></strong></pre>
<p class="mce-root">The output is as follows:</p>
<pre class="mce-root"><strong>clientVersion:
  buildDate: 2017-12-15T21:07:38Z
  compiler: gc
  gitCommit: 925c127ec6b946659ad0fd596fa959be43f0cc05
  gitTreeState: clean
  gitVersion: v1.9.0
  goVersion: go1.9.2
  major: "1"
  minor: "9"
  platform: darwin/amd64
    
The connection to the server localhost:8080 was refused - did you specify the right host or port?
  </strong></pre>
<p>That was a much better (more readable) output.</p>
<p>We can see that the client version is 1.9. At the bottom is the error message stating that <kbd>kubectl</kbd> could not connect to the server. That is expected since we did not yet create a cluster. That's our next step.</p>
<div class="packt_infobox">At the time of writing this book kubectl version was 1.9.0. Your version might be different when you install.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Minikube</h1>
                </header>
            
            <article>
                
<p>Minikube supports several virtualization technologies. We'll use VirtualBox throughout the book since it is the only virtualization supported in all operating systems. If you do not have it already, please head to the <span class="packt_screen">Download VirtualBox</span> (<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank"><span class="URLPACKT">https://www.virtualbox.org/wiki/Downloads</span></a>) page and get the version that matches your OS. Please keep in mind that for VirtualBox or HyperV to work, virtualization must be enabled in the BIOS. Most laptops should have it enabled by default.</p>
<p>Finally, we can install Minikube.</p>
<p>If you're using <strong>MacOS</strong>, please execute the command that follows:</p>
<pre><strong>brew cask install minikube</strong>  </pre>
<p>If, on the other hand, you prefer <strong>Linux</strong>, the command is as follows:</p>
<pre><strong>curl -Lo minikube </strong>
<strong>https://storage.googleapis.com/minikube/releases/latest/minikube-"linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube "/usr/local/bin/</strong></pre>
<p>Finally, you will not get a command if you are a Windows user. Instead, download the latest release from of the <kbd>minikube-windows-amd64.exe</kbd> (<a href="https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe" target="_blank"><span class="URLPACKT">https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe</span></a>) file, rename it to <kbd>minikube.exe</kbd>, and add it to your path.</p>
<p>We'll test whether Minikube works by checking its version.</p>
<pre><strong>minikube version</strong>  </pre>
<p>The output is as follows:</p>
<pre><strong>minikube version: v0.23.0</strong> </pre>
<p>Now we're ready to give the cluster a spin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a local Kubernetes cluster with Minikube</h1>
                </header>
            
            <article>
                
<p>The folks behind Minikube made creating a cluster as easy as it can get. All we need to do is to execute a single command. Minikube will start a virtual machine locally and deploy the necessary Kubernetes components into it. The VM will get configured with Docker and Kubernetes via a single binary called localkube.</p>
<pre><strong>minikube start --vm-driver=virtualbox</strong>  </pre>
<div class="packt_infobox"><span class="OtherTok"><span class="packt_screen">A note to Windows users</span><br/></span>You might experience problems with <kbd>virtualbox</kbd>. If that's the case, you might want to use <kbd>hyperv</kbd> instead. Open a Powershell Admin Window and execute the <kbd>Get-NetAdapter</kbd> command, noting the name of your network connection. Create a <kbd>hyperv</kbd> virtual switch <kbd>New-VMSwitch -name NonDockerSwitch -NetAdapterName Ethernet -AllowManagementOS $true</kbd> replacing <kbd>Ethernet</kbd> with your network connection name. Then create the Minikube vm: <kbd>minikube start --vm-driver=hyperv --hyperv-virtual-switch "NonDockerSwitch" --memory=4096</kbd>. Other minikube commands such as <kbd>minikube start</kbd>, <kbd>minikube stop</kbd>, and <kbd>minikube delete</kbd> all work the same whether you're using VirutalBox or Hyper-V.</div>
<p>A few moments later, a new Minikube VM will be created and set up, and a cluster will be ready for use.</p>
<p>When we executed the <kbd>minikube start</kbd> command, it created a new VM based on the Minikube image. That image contains a few binaries. It has both <kbd>Docker</kbd> (<a href="https://www.docker.com/" target="_blank"><span class="URLPACKT">https://www.docker.com/</span></a>) and <kbd>rkt</kbd> (<a href="https://coreos.com/rkt/" target="_blank"><span class="URLPACKT">https://coreos.com/rkt/</span></a>) container engines as well as <kbd>localkube</kbd> library. The library includes all the components necessary for running Kubernetes. We'll go into details of all those components later. For now, the important thing is that localkube provides everything we need to run a Kubernetes cluster locally.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7bc69942-e243-4ced-bcaf-5df7d15beec7.png" style="width:19.92em;height:17.08em;"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 2-1: Minikube simplified architecture</div>
<p>Remember that this is a single-node cluster. While that is unfortunate, it is still the easiest way (as far as I know) to "play" with Kubernetes locally. It should do, for now. Later on, we'll explore ways to create a multi-node cluster that will be much closer to a production setup.</p>
<p>Let's take a look at the status of the cluster:</p>
<pre><strong>minikube status</strong>  </pre>
<p>The output is as follows:</p>
<pre><strong>minikube: Running</strong>
<strong>cluster: Running</strong>
<strong>kubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100</strong> </pre>
<p>Minikube is running, and it initialized a Kubernetes cluster. It even configured <kbd>kubectl</kbd> so that it points to the newly created VM.</p>
<p>You won't see much UI in this book. I believe that a terminal is the best way to operate a cluster. More importantly, I am convinced that one should master a tool through its commands first. Later on, once we feel comfortable and understand how the tool works, we can choose to use a UI on top of it. We'll explore the Kubernetes UI in one of the later chapters. For now, I'll let you have a quick glimpse of it.</p>
<pre><strong>minikube dashboard</strong>  </pre>
<p>Feel free to explore the UI but don't take too long. You'll only get confused with concepts that we did not yet study. Once we learn about pods, replica-sets, services, and a myriad of other Kubernetes components, the UI will start making much more sense.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/312187e1-b120-4562-a13d-8c8d76f4b4a3.png" style="width:81.33em;height:44.50em;"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 2-2: Kubernetes dashboard</div>
<p>Another useful Minikube command is <kbd>docker-env</kbd>.</p>
<pre><strong>minikube docker-env</strong>  </pre>
<p>The output is as follows:</p>
<pre><strong>export DOCKER_TLS_VERIFY="1"</strong>
<strong>export DOCKER_HOST="tcp://192.168.99.100:2376"</strong>
<strong>export DOCKER_CERT_PATH="/Users/vfarcic/.minikube/certs"</strong>
<strong>export DOCKER_API_VERSION="1.23"</strong>
<strong># Run this command to configure your shell:</strong>
<strong># eval $(minikube docker-env)</strong>  </pre>
<p>If you worked with Docker Machine, you'll notice that the output is the same. Both <kbd>docker-machine env</kbd> and <kbd>minikube docker-env</kbd> serve the same purpose. They output the environment variables required for a local Docker client to communicate with a remote Docker server. In this case, that Docker server is the one inside a VM created by Minikube. I assume that you already have Docker installed on your laptop. If that's not the case, please go to the install Docker (<a href="https://docs.docker.com/install/" target="_blank"><span class="URLPACKT">https://docs.docker.com/install/</span></a>) page and follow the instructions for your operating system. Once Docker is installed, we can connect the client running on your laptop with the server in the Minikube VM.</p>
<pre><strong>eval $(minikube docker-env)</strong>  </pre>
<p>We evaluated (created) the environment variables provided through the <kbd>minikube docker-env</kbd> command. As a result, every command we send to our local Docker client will be executed on the Minikube VM. We can test that easily by, for example, listing all the running containers on that VM.</p>
<pre><strong>docker container ls</strong>  </pre>
<p>The containers listed in the output are those required by Kubernetes. We can, in a way, consider them system containers. We won't discuss each of them. As a matter of fact, we won't discuss any of them. At least, not right away. All you need to know, at this point, is that they make Kubernetes work.</p>
<p>Since almost everything in that VM is a container, pointing the local Docker client to the service inside it should be all you need (besides <kbd>kubectl</kbd>). Still, in some cases, you might want to SSH into the VM.</p>
<pre><strong>minikube ssh</strong>
    
<strong>docker container ls</strong>
    
<strong>exit</strong>  </pre>
<p>We entered into the Minikube VM, listed containers, and got out. There's no reason to do anything else beyond showing that SSH is possible, even though you probably won't use it.</p>
<p>What else is there to verify? We can, for example, confirm that <kbd>kubectl</kbd> is also pointing to the Minikube VM.</p>
<pre><strong>kubectl config current-context</strong>  </pre>
<p>The output should be a single word, <kbd>minikube</kbd>, indicating that <kbd>kubectl</kbd> is configured to talk to Kubernetes inside the newly created cluster.</p>
<p>As an additional verification, we can list all the nodes of the cluster.</p>
<pre><strong>kubectl get nodes</strong>  </pre>
<p>The output is as follows:</p>
<pre><strong>NAME     STATUS ROLES  AGE VERSION</strong>
<strong>minikube Ready  &lt;none&gt; 31m v1.8.0</strong>  </pre>
<p>It should come as no surprise that there is only one node, conveniently called <kbd>minikube</kbd>.</p>
<p>If you are experienced with Docker Machine or Vagrant, you probably noticed the similar pattern. Minikube commands are almost exactly the same as those from Docker Machine which, on the other hand, are similar to those from Vagrant.</p>
<p>Let's make a sneak peek into the components currently running in our tiny cluster.</p>
<pre><strong>kubectl get all --all-namespaces</strong></pre>
<p>Behold, the cluster in all its glory. It's made out of many building blocks we are yet to explore. Moreover, those are only the beginning. We'll be adding more as our needs and knowledge increase. For now, remember that there are many moving pieces. We won't go into details just yet. That would be too much to start with.</p>
<p>Going back to minikube, we can do all the common things we would expect from a virtual machine. For example, we can stop it.</p>
<pre><strong>minikube stop</strong>  </pre>
<p>We can start it again.</p>
<pre><strong>minikube start</strong>  </pre>
<p>We can delete it.</p>
<pre><strong>minikube delete</strong>  </pre>
<p>One interesting feature is the ability to specify which Kubernetes version we'd like to use.</p>
<p>Since Kubernetes is still a young project, we can expect quite a lot of changes at a rapid pace. That will often mean that our production cluster might not be running the latest version. On the other hand, we should strive to have our local environment as close to production as possible (within reason).</p>
<p>We can list all the available versions with the command that follows:</p>
<pre><strong>minikube get-k8s-versions</strong>  </pre>
<p>The output, limited to the first few lines, is as follows:</p>
<pre><strong><span class="VerbatimChar">The following Kubernetes versions are available:<br/></span>        - v1.9.0
        - v1.8.0
        - v1.7.5
        - v1.7.4
        - v1.7.3
        - v1.7.2
        - v1.7.0
        ...</strong></pre>
<p>Now that we know which versions are available, we can create a new cluster based on, let's say, Kubernetes v1.7.0.</p>
<pre><strong>minikube start \</strong>
<strong>    --vm-driver=virtualbox \</strong>
<strong>    --kubernetes-version="v1.7.0"</strong>
    
<strong>kubectl version --output=yaml</strong>  </pre>
<p>We created a new cluster and output versions of the client and the server.</p>
<p>The output of the latter command is as follows:</p>
<pre><strong>clientVersion:</strong>
  <strong>buildDate: 2017-10-24T19:48:57Z</strong>
  <strong>compiler: gc</strong>
  <strong>gitCommit: bdaeafa71f6c7c04636251031f93464384d54963</strong>
  <strong>gitTreeState: clean</strong>
  <strong>gitVersion: v1.8.2</strong>
  <strong>goVersion: go1.8.3</strong>
  <strong>major: "1"</strong>
  <strong>minor: "8"</strong>
  <strong>platform: darwin/amd64</strong>
<strong>serverVersion:</strong>
  <strong>buildDate: 2017-10-04T09:25:40Z</strong>
  <strong>compiler: gc</strong>
  <strong>gitCommit: d3ada0119e776222f11ec7945e6d860061339aad</strong>
  <strong>gitTreeState: dirty</strong>
  <strong>gitVersion: v1.7.0</strong>
  <strong>goVersion: go1.8.3</strong>
  <strong>major: "1"</strong>
  <strong>minor: "7"</strong>
  <strong>platform: linux/amd64</strong></pre>
<p>If you focus on the <kbd>serverVersion</kbd> section, you'll notice that the <kbd>major</kbd> version is <kbd>1</kbd> and the <kbd>minor</kbd> is <kbd>7</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What now?</h1>
                </header>
            
            <article>
                
<p>We are finished with a short introduction to Minikube. Actually, this might be called a long introduction as well. We use it to create a single-node Kubernetes cluster, launch the UI, do common VM operations like <kbd>stop</kbd>, <kbd>restart</kbd>, and <kbd>delete</kbd>, and so on. There's not much more to it. If you are familiar with Vagrant or Docker Machine, the principle is the same, and the commands are very similar.</p>
<p>Before we leave, we'll destroy the cluster. The next chapter will start fresh. That way, you can execute commands from any chapter at any time.</p>
<pre><strong>minikube delete</strong>  </pre>
<p>That's it. The cluster is no more.</p>


            </article>

            
        </section>
    </body></html>