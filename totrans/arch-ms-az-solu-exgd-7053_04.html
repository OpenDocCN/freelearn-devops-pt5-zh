<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing Serverless and Microservices</h1>
                </header>
            
            <article>
                
<p><span>In the previous chapter, we covered the </span><span>objective of </span><span>web applications. You read about web applications, App Service plans, containers, Web APIs, and more. You should now be aware of when to use these different features.</span></p>
<p>This chapter introduces serverless and m<span>icroservices. It will cover serverless computing and what Azure has to offer regarding the creation of serverless applications, such as Azure Functions and Azure Logic Apps. You will read about how to design for serverless computing using Azure Containers and API Management. Finally, microservices-based solutions are covered. You will learn about containers for microservices and the different platforms that are available.</span></p>
<p>The following topics will be covered:</p>
<ul>
<li><span>Event-driven actions using </span><span>Azure Functions</span></li>
<li><span>Designing applications using Azure Functions and Logic Apps</span></li>
<li><span>Designing for serverless computing using Azure Container Instances</span></li>
<li>Container orchestrations and the d<span>ifferent container orchestration platforms</span></li>
<li>Azure Service Fabric</li>
<li>API Management</li>
<li>Cloud-native deployments versus migrating assets</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter uses the following tools for the examples:</p>
<ul>
<li>Azure PowerShell: <a href="https://docs.microsoft.com/en-us/powershell/azure/install-azurerm-ps?view=azurermps-5.1.1">https://docs.microsoft.com/en-us/powershell/azure/install-azurerm-ps?view=azurermps-5.1.1</a></li>
</ul>
<p>The source code for this chapter can be downloaded from here:</p>
<ul>
<li><a href="https://github.com/SjoukjeZaal/AzureArchitectureBook/tree/master/Chapter%204">https://github.com/SjoukjeZaal/AzureArchitectureBook/tree/master/Chapter%204</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Event-driven actions using Azure Functions</h1>
                </header>
            
            <article>
                
<p>Azure Functions is a serverless compute service that enables you to create event-driven actions and triggers without the need to provision or manage your own infrastructure. In Azure Functions, you can run a script or custom code that responds to events from Azure, third-party services, or on-premises systems. <span>You can build HTTP-based API endpoints (called HTTP triggers) that can be accessed by a wide range of applications, as well as mobile and IoT devices. You can also create <strong>timer triggers</strong>, which can run based on a schedule. With Azure Functions, you pay only for the resources you consume.</span></p>
<p>Functions use an Azure storage account to store code and configuration bindings. It uses the standard Azure Storage, which provides blob, table, and queue storage for storing the files and triggers. You can use the same App Service plans for your functions as you use for web apps and APIs. Azure Functions can also be deployed in <strong>App Service Environments</strong> (<strong>ASEs</strong>).</p>
<div class="packt_infobox">For more information about Azure Functions and which events and triggers it supports, you can refer to the following site: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview">https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview</a>. <br/>
For more information about the different App Service plans and ASEs, you can refer to <a href="de2f1b21-edb1-4616-a8ff-8fbf484459a0.xhtml" target="_blank">Chapter 3</a>, <em>Designing Web Applications</em>.</div>
<p>Azure Functions can be created from the Azure Portal and from Visual Studio 2017 and can be created in a variety of programming languages, such as <span>C#, F#, Node.js, Java, PHP, Batch, PowerShell, JavaScript, Python, and TypeScript. They can be created using ARM templates as well. They can be deployed on Windows or Linux and by using </span><span>continuous deployment. At the time of writing this book, it supports Bitbucket, Dropbox, external repositories (Git or Mercurial), a Git local repository, GitHub, OneDrive, and Visual Studio Team Services as a deployment source. Continuous deployment can be configured from the Azure Portal.</span><span><br/></span></p>
<div class="CDPAlignCenter CDPAlign"><span><img src="Images/5de12eaf-3a26-4d5b-889f-4d981dcf515e.jpg" style="width:50.08em;height:28.67em;" width="2736" height="1562"/><br/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Continuous deployment for Azure Functions</span></div>
<div class="packt_infobox"><span>The Azure Functions tools in Visual Studio have been included since the 15.3 release. If you want to create them using Visual Studio 2017, update Visual Studio to at least version 15.3 or higher.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Consumption App Service plan</h1>
                </header>
            
            <article>
                
<p>For Azure Functions, Microsoft introduced a new hosting plan where you share a pool of instances with functions from other customers. This plan is called the <strong>Consumption plan</strong>. This plan is more cost effective then the other available App Service plans because it automatically scales down and up, depending on the workload. When your function isn't running, you don't have to pay anything and when the function is running, instances are added dynamically and removed based on the number of incoming events. Functions hosted on the Consumption plan can run for a maximum of 10 minutes (the default timeout is 5 minutes, but this can be increased to 10 <span>minutes</span>). The Azure Function code and the binding configurations are stored on Azure File Storage on a separate storage account.</p>
<p>When you need your function to run continuously, or for it to run in the same App Service plan as other functions, or you need more CPU power, or you want to host your function on Linux, then it is best to use a dedicated App Service plan for your functions. All the other available App Service plans can be used for Azure Functions as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing application solutions using Azure Functions</h1>
                </header>
            
            <article>
                
<p>In this demo, we are creating an Azure Function from the Azure Portal. This function is going to listen to an HTTP trigger and then add a message to a queue:</p>
<ol>
<li>Navigate to the Azure Portal by opening <a href="https://portal.azure.com/">https://portal.azure.com/</a>.</li>
<li>Click on <span class="packt_screen">New</span><span> </span>and and type <kbd>Function App</kbd> in the search bar. Click the <span class="packt_screen">Create</span> button.</li>
<li>A new blade <span>opens up, where you can fill in the basic settings of the function. For the hosting plan, we are using a queue to store messages. When using the Consumption plan, queue storage is not part of your storage account, because it only uses Azure File Storage to store the function files. For the App Service plan, you can create a new App Service plan or pick an existing one. You can choose an ASE here as well. For the</span> storage<span>, by default, a new storage account is created. If you want to use an existing storage account, you can choose that as well. </span><span>Add the following details and click on <span class="packt_screen">Create</span>:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/8f02aab3-b11f-4606-8b68-2e8cf231d3a8.jpg" style="width:21.92em;height:50.50em;" width="622" height="1435"/><br/>
<br/>
<span>Creating an Azure Function from the Azure Portal</span></div>
<ol start="4">
<li>Once created, open the function from the Azure Portal and, in the left-hand menu, under <span class="packt_screen">Function Apps</span>, select <span class="packt_screen">Functions</span> | <span class="packt_screen">New function</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/22bd157f-d91c-4f40-9280-35ff67dce9ed.png" style="width:58.25em;height:24.50em;" width="1102" height="464"/></div>
<div style="color: black" class="CDPAlignCenter CDPAlign packt_figref">Azure Functions wizard from the Azure Portal</div>
<ol start="5">
<li>On the next screen, select <span class="packt_screen">HTTP trigger</span>:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/765be821-8502-44a7-a226-0a34dc34e7f3.png" style="width:58.17em;height:43.08em;" width="1081" height="801"/></div>
<div style="color: black" class="CDPAlignCenter CDPAlign packt_figref">Selecting the HTTP trigger</div>
<ol start="6">
<li class="mce-root"><span>The next step is the <span class="packt_screen">HTTP trigger</span> settings. Fill in the following values. For the</span> <span class="packt_screen">Authorization level</span><span>, you can choose <span class="packt_screen">Anonymous</span> right now. However, this is only for demo purposes; you should not choose that for your production functions.</span> Click on <span class="packt_screen">Create</span> and the trigger is created:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;color: black;font-size: 1em;width:22.17em;height:45.00em;" class="alignnone size-full wp-image-424 image-border" src="Images/fb84923d-4f63-490e-90fa-aacf42e651fd.png" width="539" height="1095"/><span><br/></span></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span>HTTP trigger settings</span></div>
<ol start="7">
<li>To configure the queue settings, click on <span class="packt_screen">Integrate</span> | <span class="packt_screen">New Output</span> and then select <span class="packt_screen">Azure Queue Storage</span>. Click on <span class="packt_screen">Select</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d4a7f0fa-79f2-48cc-affd-b9cc0fd1cd2f.jpg" style="width:60.17em;height:38.08em;" width="2275" height="1439"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span><span>Configure queue</span></span></div>
<ol start="8">
<li>Under <span class="packt_screen">Azure Queue Storage output</span>, keep the default settings and click on <span class="packt_screen">Save</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-425 image-border" src="Images/8d74b84a-afab-47cf-a069-68c8c3c55eb0.png" style="width:58.17em;height:36.00em;" width="1191" height="738"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Configure queue</span></div>
<ol start="9">
<li>In the left-hand menu, select your function. The code editor will open. Replace the code with the following:</li>
</ol>
<pre style="padding-left: 60px">using System.Net;<br/><br/>public static async Task&lt;HttpResponseMessage&gt; Run(HttpRequestMessage req, ICollector&lt;string&gt; outputQueueItem, TraceWriter log)<br/>{<br/>    log.Info("C# HTTP trigger function processed a request.");<br/>      <br/>    // parse query parameter<br/>    string name = req.GetQueryNameValuePairs()<br/>        .FirstOrDefault(q =&gt; string.Compare(q.Key, "name", true) == 0)<br/>        .Value;<br/><br/>    // Get request body<br/>    dynamic data = await req.Content.ReadAsAsync&lt;object&gt;();<br/><br/>    // Set name to query string or body data<br/>    name = name ?? data?.name;<br/><br/>    outputQueueItem.Add("Name passed to the function: " + name); <br/><br/>    return name == null<br/>        ? req.CreateResponse(HttpStatusCode.BadRequest, "Please pass a name on the query string or in the request body")<br/>        : req.CreateResponse(HttpStatusCode.OK, "Hello " + name);<br/>}</pre>
<ol start="10">
<li>The preceding code adds a message inside the queue and then you need to click on <span class="packt_screen">Save</span>:</li>
</ol>
<ol start="11">
<li>To test the code, click the <span class="packt_screen">Test</span> tab on the right-hand side of the screen. You can provide a message inside the JSON call and click on <span class="packt_screen">Save and run</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><span><img src="Images/09dc3fd5-8780-49b1-ac74-5faf6fae7d8d.jpg" style="width:46.67em;height:30.58em;" width="2110" height="1381"/><br/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span><span>Testing the function</span></span></div>
<ol start="12">
<li>The default code generates an output message, which is displayed inside the output window. To see what is added to the queue, open the <span class="packt_screen">Azure Storage Explorer</span> and connect to your Azure account using your credentials. In the left-hand tree view, navigate to the function storage account and click on <span class="packt_screen">Queues</span>. The added message can be found there:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><span><img src="Images/9798bf78-5bfa-4905-9843-e4fe2527c72f.jpg" style="width:48.17em;height:37.25em;" width="1982" height="1529"/><br/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Queue message inside the Azure Storage Explorer</span></div>
<div class="packt_tip">The Azure Storage Explorer is part of the Azure Tools for Visual Studio. You can view blob, queue, and table data from your storage accounts in Azure. You can also download the Azure Storage Explorer from this direct link: <a href="https://go.microsoft.com/fwlink/?LinkId=708343&amp;clcid=0x409">https://go.microsoft.com/fwlink/?LinkId=708343&amp;clcid=0x409</a>. </div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Durable Functions</h1>
                </header>
            
            <article>
                
<p>At the time of writing this book, Durable Functions is still in preview. Durable Functions is an extension of Azure Functions and Azure WebJobs, and it provides the ability to create stateful functions with state management capabilities, checkpoints, and a restarting mechanism.</p>
<p>It introduces a new orchestrator function that has a couple of advantages. These are as follows:</p>
<ul>
<li>Workflows can be created in code; JSON schemas are not needed.</li>
<li>It can call other functions s<span>ynchronously and asynchronously. The output can be stored in local variables.</span></li>
<li>It saves the state of the function when VMs are waiting and rebooting. </li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Workflow-driven applications using Logic Apps</h1>
                </header>
            
            <article>
                
<p>Logic Apps, another service for the serverless offering from Azure, has a lot of overlap with Azure Functions. They can both be used to integrate apps or services. The main difference between the two is that Azure Functions are event-driven and Logic Apps are more workflow-driven. You can use Logic Apps to automate your business processes using a visual designer from the Azure Portal (developers can create them in Visual Studio as well), whereas Azure Functions are completely written in code. You can, however, call Azure Functions from within a Logic App. </p>
<p>With Logic Apps, you can build apps that integrate numerous cloud services and on-premises applications. These can be Azure services, third-party cloud services, different data stores and databases, and LOB applications. Azure Logic Apps provide a number of pre-built connectors that you leverage inside your workflow. Besides that, you can also create your own connectors using Visual Studio. Each connector provides an API, which can be called from inside the Logic App. Authentication is added to this connector as well.</p>
<div class="packt_infobox">You can refer to the following article for an overview of all the available connectors for Azure Logic Apps: <a href="https://docs.microsoft.com/en-us/azure/connectors/apis-list">https://docs.microsoft.com/en-us/azure/connectors/apis-list</a>.</div>
<p><span>Besides using the Visual Editor, you can create and make adjustments to the Workflow Definition Language schema manually as well. This schema is created using JSON and can be created from scratch using Visual Studio or can be adjusted inside the Azure Portal. They both use the Code View editor (Visual Studio uses the same editor as the Azure Portal).<br/>
Some capabilities can only be added to the schema directly and cannot be made from the Visual Editor. Examples of this are date and time formatting and string concatenation. Logic App definition files can be added to ARM templates and deployed using PowerShell, CLI, or REST APIs.</span></p>
<p><span>Here is an example of the JSON code-behind file:</span></p>
<pre>{<br/>  "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",<br/>  "contentVersion": "1.0.0.0",<br/>  "parameters": {<br/>    "order": {<br/>      "defaultValue": {<br/>        "quantity": 10,<br/>        "id": "mycustomer-id"<br/>      },<br/>      "type": "Object"<br/>    }<br/>  },<br/>  "triggers": {<br/>    "Request": {<br/>      "type": "request",<br/>      "kind": "http"<br/>    }<br/>  },<br/>  "actions": {<br/>    "order": {<br/>      "type": "Http",<br/>      "inputs": {<br/>        "method": "GET",<br/>        "uri": "http://www.packt.com/?id=@{parameters('customer').id}"<br/>      }<br/>    },<br/>    "ifTimingWarning": {<br/>      "type": "If",<br/>      "expression": "@less(actions('customer').startTime,addseconds(utcNow(),-1))",<br/>      "actions": {<br/>        "timingWarning": {<br/>          "type": "Http",<br/>          "inputs": {<br/>            "method": "GET",<br/>            "uri": "http://www.packt.com/?recordLongOrderTime=@{parameters('customer').id}&amp;currentTime=@{utcNow('r')}"<br/>          }<br/>        }<br/>      },<br/>      "runAfter": {<br/>        "order": [<br/>          "Succeeded"<br/>        ]<br/>      }<br/>    }<br/>  },<br/>  "outputs": {}<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing application solutions using Logic Apps</h1>
                </header>
            
            <article>
                
<p><span>In this demo, we are creating the same functionality as we did in the previous Azure Function demo. We are adding a message to a queue. This way, you can see the difference between an event-driven approach and a workflow-driven approach. The steps are as follows:</span></p>
<ol>
<li>Navigate to the Azure Portal by opening <a href="https://portal.azure.com/">https://portal.azure.com/</a>.</li>
<li>Click on <span class="packt_screen">New</span><span> </span>and and type <kbd>Logic App</kbd> in the search bar. Click on the<span> </span><span class="packt_screen">Create</span><span> </span>button.</li>
</ol>
<ol start="3">
<li><span>A new blade </span>opens up where you can fill in the basic settings of the Logic App. Add the following and click on <span class="packt_screen">Create</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-426 image-border" src="Images/3f69971f-5971-41a5-b574-1da856d74de7.png" style="width:18.50em;height:43.67em;" width="608" height="1436"/></div>
<div style="color: black" class="CDPAlignCenter CDPAlign packt_figref">Azure Logic App settings</div>
<ol start="4">
<li class="mce-root"><span>When you navigate to the Logic App in the</span> <span>Azure Portal</span><span>, the designer is opened. Click on the HTTP request trigger:</span></li>
</ol>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-427 image-border" src="Images/9e231e0d-5d04-4438-aac2-ed2868c2e2a9.png" style="width:100.67em;height:55.42em;" width="1208" height="665"/></div>
<div style="color: black" class="CDPAlignCenter CDPAlign packt_figref">Azure Logic App designer</div>
<ol start="5">
<li>The workflow canvas will open. Click the top action, <span class="packt_screen">When a HTTP request is received</span>, and add the following JSON schema to it:</li>
</ol>
<pre style="padding-left: 60px">{<br/>    "type": "object",<br/>    "properties": {<br/>        "name": {<br/>            "type": "string"<br/>        }<br/>    }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-428 image-border" src="Images/0a3aa0c7-de34-4514-a8dc-80a604acd707.png" style="width:66.83em;height:29.92em;" width="1364" height="611"/></div>
<div class="CDPAlignCenter packt_figref"><span><span>Azure Logic App designer</span></span></div>
<ol start="6">
<li>Click on <span class="packt_screen">New step</span> to add an action. Click <span class="packt_screen">Add an Action</span>, and inside the search box type <kbd>Azure Queue</kbd>. Select <span class="packt_screen">Azure Queues - Put a message on a queue</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img style="text-align: center;font-size: 1em;width:55.33em;height:33.08em;" class="alignnone size-full wp-image-429 image-border" src="Images/5fa5b0b3-6ad1-4259-bf9e-61a4d22709f1.png" width="1360" height="813"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Add action in the Azure Logic App designer</span></div>
<ol start="7">
<li>Give your connection a name, such as <kbd>PacktQueueConnection</kbd>. You can then select a storage account from the different storage accounts that are available inside your Azure subscription. Pick the one that is used for the Azure Function as well. Click on <span class="packt_screen">Create</span>.</li>
<li>Select the <span class="packt_screen">outqueue</span> and add the following message: <kbd>Name passed to the Logic App:</kbd>. Then add the <span class="packt_screen">name</span> parameter after the colon and click on <span class="packt_screen">Save</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-430 image-border" src="Images/714baf35-dd8a-468e-9964-0df450cf5633.png" style="width:114.50em;height:45.08em;" width="1374" height="541"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Configuring the message</span></div>
<ol start="9">
<li>Go to the <span class="packt_screen">Overview</span> settings page of the Logic App and copy the <span class="packt_screen">Callback url</span> to the clipboard:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><span><img src="Images/965e4a3d-c989-4e43-be2f-0a2ac117a3be.jpg" style="width:49.75em;height:25.50em;" width="2614" height="1339"/><br/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Retrieving the API request URL</span></div>
<ol start="10">
<li>Now open Postman, or some other tool for testing APIs, and paste the request URL. Add the same message to the <span class="packt_screen">Body</span> as we used in the Azure Function example and click <span class="packt_screen">Enter</span>:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/775b194a-4793-4a33-bb98-d2643fc15d21.png" style="width:114.67em;height:38.33em;" width="1376" height="460"/></div>
<div style="color: black" class="CDPAlignCenter CDPAlign packt_figref">Creating a POST request in Postman</div>
<ol start="11">
<li>Open the <span class="packt_screen">Azure Storage Explorer</span> tool again and you'll see the queue message created by the Logic App in there:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-432 image-border" src="Images/90db17a5-c962-4042-955a-7c657e856fd8.png" style="width:113.92em;height:88.42em;" width="1367" height="1061"/></div>
<div style="color: black" class="CDPAlignCenter CDPAlign packt_figref">Queue message created by the Logic App</div>
<div class="packt_tip packt_infobox">Postman can be downloaded from the following URL: <a href="https://www.getpostman.com/">https://www.getpostman.com/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing for serverless computing using Azure Container Instances</h1>
                </header>
            
            <article>
                
<p>Containers are a broadly accepted open standard, and have significantly changed the way applications are developed and deployed. A container is an application packaging and deployment mechanism that simplifies the way we develop and deploy software. With the use of a container, we can add all the different artifacts that make the application run, such as configuration files, databases, and Web APIs, in an isolated package and deploy it everywhere. This eliminates unexpected failures that usually pop up when deploying software to different environments, such as development, test, or production environments. And any further knowledge of those different environments, such as which operating system it's using, is not needed anymore. If your application runs on your development environment, it will run on all environments. B<span>ecause of the isolation, </span>containers also solve the problem of running different versions of <span>runtimes or </span>applications that can interfere with each other.</p>
<p>Azure provides <strong>Azure Container Instances</strong> (<strong>ACI</strong>), which provide a <span>hosted environment for running containers in Azure without managing the VMs and the underlying infrastructure. </span>One ACI is a single Docker container, and <span>you </span><span>pay</span><span> only for the resources you consume (per second for each running instance). It offers <strong>Role-Based Access Control </strong>(<strong>RBAC</strong>) on the instance, and you can track the usage at the individual container level. Containers can be deployed on Windows and Linux.</span></p>
<p>Containers can be created using PowerShell, CLI, and in the Azure Portal.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating containers</h1>
                </header>
            
            <article>
                
<p>Containers can be easily created. In this example, the container is created from the CLI, with only a few parameters. To create a container, open the Azure Cloud Shell from the Azure Portal, select the <kbd>Bash</kbd> tab, and add the following code:</p>
<p>This step is optional. You can use this if you want to check and change the default selected Azure subscription:</p>
<pre>az account show<br/>az account set -s "Your-Subscription-Name"</pre>
<p>Next, create the resource group and the container:</p>
<pre>az group create --name packtcontainergroup --location "West Europe"<br/>az container create -g packtcontainergroup --name packtcontainer --image library/nginx --ip-address public</pre>
<div class="packt_tip packt_infobox">You can also install CLI 2.0 on your Windows device using the following URL: <a href="https://azure.microsoft.com/nl-nl/blog/azure-cli-2-0-new-commands-features-available-now-in-azure-cloud-shell/">https://azure.microsoft.com/nl-nl/blog/azure-cli-2-0-new-commands-features-available-now-in-azure-cloud-shell/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Container orchestrations</h1>
                </header>
            
            <article>
                
<p>A set of containers is managed by a container orchestration. An orchestration provides a single entity from where you manage scheduling, scaling, health monitoring, failover, networking, and application upgrades for your container instances. Also, continuous integration and continuous deployment are handled at the orchestration level.</p>
<p>ACI offers a layered approach for orchestrating your containers. ACI provides you with the features to manage one single container. It can manage <span>simple applications, task automation, and build jobs for the isolated containers. For more advanced scenarios, where you need full container orchestration, including service discovery across multiple containers, automatic scaling, and coordinated application upgrades, you need to use orchestration platforms.</span></p>
<p><span>Orchestration platforms </span>handle the tasks of managing a cluster of containers. <span>The orchestration platform is only responsible for the multi-container architecture </span>and doesn't have <span>to worry about the underlying infrastructure because this is handled by Azure (using ACI).</span></p>
<p><span>Container orchestrations offer the following features and capabilities:</span></p>
<ul>
<li><strong>Scaling</strong>: The orchestrator can add or remove container instances. This can be done <span>manually or automatically.</span></li>
<li><strong>Service discovery</strong>: This allows containers to locate each other, even when the IP addresses are changed, and when the containers are moved between physical host machines.</li>
<li><strong>Networking</strong>: This provides a network that can be used by the underlying containers for communication across multiple host machines.</li>
<li><strong>Scheduling</strong>: The scheduler will use the container image and the resource request to locate a suitable VM to run the container on.</li>
<li><strong>Health monitoring</strong>: This monitors the health of the containers and can automatically provide rescheduling.</li>
<li><strong>Application upgrades</strong>: This provides coordinated container upgrades and rollbacks.</li>
<li><strong>Failover</strong>: This checks the current state of the machines and reschedules containers from unhealthy to healthy machines.</li>
<li><strong>Affinity/anti-affinity</strong>: This determines that a set of containers should run near each other to improve the performance of the application, or far away from each other to improve the availability of the application.</li>
</ul>
<p>Azure offers support for different orchestration platforms. Platforms that are supported on Azure are Azure Container Service (AKS), <span>Kubernetes, DC/OS (powered by Apache Mesos), Docker Swarm, and Azure Service Fabric.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Service Fabric</h1>
                </header>
            
            <article>
                
<p>Azure Service Fabric is an orchestration platform from Microsoft that can be used to deploy, manage, and package microservices and containers. It is similar to Docker Cloud and Kubernetes, where Service Fabric is fully bound to the Azure platform. </p>
<p>The difference between the three is that Service Fabric is the only one that is fully bound to the Azure Platform. <span>Examples of this tight integration with the Azure platform includes the fact that Azure Service Fabric can use API Management, Event Hub, and IoT Hub out of the box as stateless gateways. When using other providers, stateless gateways are mostly built manually. You can import Docker images in Azure Fabric as well, but the orchestration of the Docker containers is then fully handled by Azure Service Fabric.</span></p>
<p>Azure Service Fabric offers a lightweight runtime for building distributed, scalable, stateless and stateful microservices that can run inside containers. Using Service Fabric, you can deploy the microservices and containers across a cluster of machines. On top of that, it offers comprehensive application management capabilities to deploy, provision, upgrade and patch, delete, and monitor applications and services on containers. Service Fabric is tailored to create full cloud-native applications that can start small and eventually scale up to thousands of machines over time. </p>
<p class="mce-root">Service Fabric can be deployed inside your own data center as well, on Windows Server machines. On Azure, Service Fabric can be deployed on Windows, Linux, and Azure Stack. There are a number of Azure PaaS solutions or resources that run on Service Fabric, such as Azure SQL Database, Cosmos DB, Intune, IoT Hub, Event Hubs, Skype, Cortana, Power BI, and Microsoft Dynamics.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-421 image-border" src="Images/c371d310-5dc7-4462-b3c9-85f95f625075.png" style="width:166.58em;height:79.50em;" width="1999" height="954"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Azure Service Fabric overview</div>
<p>Applications use the Service Fabric programming models to create and manage your services. There are Service Fabric APIs that can be used in custom applications to take full advantage of the platform's features and application frameworks. You can deploy guest executables, which don't use the Service Fabric APIs, but can use the capabilities of the underlying platform. Guest executables are treated as stateless services and are deployed across different nodes inside a cluster. They can benefit from the affinity, anti-affinity and failover, application life cycle management, and discovery capabilities, for instance. </p>
<p>Service Fabric supports two different programming models that can be used to build scalable and stateful services in Visual Studio 2017. They are called the Reliable Services and the Reliable Actor programming model. By leveraging these models inside your code, Azure can guarantee that the services are consistent, scalable, reliable, and available inside Azure Service Fabric. <span>Service Fabric integrates with ASP.NET Core as well, so you can write both stateless and stateful ASP.NET Core applications that take advantage of these reliable collections and the orchestration capabilities of Service Fabric.</span></p>
<div class="packt_infobox">For more information on the available programming models for Azure Service Fabric, you can refer to the Microsoft documentation: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction</a>. For more information on the <span>Reliable Actor </span><span>programming model, you can refer to: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-actors-introduction">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-actors-introduction</a>.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Life cycle management</h1>
                </header>
            
            <article>
                
<p>With Azure Service Fabric, you can manage the entire life cycles of your microservice applications. It supports all the different tasks, from developing the microservices to deployment, management, and maintenance. To accomplish this, Azure Service Fabric provides different roles that can operate independently. These different roles are as follows:</p>
<ul>
<li><strong>Service developer</strong>: Develops generic microservices that can be leveraged in different applications. The developer uses the <span>Reliable Services and Reliable Actor </span><span>programming model to create the microservices.<br/></span></li>
<li><strong>Application developer</strong>: Creates applications by using the various services developed by the service developer. The application developer creates the application manifest.</li>
<li><strong>Application administrator</strong>: Creates the application configuration files and creates the deployment packages. The administrator uses PowerShell to create the application packages.</li>
<li><strong>Operator</strong>: Deploys the application, monitors the application's health and performance after deployment, and maintains the <span><span>physical infrastructure. The operator uses PowerShell, CLI, or the REST API to deploy the application.</span></span></li>
</ul>
<div class="packt_infobox">For more information on the Service Fabric application life cycle features, you can refer to the following article: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">API Management</h1>
                </header>
            
            <article>
                
<p>API Management is an Azure service that can be used to expose different types of apps to the outside world as APIs.  You can import your custom APIs or serverless apps, such as Azure Functions, Web APIs, Logic Apps, or Service Fabric Apps. </p>
<p><span>You can also use API Management for your internal organization and use it as a service repository that all developers can use to compose their applications or services.</span></p>
<p><span>API Management offers an API Gateway, a Management portal, and a Developer portal, which are covered in more detail in the following sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">API Gateway</h1>
                </header>
            
            <article>
                
<p>The API Gateway acts as a bridge between your app and the outside world. This app can be<span> a custom API, or any other backend application. The API Gateway accepts API calls and routes them to the backend. It provides extra features, such as enhanced security, by adding policies and authentication methods. It can verify API keys, JWT tokens, certificates, and more. You can create transformations without using code modifications, and enforce usage quotas and rate limits. It adds support for caching and throttling, and can log call metadata for analytics purposes.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">API Management portal </h1>
                </header>
            
            <article>
                
<p><span>The API Management portal is where you define and import your custom APIs. You can package your APIs into <strong>products</strong> in there as well. APIs inside API Management are exposed as products to developers and can be configured with a title, description, and terms of use. Products can even be <strong>open</strong> or <strong>protected.</strong> For protected APIs, developers need a subscription. Open<strong> </strong>APIs can be used without a subscription.</span></p>
<p><span>API Management uses <strong>groups</strong> to manage the visibility of products to developers. There are three different types of group: </span></p>
<ul>
<li><span><strong>Administrators</strong>: Administrators can create APIs, operations, and products that are used by developers and manage API Management service instances.</span></li>
<li><strong>Developers</strong>: Developers are <span>the customers that build applications using your APIs. </span>Developer portal users are part of this group. They can be granted access to the Developer portal and leverage the APIs in their custom applications.</li>
<li><strong>Guests</strong>: Guest users are only granted read-only access to the developer portal. They may be future customers or developers, or users that only need to have view access on the different products.</li>
</ul>
<p>Inside the API Management portal, you can set up policies, <span>such as access restriction policies and transformation policies. You can get insights from analytics and create different versions of the APIs.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developer portal</h1>
                </header>
            
            <article>
                
<p><span>API Management also offers a developer portal, from where developers can access your APIs and read API documentation. It provides a console from where APIs can be tested. From there, developers can subscribe to different products. Future customers can visit the portal, view the products with their included operations, and sign up for a subscription. Developers can get insights about their usage from there as well. </span></p>
<p>The look and feel of the Developer portal can be customized. You can add custom content and add custom styles and your company branding to the portal as well. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cloud-native deployments versus migrating assets</h1>
                </header>
            
            <article>
                
<p>Most organizations are moving to the cloud for cost reduction and to speed up the development process of applications. To migrate an application to Azure, there are a couple of strategies you can use. Which one to use depends on the type of application and the priorities and needs of the organization.</p>
<p>Organizations are moving to the cloud to reduce costs and speed up the development process of applications. There are a couple of strategies you can use to migrate your applications to the cloud. Which strategy you use will depend on the type of application and the needs and priorities of the organization. Not all applications are worth the investment of moving to a PaaS model or developing a cloud-native app. For modern applications, you can choose to migrate to a cloud-optimized or cloud-native app, but with applications that are existing or legacy assets, <span>the key is to spend minimal time and money (no re-architecting or code changes) while moving them to the cloud in order to realize the significant benefit therein.</span></p>
<p>There are three different migration levels from which you can choose:</p>
<ul>
<li><strong>Cloud infrastructure-ready</strong>: In this approach, you simply move your current application and host it inside of Azure VMs. There are no code changes needed for this approach.</li>
<li><strong>Cloud DevOps-ready</strong>:<strong> </strong>By using this approach, you are using containers for developing and deploying your applications. This decouples your application from the infrastructure layer, which reduces the failures that are caused by the application dependencies. You can also leverage continuous development and integration on the orchestration level, which makes the deployment process a lot faster. </li>
<li><strong>Cloud-optimized</strong>:<strong> </strong>This migration approach targets the modernizing of your mission-critical applications. This type of modernization usually requires you to re-architect your application for the cloud. New code needs to be written, and you can create cloud-native applications and leverage microservices architectures.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered serverless and microservices. We covered Azure Function, Azure Logic Apps, and the main differences between them. We also covered Azure containers services and container orchestrations. We explained what Azure Service Fabric is and what API Management is. Next, we talked about when to choose to migrate your assets to the cloud and when to choose a cloud-native deployment model.</p>
<p>This concludes the design compute infrastructure objective and, in the next chapter we will proceed with the design networking implementation objective, starting with robust networking implementations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p><span>Answer the following questions to test your knowledge of the information in this chapter. You can find the answers in the <em>Assessments</em> section at the end of this book.</span></p>
<ol>
<li>Can you use API Management as a stateless gateway for your microservices hosted in Azure Service Fabric?
<ol>
<li>Yes</li>
<li>No</li>
</ol>
</li>
<li>Can you deploy Kubernetes containers to Azure Container Instances?
<ol>
<li>Yes</li>
<li>No</li>
</ol>
</li>
<li>Is Azure Service Fabric suitable for DevOps environments?
<ol>
<li>Yes</li>
<li>No</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>You can check the following links for more information about the topics that are covered in this chapter:</p>
<ul>
<li><strong>Introducing Azure Functions</strong>: <a href="https://azure.microsoft.com/nl-nl/blog/introducing-azure-functions/">https://azure.microsoft.com/nl-nl/blog/introducing-azure-functions/</a></li>
<li><strong>Azure Functions Documentation</strong>: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/">https://docs.microsoft.com/en-us/azure/azure-functions/</a></li>
<li><strong>Durable Functions overview</strong>: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview">https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview</a></li>
<li><strong>Azure Logic Apps Documentation</strong>: <a href="https://docs.microsoft.com/en-us/azure/logic-apps/">https://docs.microsoft.com/en-us/azure/logic-apps/ </a></li>
<li><strong>API Management documentation</strong>: <a href="https://docs.microsoft.com/en-us/azure/api-management/">https://docs.microsoft.com/en-us/azure/api-management/</a></li>
<li><strong>Azure Container Instances Documentation</strong>: <a href="https://docs.microsoft.com/en-us/azure/container-instances/">https://docs.microsoft.com/en-us/azure/container-instances/</a></li>
<li><strong>Azure Container Instances and container orchestrators</strong>: <a href="https://docs.microsoft.com/en-us/azure/container-instances/container-instances-orchestrator-relationship">https://docs.microsoft.com/en-us/azure/container-instances/container-instances-orchestrator-relationship</a></li>
<li><strong>Azure Service Fabric Documentation</strong>: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/">https://docs.microsoft.com/en-us/azure/service-fabric/</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>