- en: Ansible and Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible's realm of DevOps integrations is not limited to CI solutions or Configuration
    Management provisioning implementations. In addition to these, its integration
    with cloud infrastructure and virtualization-oriented solutions is considered
    second to none by industry experts. Virtualization solutions such as Docker and
    Vagrant have taken the cloud computing industry by storm. As such, the integration
    between Configuration Management tools (including Ansible) has become increasingly
    robust.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a deep dive into the relationship that can be
    forged between Docker and Ansible. We will discover how Ansible can be used to
    create, maintain, and deploy Docker images. We will take a look at how Ansible's
    module solution for Docker can help automate the delivery of software applications.
    We will discover commonly popular ways to integrate Ansible with this modern virtualization
    solution and learn how experts in the industry are combining these two tools to
    create horizontally scalable and powerful infrastructure delivery solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Upon completing this chapter, we will have a better understanding of how to
    integrate Ansible with Docker. We will have a solid grasp of the technical requirements
    required to create a scalable Docker environment, and you will learn how to better
    automate continuous integration and continuous delivery pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker's Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Docker Containers with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible to Create Docker Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Docker Images with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering Facts About Docker Containers using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker's Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, combining Docker and Ansible may seem contrary to good configuration
    management tactics. However, after some research, we quickly learn that these
    two seemingly different technologies are actually quite robust and scalable when
    combined. This chapter will focus on integrating Ansible and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is easily the frontrunner of virtualization solutions. It provides a
    huge benefit above virtually every other virtualization solution on the market.
    As such, Dockers popularity has grown significantly in organizations looking to
    deliver high-quality, robust implementations to customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can dive into the integration points, let''s talk about Dockers''
    architecture. This is important to understand as it is what sets Docker aside
    from the competition. The following diagram shows Docker''s unique architecture
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/957222cd-e575-4ccb-987e-aab376565fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding diagram, Dockers architecture provides us with
    a **shared kernel** that sits on top of the **Host operating system**. In addition
    to the shared kernel, we also have **Shared libraries** and a set of shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: This is important to understand because in the case of the **Host operating
    system**, the flavor of Linux is irrelevant. This support structure allows Docker
    to sit on top of any flavor of Linux and yet still serve up a filesystem from
    another flavor of Linux. For example, the **Host operating system** could be Ubuntu
    Linux and yet the containers might have a Fedora flavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how this works via the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aa93f36-363f-4bc3-a7b6-187b40762677.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding diagram, we can see exactly how the various Linux distributions
    can be used via a Docker container. In our illustration, we have three highly
    unique flavors of Linux and web applications that reside within different Linux
    flavors. Neat, right?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker containers as environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker's implementation makes it highly effective for spinning up environments.
    Environments in this context represent application hosts, database tiers, and
    APIs that can be combined to provide a working instance of a software solution.
    In the case of larger organizations, these environments might be multiple instances
    (development, QA, stage, and production).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see the architecture of a full-scale environment
    implementation using Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc15d2ed-78c0-4d82-a39a-16f69ce2ab89.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have multiple containers serving up multiple environments.
    Ansible's integration and orchestration solution can help pave and maintain these
    environments. In the next section, we will see exactly how.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Docker Containers with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a unique set of modules that allow Ansible playbook developers
    to integrate Ansible with Docker directly. The *Docker module* provides the Ansible
    playbook developer with the ability to `create`, `start`, `restart`, `modify`,
    and `remove`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at basic operational techniques that can
    be applied to managing Docker containers using Ansible. Specifically, we will
    cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create Docker containers using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to update Docker containers using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to delete Docker containers using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to launch a Docker container using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, performing these tasks may seem a bit daunting. But once we pull
    back the veil on this solution, we will see that the implementation of such tasks
    within a playbook is fairly straightforward. Let's take a look at how these playbook
    modules can help us manage Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating Docker containers may seem like a difficult task through Ansible;
    however, it''s actually quite simple. In this section, you will learn how to do
    exactly that. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding Ansible task creates a Docker data container using the `busybox`
    image with a simple volume of `/data`. While it's easy to create simple containers,
    we will obviously need more substance to create more useful containers. Let's
    take a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Removing Docker containers can be achieved with a simple Ansible state for
    the container provided within the task itself. The following is an example of
    how to remove a Docker container from the local Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Launching and stopping Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launching Docker containers using Ansible can be achieved via the Ansible Docker
    task. In the following example, we launch a Docker container for `mysql`. Let''s
    take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding example, we can see the task launches a MySQL Docker container
    (version 1.0). The primary parameters we used in this task are `image` and `name`.
    These parameters define the image and tag for the task to use and what we want
    to title the container we are managing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to launching the container is the `started` state. State in this context
    provides the following switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`absent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`present`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`started`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in order to expand on this, let''s take a look at an example of the same
    Ansible task, which instead of launching the container will stop it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For teams who update their containers frequently, it is probably a good idea
    to add the following flags to the Docker container launch operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These operational parameters will force Docker to pull a fresh container every
    time it's executed *and* to reload the container as part of the task.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete documentation of the Ansible Docker container module, go to [https://docs.ansible.com/ansible/docker_container_module.html](https://docs.ansible.com/ansible/docker_container_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to launching and stopping a Docker container using the `started`
    and `stopped` switches, we can also launch a container and execute a command.
    Let''s take a look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Managing network access Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What good is an isolated Docker container with no network access? In this section,
    we are going to take a look at how to add a container to a network and conversely
    also remove it from the network.
  prefs: []
  type: TYPE_NORMAL
- en: To manage network connectivity within a Docker container, the Ansible task implementation
    has provided a set of network switches to the main Docker container task. Let's
    take a look at an example of these switches in action and see how to leverage
    Ansible in this form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a container to a network can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing a container from the network can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using Ansible to Create Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker provides an out-of-box solution to build Docker images using a Docker
    domain-specific language. Docker files are created in order to provide spin-up
    instructions that Docker can execute in order to build an image. After learning
    to create Docker files, one may ask why we would advocate for leveraging Ansible
    to create Docker containers in conjunction with a Dockerfile. The answer is quite
    simple—idempotency. An idempotent operation is one where the operation, once executed,
    can be executed repeatedly without any change. This is precisely what Ansible
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Once Ansible has effected a change in a given system, it will automatically
    skip that change if the change is already present. So for example, if an Ansible
    playbook runs against a target system and makes, say, four changes to that system,
    it will automatically skip trying to make that change again *if* the change is
    found already present or if the system is already in the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of creating Docker images using Ansible, it is a good idea to leverage
    Ansible because the domain language is a bit easier to read, the operations are
    idempotent, and the changes can be applied to one container or a hundred simultaneously.
    This provides a large amount of flexibility and scalability within this space.
    In this section, we are going to look at how to leverage Ansible to create Docker
    images. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dockerfiles to launch Ansible playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By leveraging Docker files to call Ansible playbooks once launched, we can
    make our implementation of Docker containers fairly robust. This type of implementation
    has a number of benefits. The most notable are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is existing infrastructure that is already leveraging Ansible, keeping
    the automation control consistent is a no-brainer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible's module system provides integration with a number of third-party tools
    and technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible's implementation of easy-to-read syntax and idempotent architecture
    provides a significant set of capabilities for developers onboarding into Ansible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at how to best leverage a Dockerfile to
    execute an Ansible playbook. Let''s get started by taking a look at an example
    Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be fairly self-documented. However, it basically
    creates a Docker image based on Ubuntu 14.04, defines a working directory for
    Ansible, and then runs Ansible locally using `myplaybook.yml` as its source. Easy,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Managing Docker Images with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker images are slightly different from containers. That is, the image is
    the stored copy of the container. Docker images are stored in what is commonly
    referred to as a **registry.** In the context of Docker, the registry acts similar
    to a source control solution in many ways. That source control solution is mirrored
    in many ways to Git. Docker registries parallel Git in many ways; the most obvious
    is the ability to have a distributed set of registries. Confused yet? Let''s take
    a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cebd8ec3-2cd1-4367-8467-a9ed47fa9f8b.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding illustration, we can see that the **Docker registry** is
    a remote location that stores Docker images. Docker images then reside in a local
    registry (local to the developer) where they can manipulate and store changes
    made to the various containers stored within the **Docker registry**. When a set
    of changes has been deemed complete, the developer has the option to **push**
    the image(s) to the remote registry and communicate their changes.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling, pushing, and tagging images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the fundamental Docker development requirements is the ability of the
    developer to pull, push, and tag Docker images from the remote registry. Ansible
    can be useful in this *if* you have a build system that orchestrates changes to
    the infrastructure and stores the baked images for future deployment. Within this
    type of scenario, the workflow might go something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer checks out the source code for a set of Ansible playbooks that
    define the organization's infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The developer makes a change to a playbook that is associated with the DB tier
    of the environment and commits their code change to Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins offers an automated CI solution, which sees the commit, and pulls down
    the playbook repo for validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins executes Ansible to run the playbook, which automatically creates a
    newer version of the Docker image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The updated Docker image is then pushed to the remote registry for deployment
    into a development or QA environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This type of workflow is pretty simple. It ensures that the development organization
    is not manually making changes to the containers; it ensures that Ansible is the
    tool used to develop, automate, and deploy the software solution; and it ensures
    that the images spun up are tested before deployment to production.
  prefs: []
  type: TYPE_NORMAL
- en: Automating this type of workflow in Ansible takes the ability to pull a Docker
    image, push a Docker image, and tag a Docker image. Let's look at the playbook
    tasks that could make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pull a Docker image, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To tag an image and push it, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the implementation of these tasks is actually *very* straightforward.
    But what about tagging and pushing to a local registry? I''m glad you asked. Let''s
    look at how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right? Finally, let's look at how to build and image from a Dockerfile
    and push it to a private registry. This should be simple, easy right?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how an image is built from a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This task assumes you have a Dockerfile located at `./test`, and it definitely
    isn't rocket science.
  prefs: []
  type: TYPE_NORMAL
- en: Building and archiving Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building Docker images from a Dockerfile is a topic we briefly touched on in
    the previous section, but it deserves a bit more depth. In building a Docker image
    from a Dockerfile, we can leverage it later. But first, we would need a Dockerfile
    to make this happen. Let''s look at an example of a Dockerfile and then look at
    how to build it using Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This Dockerfile should look *very* familiar. In fact, it is! It''s the source
    code we leveraged earlier to have it run an Ansible playbook at launch. Can you
    see where we are going with this example? Save this Dockerfile to the `/opt/test`
    directory and then create a playbook with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a simple playbook in `/srv/example/myplaybook.yml` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Nice. Now run the `/opt/test` Ansible playbook and see the solution build a
    Docker container with nginx already installed and sitting happily in the local
    Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading archived Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker provides a unique ability to share containers using tarballs. This allows
    developers to pass around a tarball copy of the infrastructure for inspection
    and manipulation. Generally, there are two distinct operations involved in archiving
    a Docker container (exporting/archiving and loading an archive); a Docker image
    is also a really straightforward task. Let''s look at an example code on how to
    archive a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading an archived image can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Gathering Facts About Docker Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facts are the bread and butter of how Ansible works and manages information
    about its controlled/automated systems. Facts represent data about the device
    and the current state. Ansible provides a set of playbook tasks that can be readily
    leveraged to gather facts about Docker images. Let's take a look at a couple of
    examples of how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is example 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is example 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding playbook tasks inspect a single or multiple Docker image setup
    and report the facts. The fact data itself is stored in the return value. An example
    of the output is provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output of the command provides a nice hash data set. This data could then
    be further dissected and used within playbook's.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered some interesting and unique ways to integrate
    the Ansible automation system with Docker. We learned that these two seemingly
    redundant technologies can be combined to provide a robust automation implementation
    that scales very well.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about how to inversely leverage Ansible playbook tasks to create,
    update, delete, and manage containers. Then, we covered how to attach and remove
    networking from these containers. You learned that even though these implementations
    might have looked difficult at first, they proved to be quite easy actually.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how to extend Ansible and create
    custom modules. We will educate you on how to use Python to extend Ansible and
    create custom modules that integrate with unique specific technology stacks. This
    will be done by providing a set of tutorials that teach you how to write and release
    custom Ansible modules. This chapter will teach you how to read input, manage
    facts, perform automated tasks, interact with REST APIs, and generate documentation.
  prefs: []
  type: TYPE_NORMAL
