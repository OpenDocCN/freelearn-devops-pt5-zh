<html><head></head><body>
        

                            
                    <h1 class="header-title">Integrating Ansible with CI and CD Solutions</h1>
                
            
            
                
<p>Ansible, DevOps, Agile, <strong>Continuous Integration</strong> (<strong>CI</strong>), and <strong>Continuous Delivery</strong> (<strong>CD</strong>) implementations go hand in hand. Each transitions smoothly into the next. Through Ansible's comprehensive module implementation that we learned about in the last chapter, we can saw how Ansible integrates quite nicely with many industry standard Agile, Continuous Integration and Continuous Delivery solutions. Some of the more common CI-&gt;CD solutions that Ansible integrates with include Jenkins, Artifactory, Maven, Bamboo, and so on. Ansible integrates with these solutions so tightly that in fact, Ansible even has a complete CI-&gt;CD integration guide provided at the following URL <a href="https://www.ansible.com/continuous-delivery">https://www.ansible.com/continuous-delivery</a>.<a href="https://www.ansible.com/continuous-delivery"/></p>
<p>For those unfamiliar with Continuous Integration and Continuous Delivery, these solutions have taken the software development world by storm. They propose a modern standardized way for committing, building, delivering, and testing code via software automation. The progression of code to production through automation and process is called a pipeline. The result of implementing a CI-&gt;CD pipelines is a highly effective way of automating the release of a software project by creating a repeatable process, and providing the team members with automatic feedback loops on the quality.</p>
<p>CI-&gt;CD best practices aim to provide a highly reliable way to build and keep a software project releasable at any moment in time. This is accomplished through a combination of highly disciplined development practices and automation of the build, delivery, and testing apparatuses of the software solution. By combining some fundamental practices with automation, an organization can become highly efficient at developing and delivering code.</p>
<p>In this chapter, we will begin to look at Continuous Integration and Continuous Delivery. We will take a deep dive into the fundamental constructs associated with each and provide details on how to integrate Ansible with popular CI-&gt;CD solutions that are readily available. Specifically, in this chapter, we will cover the following topics:</p>
<ul>
<li>Overview of Continuous Integration</li>
<li>Overview of Continuous Delivery</li>
<li>Ansible's Role in a CI-&gt;CD oriented organization</li>
<li>Integrating Ansible with Jenkins</li>
<li>Integrating Ansible with Vagrant</li>
</ul>
<p>Let's begin exploring this crucial integration piece.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of Continuous Integration</h1>
                
            
            
                
<p>Continuous integration, otherwise known as CI, has been around for quite some time. Its origins can be traced back to Kent Beck, Martin Fowler, and their work at the Chrysler corporation in the mid-nineties. The basic idea was that organizations could save a significant amount of time and effort by performing small yet frequent code merges into a central mainline within source control instead of a large risky merge just prior to release.</p>
<p>This way of thinking requires a team to discipline itself fairly well and requires that each team member commit their code frequently. It discourages isolated feature development efforts for long periods of time and encourages a higher level of collaboration and communication. The result of such an implementation is a much higher quality release due to less complex merge conflicts and code integration issues.</p>
<p>The idea of continuous integration has been a trending topic for years. This is because of the higher level of communication that is required for it to become a successful practice. Beyond the basic commit stage, CI also includes an automated verification system and notification feedback loop so stakeholders can be notified if the commit and merge were defective. This notification system provides instant feedback on the quality of the commit.</p>
<p>Software development professionals have debated the effectiveness of this solution for quite some time and will continue to debate in the future. Generally, the practice of CI can be described with the following diagram:</p>
<div><img height="333" width="575" class="image-border" src="img/836870e3-079b-48a8-8b6e-0742ebe0507d.png"/></div>
<p>As we can see from this diagram, continuous integration spans the full development life cycle of a software project. This specifically includes the following stages:</p>
<ul>
<li>Code development collaboration</li>
<li>Code commit and merging</li>
<li>Automation-based provisioning of build/development environment</li>
<li>Automation-based builds</li>
<li>Automation-based testing of the completed builds (unit test, code coverage, lint and style tests)</li>
<li>Automation based packaging of the build results (binaries and deliverables)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous integration concepts and practices</h1>
                
            
            
                
<p>As we mentioned earlier, the concept of Continuous Integration is not new. The general practice of implementing a continuous integration oriented development team requires a change in mindset across the team, a level of engineering collaboration applied across the team, and a set of basic required practices. These practices are outlined in the list here:</p>
<ul>
<li>Mainline development (no source-control-based branches or highly frequent branch merges).</li>
<li>A CI based automation system that:
<ul>
<li>Automatically checks out code onto a system</li>
<li>Verifies the compilability of the source code</li>
<li>Notifies users of any failures</li>
</ul>
</li>
</ul>
<p>The branching concept of CI over a period of time would look something like what is shown in the following diagram:</p>
<div><img height="244" width="405" class="image-border" src="img/5af46a46-1827-416e-a4b7-b4f415f12671.png"/></div>
<p>Based on this illustration, we can see that in a Continuous Integration environment, developers would be required to push and pull from a central mainline frequently. Each push is then automatically verified using an automated build and test system. Any failures are reported to the larger team and stakeholders.</p>
<p>If a failure is reported by the system, all commits and pushes to the system should stop until the error is fixed. This is because the system is <em>not</em> in a known working state and that failed state must be fixed in order to prevent compounded errors.</p>
<p>While CI generally encourages mainline development, it is possible to achieve Continuous Integration with branches. The main requirement of CI is to have developers remain in sync with the mainline. If a branching system is adopted, strict discipline will need to be maintained in order to ensure branch development does not go on in isolation for long periods of time.</p>
<p>The result of implementing a CI solution is commit phase elements within a build pipeline. Now that we have an understanding of what CI is and how it might work, let's look at Continuous Delivery.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling unfinished work</h1>
                
            
            
                
<p>When working in a Continuous Integration or Continuous Delivery development environment, there is often a common misconception that developers need source control branching as a way to isolate unfinished work. This branch-based development is the antithesis of a Continuous Integration pattern. As such, there are structures and development practices that can be implemented to allow CI and CD to continue without the need for extraneous branches within source control. Let's spend a few minutes looking at the options available to developers who want to satisfy Continuous Integration without having their work complete.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Branch by abstraction</h1>
                
            
            
                
<p>Branching by abstraction provides a solid way for developers to continue working on an incomplete implementation and they not need to create a new branch. The idea behind the branching by abstraction architecture is simple:</p>
<ol>
<li>Modularize the architecture of the software system.</li>
<li>Replace dated modules by simply creating a new class or folder structure on side by side the old one.</li>
<li>Swap out the calls to the module.</li>
</ol>
<p>The basic implementation documented earlier can also be summarized with the following diagram:</p>
<div><img height="147" width="219" class="image-border" src="img/b30e833a-b65c-44a8-a972-edf62c4e88f1.png"/></div>
<p>As we can see from the architecture, the new component is simply interchanged from the old one once it has been completed and deemed functional. This allows the source control level for the components to be committed and pushed without the need for a new branch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Feature toggles</h1>
                
            
            
                
<p>Feature toggles are another way to provide a comprehensive CI implementation. Feature toggles exist in the form of switches. Switches can be turned off/turned on via a configuration change, UI implementation switch, or other configurable objects.</p>
<p>Software programming languages provide the ability to feature toggle code by nature. The most simple example of a feature toggle would be a simple <kbd>if</kbd>/<kbd>else</kbd> condition, as shown here:</p>
<pre>
# Simple Feature toggle<br/>if x in y:<br/> # Do something
</pre>
<p>Beyond a programmatic implementation, a feature toggle's basic flow of operation would be something like what is shown in the following figure:</p>
<div><img height="173" width="554" class="image-border" src="img/1785885f-517f-4821-a51d-3cc09429c196.png"/></div>
<p>Feature toggles allow us to commit code into the mainline and even push that code into production without the necessary overhead of creating a branch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A/B testing patterns</h1>
                
            
            
                
<p>A/B testing is a relatively new addition to the software landscape. For those not familiar with it, the user base is presented with two distinct data implementations. Depending on which implementation the user base likes best, the feature that is the most popular gets rolled out to the larger audience and becomes permanent. Let's look at a simple diagram of A/B testing:</p>
<div><img height="266" width="466" class="image-border" src="img/bed39e93-73de-4dee-a57f-14aff1c17af4.png"/></div>
<p>As we can see in the preceding diagram, A/B testing allows us to expose only a certain percentage of users to a feature and thus use that control group as a testing ground for whether the feature is useful. This type of implementation helps reduce the risk of over-engineering a feature only to find out it's not actually valuable.</p>
<p>Generally, A/B testing aims to save an organization time and money. These savings provide the business with better agility and higher competency in becoming/remaining competitive. Even though the diagram illustrates 50% of users being shown a <strong>Variation B</strong>, it does not always need to be an exact 50%.</p>
<p>For example, if we were doing A/B properly, we might show <em>only</em> 1% of users a feature and leave the other 99% on the stable version. Then, if the 1% generally approves of the feature, we might expand that scope.</p>
<p>At this point in time, you may be asking where and how Ansible fits into A/B testing. This would be a great question. Ansible provides us with a way of targeting hosts with our playbook's. As such, 1% of users may simply be delegated to a single host-oriented deployment. However, in most cases, you wouldn't want to just deploy an upgrade to a single host. Instead, you might consider something like blue-green deployments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of Continuous Delivery</h1>
                
            
            
                
<p>Continuous Delivery was conceptualized by Jez Humble in 2012 with his revolutionary book on Continuous Delivery. The idea that Humble had when writing the book was to extend the concept of CI to support the delivery and automated testing apparatuses a software team would undertake prior to release. This concept radically changed the way software organizations looked at releasing software solutions to customers and aims to keep the software releasable at any time.</p>
<p>In the previous years of software development, having and maintaining a build system was considered a best practice. However, once the build was completed and unit tests all passed, there were still numerous manual processes that needed to be maintained in order to ensure the software solution was, in fact, releasable.</p>
<p>Some of the more popular post build tasks include the following:</p>
<ul>
<li>Installation verification</li>
<li>Quality assurance testing</li>
<li>Deployment environment provisioning</li>
<li>Deployment</li>
<li>Post-deployment verification</li>
</ul>
<p>As software companies suffered more and more failures, those who were managing software projects realized that manually performing these tasks can become error-prone and time-consuming. These tasks also increased in complexity as the software systems they were building grew in size and increased in the user base. The solution Jez proposed was a repeatable and highly automated advance to Continuous Integration. He titled the implementation Continuous Delivery, or CD.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous Delivery defined</h1>
                
            
            
                
<p>CD, as we mentioned earlier, aimed to extend the implementation of CI. This way, a software system remains in a releasable state. This is accomplished by combining mainline development practices, Continuous Integration automation a set of automated provisioning and deployment solutions (to pre-production environments), and automated testing.</p>
<p>In a Continuous Delivery oriented organization, deployment pipelines are created to help implement the previously listed solutions. An example of a high-level deployment pipeline is shown next:</p>
<div><img height="112" width="673" class="image-border" src="img/b35ae327-5dea-4d02-b589-e066273b8ddb.png"/></div>
<p>The deployment pipeline shown here is pretty simple in nature. It simply shows a commit flowing from a developer's hands into production and release. In the following diagram, we can see how a deployment pipeline looks from a bit lower of a view:</p>
<div><img height="453" width="614" class="image-border" src="img/965ee5fd-5959-46ab-a1f6-29f6bf0caef2.png"/></div>
<p>From the shown diagram, we can see that there are a few more visible components within the build pipeline. These components include the following:</p>
<ul>
<li>An artifact repository</li>
<li>Version control</li>
<li>Push button deployments</li>
<li>Configuration management</li>
<li>Smoke tests</li>
<li>Functional tests</li>
<li>Capacity tests</li>
<li>A production stage</li>
</ul>
<p>These additional components of Continuous Delivery are important. Let's go over each and see what they do or aim to accomplish:</p>
<ul>
<li><strong>Version control</strong>: Version control aims to allow a central location for developers to communicate their code changes with the larger group. Some examples of modern version control systems include Git, Mercurial, SVN, and Perforce. The version control system allows not only easy communication but also the reverting of faulty code.</li>
<li><strong>Artifact repository</strong>: Adding a structured <strong>Digital Media Library</strong> (<strong>DML</strong>) to your organization is an important step in relation to implementing Continuous Delivery. This represents a definitive location where the output of the build system can be versioned and kept as a release approaches. It also allows multiple versions of the same.</li>
<li><strong>Push button deployments</strong>: Push button deployments are solutions that can be automatically deployed via a single button push.</li>
</ul>
<p>This is how the solution can be deployed:</p>
<ol>
<li>The automation pulls the binary from the artifact repository.</li>
<li>The automation pushes the artifact using a configuration management solution.</li>
<li>The artifact is unzipped and the automation inside is executed to perform the deployment.</li>
</ol>
<p>Let's look at the other component in detail:</p>
<ul>
<li><strong>Configuration management</strong>: In this step, a configuration management solution (such as Ansible) is used to deploy/configure the software installation onto the target environment machine.</li>
<li><strong>Smoke tests</strong>: Smoke tests are high-level functional tests that determine whether the software is worth testing further.</li>
<li><strong>Functional tests</strong>: Functional tests are verification tests (automated) that verify that the software meets business functional requirements. Each test suite within a functional test solution should be parallelized where possible in order to ensure that there is no bottleneck in performance when executing these tests.</li>
<li><strong>Capacity tests</strong>/<strong>stress tests</strong>: This type of test helps validate that the software can operate and perform effectively under normal traffic loads from the potential user base. Often, this type of test is overlooked, which results in unscalable software solutions that crash under heavy load.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling complex and long running builds and deployments</h1>
                
            
            
                
<p>Sometimes, a build or deployment will be time-consuming (multiple different components or complicated environment setup steps). When this happens, Continuous Delivery-oriented organizations can handle this as well. This is best handled by modularizing the architecture of the software project into uniquely deployable entities. Once the software has been modularized, the deployment and automated testing apparatuses can be broken into multiple component-oriented delivery pipelines. An example of a multi-component delivery pipeline is shown next:</p>
<div><img height="337" width="608" class="image-border" src="img/d21a897d-478e-48c4-956a-54a6f1db4f58.png"/></div>
<p>As we can see from the diagram, multiple pipelines can be created in an effort to streamline the deployment process. Each pipeline would have its own build, package, unit test, and related apparatuses. From these multiple pipelines, we can deploy individual component versions into environments swiftly and reliably.</p>
<p>Now that we have a good grasp on how a basic pipeline would be architected, let's take a look at how the same type of pipeline would look in terms of notifications and feedback.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">CI-&gt;CD feedback loop</h1>
                
            
            
                
<p>The CI feedback loop is one of the major selling points of CI-&gt;CD. The basic idea is that the user base and stakeholders can get CD feedback loop almost instantaneous feedback on the quality of committed code. This would allow the developers to address automation-identified issues quickly and will help improve the quality of the overall system. The basic feedback loop would look something like what is shown in the following:</p>
<div><img height="249" width="552" class="image-border" src="img/8c3cb88b-b73b-4248-a34e-53b340944aa3.png"/></div>
<p>As you can see, the notification loop provides the stakeholders with a notification (e-mail, IM, Slack, Hipchat, and so on) at every stage in the pipeline.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blue-green deployments</h1>
                
            
            
                
<p>Blue-green deployments represent a wise innovation on the part of system operators and engineering groups. The basic concept of a blue-green deployment is, in many ways, similar to the branching by abstraction concept we discussed earlier.</p>
<p>Blue-green deployments offer the idea of deploying a side-by-side instance of a component or application, all the while leaving the existing instance running and serving live traffic. When the deployment is deemed a success, traffic is flipped from the old version over to the new one. The following is a simple diagram illustrating blue-green deployments:</p>
<div><img height="275" width="483" class="image-border" src="img/0d5da00d-58a8-4f89-8682-f5fde552360e.png"/></div>
<p>As we can see, new connections go to the green instance and old connections remain persistent with the blue instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">CI-&gt;CD anti-patterns</h1>
                
            
            
                
<p>With all of the talk of CD anti-patterns branching by abstraction and feature toggles it is probably a good idea at CD anti-patterns this point to look at some anti-patterns that are commonly employed by organizations that represent the antithesis of CI-&gt;CD best practices:</p>
<ul>
<li><strong>Feature branches</strong>: This is because one of the core tenants of Continuous Integration is the merging of code with the main line. This is the area where defects become most prevalent.</li>
<li><strong>Leaving the build in a failed state</strong>: Leaving the build in a known failed state is a common anti-pattern for Continuous Integration efforts. This is an anti-pattern since it effectively leaves a landmine for other developers.</li>
<li>K<strong>eeping code locally on a developer workstation for long periods of time</strong>: Coding software changes on a local system and not merging it with the mainline is, in essence, hiding changes. The risk from this pattern comes with the huge merge that needs to be done. This large-scale merge usually takes place right before a release, which puts the release quality at risk.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible's Role in CI-&gt;CD</h1>
                
            
            
                
<p>Ansible fits in a number of areas of the CI-&gt;CD implementation. It can be used for build environment provisioning, local workstation environment provisioning, configuration management on deployment servers, managing physical deployments, and much more.</p>
<p>In this section of Implementing DevOps with Ansible, we will take a look at where Ansible fits into the CI-&gt;CD pipeline implementation and some best practices associated with each implementation location. Before we begin looking into focus areas, let's identify the common steps in a CI-&gt;CD pipeline.</p>
<p>Initially, a delivery pipeline will be simple; it may contain a set of very basic steps. These steps might include the followng:</p>
<ol>
<li>Check out the source control when a change is committed.</li>
<li>Perform a build or syntax check.</li>
<li>Execute some unit tests.</li>
<li>Report on the quality of the commit.</li>
</ol>
<p class="mce-root">These steps are illustrated in the following diagram:</p>
<div><img height="420" width="288" class="image-border" src="img/404eeb7a-2316-4612-a2f1-8106ce2d2760.png"/></div>
<p class="CDPAlignLeft CDPAlign">Based on the initial CI process described, we might consider using Ansible in the following CI steps:</p>
<ul>
<li>To help developers provision their development environment using an Ansible playbook</li>
<li>To provision the build machine automatically and ensure the build machine's configuration is maintained by Ansible playbooks</li>
<li>To act as the automation binding to execute the build and unit tests</li>
</ul>
<p class="CDPAlignLeft CDPAlign">As we can see from these set of steps, we can leverage Ansible in more ways than simply to perform configuration management tasks and deployments.</p>
<p class="CDPAlignLeft CDPAlign">Now that we have Continuous Integration defined, let's take a look at how Ansible can be used within the extension of CI and CD. Take a look at the following Continuous Delivery diagram:</p>
<div><img height="343" width="683" class="image-border" src="img/bd16b2d1-d389-4236-b18d-8a5d1f3d205c.png"/></div>
<p class="CDPAlignLeft CDPAlign">Based on this diagram and flowchart, we can see that there are a number of places within CI-&gt;CD where Ansible would prove useful. Let's take a look at these places:</p>
<ol>
<li>In provisioning the test environments (smoke, functional, and unit).</li>
<li>In provisioning the deployment environments (DEV, QA, STG, PROD).</li>
<li>In performing the deployment.</li>
<li>In launching the application after it has been deployed.</li>
<li>In rolling back the environment if there are failures.</li>
<li>In performing a feathered/incremental rollout of the application into production.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible best practices in CI-&gt;CD</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Ansible can be leveraged for a number of tasks within a Continuous Integration and Continuous Delivery atmosphere. When adopting Ansible, it makes sense to start with a small footprint and expand it to be more and more responsible for the automation being executed.</p>
<p class="CDPAlignLeft CDPAlign">In this section, let's take a few minutes to explore some best practices within CI-&gt;CD in conjunction with Ansible:</p>
<ol>
<li>Always store your Ansible playbooks in source control.</li>
<li>Ship your ansible playbooks with your artifacts (version everything!).</li>
<li>Maintain separate inventory files for each environment (DEV, QA, and so on).</li>
<li>Try to use the same playbooks for deploying to DEV as you would in production.</li>
<li>Leverage Ansible's configuration management implementation to help keep your infrastructure in sync.</li>
<li>Keep your playbooks as simple as possible.</li>
<li>Use roles to help define reusable automation.</li>
<li>Use Ansible for your build and deployment automation glue where possible.</li>
<li>Keep your environments in sync (Apples | Apples | Apples, Dev | QA | PROD).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrating Ansible with Jenkins</h1>
                
            
            
                
<p>In this section, we will talk about integrating Ansible with Jenkins. Jenkins is a modern CI and automation orchestration solution created and distributed by the open source community. Jenkins originated as Hudson and was eventually transitioned with a new brand name and developed into a comprehensive free and open source build and delivery pipeline orchestration solution. You can download a copy of Jenkins at <a href="https://jenkins.io/">https://jenkins.io/</a><a href="https://www.ansible.com/continuous-delivery">.</a></p>
<p>Integrating Ansible with Jenkins is generally a straightforward task. To accomplish this, there are a few well-known integration points where Ansible can be leveraged. They include the Jenkins Ansible plugin, installing Ansible on the Jenkins CI server directly and calling it through an execute shell operation and using the Ansible module to control Jenkins. Let's spend a few minutes discussing each of these options and see how they work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Jenkins Ansible plugin</h1>
                
            
            
                
<p>The Jenkins Ansible plugin provides the ability for Jenkins to directly communicate with Ansible and run a playbook. This option is probably the most straightforward integration point between Jenkins and Ansible. Using this solution, Ansible doesn't necessarily need to run playbooks on a remote server (however, it definitely can). In this solution, we can run playbooks directly from the Jenkins server and either have those playbooks run locally or run them against targeted infrastructure.</p>
<p>In order to facilitate the execution of playbooks through Jenkins, we will need to first install the Ansible plugin via the Jenkins plugin manager. Let's take a look at how to do this.</p>
<p>This tutorial assumes you have a Jenkins instance already installed and running.</p>
<p>The first thing we will want to do is fire up Jenkins. Upon the initial load of Jenkins, we will see something like the following:</p>
<div><img class="image-border" src="img/e42cccfa-03ad-4904-9489-d82b47fb8f80.png"/></div>
<p>To install the Ansible plugin. simply navigate to Plugin Manager (as a Jenkins administrator) and select Ansible plugin from the Available plugins tab and install the plugin. This is shown in the following screenshots:</p>
<div><img class="image-border" src="img/110ed814-1452-4a1d-a822-c2d034ffa808.png"/></div>
<p>Search for the Ansible plugin and select it. Now install the plugin by clicking on Install without restart:</p>
<div><img class="image-border" src="img/a64391d6-fab8-427f-ad7f-f8fabe6e5e55.png"/></div>
<p>Next, we will want to go to the job configuration page for the job we wish to leverage Ansible through and enable the job to use Ansible. The configuration would look something like what is shown in the following screenshot:</p>
<div><img class="image-border" src="img/815c6266-2d26-4738-bc2f-e181af812dd5.png"/></div>
<p>From this screenshot, we can see that there are a number of options available for use with the Ansible plugin in Jenkins. The complete documentation is available at <a href="https://wiki.jenkins-ci.org/display/JENKINS/Ansible+Plugin">https://wiki.jenkins-ci.org/display/JENKINS/Ansible+Plugin</a>.</p>
<p>Once the plugin and job are configured, run the Jenkins job to see it connect to Ansible and leverage Ansible for the automation engine of the job. The output from the execution of a Jenkins job using the Ansible plugin would be something like what is shown in the following screenshot:</p>
<div><img class="image-border" src="img/428f61dc-4658-48e5-b9e0-e6028bdd8c30.png"/></div>
<p>Now that we have a good idea of how to leverage Jenkins to execute Ansible playbook, let's take a look at how to have Ansible control Jenkins via the API.</p>
<p>Ansible playbooks in this scenario are best stored in source control and checked out during the SCM phase of the Jenkins job.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Jenkins Ansible API modules</h1>
                
            
            
                
<p>The Jenkins Ansible module provides a direct API-level integration between Jenkins and Ansible. Through this solution, Ansible can manage and control Jenkins through its REST API. The Jenkins REST API is fairly robust and provides the ability to create jobs, execute jobs, manage users, and much more. In this section, we will take a look at some examples of the capabilities that the Ansible module provide.</p>
<p>Ansible's integration with Jenkins is broken down into three uniquely classified modules. These modules (as mentioned previously) communicate with Jenkins on an API level and provide a level of control over the Jenkins solution. The three specific modules that we will be looking at are as follows:</p>
<ul>
<li><kbd>jenkins_job</kbd>: Manages Jenkins jobs</li>
<li><kbd>jenkins_plugin</kbd>: Adds or removes the Jenkins plugin</li>
<li><kbd>jenkins_script</kbd>: Executes a groovy script in the Jenkins instance</li>
</ul>
<p>Let's start with the <kbd>jenkins_job</kbd> Ansible module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The jenkins_job Ansible Module</h1>
                
            
            
                
<p>The <kbd>jenkins_job</kbd> Ansible module provides a level of inter-connectivity between Jenkins jobs and Ansible. Through this module, Ansible can create Jenkins jobs, execute them, manage them, delete them, and more. In order to use this module, we will need the following package libraries installed on the Ansible control server:</p>
<ul class="simple">
<li><kbd>python-jenkins</kbd> &gt;= 0.4.12</li>
<li><kbd>lxml</kbd> &gt;= 3.3.3</li>
</ul>
<p>These libraries can be installed using <kbd>pip</kbd> or a package management system such as <kbd>apt-get</kbd> or <kbd>yum</kbd>.</p>
<p>After making sure the modules are installed, we can begin to make use of the Ansible module's features. Let's take a look at some example playbook plays to create and control Jenkins jobs via the REST API. In addition to this, we will also take a look at the documentation for the supported features of the module:</p>
<pre class="mce-root">
<strong># Create a Jenkins Job</strong><br/>- jenkins_job: <br/>    config: "{{ lookup('file', 'templates/example.xml') }}"<br/>    name: HelloJenkins<br/>    password: admin<br/>    url: "http://localhost:8080"<br/>    user: admin
</pre>
<pre class="mce-root">
<strong># Delete a jenkins job using the Ansible Jenkins_Job Module</strong><br/> - jenkins_job:<br/>    name: AnsibleExample<br/>    password: admin<br/>    state: absent<br/>    url: http://localhost:8080<br/>    user: admin
</pre>
<pre class="mce-root">
<strong># Disable a Jenkins job using the Ansible Jenkins_Job module</strong><br/>- jenkins_job:<br/>    name: AnsibleExample<br/>    password: admin<br/>    enabled: False<br/>    url: http://localhost:8080<br/>    user: admin
</pre>
<p>To create the <kbd>example.xml</kbd> template, you will need to use the Jenkins UI wizard to create a new template. This can be done via the job templates plugin. More information on this plugin can be found at the following URL: <a href="https://www.cloudbees.com/products/cloudbees-jenkins-platform/enterprise-edition/features/templates-plugin">https://www.cloudbees.com/products/cloudbees-jenkins-platform/enterprise-edition/features/templates-plugin</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrating Ansible with Vagrant</h1>
                
            
            
                
<p>In this section, we will talk about integrating Ansible with Vagrant. Vagrant is a freely available infrastructure virtualization solution that is currently in use by countless organizations. It is provided free of charge via the kind folks at HashiCorp. A complete documentation for Vagrant can be found at <a href="https://www.vagrantup.com/intro/index.html">https://www.vagrantup.com/intro/index.html</a>.<a href="https://www.vagrantup.com/intro/index.html"/></p>
<p>To begin, we will assume you already have Vagrant up and running. If not, refer to the instructions located within HashiCorp's Vagrant Up website at <a href="https://www.vagrantup.com/docs/cli/up.html">https://www.vagrantup.com/docs/cli/up.html</a> to get the initial setup completed. Once the initial setup of Vagrant has been completed, we can take a look at how to leverage Ansible within Vagrant.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Leveraging Ansible for Vagrant provisioning</h1>
                
            
            
                
<p>Ansible's playbook implementation can be used to provision Vagrant machines through the Ansible provider. Providers in Vagrant allow the Vagrant user to specify a configuration management solution that will be leveraged to automate the standup of a given virtual machine. This information is contained in a Ruby Vagrantfile. An example of a simple Vagrantfile is provided here:</p>
<pre>
# This is an example Vagrantfile which can be used with <br/># Vagrant 1.7 and greater to provision an Ubuntu Box <br/># using Ansible<br/><br/>Vagrant.require_version "&gt;= 1.7.0"<br/>Vagrant.configure(2) do |config|<br/><br/>config.vm.box = "ubuntu/trusty64"<br/> config.vm.provision "ansible" do |ansible|<br/> ansible.verbose = "v"<br/> ansible.playbook = "playbook.yml"<br/> end<br/>end
</pre>
<p>From this example, we can see that we use Ansible to configure our Vagrant environment. This will cause Vagrant to execute the Ansible playbook. Once the Vagrantfile has been updated, we can run it using the <kbd>vagrant up</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we talked about Continuous Integration, Continuous Delivery, and Ansible. We also talked about the organizational requirements of CI-&gt;CD and how CI-&gt;CD makes software delivery more efficient. You learned about some of the patterns that make a CI-&gt;CD implementation effective.</p>
<p>After talking about CI-&gt;CD in depth and discussing the said patterns, we talked about Ansible's role within a CI-&gt;CD oriented organization. We discovered the connecting points that tools such as Ansible can be leveraged to make the process more efficient. By standardizing and making a software development organization more efficient through the use of modern tools such as Ansible, we can save the organization time and money.</p>
<p>In the next chapter, we will explore how to use Ansible with Docker. The chapter will teach you how to provision docker containers using Ansible, how to integrate Ansible with dockers service, how to manage docker image facts, and how to gain full control over docker images.</p>


            

            
        
    </body></html>