<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Your Users and Gitolite</h1></div></div></div><p>Now that we have a working installation of Gitolite, it's time to talk about how users interact with a Gitolite-managed system, and what they need to know to start using it. This will allow you to get some of your advanced users to start using the system while you continue to learn about Gitolite as we progress. As an administrator, you will be making a lot of decisions in terms of things such as naming conventions for repositories as well as branches, how tight or relaxed the access rules will be, and many more aspects that you will learn going forward. These advanced users could help by giving you feedback or acting as sounding boards for these decisions.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Accessing Git repositories</h1></div></div></div><p>Before discussing <a id="id58" class="indexterm"/>how to access a Gitolite-managed repository, we will first need some background on how Git repositories are normally accessed, that is, when you aren't using Gitolite.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Git servers, SSH, and HTTP</h2></div></div></div><p>We start <a id="id59" class="indexterm"/>by reviewing how a user views a normal Git server. Git repositories use URLs as locators, so when a user clones, fetches from, or pushes to a remote repository, it is done using a suitable URL. Git URLs are not very different from any other URL, and the man page for git-clone has a section on them, so you can see all the syntax variations that you can use.</p><p>However, for authenticated remote access, there are really only two protocols that are of interest: SSH<a id="id60" class="indexterm"/> and HTTP. <a id="id61" class="indexterm"/>Of these, ssh-based access is a lot more common, because it is quick and easy to set up; even on a freshly installed Unix, there's usually no extra configuration required to get it working.</p><p>As the main page mentioned previously says an ssh URL has the general form <code class="literal">ssh://[user@]host.xz[:port]/path/to/repo.git</code>. When you type an URL, such as <code class="literal">ssh://git@server.example.com/repo</code> to access a remote git repository, you will usually be asked for a password, unless an ssh key pair has already been set up for access to the remote host. Once access has been granted, the ssh daemon runs the appropriate Git command on the remote side to talk to the Git client on the local side.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Accessing Gitolite repositories</h1></div></div></div><p>With the background <a id="id62" class="indexterm"/>from the previous section, we're ready to see how things change when a user goes through Gitolite to access a Git repository.</p><div><div><h3 class="title"><a id="note008"/>Note</h3><p>This section will contain the basic material that most administrators would need to provide to their users, or to explain to them how to access a Gitolite server. However, depending on your users' familiarity with ssh and related topics, you may have to expand this material with supplementary information, examples, or instructions specific to your site.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec19"/>SSH key pairs</h2></div></div></div><p>The most <a id="id63" class="indexterm"/>significant change is that password access is no longer possible; users <em>must</em> use a key pair and send the public key to the administrator so that they can be added to Gitolite. If this does not happen, Gitolite has no way to recognize the user.</p><p>If they don't already have an ssh key pair, they should generate one on their own workstations.</p><p>Your users will need to use the <code class="literal">ssh-keygen</code> command<a id="id64" class="indexterm"/> to create the key pair. This creates two files, which are <code class="literal">id_rsa</code> containing the private key and <code class="literal">id_rsa.pub</code> containing the public key, if they chose the default options. On a Windows system, the command will respond with the full paths of where the files were created, while on a Unix system they will be in <code class="literal">$HOME/.ssh</code>.</p><div><div><h3 class="title"><a id="note009"/>Note</h3><p>Ideally, users should set a passphrase on the private key for security and then use <code class="literal">ssh-agent</code> for convenience; however, both of these topics are out of the scope of this book. Any ssh-related text or website should have sufficient details, as will the documentation that comes with the OpenSSH package.</p></div></div><p>They will then send the public key (the file whose name ends in <code class="literal">.pub</code>) to you, so that you may add them as a user.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Repository naming</h2></div></div></div><p>The second <a id="id65" class="indexterm"/>change is that the name of each repository will be whatever you, as the administrator, have created in the <code class="literal">conf/gitolite.conf</code> file that we briefly saw in the last section of the previous chapter. Gitolite actually creates all its repositories inside <code class="literal">$HOME/repositories</code> in the hosting user account, but only you (the administrator) need to know this. As far as the user is concerned, to access a repository that is listed in the conf file as <code class="literal">repo foo</code>, the URL to use is simply <code class="literal">git@server:foo</code> (or the longer form <code class="literal">ssh://git@server/foo</code>).</p><p>Also, note that the <code class="literal">.git</code> at the end of the repository name is optional for Git commands (namely <code class="literal">clone</code>, <code class="literal">fetch</code>, <code class="literal">push</code>, <code class="literal">ls-remote</code>, and <code class="literal">archive</code>). Git itself works fine with or without it, so Gitolite does the same in order to be consistent. However, in interactions with Gitolite, such as when running Gitolite commands that refer to repositories, you must use the bare name (without the trailing <code class="literal">.git</code>), which is the name that Gitolite prints in its error messages or informational output.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Getting information from Gitolite</h1></div></div></div><p>Once your users have access to Gitolite, they would probably like to see which repositories they can access. The simplest way to do this is to run the <code class="literal">info</code> command<a id="id66" class="indexterm"/>, which is available to all remote users:</p><div><pre class="programlisting">
<strong>$ ssh git@server info </strong>
<strong>hello adam, this is git@server running gitolite3 v3.5.3.1-7-g5f88a09 on git 1.8.3.1 </strong>
<strong> R W  gitolite-admin </strong>
<strong> R W  t2 </strong>
<strong> R W  testing</strong>
</pre></div><p>This tells you what your Gitolite username is (in this case, <code class="literal">adam</code>), which repos you have access to, and whether you are allowed to read and write, or only read but not write to the repo. Apart from that, this command also tells you which version of Gitolite and which version of Git is running on the server, which could be useful.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Gitolite commands</h1></div></div></div><p>The <code class="literal">info</code> command <a id="id67" class="indexterm"/>is not the only command available to your users, of course; there are a few more. As you may have guessed from the preceding part, the general format for running Gitolite commands is simply <code class="literal">ssh git@server command-name command-arguments</code>, where the arguments are of course optional.</p><p>Conveniently, Gitolite also has a command to list all the available commands:</p><div><pre class="programlisting">
<strong>$ ssh git@server help </strong>
<strong>hello adam, this is gitolite3 v3.5.3.1-7-g5f88a09 on git 1.8.3.1 </strong>

<strong>list of remote commands available: </strong>

<strong>  desc </strong>
<strong>  help </strong>
<strong>  info </strong>
<strong>  perms </strong>
<strong>  writable</strong>
</pre></div><p>As you can <a id="id68" class="indexterm"/>see, this gives the remote user the list of commands that they are allowed to run. (Some of these commands can only be explained in later chapters).</p><p>Further, if you run this from the Gitolite hosting user command line, as <code class="literal">gitolite help</code>, you will get a listing of <em>all</em> the available commands, and not just the ones that are enabled for remote access.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Getting help for commands</h1></div></div></div><p>Getting help for a<a id="id69" class="indexterm"/> command is easy. Every Gitolite command responds with a help message when called with <code class="literal">-h</code> as the only argument. For example, the help message for the info command is given as follows:</p><div><pre class="programlisting">
<strong>$ ssh git@server info -h </strong>

<strong>Usage:  gitolite info [-lc] [-ld] [&lt;repo name pattern&gt;] </strong>

<strong>List all existing repos you can access, as well as repo name patterns you can </strong>
<strong>create repos from (if any). </strong>

<strong>    '-lc'       lists creators as an additional field at the end. </strong>
<strong>    '-ld'       lists description as an additional field at the end. </strong>

<strong>The optional pattern is an unanchored regex that will limit the repos </strong>
<strong>searched, in both cases.  It might speed up things a little if you have more </strong>
<strong>than a few thousand repos. </strong>
</pre></div><p>As before, some of these options pertain to features of Gitolite we have not yet encountered, and will become clearer when that material is presented.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Troubleshooting SSH issues</h1></div></div></div><p>When<a id="id70" class="indexterm"/> you start adding your first few users to a system, <a id="id71" class="indexterm"/>you may run into some ssh-related issues. This section will discuss the possible issues in brief, and explain how to recognize and fix them.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Authorization, not authentication</h2></div></div></div><p>First, we need a couple of basic definitions. Authentication is<a id="id72" class="indexterm"/> the process of verifying that you are who you claim to be. Authorization<a id="id73" class="indexterm"/> is the process of determining what you want to do and deciding whether you're allowed to do it or not. Authorization<a id="id74" class="indexterm"/> happens after authentication (the system can only decide what you are allowed to do <em>after</em> establishing who you are!).</p><p>Gitolite is only concerned with authorization; it does not do authentication. It leaves authentication up to an ssh server or a web server.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>The HTTP mode is out of scope for this book; please consult Gitolite's online documentation to use that mode.</p></div></div><p>Once the ssh server has authenticated the user, it uses the <code class="literal">command</code> option in the ssh authorized keys file (<code class="literal">$HOME/.ssh/authorized_keys</code>) to invoke Gitolite and pass it the username. Gitolite then decides whether this user is allowed to access this repository or not.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Duplicate public keys</h2></div></div></div><p>If the user's public <a id="id75" class="indexterm"/>key was already part of the authorized keys file before setting up Gitolite (perhaps to allow him to get a login shell and run Unix commands), the key will appear twice in the authorized keys file—once as is, and once with the <code class="literal">command</code> option and other options that Gitolite adds to each public key in the <code class="literal">keydir</code> directory.</p><p>However, if a key appears twice in the authorized keys file, the ssh server will only look at the first occurrence. At the same time, Gitolite tries very hard to make sure that a key that already had normal access to the server continues to have it, so it will place the Gitolite line, which is more restrictive than the default access, <em>after</em> the normal line. This means that users who have shell access to the Gitolite hosting user will not be able to use Gitolite, since the key will not invoke Gitolite. They will need to create and use a different ssh key pair for Gitolite (that is, repository) access. They would then have to manage these two key pairs on their client, perhaps using <code class="literal">$HOME/.ssh/config</code> to help. Further explanation of the ssh <code class="literal">config</code> file and how it helps you choose which key to use, is out of scope for this book. However, almost any decent book on ssh, as well as the main pages for ssh on your system, should have this information.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Diagnosing public key problems</h2></div></div></div><p>The best<a id="id76" class="indexterm"/> way to diagnose public key problems, such as in the previous section, is to run the <code class="literal">sshkeys-lint</code> program that comes with Gitolite. Here is an example where two problems with public keys were intentionally created. The first is that we reused a key that already had shell access, adding it to Gitolite as <code class="literal">u2.pub</code>. The second is that we copied the file <code class="literal">u5.pub</code> as <code class="literal">u6.pub</code>. The output of the sshkeys-lint command after these changes is given as follows:</p><div><pre class="programlisting">
<strong>$ gitolite sshkeys-lint </strong>
<strong>sshkeys-lint: ==== checking authkeys file: </strong>
<strong>sshkeys-lint: WARNING: authkeys line 5 (user u2) will be ignored by sshd; same key found on line 1 (shell access) </strong>
<strong>sshkeys-lint: WARNING: authkeys line 9 (user u6) will be ignored by sshd; same key found on line 8 (user u5) </strong>
<strong>sshkeys-lint: ==== checking pubkeys: </strong>
<strong>sshkeys-lint: admin.pub maps to user admin </strong>
<strong>sshkeys-lint: u1.pub maps to user u1 </strong>
<strong>sshkeys-lint: u2.pub maps to shell access </strong>
<strong>sshkeys-lint: u3.pub maps to user u3 </strong>
<strong>sshkeys-lint: u4.pub maps to user u4 </strong>
<strong>sshkeys-lint: u5.pub maps to user u5 </strong>
<strong>sshkeys-lint: WARNING: u6.pub appears to be a COPY of u5.pub </strong>
<strong>sshkeys-lint: u6.pub maps to user u5 </strong>

<strong>3 warnings found </strong>
</pre></div><p>As you can see, the command lists potential problems, first in the authorized keys file (<code class="literal">$HOME/.ssh/authorized_keys</code>), and then among the public keys that Gitolite owns.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>SSH best practice</h2></div></div></div><p>We've now <a id="id77" class="indexterm"/>seen how to troubleshoot ssh issues. However, it's better to avoid such problems in the first place, and a good rule of thumb for avoiding them is this: don't give any user shell access to the server. Even you, as the administrator, should log on to some other user ID, run <code class="literal">su - git</code>, and then provide a password when you need to do anything on the Gitolite hosting user's command-line shell. Let all the keys in the authorized keys file be Gitolite-managed keys unless you are really familiar with ssh. That should eliminate most of the common issues with ssh keys.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we saw how to add users to your new Gitolite installation, and how to find and fix problems with ssh keys.  In the next chapter, we will talk about creating new repositories.</p></div></body></html>