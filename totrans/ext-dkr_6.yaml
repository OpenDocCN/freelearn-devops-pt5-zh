- en: Chapter 6. Extending Your Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Introducing First-party Tools"), *Introducing
    First-party Tools*, we looked at the tools Docker provides for extending the functionality
    of the core Docker engine. In this chapter, we will look at third-party tools
    that extend the way you manage your Docker configuration and build and launch
    containers. The tools that we are going to be discussing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Puppet**: [http://puppetlabs.com/](http://puppetlabs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible**: [http://www.ansible.com/docker/](http://www.ansible.com/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vagrant**: [https://docs.vagrantup.com/v2/docker/](https://docs.vagrantup.com/v2/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packer**: [https://www.packer.io/docs/builders/docker.html](https://www.packer.io/docs/builders/docker.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins**: [https://jenkins-ci.org/content/jenkins-and-docker/](https://jenkins-ci.org/content/jenkins-and-docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of the tools, we will look at how to install, configure, and use them
    with Docker. Before we look at how to use the tools, let's discuss why we would
    want to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Why use these tools?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been looking at tools that either use the main Docker client
    or use the tools that are provided by Docker and other third parties to support
    the main Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: For quite a while, the functionality that some of these tools have now did not
    exist within a Docker support product. For example, if you wanted to launch a
    Docker host, you couldn't just use Docker Machine, instead you had to use something
    such as Vagrant to launch a virtual machine (locally or in the cloud) and then
    install Docker using a bash script, Puppet, or Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Once you had your Docker host up and running, you could use these tools to place
    your containers on hosts as there was no Docker Swarm or Docker Compose (remember
    Docker Compose started off as a third-party tool called Fig).
  prefs: []
  type: TYPE_NORMAL
- en: So while Docker has slowly been releasing their own tooling, some of these third-party
    options are actually more mature and have quite an active community behind them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Puppetize all the things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Long before the following *Containerize all the things* meme regularly started
    to pop up in people''s presentations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Puppetize all the things](img/B05468_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: People were saying the same thing about Puppet. So, what is Puppet and why would
    you want to use it on all things?
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet Labs, the makers of Puppet, describe Puppet as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"With Puppet, you define the state of your IT infrastructure, and Puppet automatically
    enforces the desired state. Puppet automates every step of the software delivery
    process, from provisioning of physical and virtual machines to orchestration and
    reporting; from early-stage code development through testing, production release
    and updates."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Before tools such as Puppet, working as a sysadmin could sometimes be quite
    a tedious process: if you weren''t looking into problems, you were writing your
    own scripts to bootstrap servers once they had been built, or even worse, you
    were copying and pasting commands from an internal wiki to install your software
    stack and configure it.'
  prefs: []
  type: TYPE_NORMAL
- en: Servers would very quickly evolve away from your initial installation and when
    they broke, which all servers eventually do, things could get really interesting,
    complicated, scary, very bad, or all of them quickly.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Puppet comes in; you define what you need your server to look
    like and Puppet does the heavy lifting for you, making sure that your configuration
    is not only applied, but also maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I had several servers behind a load balancer for my PHP-powered
    website, it''s important that the servers are all configured in the same way,
    meaning that they all have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The same NGINX or Apache configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same version of PHP along with the same configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same PHP modules installed, at the same version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do this before Puppet, I would have to ensure that not only I kept a script
    that is used to do the initial installation, but I would also have to carefully
    manually apply the same configuration changes across the servers or write a script
    to synchronize my changes across the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: I would also have to ensure that anyone who has access to the servers adheres
    to the processes and procedures I have put in place in order to maintain consistency
    across my load balanced web servers.
  prefs: []
  type: TYPE_NORMAL
- en: If they didn't, I would start to get configuration drift, or worse, still one
    in every x requests could be being served from a server that is running a different
    codebase/configuration from the other machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Puppet, if I need to run an up-to-date version of PHP 5.6 because my application
    doesn''t work correctly under PHP 7, then I can use the following definition to
    ensure that my requirements are met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure that the `php` package is installed and that the version
    is and stays at 5.6, I can then take this single configuration and apply it across
    all of my web servers.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's this got to do with Docker?
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Docker Machine, Docker Compose, and Docker Swarm, I used Puppet to bootstrap
    and manage my Docker hosts and containers. Let's take a look at the excellent
    Docker Puppet module written by Gareth Rushgrove.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, we need a virtual machine to work on. In the previous chapters,
    we have been using Docker Machine to launch virtual machines that we can run our
    containers on.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we want Puppet to manage the installation of Docker and the container
    on which we are going to be launching a local virtual machine using Vagrant, confusingly,
    we are also going to be looking at Vagrant later in this chapter, so we will not
    go into much detail here.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you need to ensure that you have Vagrant installed, you can get
    the latest release from [https://www.vagrantup.com/](https://www.vagrantup.com/)
    and you can find a guide to perform the installation at [https://www.vagrantup.com/docs/getting-started/](https://www.vagrantup.com/docs/getting-started/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have Vagrant installed, you can a launch an Ubuntu 14.04 virtual server
    using VirtualBox by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download and launch the virtual server, storing everything in the
    `ubuntu` folder. It will also mount the `ubuntu` folder as a filesystem share
    using the `/vagrant` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker and Puppet](img/B05468_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our virtual server up and running, let''s connect to it and
    install the Puppet agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker and Puppet](img/B05468_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the Puppet agent installed, the final step is to install the
    Docker module from Puppet Forge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may see warnings such as the one in the following terminal session; don''t
    worry about these, they are to just inform you of the upcoming changes to Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker and Puppet](img/B05468_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, it''s worth point out that we haven''t actually installed Docker
    yet, so let''s do that now by running our first puppet manifest. On your local
    machine, create a file called `docker.pp` in the `ubuntu` folder. The file should
    contain the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we run this manifest using `puppet apply`, Puppet will know that we need
    Docker installed to be able download the `russmckendrick/base` image and then
    launch the `helloworld` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on our virtual machine, let''s apply the manifest by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a lot of output from the command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker and Puppet](img/B05468_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that happens is that Puppet will compile a catalogue, this
    is essentially a list of all the tasks that it needs to complete in order to apply
    the configuration that we have defined in the manifest file. Puppet will then
    execute these tasks. You should be able to see Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the official Docker APT repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform an `apt` update to initialize the new repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Docker and its prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the `russmckendrick/base` image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch the `helloworld` container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s check whether this happened by confirming the Docker version, look at
    the images that are downloaded, check which containers are running, and finally
    attach to the `helloworld` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To detach from the container, press *Ctrl* + *C* on your keyboard. This will
    not only return your prompt to the virtual machine, but also stop the `helloworld`
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the output I got when running the commands in the following terminal
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker and Puppet](img/B05468_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So what happens if we apply the manifest again? Let's see it by running `puppet
    apply /vagrant/docker.pp` for a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a lot less output this time, in fact, the only output you should
    see other than the warnings is the confirmation that the `helloworld` container
    has started backing up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker and Puppet](img/B05468_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an idea of how to get something basic up and running, let's
    deploy our WordPress installation. First of all, by default, our virtual machine
    has quite a limited vagrant configuration, so let's remove the virtual machine
    and bring up a more complex configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the virtual machine, type exit in your terminal until you are back
    on your local PC; once there, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once you hit Enter, you will receive a prompt asking *Are you sure you want
    to destroy the 'default' VM?*, answer yes and the virtual machine will be powered
    down and removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, replace the entire content of the file called `Vagrantfile` that can
    be found in your `ubuntu` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can also find a copy of the file in the book's GitHub repository, which
    can be found at [https://github.com/russmckendrick/extending-docker/blob/master/chapter06/puppet-docker/Vagrantfile](https://github.com/russmckendrick/extending-docker/blob/master/chapter06/puppet-docker/Vagrantfile).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have `Vagrantfile` in place, run `vagrant up` again and the virtual
    machine will boot.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between this virtual machine and the previous one that we launched
    is that it will have an IP address of `192.168.33.10`, which is only accessible
    from your local PC. The `Vagrantfile` also runs the commands to install Puppet
    and the Docker Puppet module.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the machine is booting, put a copy of the following Puppet manifest in
    your `ubuntu` folder, call it `wordpress.pp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the format itself resembles the Docker Compose file we used
    to launch our WordPress installation back in [Chapter 2](ch02.html "Chapter 2. Introducing
    First-party Tools"), *Introducing First-party Tools*. Once the virtual machine
    has booted, connect to it, and apply the `wordpress.pp` manifest by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, you will see quite a bit of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker and Puppet](img/B05468_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the manifest has been applied, you should be able to point your browser
    to the IP address at `http:// 192.168.33.10/` or use the following URL at [http://docker.media-glass.es/](http://docker.media-glass.es/),
    this URL resolves to the IP address configured in `Vagrantfile` and will only
    be accessible once the virtual machine is running and then manifest applied.
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can install WordPress as you have done in other chapters. Once
    you have finished, don't forget to destroy your virtual machine using the `vagrant
    destroy` command, as it will quite happily sit in the background using resources.
  prefs: []
  type: TYPE_NORMAL
- en: So, there you have it, a very basic practical introduction to running Puppet
    and Docker together.
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced Puppet example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been running Puppet on a single virtual machine, this isn't
    actually where its strengths lie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where Puppet comes into its own is when you deploy a Puppet Master server and
    have the Puppet Agents on your hosts talk to the Master. Here, you are able to
    define exactly how you want your hosts to look. For example, the following diagram
    shows a single Puppet Master server controlling four Docker nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A more advanced Puppet example](img/B05468_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we could have a Puppet manifest on the Puppet Master for each
    of the hosts, along with a manifest for configuration this is common across all
    four of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, I have Weave installed on each of the nodes, check the Puppet
    Forge at [https://forge.puppetlabs.com/](https://forge.puppetlabs.com/), there
    is a module that allows you to manage Weave called `tayzlor/weave`, this module
    alongside `garethr/docker` will allow you to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Docker on each node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Weave on each node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Weave network across all four nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage images on each node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch containers on each node and configure them to use the Weave network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the Puppet agent on each of the nodes will call back to the Puppet
    master server every 15 minutes; when it does this, it will work through the manifests
    that apply to the node. If there are any changes, these will be applied during
    the Puppet Agent run; if there are no changes to the manifests, then no action
    will be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Add to this that the Puppet configuration, including the manifests, lends itself
    really well in order to being managed by a source control and you can create some
    really useful workflows.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of this configuration is that it does not replace Docker Swarm,
    as all of the logic as to where the containers are launched is defined manually
    within each of manifest files. That's not to say that you can't launch a Swarm
    cluster using Puppet, as you can, with a little more work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not going to work through the example as we still have four more tools
    to work through in this chapter, there are plenty of resources available on the
    Puppetlabs website:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning VM**: [https://puppetlabs.com/download-learning-vm](https://puppetlabs.com/download-learning-vm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Puppet Open Source Docs**: [https://docs.puppetlabs.com/puppet/](https://docs.puppetlabs.com/puppet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more details on the two Puppet modules that I have mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker module**: [https://forge.puppetlabs.com/garethr/docker/](https://forge.puppetlabs.com/garethr/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weave module**: [https://forge.puppetlabs.com/tayzlor/weave/](https://forge.puppetlabs.com/tayzlor/weave/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A final note about Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next part of this chapter, we are going to be looking at Ansible, which
    most people, I suspect, think that it does exactly the same job as Puppet. While
    its true that there is a lot of crossover between the two, I see Ansible's strengths
    as an orchestration tool and Puppet excels at being a configuration management
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: As Puppet is a really great configuration management tool, there is the temptation
    to start bundling a Puppet Agent inside your containers, using it as part of your
    image build process, or even for real-time configuration, as the container launches.
  prefs: []
  type: TYPE_NORMAL
- en: Try to avoid this, as it may add unnecessary bloat to your containers as well
    as introduce additional processes. Remember in an ideal world, your containers
    should run a single process and be ready to work as soon as they are started.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I suspect a lot of people will be expecting an Ansible versus Puppet opening
    to this section of the chapter. In fact, as mentioned at the end of the previous
    section, while the two tools have a lot of crossover, their strengths lie in doing
    two different jobs.
  prefs: []
  type: TYPE_NORMAL
- en: They also work in completely different ways. Rather than going into the details
    now, let's jump right in and install Ansible and then launch our WordPress containers
    using an Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if, for any reason, you are not able to work through this section
    of the chapter, I have recorded a screencast to show you what happens when you
    launch the Ansible playbook, which can be found at [https://asciinema.org/a/39537](https://asciinema.org/a/39537).
  prefs: []
  type: TYPE_NORMAL
- en: Before launching our containers, we need to do a few things. The first thing
    is to install Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running OS X, I would recommend installing Ansible using Homebrew.
    Homebrew is available at [http://brew.sh/](http://brew.sh/) and can be installed
    with the following single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have followed the on-screen prompts, you should be in a position to
    install Ansible using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Ansible is installed, we need to install a certain version of the
    DigitalOcean Python library. To do this, we need to use the `pip` command. If
    you don''t have the `pip` command installed, then you need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that `pip` is installed, run the following command to install the correct
    version of the Python library we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The final thing you will need is the name of your DigitalOcean key. The Ansible
    playbook we are going to run will create one for you and upload it if you don't
    have one already configured, so if that's the case, you can skip this part.
  prefs: []
  type: TYPE_NORMAL
- en: If you do happen to have one already associated with your DigitalOcean account,
    then you will name the name of it to launch the two instances and then connect
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find this out, log in to the DigitalOcean control panel at [https://cloud.digitalocean.com/](https://cloud.digitalocean.com/)
    and click on the `cog icon` on the top right-hand side of the screen and from
    the menu that pops up, click on the **Settings** button. Once the settings page
    loads, click on the **Security** button, you should then see a list of SSH keys,
    make a note of the name you want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparation](img/B05468_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, my SSH key is creatively called `Russ Home`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to get a copy of the Ansible playbook we are going to be running. The
    code for this can be found in the `chapter06/docker-ansible` folder on the GitHub
    repository for this book, the complete URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/russmckendrick/extending-docker/tree/master/chapter06/docker-ansible](https://github.com/russmckendrick/extending-docker/tree/master/chapter06/docker-ansible)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the playbook downloaded, open your terminal and go to the `docker-ansible`
    folder. Once in there, run the following command, replacing the DigitalOcean API
    with your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are now in a position where we can run the playbook, but before we do, remember
    that this playbook will connect to your DigitalOcean account and launch two instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the playbook, run the following command and wait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It will take several minutes to run through the entire process, but what you
    should have the end of it is two Ubuntu 14.04 Droplets launched in your DigitalOcean
    account. Each droplet will have the latest version of both Docker and Weave installed,
    Weave will be configured so that the two hosts can talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: One droplet will be running our WordPress container and the second will be running
    our MySQL container, both containers will be talking to each using the cross-host
    Weave network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the task completes, you will should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparation](img/B05468_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, in my case, I can go to `http://46.101.4.247` in my browser
    to start the WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for any reason, parts of the installation fail, for example, sometimes
    droplets can take a little longer to start and won''t be available for Ansible
    to connect to when it tries to SSH to them, then don''t worry, you will be able
    to rerun the Ansible playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Ansible will also work through the entire playbook again, this time, skipping
    anything that has already been created or actioned.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not working through this example, or have problems, I have recorded
    an entire run-through of launching the playbook and then rerunning it, you can
    view this at [https://asciinema.org/a/39537](https://asciinema.org/a/39537).
  prefs: []
  type: TYPE_NORMAL
- en: The playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are quite a few parts of the playbook, as you can see from the following
    list of folders and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The main file we called when launching the playbook was the `site.yml` file,
    this defines the order which tasks in defined in the roles folder are executed.
    Let's take a look at the content of this file and the roles that are being called.
  prefs: []
  type: TYPE_NORMAL
- en: Section one
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The file itself is split into four sections, the following first section deals
    with connecting to DigitalOcean''s API from your local machine and launching the
    two Droplets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It loads the both the main `environment.yml` variables file, this is where we
    define things such as which region the droplet is being launched in, name of the
    droplets, size to use, and also which image should be launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also loads the `do.yml` file which contains your DigitalOcean API key and
    SSH keyname. If you look into the role task file in the `droplet` folder, you
    will see that along with launching the two droplets, it also creates the following
    three host groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dockerhosts`: This group contains both droplets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dockerhost01`: This contains our first droplet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dockerhost02`: This group contains the second droplet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final action that is taken at this stage is that a file is written to the
    `group_vars` folder, which contains the public IP addresses of our two droplets.
  prefs: []
  type: TYPE_NORMAL
- en: Section Two
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next section of the `site.yml` file deals with the installation of some
    basic prerequisites, Docker, and Weave on the droplets within the `dockerhosts`
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first role deals with the installation of Docker, let's take a look at what's
    going within the task file for this role.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will install curl using the `apt` package manager as we will
    need this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once curl has been installed, we will start configuring the official Docker
    APT repository by first adding the keys for the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll add the actual repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository has been added, we can do the actual installation of Docker,
    making sure that we update the cached repository list before the package is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Docker is installed, we need to ensure that the Docker daemon has
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to install the tools that Ansible will use to interact with the
    Docker daemon on our hosts, like Ansible, this is a Python program. To make sure
    that we can install it, we need to ensure that `pip`, the Python package manager,
    is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know that pip is installed, we can install the `docker-py` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This package is a Docker client written in Python and supplied by Docker itself.
    More details on the client can be found at [https://github.com/docker/docker-py](https://github.com/docker/docker-py).
  prefs: []
  type: TYPE_NORMAL
- en: This ends the first role that is called in the second section of the `site.yml`
    file. Now that Docker is installed, it's time to install Weave, this is handled
    by the `weave-install` task.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we download the weave binary from the URL defined in the `environment.yml`
    file to the filesystem path that is also defined in the `environment.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the binary downloaded, we need to see the correct read, write,
    and execute permissions on the file so that it can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to start weave and also pass it a password to enable encryption,
    the password is also defined in the `environment.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, at the end of this part of the task, we are telling Ansible
    to ignore any errors generated here. This is because, if the playbook was to be
    launched for a second time and weave was already running, it would complain saying
    that the weave router was already active. This will stop playbook from progressing
    any further, as Ansible interprets this message as a critical error.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, we have to tell Ansible to ignore what it thinks is a critical
    error here for the playbook to progress pass this stage.
  prefs: []
  type: TYPE_NORMAL
- en: Section three
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next section of the `site.yml` file performs one last piece of configuration
    before launching the containers that go to make up our WordPress installation.
    All of these roles are run on our first droplet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first role, which is called, connects the two weave networks on the two
    hosts together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the variable file that contains the IP address of our two droplets
    is loaded for the first time here and is used to get the IP address of the second
    droplet; this file, called `dyn.yml`, was created by the role that originally
    launched the two droplets.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the IP address of the second droplet, the `weave connect` command
    is executed and the configuration of the weave network is completed. We can now
    launch the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first container that we need to launch is the database container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is quite a similar syntax to Docker Compose files; however,
    there may be slight differences, so double-check the Docker pages on the Ansible
    core module documentation site to ensure that you are using the right syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `my-wordpress-database` container has been started, it means that all
    the tasks we need to execute on `dockerhost01` are completed.
  prefs: []
  type: TYPE_NORMAL
- en: Section four
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final section of the `site.yml` file connects to our second droplet and
    then launches the WordPress container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'All this role does is launch the WordPress container, again the file has close
    resemblance to the Docker Compose file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The final debug line prints the message at the end of the playbook run that
    contains the IP address of the second droplet.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Puppet, Ansible, when used with a playbook like the one we have discussed,
    can be used as a replacement for Docker Machine and Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: However, one thing you may have noticed is that unlike Puppet, we did not install
    an agent in the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: When you run an Ansible playbook, it is compiled locally, and then the compiled
    script is pushed to your target servers using SSH and then executed.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons why, during our playbook run, we have to install
    the Docker Python library on our two droplets, without which the compiled playbook
    would not have been able to launch the two containers.
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference between the two tools is that Ansible executes
    the tasks in the order you define in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The Puppet example we worked through wasn't complex enough to really demonstrate
    why this can be an issue when it comes to running Puppet manifests, but Puppet
    works using an eventual consistency concept, meaning that it may take a few manifest
    runs for your configuration to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to add requirements to Puppet manifests, for example, requiring
    XYZ to be executed after ABC has run. However, this can start to cause performance
    issues if your manifest is quite large; also, you could find yourself in a position
    where the manifest stops working altogether as Puppet is not able to successfully
    execute the manifest in the order you are defining.
  prefs: []
  type: TYPE_NORMAL
- en: This is why, in my opinion, Ansible is a lot better when it comes to orchestration
    than Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: It's situations like this where it really matters that the tasks you have defined
    are executed in the exact order you need them to run in rather than leaving it
    up to the tool you are using to figure out the most efficient way of applying
    the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To me, this is the reason you should not approach any task with an attitude
    of "I need to choose one tool and only use that for everything," you should always
    choose the tool that works for the job you want to do.
  prefs: []
  type: TYPE_NORMAL
- en: This can probably be said for a lot of the tools we are looking at in this chapter;
    rather than assessing a tool in a "this versus that" manner, we should be asking
    "this or that" or even "this and that" and not limit ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant (again)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already discovered earlier in this chapter, Vagrant can be used as
    a virtual machine manager. We have already used it to bring up a local Ubuntu
    14.04 instance using VirtualBox on our local machine; however, if we wanted to,
    we could have done this using VMware Fusion, Amazon Web Services, DigitalOcean,
    or even OpenStack.
  prefs: []
  type: TYPE_NORMAL
- en: Like Puppet and Ansible, when Docker was first released, there were a lot of
    articles published around Vagrant versus Docker. In fact, when the question was
    asked on Stack Overflow, the authors of both Vagrant and Docker weighed in on
    the question. You can read the full discussion at [http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment](http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment)
  prefs: []
  type: TYPE_NORMAL
- en: So, in what ways can Vagrant support Docker? There are two main ones we are
    going to be looking at. The first is the provisioner.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning using Vagrant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we worked out way through Puppet, we used Vagrant to launch Ubuntu 14.04
    locally using VirtualBox; as part of that, we used the Shell provisioner to install
    Puppet and deploy the Docker Puppet module. Vagrant has the following provisioners
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File**: This copies files in place onto the Vagrant host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shell**: This compiles/copies bash scripts to the host and executes them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible**: This runs an Ansible playbook either on or against the host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chef and Puppet**: There are around dozen different ways you can use Chef
    or Puppet to provision your Vagrant host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: This is what we will be using to provision our containers on the
    Vagrant host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Vagrantfile` looks really close to the one we used to deploy our Puppet
    WordPress example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this will download (if you don't have it already) and launch
    an Ubuntu 14.04 server and then provision two containers, one WordPress and one
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the host, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Provisioning using Vagrant](img/B05468_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also run the following command to open your browser and get to your
    WordPress installation screen (remember: we have launched the Vagrant host with
    a fixed local IP address, which means the following URL should resolve to your
    local installation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have already noticed one thing that happened when we launched the Vagrant
    host: we didn''t have to provide Vagrant any commands to install Docker; it took
    care of that for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, we had to launch our MySQL container before we launched our WordPress
    one. This is because we have linked our WordPress container to the MySQL one.
    If we tried to launch the WordPress container first, we would have received an
    error telling us that we are trying to reach a link that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following terminal output, you can connect to your
    Vagrant host using the `vagrant ssh` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Provisioning using Vagrant](img/B05468_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other thing you may notice is that the Docker version installed isn't the
    most up-to-date one; this is because Vagrant installs the version that is available
    in the operating system's default repository rather than the latest version provided
    by Docker in their repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Vagrant Docker provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned, there are two ways in which you can use Docker with Vagrant:
    the one we just looked at is a provisioner, and the second way is to use a provider.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what's a provider? We have already used a provider twice in this chapter
    when we launched our Docker hosts. A provider is a virtual machine process, manager,
    or API that Vagrant can make a connection to and then launch a virtual machine
    from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vagrant has the following providers built in:'
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyper-V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also a commercial plugin provided by the authors, which adds the following
    provider:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Fusion and Workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Vagrant supports custom providers, such as ones for Amazon Web Services,
    libvirt, and even LXC, for example. A full list of custom providers and other
    Vagrant plugins can be found at [http://vagrant-lists.github.io/](http://vagrant-lists.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, if you are using OS X, then you won't be able to use the Docker provider
    natively; however, Vagrant takes care of this you. Let's look at launching an
    NGINX container using the Docker provider rather than a provisioner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vagrantfile` looks a little different to the ones we have been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is split into two parts: one for a Boot2Docker virtual machine
    and the second part for the container itself. If you were to run `vagrant up`,
    you would see something like the following terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Vagrant Docker provider](img/B05468_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, as I am using OS X, Vagrant knows that I can run Docker natively,
    so it takes the first section of `Vagrantfile` and launches a Boot2Docker instance.
    Boot2Docker is the tiny Linux distribution that powers Docker Machine's default
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: Once it has downloaded the Boot2Docker Vagrant Box, it launches the virtual
    machine and maps port `22` on the virtual machine to port `2222` on our local
    PC so that we can get SSH access. Also, as defined in `Vagrantfile`, port `80`
    from the virtual machine is mapped to port `9999` on the local PC.
  prefs: []
  type: TYPE_NORMAL
- en: Its worth noting that if I were running this on a Linux PC that had Docker installed,
    then this step would have been skipped and Vagrant would have made use of my local
    Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that Boot2Docker has been started, the second part of the `Vagrantfile`
    can be run. If, like in my case, Vagrant has downloaded and launched the Boot2Docker
    Vagrant Box, then you will be asked for a password; this is because we have not
    exchanged keys with the Boot2Docker virtual machine. The password is `tcuser`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered the password, Vagrant will download the NGINX image from
    [https://hub.docker.com/r/russmckendrick/nginx/](https://hub.docker.com/r/russmckendrick/nginx/)
    and launch the container, opening port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the container has been launched, you should be able to go to the NGINX
    welcome page at `http://localhost:9999/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like, you can SSH into the Boot2Docker virtual machine, as Vagrant is
    primarily managing the container and not the Boot2Docker virtual machine. You
    will have to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, because we have not exchanged keys, you will need to enter the password,
    `tcuser`. You should then see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Vagrant Docker provider](img/B05468_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once SSHed in, you will be able to run Docker commands locally. Finally, to
    terminate both the container and virtual machine, run the following command from
    within the same folder as your `Vagrantfile` and you will see something as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![The Vagrant Docker provider](img/B05468_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will prompt you, asking whether you are sure you would like to remove the
    container and then the virtual machine; answer yes to both questions.
  prefs: []
  type: TYPE_NORMAL
- en: You must have noticed that we didn't cover our WordPress example while walking
    through the Docker provider. The reason for this is that the Docker provider functionality,
    in my opinion, is pretty much redundant now, especially as it has quite a few
    limitations that can all be easily overcome by using the provisioner or other
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: One such limitation is that it can only use port mapping; we cannot assign an
    IP address to the virtual machine. If we did, it would have silently failed and
    reverted to port mapping from the virtual machine to the host PC.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the functionality offered when launching containers doesn't feel as up
    to date and feature aligned to the latest version of Docker as the other tools
    we have been looking at so far in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, I would recommend that you look at using the provisioner rather
    than the provider if you are looking at utilizing Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been quite happily downloading prebuilt images from the Docker
    Hub to test with. Next up, we are going to be looking at creating our own images.
    Before we dive into creating images using third-party tools, we should have a
    quick look at how to go about building them in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: An application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start building our own images, we should really have an application
    to "bake" into it. I suspect you are probably getting bored of doing the same
    WordPress installation over and over again. We are going to be looking at something
    completely different.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are going to build an image that has Moby Counter installed. Moby counter
    is an application written by Kai Davenport, who describes it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A small app to demonstrate keeping state inside a docker-compose application."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The application runs in a browser and will add a Docker logo to the page wherever
    you click, the idea being that it uses a Redis or Postgres backend to store the
    number of Docker logos and their positions, which demonstrates how data can persist
    on volumes such as the ones we looked at in [Chapter 3](ch03.html "Chapter 3. Volume
    Plugins"), *Volume Plugins*. You can find the GitHub repository for the application
    at [https://github.com/binocarlos/moby-counter/](https://github.com/binocarlos/moby-counter/).
  prefs: []
  type: TYPE_NORMAL
- en: The Docker way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know a little about the application we are going to be launching,
    let's take a look at how the image would be built using Docker itself.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this part of the chapter is available from the GitHub repository
    that accompanies this book; you can find it at [https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/docker](https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dockerfile` for the basic build is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When we run the build, it will download the `russmckendrick/nodejs` image from
    the Docker Hub; this, as you may have guessed, has NodeJS installed.
  prefs: []
  type: TYPE_NORMAL
- en: Once that image has been downloaded, Docker will launch the container and add
    the content of the current working directory, which contains the Moby Counter
    code. It will then change the working directory to where the the code was uploaded
    to `/srv/app`.
  prefs: []
  type: TYPE_NORMAL
- en: It will then install the prerequisites required to run the application by issuing
    the `npm install` command; as we have set the working directory, all of the commands
    will be run from that location, meaning that the `package.json` file will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Accompanying the `Dockerfile` is a Docker Compose file, this kicks off the build
    of the Moby Counter image, downloads the official Redis image, and then launches
    the two containers, linking them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do that, we need to bring up a machine to run the build on; to do
    this, run the following command to launch a local VirtualBox-based Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the Docker host has been launched, run the following to configure
    your local Docker client to talk directly to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the host ready and client configured, run the following to
    build the image and launch the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the command, you should see something like the following output
    in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker way](img/B05468_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the application has been launched, you should be able to open your
    browser by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You will see a page that says Click to add logos, if you were to click around
    the page, Docker logos would start appearing. If you were to click on refresh,
    the logos you added would remain as the number of the logos, their position being
    stored in the Redis database.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker way](img/B05468_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To stop the containers and remove them, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Before we look into the pros and cons of using the Docker approach to building
    container images, let's look at a third-party alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Building with Packer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packer is written by *Mitchell Hashimoto* from *Hashicorp*, the same author
    as Vagrant's. Because of this, there are quite a lot of similarities in the terms
    we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Packer website has probably the best description of the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Packer is an open source tool for creating identical machine images for multiple
    platforms from a single source configuration. Packer is lightweight, runs on every
    major operating system, and is highly performant, creating machine images for
    multiple platforms in parallel. Packer does not replace configuration management
    like Chef or Puppet. In fact, when building images, Packer is able to use tools
    like Chef or Puppet to install software onto the image."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I have been using Packer since its first release to build images for both Vagrant
    and public clouds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Packer from [https://www.packer.io/downloads.html](https://www.packer.io/downloads.html)
    or, if you installed Homebrew, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have Packer installed, let's take a look at a configuration file.
    Packer configuration files are all defined in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON)** is a lightweight data-interchange
    format. It is easy for humans to read and write and for machines to parse and
    generate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file does almost exactly what our `Dockerfile` did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Again, all of the files required to build the image, along with the Docker Compose
    file to run it, are in the GitHub repository at [https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/packer](https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/packer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using the Docker Compose file to build the image, we are going
    to have to run **packer** and then import the image file. To start the build,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building with Packer](img/B05468_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once Packer has built the image, it will save a copy to the folder you initiated
    the Packer build command from; in our case, the image file is called `mobycounter.tar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the image so that we can use it, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This will import the image and name it `mobycounter`; you can check whether
    the image is available by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building with Packer](img/B05468_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have confirmed the image has been imported and is called `mobycounter`,
    you can launch a container by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you will be able to open your browser and start clicking around to place
    logos by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: While there may not seem to be much difference, let's take a look at what's
    going on under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Packer versus Docker Build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go into detail about the difference between the two methods of building
    images, let's try running Packer again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time though, let''s to try and reduce the image size: rather than using
    the `russmckendrick/nodejs` image, which has nodejs preinstalled, let''s use the
    base image that this was built on, `russmckendrick/base`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This image just has bash installed; install NodeJS and the application using
    Packer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added a few more commands to the shell provisioner;
    these use Alpine Linux's package manager to perform an update, install nodejs,
    configure the application, and finally, clean both the apk and npm caches.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like, you can build the image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This will leave us with two image files. I also exported a copy of the container
    we built using the `Dockerfile` using the following command while the container
    was running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'I now have three image files, and all three are running the same application,
    with the same software stack installed, using as close to the same commands as
    possible. As you can see from the following list of file sizes, there is a difference
    in the image size:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile** (using `russmckendrick/nodejs`) = 52 MB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packer** (using `russmckendrick/nodejs`) = 47 MB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packer** (installing the full stack using packer) = 40 MB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 MB may not seem like a lot, but when you are dealing with an image that is
    only 52 MB big, that's quite a decent saving.
  prefs: []
  type: TYPE_NORMAL
- en: So why is there a difference? Let's start by discussing the way in which Docker
    images work.
  prefs: []
  type: TYPE_NORMAL
- en: They are essentially made up of layers of changes on top of a base. When we
    built our first image using the `Dockerfile`, you may have noticed that each line
    of the `Dockerfile` generated a different step in the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each step is actually Docker starting a new filesystem layer to store the changes
    for that step of the build. So, for example, when our `Dockerfile` ran, we had
    six filesystem layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The first layer contains the base operating system along with the layers on
    which NodeJS is installed, and the second layer contains the files for the application
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The third layer just contains the metadata for setting the `workdir` variable;
    next up, we have the layer that contains the NodeJS dependencies for the application.
    The fifth and sixth layers just contain the metadata needed to configure which
    ports are exposed and what the "entry point" is.
  prefs: []
  type: TYPE_NORMAL
- en: As each of these layers is effectively a separate archive within the image file,
    we also have the additional overhead of these archives within our image file.
  prefs: []
  type: TYPE_NORMAL
- en: A better example of how the layers work is to look at some of the most popular
    images from the Docker Hub in the ImageLayers website, which can be found at [https://imagelayers.io/](https://imagelayers.io/).
  prefs: []
  type: TYPE_NORMAL
- en: This site is a tool provided by Century Link Labs ([https://labs.ctl.io/](https://labs.ctl.io/))
    to visualize Docker images that have been built from a `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following screenshot, some of the official images are
    quite complex and also quite large:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packer versus Docker Build](img/B05468_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can view the previous page at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://imagelayers.io/?images=java:latest,golang:latest,node:latest,python:latest,php:latest,ruby:latest](https://imagelayers.io/?images=java:latest,golang:latest,node:latest,python:latest,php:latest,ruby:latest).'
  prefs: []
  type: TYPE_NORMAL
- en: Even while the official images should be getting smaller thanks to Docker hiring
    the creator of Alpine Linux and moving the official images over to the smaller
    base operating system (check out the following hacker news post for more information
    [https://news.ycombinator.com/item?id=11000827](https://news.ycombinator.com/item?id=11000827)),
    it does not change the amount of layers required for each image. It's also worth
    pointing out that each image can have a maximum of 127 layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does Packer do differently? Rather than creating a separate filesystem
    layer for each step, it produces only two: the first layer is the base image you
    define, and the second one is everything else—this is where our space savings
    come in.'
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage of using Packer over Dockfiles is that you can reuse your
    scripts. Imagine you were doing your local development work using Docker but when
    you launched into production, you for one reason or another had to launch on one
    of the containerized virtual machines. Using Packer, you can do exactly that knowing
    that you could actually use the same set of build scripts to bootstrap your virtual
    machines as you did for your development containers.
  prefs: []
  type: TYPE_NORMAL
- en: As I have already mentioned, I have been using Packer for a while and it helps
    to no end to have a single tool that you can use to target different platforms
    with the same set of build scripts. The consistency this approach brings is well
    worth the initial effort of learning a tool such as Packer as you will end up
    saving a lot of time in the long run; it also helps with eliminating the whole
    "worked in development" meme we discussed at the start of [Chapter 1](ch01.html
    "Chapter 1. Introduction to Extending Docker"), *Introduction to Extending Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: There are some downsides to using this approach, which may put some people off.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest one in my opinion is that while you are able to push the final image
    automatically to the Docker Hub, you will not be able to add it as an automated
    build.
  prefs: []
  type: TYPE_NORMAL
- en: This means that while it may be available for people to download, it might not
    be considered trusted as people cannot see exactly what has been added to the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the lack of support for metadata—functions that configure runtime
    options such as exposing ports and the command executed by default when the container
    launches are not currently supported.
  prefs: []
  type: TYPE_NORMAL
- en: While this can be seen as a drawback, it is easily overcome by defining what
    you would have defined in your `Dockerfile` in a Docker Compose file or passing
    the information directly using the `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: Image summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, to summarize, if you need to build not only container images but also target
    different platforms, then Packer is exactly the tool you are after. If it's just
    container images you need to build, then you may be better off sticking with the
    `Dockerfile` build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other tools we have looked at in this chapter, such as Ansible
    and Puppet, also support building images by issuing a `docker build` command against
    a `Dockerfile`, so there are plenty of ways to build that into your workflow,
    which leads us to the next tool we are going be looking at: Jenkins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let''s quickly just double-check that you are not running
    any Docker hosts. To do this, run the following commands to check for any Docker
    hosts and then remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to only remove hosts that you are using for following along with
    this book; don't remove any you are using for you own projects!
  prefs: []
  type: TYPE_NORMAL
- en: Serving up Docker with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is quite a big topic to cover in a small section of a single chapter,
    so the walkthrough is going to be really basic and will only deal with building
    and launching containers.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to note is that I am going to be covering Jenkins 2.0; at the
    time of writing this, the first beta has just been released, which means that
    while things may change slightly as themes and such are refined, all of the features
    and basic functionality are locked in.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for covering Jenkins 2.0 rather than the Jenkins 1.x branch is that
    as far as Jenkins is concerned, Docker is now a first-class citizen, meaning that
    it fully supports and embraces the Docker way of working. A full overview of the
    current status of Jenkins 2.0 can be found at [https://jenkins.io/2.0/](https://jenkins.io/2.0/).
  prefs: []
  type: TYPE_NORMAL
- en: So what is Jenkins? Jenkins is an open source continuous integration tool written
    in Java, and it has a lot of uses.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I am really late to the Jenkins party; being from an operations
    background, I have always just shrugged it off a tool used for running unit tests
    on code; however, as I have moved more into orchestration and automation, I am
    finding the need for a tool that can run tasks based on the results of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I have already mentioned, I am not going to go into much detail about the
    testing side of Jenkins; there are plenty of resources that cover this functionality,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mastering Jenkins* by Jonathan McAllister'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jenkins* *Continuous Integration Cookbook* by Alan Mark Berg'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are both available from [https://www.packtpub.com/](https://www.packtpub.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than running it locally, let''s launch a DigitalOcean droplet and install
    Jenkins there. First off, we need to use Docker Machine to launch the droplet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Once the droplet has been launched, we don't need to bother configuring our
    local Docker client to talk on the droplet by running the Docker engine as Jenkins
    will be handling everything to do with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we need Jenkins to run Docker, we will need to install it directly
    on our droplet rather than run it as a container; first of all, we will need to
    SSH onto the droplet. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the droplet, we need to install Docker Compose, Jenkins, and all of
    its prerequisites. Let''s start by installing Docker Compose. I have written a
    quick script to do this, which can be executed by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have Docker Compose installed, it's time to install Jenkins. As
    version 2 is currently in beta, it is not in any of the main repositories yet;
    however, there is a DEB package for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, we need to download a local copy and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the `gdebi` tool, which we will then use to install Jenkins
    and its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Jenkins is installed, we need to add the Jenkins user to the Docker
    group so that the user has permissions to interact with Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to ensure that Jenkins picks up that it has been added to the group,
    we need to restart it using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now open your browser to complete the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When your browser opens, you should be greeted with a screen that looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For security reasons, when the Jenkins container was launched, a random string
    was generated; before you can proceed with the installation, Jenkins requires
    you to confirm what this string is. You can find it out by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can quit `less` by pressing the *Q* key.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is a most welcome one as not securing your Jenkins installation
    correctly from the start can have quite bad implications, as I found out when
    a third party hijacked a test Jenkins 1.x installation I had up running and forgotten
    about—whoops!
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered the initial admin password, click on the **Continue**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next page you come to will ask you which plugins you would like to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our purposes, just click on **Install suggested Plugins**, which is highlighted.
    The next page will show you the progress of the suggested plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will take a minute or two to complete. Once it has completed, you will be
    asked to create a Jenkins user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As I have already mentioned, it''s important to secure your Jenkins installation
    from the start, so I recommend you don''t skip this step. Once you have filled
    in the requested information, click on the **Save and Finish** button. If all
    has gone well, you will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All you have to do now is click on **Start using Jenkins** and you will be
    logged in and taken to the start screen, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This installation process is one of the many improvements that Jenkins 2 brings
    to the table; earlier, you would have had to install Jenkins and then manually
    work through several wizards and procedures to both secure and configure the software,
    which as I have already mentioned can have bad consequences if you don't get it
    right.
  prefs: []
  type: TYPE_NORMAL
- en: The final step of the setup is to install the CloudBees Docker Pipeline plugin;
    to do this, click on the **Manage Jenkins** button from the left-hand side menu,
    and then click on **Manage Plugins** button.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a new installation, you will probably see a message about plugins
    being updated at some point. Ignore the request to restart Jenkins; we will be
    doing this as part of the installation.
  prefs: []
  type: TYPE_NORMAL
- en: There are four tabs on the main screen; click on **Available** button and you
    will be presented with a list of all of the Jenkins plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In the top right-hand portion of the main screen, there is a search box labelled
    **Filter**. Type in `Docker Pipeline` here, and you should receive one result.
    Tick the install box and then click on the **Download now and install after restart**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It will take a minute or two to restart Jenkins; after it has started back up,
    you will be prompted to log back in using the credentials you provided during
    the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have Jenkins installed and configured, it's time to add our pipeline.
    To do this, we need an application to add.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a sample application based on Moby Counter available at the following
    GitHub repository: `https://github.com/russmckendrick/jenkins-docker-example/tree/master`.
    The main page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an application](img/B05468_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we add the application, it is best that you fork the code, as we will
    be making changes to the codebase later on. To do this, click on the **Fork**
    button in the top right of the screen. You will be asked where you want to fork
    the repository. Once you have forked it, make a note of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: As I own the repository, I was not able to fork it. Because of this, I have
    created a copy called `jenkins-pipeline`, so you will see references to this in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that Jenkins is configured and we have a GitHub repository that contains
    the application, we would like to deploy. It's time to roll our sleeves up and
    configure the pipeline within Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: To start, click on the **create new jobs** button on the main page, you will
    be taken to a screen that has several options on it, enter the name of the pipeline
    in the top box.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am calling mine `Docker Pipeline`, and then click on **Pipeline** button.
    You should see a small box that says **OK** button at the bottom of the screen,
    click on the **OK** button to create the pipeline, which will take you to the
    configuration screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will now be on the pipeline configuration screen, as you can see, there
    are a lot of options. We are going to be keeping things really simple and will
    be just adding a pipeline script. The script looks similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you add the script to the Pipeline section of the configuration page,
    replace the Git URL with the one of your own repository. Leave all the other options
    as they are and click on the **Save** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s it, our pipeline is now configured. We have told Jenkins to perform
    the following three tasks each time a build is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkout**: This downloads the latest code for our application from your
    GitHub repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: This uses `Dockerfile` that is in the GitHub repository to build
    the `Mobycounter` image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy**: This runs a script that clears down any currently running containers
    and then uses the included Docker Compose file to relaunch the application. When
    launching Redis, the Docker Compose file uses the built-in volume driver for `/data`,
    meaning that the position of the Docker logos will persist between the containers
    being relaunched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To trigger a build, click on the **Build Now** button option on the left-hand
    side menu. If everything goes well, you should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, all three tasks are executed without error. You should be able
    to see the application by opening your browser using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Place some logos to test that everything is working as expected, and that''s
    it, you have deployed your application using Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hold on a minute—there is a problem! As you may have already noticed, the page
    title is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and fix that. To do so, navigate to the following page in your
    GitHub repository: `your-github-repo` | `src` | `client` | `index.html`. From
    here, click on the **Edit** button. Once in the editing screen, update the title
    between the `<title>` and `</title>` tags, and then click on the **Commit changes**
    button.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have updated your application code, go back to Jenkins and click
    on **Build Now** again. This will trigger a second build, which will deploy the
    changes we made in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the second browser tag in the previous screenshot, the title
    of our application has changed and the second build was successful. If you refresh
    your application window, you should see that your title has been updated and the
    Docker logos are where you left them.
  prefs: []
  type: TYPE_NORMAL
- en: A few other things to note are that that the second build confirms that there
    is one commit difference between our initial build and the current one. Also,
    the build itself took less time than our original build; this is because Docker
    didn't have to download the base image for a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view logs for each task by hovering your mouse over the stage you want
    to see the logs for and clicking on the **Logs** link. This will make a dialog
    pop up with the logs for the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also look at the full console output for each build by clicking on
    the build number, say `#2`, in the left-hand side menu and then clicking on the
    **Console Output** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is useful if your build has errors. Try clicking on some of the options,
    such as **Docker Fingerprints** and **Changes**, to look at the other information
    that is recorded during each build.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the main Jenkins page, you should see a quick summary of your
    builds. You should also see a sun icon next to your pipeline, meaning that everything
    is OK.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What if everything wasn't okay with the second build? Consider that we had made
    a syntax error within the Dockerfile when we edited the page title, what would
    have happened?
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins would have checked the update files from GitHub, started the build of
    the updated image, detected the error, and then failed. As this stage would have
    given an error, the deploy stage would not have been executed, meaning that our
    application would still be running in its current state, wrong title and all.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Jenkins' strength lies, if you configure enough tests with both
    your code and deployment pipelines, you can stop any potential service affecting
    changes being deployed, it also records enough information to be an extremely
    valuable resource when it comes to tracking down errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, we have only touched the tip of the iceberg when it
    comes to Jenkins, there is a lot of functionality we haven't covered as it is
    out of scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, from the little we have discussed, I hope you can see the value of
    using a continuous integration and deployment platform such as Jenkins to help
    build and deploy your containers and code. Don't be late to the party like I was,
    if you deploy any type of code, then consider using Jenkins to assist you, don't
    wait until you have deployed a serious application-breaking bug.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common thread among all the tools we have looked at in this chapter is that
    they all quickly evolved to offer support for Docker, filling in gaps in functionality,
    which was missing from the core Docker toolset.
  prefs: []
  type: TYPE_NORMAL
- en: Over the past 12 months, the rapid development of Docker has meant that some
    of these tools may not necessarily be required any more.
  prefs: []
  type: TYPE_NORMAL
- en: However, as they all provide a wide range of functionality outside of Docker,
    it means that they can still be a valuable part of your day-to-day workflow should
    Docker only be one of the technologies you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: There is one thing using that the tools in this chapter does not provide and
    that's some intelligence around where your containers are launched, you still
    have to instruct the tools to *place container A on Docker host Z*.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will be looking at schedulers that make the decision
    as to where a container should be launched for you, based on host availability,
    utilization, and other rules such as *don't place Container A on the same host
    as Container B*, meaning that you are no longer confined to a fixed infrastructure.
  prefs: []
  type: TYPE_NORMAL
