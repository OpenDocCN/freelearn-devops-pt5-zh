- en: Chapter 6. Extending Your Infrastructure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 扩展你的基础设施
- en: 'In [Chapter 2](ch02.html "Chapter 2. Introducing First-party Tools"), *Introducing
    First-party Tools*, we looked at the tools Docker provides for extending the functionality
    of the core Docker engine. In this chapter, we will look at third-party tools
    that extend the way you manage your Docker configuration and build and launch
    containers. The tools that we are going to be discussing are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章：介绍第一方工具")，*介绍第一方工具*中，我们介绍了Docker提供的用于扩展核心Docker引擎功能的工具。在本章中，我们将介绍一些第三方工具，这些工具扩展了管理Docker配置、构建和启动容器的方式。我们将讨论的工具如下：
- en: '**Puppet**: [http://puppetlabs.com/](http://puppetlabs.com/)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Puppet**: [http://puppetlabs.com/](http://puppetlabs.com/)'
- en: '**Ansible**: [http://www.ansible.com/docker/](http://www.ansible.com/docker/)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible**: [http://www.ansible.com/docker/](http://www.ansible.com/docker/)'
- en: '**Vagrant**: [https://docs.vagrantup.com/v2/docker/](https://docs.vagrantup.com/v2/docker/)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vagrant**: [https://docs.vagrantup.com/v2/docker/](https://docs.vagrantup.com/v2/docker/)'
- en: '**Packer**: [https://www.packer.io/docs/builders/docker.html](https://www.packer.io/docs/builders/docker.html)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Packer**: [https://www.packer.io/docs/builders/docker.html](https://www.packer.io/docs/builders/docker.html)'
- en: '**Jenkins**: [https://jenkins-ci.org/content/jenkins-and-docker/](https://jenkins-ci.org/content/jenkins-and-docker/)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**: [https://jenkins-ci.org/content/jenkins-and-docker/](https://jenkins-ci.org/content/jenkins-and-docker/)'
- en: For each of the tools, we will look at how to install, configure, and use them
    with Docker. Before we look at how to use the tools, let's discuss why we would
    want to use them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个工具，我们将讨论如何安装、配置和使用它们与Docker一起使用。在讨论如何使用这些工具之前，让我们先讨论一下为什么我们会想要使用它们。
- en: Why use these tools?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用这些工具？
- en: So far, we have been looking at tools that either use the main Docker client
    or use the tools that are provided by Docker and other third parties to support
    the main Docker client.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在关注那些使用主Docker客户端或使用Docker和其他第三方提供的工具来支持主Docker客户端的工具。
- en: For quite a while, the functionality that some of these tools have now did not
    exist within a Docker support product. For example, if you wanted to launch a
    Docker host, you couldn't just use Docker Machine, instead you had to use something
    such as Vagrant to launch a virtual machine (locally or in the cloud) and then
    install Docker using a bash script, Puppet, or Ansible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间，这些工具所拥有的功能在Docker支持产品中并不存在。例如，如果你想启动一个Docker主机，你不能仅仅使用Docker Machine，而是必须使用像Vagrant这样的工具来启动虚拟机（本地或在云中），然后使用bash脚本、Puppet或Ansible来安装Docker。
- en: Once you had your Docker host up and running, you could use these tools to place
    your containers on hosts as there was no Docker Swarm or Docker Compose (remember
    Docker Compose started off as a third-party tool called Fig).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动了Docker主机，你就可以使用这些工具将容器放置在主机上，因为当时还没有Docker Swarm或Docker Compose（记住，Docker
    Compose最初是一个名为Fig的第三方工具）。
- en: So while Docker has slowly been releasing their own tooling, some of these third-party
    options are actually more mature and have quite an active community behind them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，虽然Docker慢慢发布了他们自己的工具，但一些第三方选项实际上更为成熟，并且有一个相当活跃的社区支持它们。
- en: Let's start by looking at Puppet.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Puppet开始。
- en: Puppetize all the things
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppetize all the things
- en: 'Long before the following *Containerize all the things* meme regularly started
    to pop up in people''s presentations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，在以下的*把所有东西容器化*迷因开始频繁出现在人们的演示文稿中之前：
- en: '![Puppetize all the things](img/B05468_06_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Puppetize all the things](img/B05468_06_01.jpg)'
- en: People were saying the same thing about Puppet. So, what is Puppet and why would
    you want to use it on all things?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 人们也在谈论关于Puppet的同样问题。那么，Puppet是什么？为什么你要把它应用于所有事物？
- en: 'Puppet Labs, the makers of Puppet, describe Puppet as:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Labs（Puppet的开发者）将Puppet描述为：
- en: '*"With Puppet, you define the state of your IT infrastructure, and Puppet automatically
    enforces the desired state. Puppet automates every step of the software delivery
    process, from provisioning of physical and virtual machines to orchestration and
    reporting; from early-stage code development through testing, production release
    and updates."*'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“使用Puppet，你可以定义IT基础设施的状态，Puppet会自动强制执行所需的状态。Puppet自动化了软件交付过程的每一步，从物理和虚拟机器的配置到编排和报告；从早期的代码开发到测试、生产发布和更新。”*'
- en: 'Before tools such as Puppet, working as a sysadmin could sometimes be quite
    a tedious process: if you weren''t looking into problems, you were writing your
    own scripts to bootstrap servers once they had been built, or even worse, you
    were copying and pasting commands from an internal wiki to install your software
    stack and configure it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 等工具之前，作为系统管理员的工作有时会变得相当繁琐：如果你没有在处理问题，就得自己编写脚本来引导已经建好的服务器，或者更糟糕的是，你需要从内部
    Wiki 中复制粘贴命令来安装和配置你的软件堆栈。
- en: Servers would very quickly evolve away from your initial installation and when
    they broke, which all servers eventually do, things could get really interesting,
    complicated, scary, very bad, or all of them quickly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器很快就会与最初的安装配置脱节，当它们出现故障时（所有服务器最终都会故障），事情可能会变得非常复杂、棘手、可怕、糟糕，甚至是所有这些情况迅速发生。
- en: This is where Puppet comes in; you define what you need your server to look
    like and Puppet does the heavy lifting for you, making sure that your configuration
    is not only applied, but also maintained.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Puppet 发挥作用的地方；你定义所需的服务器配置，Puppet 为你完成繁重的工作，确保你的配置不仅被应用，而且还会被持续维护。
- en: 'For example, if I had several servers behind a load balancer for my PHP-powered
    website, it''s important that the servers are all configured in the same way,
    meaning that they all have the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我有几个服务器位于负载均衡器后面，提供我的 PHP 网站服务，那么确保这些服务器配置一致非常重要，这意味着它们都应该具备以下内容：
- en: The same NGINX or Apache configuration
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的 NGINX 或 Apache 配置
- en: The same version of PHP along with the same configuration
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同版本的 PHP 以及相同的配置
- en: The same PHP modules installed, at the same version
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装相同版本的 PHP 模块
- en: To do this before Puppet, I would have to ensure that not only I kept a script
    that is used to do the initial installation, but I would also have to carefully
    manually apply the same configuration changes across the servers or write a script
    to synchronize my changes across the cluster.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 之前，我必须确保不仅保留一个用于初始安装的脚本，而且还必须小心手动地将相同的配置更改应用到所有服务器，或者编写一个脚本来同步集群中的更改。
- en: I would also have to ensure that anyone who has access to the servers adheres
    to the processes and procedures I have put in place in order to maintain consistency
    across my load balanced web servers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我还必须确保任何有权访问服务器的人都遵循我制定的流程和操作程序，以便在我的负载均衡 Web 服务器之间保持一致性。
- en: If they didn't, I would start to get configuration drift, or worse, still one
    in every x requests could be being served from a server that is running a different
    codebase/configuration from the other machines.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些，我就会开始出现配置漂移，或者更糟的是，每 x 次请求中，可能有一次是从运行着与其他服务器不同的代码库/配置的服务器上提供的。
- en: 'With Puppet, if I need to run an up-to-date version of PHP 5.6 because my application
    doesn''t work correctly under PHP 7, then I can use the following definition to
    ensure that my requirements are met:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet，如果我需要运行最新版本的 PHP 5.6，因为我的应用程序在 PHP 7 下无法正常工作，那么我可以使用以下定义来确保满足我的需求：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will make sure that the `php` package is installed and that the version
    is and stays at 5.6, I can then take this single configuration and apply it across
    all of my web servers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保 `php` 包被安装，并且版本保持在 5.6，我可以将这个单一配置应用到我的所有 Web 服务器上。
- en: So, what's this got to do with Docker?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这与 Docker 有什么关系呢？
- en: Docker and Puppet
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 和 Puppet
- en: Before Docker Machine, Docker Compose, and Docker Swarm, I used Puppet to bootstrap
    and manage my Docker hosts and containers. Let's take a look at the excellent
    Docker Puppet module written by Gareth Rushgrove.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Machine、Docker Compose 和 Docker Swarm 之前，我使用 Puppet 来引导和管理我的 Docker
    主机和容器。让我们来看看 Gareth Rushgrove 编写的优秀 Docker Puppet 模块。
- en: To start off, we need a virtual machine to work on. In the previous chapters,
    we have been using Docker Machine to launch virtual machines that we can run our
    containers on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个虚拟机来工作。在前面的章节中，我们一直在使用 Docker Machine 启动虚拟机，以便运行我们的容器。
- en: However, as we want Puppet to manage the installation of Docker and the container
    on which we are going to be launching a local virtual machine using Vagrant, confusingly,
    we are also going to be looking at Vagrant later in this chapter, so we will not
    go into much detail here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们希望 Puppet 管理 Docker 的安装以及我们将使用 Vagrant 启动本地虚拟机的容器一样，令人困惑的是，我们稍后将在本章中也提到
    Vagrant，因此在这里我们不做过多详细讲解。
- en: First of all, you need to ensure that you have Vagrant installed, you can get
    the latest release from [https://www.vagrantup.com/](https://www.vagrantup.com/)
    and you can find a guide to perform the installation at [https://www.vagrantup.com/docs/getting-started/](https://www.vagrantup.com/docs/getting-started/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确保已经安装了 Vagrant，你可以从 [https://www.vagrantup.com/](https://www.vagrantup.com/)
    获取最新版本，并且可以在 [https://www.vagrantup.com/docs/getting-started/](https://www.vagrantup.com/docs/getting-started/)
    找到安装指南。
- en: 'Once you have Vagrant installed, you can a launch an Ubuntu 14.04 virtual server
    using VirtualBox by running the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Vagrant，你可以通过运行以下命令，使用 VirtualBox 启动一个 Ubuntu 14.04 虚拟服务器：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will download and launch the virtual server, storing everything in the
    `ubuntu` folder. It will also mount the `ubuntu` folder as a filesystem share
    using the `/vagrant` path:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并启动虚拟服务器，将所有内容存储在 `ubuntu` 文件夹中。它还会使用 `/vagrant` 路径将 `ubuntu` 文件夹挂载为文件系统共享：
- en: '![Docker and Puppet](img/B05468_06_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 和 Puppet](img/B05468_06_02.jpg)'
- en: 'Now that we have our virtual server up and running, let''s connect to it and
    install the Puppet agent:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让虚拟服务器启动并运行，让我们连接到它并安装 Puppet 代理：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see something similar to the following terminal session:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于以下的终端会话：
- en: '![Docker and Puppet](img/B05468_06_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 和 Puppet](img/B05468_06_03.jpg)'
- en: 'Now that we have the Puppet agent installed, the final step is to install the
    Docker module from Puppet Forge:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Puppet 代理，最后一步是从 Puppet Forge 安装 Docker 模块：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You may see warnings such as the one in the following terminal session; don''t
    worry about these, they are to just inform you of the upcoming changes to Puppet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到以下终端会话中的警告信息；不必担心这些，它们只是为了告知你即将进行的 Puppet 更改：
- en: '![Docker and Puppet](img/B05468_06_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 和 Puppet](img/B05468_06_04.jpg)'
- en: 'At this point, it''s worth point out that we haven''t actually installed Docker
    yet, so let''s do that now by running our first puppet manifest. On your local
    machine, create a file called `docker.pp` in the `ubuntu` folder. The file should
    contain the following contents:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，值得指出的是，我们还没有实际安装 Docker，所以现在通过运行我们的第一个 Puppet 清单来安装它。在你的本地机器上，在 `ubuntu`
    文件夹中创建一个名为 `docker.pp` 的文件，文件内容应如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we run this manifest using `puppet apply`, Puppet will know that we need
    Docker installed to be able download the `russmckendrick/base` image and then
    launch the `helloworld` container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `puppet apply` 运行这个清单时，Puppet 会知道我们需要安装 Docker，才能下载 `russmckendrick/base`
    镜像并启动 `helloworld` 容器。
- en: 'Back on our virtual machine, let''s apply the manifest by running the following
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的虚拟机，运行以下命令应用清单：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will see a lot of output from the command, as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到命令输出大量内容，如以下截图所示：
- en: '![Docker and Puppet](img/B05468_06_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 和 Puppet](img/B05468_06_05.jpg)'
- en: 'The first thing that happens is that Puppet will compile a catalogue, this
    is essentially a list of all the tasks that it needs to complete in order to apply
    the configuration that we have defined in the manifest file. Puppet will then
    execute these tasks. You should be able to see Puppet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先发生的事情是 Puppet 会编译一个清单，这本质上是一个任务清单，列出了它需要完成的所有任务，以便应用我们在清单文件中定义的配置。然后，Puppet
    会执行这些任务。你应该能看到 Puppet：
- en: Add the official Docker APT repository
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加官方 Docker APT 仓库
- en: Perform an `apt` update to initialize the new repository
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `apt` 更新以初始化新仓库
- en: Install Docker and its prerequisites
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker 及其依赖
- en: Download the `russmckendrick/base` image
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载 `russmckendrick/base` 镜像
- en: Launch the `helloworld` container
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 `helloworld` 容器
- en: 'Let''s check whether this happened by confirming the Docker version, look at
    the images that are downloaded, check which containers are running, and finally
    attach to the `helloworld` container:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过确认 Docker 版本、查看下载的镜像、检查正在运行的容器，最后连接到 `helloworld` 容器来检查是否成功：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To detach from the container, press *Ctrl* + *C* on your keyboard. This will
    not only return your prompt to the virtual machine, but also stop the `helloworld`
    container:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要从容器中分离，按下键盘上的 *Ctrl* + *C*。这不仅会将提示符返回到虚拟机，还会停止 `helloworld` 容器：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see the output I got when running the commands in the following terminal
    session:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我在运行命令时获得的输出，如以下终端会话所示：
- en: '![Docker and Puppet](img/B05468_06_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 和 Puppet](img/B05468_06_06.jpg)'
- en: So what happens if we apply the manifest again? Let's see it by running `puppet
    apply /vagrant/docker.pp` for a second time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果我们再次应用这个清单会发生什么呢？让我们通过第二次运行 `puppet apply /vagrant/docker.pp` 来看看。
- en: 'You should see a lot less output this time, in fact, the only output you should
    see other than the warnings is the confirmation that the `helloworld` container
    has started backing up:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你应该看到的输出会少很多，实际上，除了警告信息，你应该看到的唯一输出是确认`helloworld`容器已经开始备份：
- en: '![Docker and Puppet](img/B05468_06_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 和 Puppet](img/B05468_06_07.jpg)'
- en: Now that we have an idea of how to get something basic up and running, let's
    deploy our WordPress installation. First of all, by default, our virtual machine
    has quite a limited vagrant configuration, so let's remove the virtual machine
    and bring up a more complex configuration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何启动一些基本的东西，接下来让我们部署 WordPress 安装。首先，默认情况下，我们的虚拟机配置相对简单，因此让我们先移除虚拟机并启动一个更复杂的配置。
- en: 'To remove the virtual machine, type exit in your terminal until you are back
    on your local PC; once there, type the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除虚拟机，请在终端中输入exit，直到你返回到本地 PC；到达后，输入以下命令：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you hit Enter, you will receive a prompt asking *Are you sure you want
    to destroy the 'default' VM?*, answer yes and the virtual machine will be powered
    down and removed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你按下 Enter，系统会提示 *你确定要销毁 'default' 虚拟机吗？*，回答 yes，虚拟机将被关闭并移除。
- en: 'Next, replace the entire content of the file called `Vagrantfile` that can
    be found in your `ubuntu` folder:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，替换 `ubuntu` 文件夹中名为 `Vagrantfile` 的文件的全部内容：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can also find a copy of the file in the book's GitHub repository, which
    can be found at [https://github.com/russmckendrick/extending-docker/blob/master/chapter06/puppet-docker/Vagrantfile](https://github.com/russmckendrick/extending-docker/blob/master/chapter06/puppet-docker/Vagrantfile).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在本书的 GitHub 仓库中找到该文件的副本，仓库地址是：[https://github.com/russmckendrick/extending-docker/blob/master/chapter06/puppet-docker/Vagrantfile](https://github.com/russmckendrick/extending-docker/blob/master/chapter06/puppet-docker/Vagrantfile)。
- en: Once you have `Vagrantfile` in place, run `vagrant up` again and the virtual
    machine will boot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Vagrantfile` 配置好，重新运行 `vagrant up`，虚拟机将会启动。
- en: The differences between this virtual machine and the previous one that we launched
    is that it will have an IP address of `192.168.33.10`, which is only accessible
    from your local PC. The `Vagrantfile` also runs the commands to install Puppet
    and the Docker Puppet module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这台虚拟机和我们之前启动的虚拟机的不同之处在于，它的 IP 地址是`192.168.33.10`，仅能从本地 PC 访问。同时，`Vagrantfile`还会运行安装
    Puppet 和 Docker Puppet 模块的命令。
- en: 'While the machine is booting, put a copy of the following Puppet manifest in
    your `ubuntu` folder, call it `wordpress.pp`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机启动时，将以下 Puppet 清单文件放入你的 `ubuntu` 文件夹，并命名为 `wordpress.pp`：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the format itself resembles the Docker Compose file we used
    to launch our WordPress installation back in [Chapter 2](ch02.html "Chapter 2. Introducing
    First-party Tools"), *Introducing First-party Tools*. Once the virtual machine
    has booted, connect to it, and apply the `wordpress.pp` manifest by running the
    following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，格式本身类似于我们在[第 2 章](ch02.html "第 2 章：介绍第一方工具")，*介绍第一方工具*中用于启动 WordPress
    安装的 Docker Compose 文件。虚拟机启动后，连接到它，并运行以下命令以应用 `wordpress.pp` 清单：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As before, you will see quite a bit of output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你将会看到相当多的输出：
- en: '![Docker and Puppet](img/B05468_06_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 和 Puppet](img/B05468_06_08.jpg)'
- en: Once the manifest has been applied, you should be able to point your browser
    to the IP address at `http:// 192.168.33.10/` or use the following URL at [http://docker.media-glass.es/](http://docker.media-glass.es/),
    this URL resolves to the IP address configured in `Vagrantfile` and will only
    be accessible once the virtual machine is running and then manifest applied.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清单应用完毕，你应该可以通过浏览器访问 `http:// 192.168.33.10/` 或使用以下 URL：[http://docker.media-glass.es/](http://docker.media-glass.es/)，这个
    URL 会解析到 `Vagrantfile` 中配置的 IP 地址，且仅在虚拟机启动并应用清单后才可访问。
- en: From here, you can install WordPress as you have done in other chapters. Once
    you have finished, don't forget to destroy your virtual machine using the `vagrant
    destroy` command, as it will quite happily sit in the background using resources.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你可以像在其他章节中一样安装 WordPress。完成后，别忘了使用`vagrant destroy`命令销毁你的虚拟机，因为它会很高兴地在后台占用资源。
- en: So, there you have it, a very basic practical introduction to running Puppet
    and Docker together.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，到了这里，你已经获得了一个非常基础的关于如何将 Puppet 和 Docker 一起运行的实用介绍。
- en: A more advanced Puppet example
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更高级的 Puppet 示例
- en: So far, we have been running Puppet on a single virtual machine, this isn't
    actually where its strengths lie.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在单一的虚拟机上运行 Puppet，但这并不是它的强项所在。
- en: 'Where Puppet comes into its own is when you deploy a Puppet Master server and
    have the Puppet Agents on your hosts talk to the Master. Here, you are able to
    define exactly how you want your hosts to look. For example, the following diagram
    shows a single Puppet Master server controlling four Docker nodes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的优势在于当你部署 Puppet Master 服务器并让你的主机上的 Puppet Agent 与 Master 进行通信时。在这里，你能够精确地定义你希望主机的配置。例如，以下图示展示了一个
    Puppet Master 服务器控制四个 Docker 节点：
- en: '![A more advanced Puppet example](img/B05468_06_09.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![一个更高级的 Puppet 示例](img/B05468_06_09.jpg)'
- en: In this example, we could have a Puppet manifest on the Puppet Master for each
    of the hosts, along with a manifest for configuration this is common across all
    four of the nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以在 Puppet 主服务器上为每个主机创建一个 Puppet 清单，同时还可以有一个用于配置所有四个节点共有配置的清单。
- en: 'In the example, I have Weave installed on each of the nodes, check the Puppet
    Forge at [https://forge.puppetlabs.com/](https://forge.puppetlabs.com/), there
    is a module that allows you to manage Weave called `tayzlor/weave`, this module
    alongside `garethr/docker` will allow you to perform the following tasks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我已经在每个节点上安装了 Weave，你可以查看 Puppet Forge 网站 [https://forge.puppetlabs.com/](https://forge.puppetlabs.com/)，那里有一个名为
    `tayzlor/weave` 的模块，允许你管理 Weave。这个模块和 `garethr/docker` 一起，可以帮助你完成以下任务：
- en: Install Docker on each node
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上安装 Docker
- en: Install Weave on each node
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上安装 Weave
- en: Create a Weave network across all four nodes
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有四个节点之间创建一个 Weave 网络
- en: Manage images on each node
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理每个节点上的镜像
- en: Launch containers on each node and configure them to use the Weave network
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上启动容器，并配置它们使用 Weave 网络
- en: By default, the Puppet agent on each of the nodes will call back to the Puppet
    master server every 15 minutes; when it does this, it will work through the manifests
    that apply to the node. If there are any changes, these will be applied during
    the Puppet Agent run; if there are no changes to the manifests, then no action
    will be taken.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个节点上的 Puppet agent 会每 15 分钟回调到 Puppet 主服务器；当它回调时，它会处理适用于该节点的清单。如果有任何更改，这些更改将在
    Puppet Agent 运行时应用；如果清单没有更改，则不会执行任何操作。
- en: Add to this that the Puppet configuration, including the manifests, lends itself
    really well in order to being managed by a source control and you can create some
    really useful workflows.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，Puppet 配置（包括清单文件）非常适合使用源代码控制进行管理，这样你可以创建一些非常有用的工作流程。
- en: The only downside of this configuration is that it does not replace Docker Swarm,
    as all of the logic as to where the containers are launched is defined manually
    within each of manifest files. That's not to say that you can't launch a Swarm
    cluster using Puppet, as you can, with a little more work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置的唯一缺点是它并不能替代 Docker Swarm，因为所有有关容器启动位置的逻辑都在每个清单文件中手动定义。并不是说不能使用 Puppet 启动一个
    Swarm 集群，你可以，只是需要更多的工作。
- en: 'We are not going to work through the example as we still have four more tools
    to work through in this chapter, there are plenty of resources available on the
    Puppetlabs website:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讲解这个例子，因为在这一章中我们还有四个工具要介绍，Puppetlabs 网站上有很多资源可以参考：
- en: '**Learning VM**: [https://puppetlabs.com/download-learning-vm](https://puppetlabs.com/download-learning-vm)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习虚拟机**: [https://puppetlabs.com/download-learning-vm](https://puppetlabs.com/download-learning-vm)'
- en: '**Puppet Open Source Docs**: [https://docs.puppetlabs.com/puppet/](https://docs.puppetlabs.com/puppet/)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Puppet 开源文档**: [https://docs.puppetlabs.com/puppet/](https://docs.puppetlabs.com/puppet/)'
- en: 'You can find more details on the two Puppet modules that I have mentioned:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到更多关于我提到的两个 Puppet 模块的详细信息：
- en: '**Docker module**: [https://forge.puppetlabs.com/garethr/docker/](https://forge.puppetlabs.com/garethr/docker/)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 模块**: [https://forge.puppetlabs.com/garethr/docker/](https://forge.puppetlabs.com/garethr/docker/)'
- en: '**Weave module**: [https://forge.puppetlabs.com/tayzlor/weave/](https://forge.puppetlabs.com/tayzlor/weave/)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Weave 模块**: [https://forge.puppetlabs.com/tayzlor/weave/](https://forge.puppetlabs.com/tayzlor/weave/)'
- en: A final note about Puppet
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 Puppet 的最后一点说明
- en: In the next part of this chapter, we are going to be looking at Ansible, which
    most people, I suspect, think that it does exactly the same job as Puppet. While
    its true that there is a lot of crossover between the two, I see Ansible's strengths
    as an orchestration tool and Puppet excels at being a configuration management
    tool.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，我们将讨论 Ansible，我猜大多数人认为它和 Puppet 做的工作完全相同。虽然这两者之间确实有很多重叠，但我认为 Ansible
    更擅长作为一个编排工具，而 Puppet 更擅长做配置管理。
- en: As Puppet is a really great configuration management tool, there is the temptation
    to start bundling a Puppet Agent inside your containers, using it as part of your
    image build process, or even for real-time configuration, as the container launches.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Puppet 是一个非常优秀的配置管理工具，很多人会有将 Puppet Agent 打包进容器的冲动，将它作为镜像构建过程的一部分，或者甚至在容器启动时进行实时配置。
- en: Try to avoid this, as it may add unnecessary bloat to your containers as well
    as introduce additional processes. Remember in an ideal world, your containers
    should run a single process and be ready to work as soon as they are started.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免这样做，因为这可能会给你的容器增加不必要的负担，并引入额外的进程。记住，在理想的情况下，你的容器应该只运行一个进程，并且一启动就能工作。
- en: Orchestration with Ansible
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行编排
- en: I suspect a lot of people will be expecting an Ansible versus Puppet opening
    to this section of the chapter. In fact, as mentioned at the end of the previous
    section, while the two tools have a lot of crossover, their strengths lie in doing
    two different jobs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜很多人会期待本章的这一部分开篇讲 Ansible 与 Puppet 的对比。事实上，正如前一部分结尾提到的，虽然这两种工具有很多交集，但它们的优势在于完成两种不同的工作。
- en: They also work in completely different ways. Rather than going into the details
    now, let's jump right in and install Ansible and then launch our WordPress containers
    using an Ansible playbook.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的工作方式也完全不同。我们现在不深入细节，直接跳过，安装 Ansible，并使用 Ansible playbook 启动我们的 WordPress
    容器吧。
- en: Preparation
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if, for any reason, you are not able to work through this section
    of the chapter, I have recorded a screencast to show you what happens when you
    launch the Ansible playbook, which can be found at [https://asciinema.org/a/39537](https://asciinema.org/a/39537).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果因为任何原因你无法完成本章这一部分，我已经录制了一个视频教程，展示了当你启动 Ansible playbook 时会发生什么，视频可以在 [https://asciinema.org/a/39537](https://asciinema.org/a/39537)
    找到。
- en: Before launching our containers, we need to do a few things. The first thing
    is to install Ansible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动容器之前，我们需要做几件事。第一件事是安装 Ansible。
- en: 'If you are running OS X, I would recommend installing Ansible using Homebrew.
    Homebrew is available at [http://brew.sh/](http://brew.sh/) and can be installed
    with the following single command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 OS X，我建议使用 Homebrew 安装 Ansible。Homebrew 可以在 [http://brew.sh/](http://brew.sh/)
    找到，并且可以通过以下命令安装：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you have followed the on-screen prompts, you should be in a position to
    install Ansible using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随屏幕上的提示操作后，你应该能够使用以下命令安装 Ansible：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that Ansible is installed, we need to install a certain version of the
    DigitalOcean Python library. To do this, we need to use the `pip` command. If
    you don''t have the `pip` command installed, then you need to run:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Ansible 安装好了，我们需要安装一个特定版本的 DigitalOcean Python 库。为此，我们需要使用 `pip` 命令。如果你还没有安装
    `pip`，你需要运行：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that `pip` is installed, run the following command to install the correct
    version of the Python library we need:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `pip` 已经安装好了，运行以下命令来安装我们所需的正确版本的 Python 库：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The final thing you will need is the name of your DigitalOcean key. The Ansible
    playbook we are going to run will create one for you and upload it if you don't
    have one already configured, so if that's the case, you can skip this part.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后你需要的就是你的 DigitalOcean 密钥名称。我们将要运行的 Ansible playbook 会为你创建一个，并在没有预先配置的情况下将其上传，如果你已经有了，可以跳过这部分。
- en: If you do happen to have one already associated with your DigitalOcean account,
    then you will name the name of it to launch the two instances and then connect
    to them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了与 DigitalOcean 账户关联的密钥，那么你需要提供密钥名称来启动两个实例并连接到它们。
- en: 'To find this out, log in to the DigitalOcean control panel at [https://cloud.digitalocean.com/](https://cloud.digitalocean.com/)
    and click on the `cog icon` on the top right-hand side of the screen and from
    the menu that pops up, click on the **Settings** button. Once the settings page
    loads, click on the **Security** button, you should then see a list of SSH keys,
    make a note of the name you want to use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出这个信息，请登录到 [https://cloud.digitalocean.com/](https://cloud.digitalocean.com/)
    的 DigitalOcean 控制面板，并点击屏幕右上方的 `齿轮图标`，在弹出的菜单中点击 **设置** 按钮。一旦设置页面加载完毕，点击 **安全性**
    按钮，你应该会看到一个 SSH 密钥的列表，记下你想要使用的密钥名称：
- en: '![Preparation](img/B05468_06_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B05468_06_10.jpg)'
- en: In the preceding example, my SSH key is creatively called `Russ Home`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我的 SSH 密钥被创意性地命名为 `Russ Home`。
- en: 'Time to get a copy of the Ansible playbook we are going to be running. The
    code for this can be found in the `chapter06/docker-ansible` folder on the GitHub
    repository for this book, the complete URL is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候获取我们将要运行的 Ansible playbook 了。代码可以在本书 GitHub 仓库中的 `chapter06/docker-ansible`
    文件夹中找到，完整的 URL 如下：
- en: '[https://github.com/russmckendrick/extending-docker/tree/master/chapter06/docker-ansible](https://github.com/russmckendrick/extending-docker/tree/master/chapter06/docker-ansible)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/russmckendrick/extending-docker/tree/master/chapter06/docker-ansible](https://github.com/russmckendrick/extending-docker/tree/master/chapter06/docker-ansible)'
- en: 'Once you have the playbook downloaded, open your terminal and go to the `docker-ansible`
    folder. Once in there, run the following command, replacing the DigitalOcean API
    with your own:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 playbook 后，打开终端并进入 `docker-ansible` 文件夹。进入后，运行以下命令，并将 DigitalOcean API 替换为你自己的：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are now in a position where we can run the playbook, but before we do, remember
    that this playbook will connect to your DigitalOcean account and launch two instances.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行 playbook 了，但在此之前，请记住，此 playbook 将连接到你的 DigitalOcean 账户并启动两个实例。
- en: 'To launch the playbook, run the following command and wait:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 playbook，运行以下命令并等待：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It will take several minutes to run through the entire process, but what you
    should have the end of it is two Ubuntu 14.04 Droplets launched in your DigitalOcean
    account. Each droplet will have the latest version of both Docker and Weave installed,
    Weave will be configured so that the two hosts can talk to each other.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的过程大约需要几分钟，但你最终应该会在你的 DigitalOcean 账户中启动两个 Ubuntu 14.04 Droplet。每个 droplet
    都会安装最新版本的 Docker 和 Weave，Weave 将被配置为使得这两个主机可以相互通信。
- en: One droplet will be running our WordPress container and the second will be running
    our MySQL container, both containers will be talking to each using the cross-host
    Weave network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 droplet 将运行我们的 WordPress 容器，第二个将运行我们的 MySQL 容器，两个容器将通过跨主机的 Weave 网络相互通信。
- en: 'Once the task completes, you will should see something similar to the following
    screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任务完成，你应该会看到类似下面的截图：
- en: '![Preparation](img/B05468_06_11.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Preparation](img/B05468_06_11.jpg)'
- en: As you can see, in my case, I can go to `http://46.101.4.247` in my browser
    to start the WordPress installation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在我的案例中，我可以在浏览器中访问 `http://46.101.4.247` 来开始 WordPress 安装。
- en: 'If, for any reason, parts of the installation fail, for example, sometimes
    droplets can take a little longer to start and won''t be available for Ansible
    to connect to when it tries to SSH to them, then don''t worry, you will be able
    to rerun the Ansible playbook using the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，部分安装失败，例如有时 droplets 启动可能会稍微慢一点，并且在 Ansible 尝试通过 SSH 连接时无法访问它们，请不要担心，你可以使用以下命令重新运行
    Ansible playbook：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ansible will also work through the entire playbook again, this time, skipping
    anything that has already been created or actioned.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 还会再次执行整个 playbook，这一次，它会跳过任何已经创建或操作过的内容。
- en: If you are not working through this example, or have problems, I have recorded
    an entire run-through of launching the playbook and then rerunning it, you can
    view this at [https://asciinema.org/a/39537](https://asciinema.org/a/39537).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有按照这个示例操作，或者遇到问题，我已经录制了整个启动 playbook 的过程，并再次运行的过程，你可以在 [https://asciinema.org/a/39537](https://asciinema.org/a/39537)
    上查看。
- en: The playbook
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: playbook
- en: 'There are quite a few parts of the playbook, as you can see from the following
    list of folders and files:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: playbook 包含了很多部分，如以下文件夹和文件列表所示：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The main file we called when launching the playbook was the `site.yml` file,
    this defines the order which tasks in defined in the roles folder are executed.
    Let's take a look at the content of this file and the roles that are being called.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在启动 playbook 时调用的主要文件是 `site.yml` 文件，该文件定义了在 roles 文件夹中定义的任务执行顺序。让我们来看一下这个文件的内容以及被调用的角色。
- en: Section one
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一部分
- en: 'The file itself is split into four sections, the following first section deals
    with connecting to DigitalOcean''s API from your local machine and launching the
    two Droplets:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件本身分为四个部分，以下第一部分处理从本地机器连接到 DigitalOcean 的 API 并启动两个 Droplet：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It loads the both the main `environment.yml` variables file, this is where we
    define things such as which region the droplet is being launched in, name of the
    droplets, size to use, and also which image should be launched.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它加载了主 `environment.yml` 变量文件，在这里我们定义了 droplet 启动所在的区域、droplet 的名称、要使用的大小，以及应该启动的镜像。
- en: 'It also loads the `do.yml` file which contains your DigitalOcean API key and
    SSH keyname. If you look into the role task file in the `droplet` folder, you
    will see that along with launching the two droplets, it also creates the following
    three host groups:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它还加载了包含你 DigitalOcean API 密钥和 SSH 密钥名称的`do.yml`文件。如果你查看`droplet`文件夹中的角色任务文件，你会看到在启动两个
    droplet 的同时，它还创建了以下三个主机组：
- en: '`dockerhosts`: This group contains both droplets'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerhosts`：这个组包含两个 droplet'
- en: '`dockerhost01`: This contains our first droplet'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerhost01`：这个组包含我们的第一个 droplet'
- en: '`dockerhost02`: This group contains the second droplet'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerhost02`：这个组包含第二个 droplet'
- en: The final action that is taken at this stage is that a file is written to the
    `group_vars` folder, which contains the public IP addresses of our two droplets.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段采取的最后一个动作是写入一个文件到 `group_vars` 文件夹，其中包含我们两个 droplet 的公共 IP 地址。
- en: Section Two
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二部分
- en: 'The next section of the `site.yml` file deals with the installation of some
    basic prerequisites, Docker, and Weave on the droplets within the `dockerhosts`
    group:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`site.yml` 文件的下一部分处理在 `dockerhosts` 组中的 droplet 上安装一些基本的前提条件、Docker 和 Weave：'
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first role deals with the installation of Docker, let's take a look at what's
    going within the task file for this role.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个角色处理 Docker 的安装，我们来看看该角色任务文件中的内容。
- en: 'First of all, we will install curl using the `apt` package manager as we will
    need this later:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `apt` 包管理器安装 curl，因为稍后我们需要用到它：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once curl has been installed, we will start configuring the official Docker
    APT repository by first adding the keys for the repo:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 curl，我们将开始配置官方的 Docker APT 仓库，首先添加该仓库的密钥：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we''ll add the actual repository:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加实际的仓库：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the repository has been added, we can do the actual installation of Docker,
    making sure that we update the cached repository list before the package is installed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了仓库，我们可以实际安装 Docker，确保在安装软件包之前更新缓存的仓库列表：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that Docker is installed, we need to ensure that the Docker daemon has
    started:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Docker 已安装，我们需要确保 Docker 守护进程已启动：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we need to install the tools that Ansible will use to interact with the
    Docker daemon on our hosts, like Ansible, this is a Python program. To make sure
    that we can install it, we need to ensure that `pip`, the Python package manager,
    is installed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要安装 Ansible 用来与我们主机上的 Docker 守护进程交互的工具，像 Ansible 一样，这也是一个 Python 程序。为了确保可以安装它，我们需要确保
    `pip`（Python 包管理器）已安装：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we know that pip is installed, we can install the `docker-py` package:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 pip 已安装，我们可以安装 `docker-py` 包：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This package is a Docker client written in Python and supplied by Docker itself.
    More details on the client can be found at [https://github.com/docker/docker-py](https://github.com/docker/docker-py).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包是一个由 Docker 提供的 Python 编写的 Docker 客户端。有关该客户端的更多详细信息，请访问 [https://github.com/docker/docker-py](https://github.com/docker/docker-py)。
- en: This ends the first role that is called in the second section of the `site.yml`
    file. Now that Docker is installed, it's time to install Weave, this is handled
    by the `weave-install` task.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了在 `site.yml` 文件第二部分中调用的第一个角色。现在 Docker 已安装，是时候安装 Weave 了，这由 `weave-install`
    任务处理。
- en: 'First of all, we download the weave binary from the URL defined in the `environment.yml`
    file to the filesystem path that is also defined in the `environment.yml` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 `environment.yml` 文件中定义的 URL 下载 weave 二进制文件到文件系统路径，该路径也在 `environment.yml`
    文件中定义：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we have the binary downloaded, we need to see the correct read, write,
    and execute permissions on the file so that it can be executed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们下载了二进制文件，我们需要检查该文件的正确读、写和执行权限，以便能够执行它：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we need to start weave and also pass it a password to enable encryption,
    the password is also defined in the `environment.yml` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要启动 weave 并为其传递一个密码以启用加密，密码也在`environment.yml`文件中定义：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, at the end of this part of the task, we are telling Ansible
    to ignore any errors generated here. This is because, if the playbook was to be
    launched for a second time and weave was already running, it would complain saying
    that the weave router was already active. This will stop playbook from progressing
    any further, as Ansible interprets this message as a critical error.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这一部分任务的最后，我们指示 Ansible 忽略此处产生的任何错误。这是因为，如果 playbook 第二次启动并且 weave 已经在运行，它会提示说
    weave 路由器已经激活。此时，playbook 将停止执行，因为 Ansible 会将此消息视为一个严重错误。
- en: Due to this, we have to tell Ansible to ignore what it thinks is a critical
    error here for the playbook to progress pass this stage.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Section three
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next section of the `site.yml` file performs one last piece of configuration
    before launching the containers that go to make up our WordPress installation.
    All of these roles are run on our first droplet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first role, which is called, connects the two weave networks on the two
    hosts together:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the variable file that contains the IP address of our two droplets
    is loaded for the first time here and is used to get the IP address of the second
    droplet; this file, called `dyn.yml`, was created by the role that originally
    launched the two droplets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the IP address of the second droplet, the `weave connect` command
    is executed and the configuration of the weave network is completed. We can now
    launch the containers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'The first container that we need to launch is the database container:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, this is quite a similar syntax to Docker Compose files; however,
    there may be slight differences, so double-check the Docker pages on the Ansible
    core module documentation site to ensure that you are using the right syntax.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Once the `my-wordpress-database` container has been started, it means that all
    the tasks we need to execute on `dockerhost01` are completed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Section four
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final section of the `site.yml` file connects to our second droplet and
    then launches the WordPress container:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All this role does is launch the WordPress container, again the file has close
    resemblance to the Docker Compose file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The final debug line prints the message at the end of the playbook run that
    contains the IP address of the second droplet.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and Puppet
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Puppet, Ansible, when used with a playbook like the one we have discussed,
    can be used as a replacement for Docker Machine and Docker Compose.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: However, one thing you may have noticed is that unlike Puppet, we did not install
    an agent in the target machine.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: When you run an Ansible playbook, it is compiled locally, and then the compiled
    script is pushed to your target servers using SSH and then executed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons why, during our playbook run, we have to install
    the Docker Python library on our two droplets, without which the compiled playbook
    would not have been able to launch the two containers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference between the two tools is that Ansible executes
    the tasks in the order you define in the playbook.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The Puppet example we worked through wasn't complex enough to really demonstrate
    why this can be an issue when it comes to running Puppet manifests, but Puppet
    works using an eventual consistency concept, meaning that it may take a few manifest
    runs for your configuration to be applied.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to add requirements to Puppet manifests, for example, requiring
    XYZ to be executed after ABC has run. However, this can start to cause performance
    issues if your manifest is quite large; also, you could find yourself in a position
    where the manifest stops working altogether as Puppet is not able to successfully
    execute the manifest in the order you are defining.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: This is why, in my opinion, Ansible is a lot better when it comes to orchestration
    than Puppet.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: It's situations like this where it really matters that the tasks you have defined
    are executed in the exact order you need them to run in rather than leaving it
    up to the tool you are using to figure out the most efficient way of applying
    the tasks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: To me, this is the reason you should not approach any task with an attitude
    of "I need to choose one tool and only use that for everything," you should always
    choose the tool that works for the job you want to do.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: This can probably be said for a lot of the tools we are looking at in this chapter;
    rather than assessing a tool in a "this versus that" manner, we should be asking
    "this or that" or even "this and that" and not limit ourselves.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant (again)
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already discovered earlier in this chapter, Vagrant can be used as
    a virtual machine manager. We have already used it to bring up a local Ubuntu
    14.04 instance using VirtualBox on our local machine; however, if we wanted to,
    we could have done this using VMware Fusion, Amazon Web Services, DigitalOcean,
    or even OpenStack.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Like Puppet and Ansible, when Docker was first released, there were a lot of
    articles published around Vagrant versus Docker. In fact, when the question was
    asked on Stack Overflow, the authors of both Vagrant and Docker weighed in on
    the question. You can read the full discussion at [http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment](http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: So, in what ways can Vagrant support Docker? There are two main ones we are
    going to be looking at. The first is the provisioner.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning using Vagrant
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we worked out way through Puppet, we used Vagrant to launch Ubuntu 14.04
    locally using VirtualBox; as part of that, we used the Shell provisioner to install
    Puppet and deploy the Docker Puppet module. Vagrant has the following provisioners
    available:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**File**: This copies files in place onto the Vagrant host'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shell**: This compiles/copies bash scripts to the host and executes them'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible**: This runs an Ansible playbook either on or against the host'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chef and Puppet**: There are around dozen different ways you can use Chef
    or Puppet to provision your Vagrant host'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: This is what we will be using to provision our containers on the
    Vagrant host'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Vagrantfile` looks really close to the one we used to deploy our Puppet
    WordPress example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, this will download (if you don't have it already) and launch
    an Ubuntu 14.04 server and then provision two containers, one WordPress and one
    MySQL.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the host, run the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see something similar to the following terminal output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Provisioning using Vagrant](img/B05468_06_12.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'You can also run the following command to open your browser and get to your
    WordPress installation screen (remember: we have launched the Vagrant host with
    a fixed local IP address, which means the following URL should resolve to your
    local installation):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You may have already noticed one thing that happened when we launched the Vagrant
    host: we didn''t have to provide Vagrant any commands to install Docker; it took
    care of that for us.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Also, we had to launch our MySQL container before we launched our WordPress
    one. This is because we have linked our WordPress container to the MySQL one.
    If we tried to launch the WordPress container first, we would have received an
    error telling us that we are trying to reach a link that does not exist.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following terminal output, you can connect to your
    Vagrant host using the `vagrant ssh` command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Provisioning using Vagrant](img/B05468_06_13.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: The other thing you may notice is that the Docker version installed isn't the
    most up-to-date one; this is because Vagrant installs the version that is available
    in the operating system's default repository rather than the latest version provided
    by Docker in their repository.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The Vagrant Docker provider
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned, there are two ways in which you can use Docker with Vagrant:
    the one we just looked at is a provisioner, and the second way is to use a provider.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: So, what's a provider? We have already used a provider twice in this chapter
    when we launched our Docker hosts. A provider is a virtual machine process, manager,
    or API that Vagrant can make a connection to and then launch a virtual machine
    from.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Vagrant has the following providers built in:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyper-V
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also a commercial plugin provided by the authors, which adds the following
    provider:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: VMware Fusion and Workstation
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Vagrant supports custom providers, such as ones for Amazon Web Services,
    libvirt, and even LXC, for example. A full list of custom providers and other
    Vagrant plugins can be found at [http://vagrant-lists.github.io/](http://vagrant-lists.github.io/).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, if you are using OS X, then you won't be able to use the Docker provider
    natively; however, Vagrant takes care of this you. Let's look at launching an
    NGINX container using the Docker provider rather than a provisioner.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vagrantfile` looks a little different to the ones we have been using:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see, it is split into two parts: one for a Boot2Docker virtual machine
    and the second part for the container itself. If you were to run `vagrant up`,
    you would see something like the following terminal output:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![The Vagrant Docker provider](img/B05468_06_14.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: As you can see, as I am using OS X, Vagrant knows that I can run Docker natively,
    so it takes the first section of `Vagrantfile` and launches a Boot2Docker instance.
    Boot2Docker is the tiny Linux distribution that powers Docker Machine's default
    driver.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Once it has downloaded the Boot2Docker Vagrant Box, it launches the virtual
    machine and maps port `22` on the virtual machine to port `2222` on our local
    PC so that we can get SSH access. Also, as defined in `Vagrantfile`, port `80`
    from the virtual machine is mapped to port `9999` on the local PC.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Its worth noting that if I were running this on a Linux PC that had Docker installed,
    then this step would have been skipped and Vagrant would have made use of my local
    Docker installation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Now that Boot2Docker has been started, the second part of the `Vagrantfile`
    can be run. If, like in my case, Vagrant has downloaded and launched the Boot2Docker
    Vagrant Box, then you will be asked for a password; this is because we have not
    exchanged keys with the Boot2Docker virtual machine. The password is `tcuser`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered the password, Vagrant will download the NGINX image from
    [https://hub.docker.com/r/russmckendrick/nginx/](https://hub.docker.com/r/russmckendrick/nginx/)
    and launch the container, opening port `80`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Once the container has been launched, you should be able to go to the NGINX
    welcome page at `http://localhost:9999/`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like, you can SSH into the Boot2Docker virtual machine, as Vagrant is
    primarily managing the container and not the Boot2Docker virtual machine. You
    will have to use the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Again, because we have not exchanged keys, you will need to enter the password,
    `tcuser`. You should then see this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![The Vagrant Docker provider](img/B05468_06_15.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Once SSHed in, you will be able to run Docker commands locally. Finally, to
    terminate both the container and virtual machine, run the following command from
    within the same folder as your `Vagrantfile` and you will see something as following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![The Vagrant Docker provider](img/B05468_06_16.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: This will prompt you, asking whether you are sure you would like to remove the
    container and then the virtual machine; answer yes to both questions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: You must have noticed that we didn't cover our WordPress example while walking
    through the Docker provider. The reason for this is that the Docker provider functionality,
    in my opinion, is pretty much redundant now, especially as it has quite a few
    limitations that can all be easily overcome by using the provisioner or other
    tools.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: One such limitation is that it can only use port mapping; we cannot assign an
    IP address to the virtual machine. If we did, it would have silently failed and
    reverted to port mapping from the virtual machine to the host PC.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Also, the functionality offered when launching containers doesn't feel as up
    to date and feature aligned to the latest version of Docker as the other tools
    we have been looking at so far in the chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, I would recommend that you look at using the provisioner rather
    than the provider if you are looking at utilizing Vagrant.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Packaging images
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been quite happily downloading prebuilt images from the Docker
    Hub to test with. Next up, we are going to be looking at creating our own images.
    Before we dive into creating images using third-party tools, we should have a
    quick look at how to go about building them in Docker.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: An application
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start building our own images, we should really have an application
    to "bake" into it. I suspect you are probably getting bored of doing the same
    WordPress installation over and over again. We are going to be looking at something
    completely different.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are going to build an image that has Moby Counter installed. Moby counter
    is an application written by Kai Davenport, who describes it as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '*"A small app to demonstrate keeping state inside a docker-compose application."*'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The application runs in a browser and will add a Docker logo to the page wherever
    you click, the idea being that it uses a Redis or Postgres backend to store the
    number of Docker logos and their positions, which demonstrates how data can persist
    on volumes such as the ones we looked at in [Chapter 3](ch03.html "Chapter 3. Volume
    Plugins"), *Volume Plugins*. You can find the GitHub repository for the application
    at [https://github.com/binocarlos/moby-counter/](https://github.com/binocarlos/moby-counter/).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The Docker way
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know a little about the application we are going to be launching,
    let's take a look at how the image would be built using Docker itself.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The code for this part of the chapter is available from the GitHub repository
    that accompanies this book; you can find it at [https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/docker](https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/docker).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dockerfile` for the basic build is quite simple:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we run the build, it will download the `russmckendrick/nodejs` image from
    the Docker Hub; this, as you may have guessed, has NodeJS installed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Once that image has been downloaded, Docker will launch the container and add
    the content of the current working directory, which contains the Moby Counter
    code. It will then change the working directory to where the the code was uploaded
    to `/srv/app`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: It will then install the prerequisites required to run the application by issuing
    the `npm install` command; as we have set the working directory, all of the commands
    will be run from that location, meaning that the `package.json` file will be used.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Accompanying the `Dockerfile` is a Docker Compose file, this kicks off the build
    of the Moby Counter image, downloads the official Redis image, and then launches
    the two containers, linking them together.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do that, we need to bring up a machine to run the build on; to do
    this, run the following command to launch a local VirtualBox-based Docker host:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that the Docker host has been launched, run the following to configure
    your local Docker client to talk directly to it:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that you have the host ready and client configured, run the following to
    build the image and launch the application:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When you run the command, you should see something like the following output
    in your terminal:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker way](img/B05468_06_17.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'Now that the application has been launched, you should be able to open your
    browser by running this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You will see a page that says Click to add logos, if you were to click around
    the page, Docker logos would start appearing. If you were to click on refresh,
    the logos you added would remain as the number of the logos, their position being
    stored in the Redis database.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker way](img/B05468_06_18.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'To stop the containers and remove them, run the following commands:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Before we look into the pros and cons of using the Docker approach to building
    container images, let's look at a third-party alternative.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Building with Packer
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packer is written by *Mitchell Hashimoto* from *Hashicorp*, the same author
    as Vagrant's. Because of this, there are quite a lot of similarities in the terms
    we will be using.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The Packer website has probably the best description of the tool:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '*"Packer is an open source tool for creating identical machine images for multiple
    platforms from a single source configuration. Packer is lightweight, runs on every
    major operating system, and is highly performant, creating machine images for
    multiple platforms in parallel. Packer does not replace configuration management
    like Chef or Puppet. In fact, when building images, Packer is able to use tools
    like Chef or Puppet to install software onto the image."*'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I have been using Packer since its first release to build images for both Vagrant
    and public clouds.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Packer from [https://www.packer.io/downloads.html](https://www.packer.io/downloads.html)
    or, if you installed Homebrew, you can run the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now that you have Packer installed, let's take a look at a configuration file.
    Packer configuration files are all defined in JSON.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON)** is a lightweight data-interchange
    format. It is easy for humans to read and write and for machines to parse and
    generate.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file does almost exactly what our `Dockerfile` did:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, all of the files required to build the image, along with the Docker Compose
    file to run it, are in the GitHub repository at [https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/packer](https://github.com/russmckendrick/extending-docker/tree/master/chapter06/images/packer).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using the Docker Compose file to build the image, we are going
    to have to run **packer** and then import the image file. To start the build,
    run the following command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You should see the following in your terminal:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Building with Packer](img/B05468_06_19.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Once Packer has built the image, it will save a copy to the folder you initiated
    the Packer build command from; in our case, the image file is called `mobycounter.tar`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the image so that we can use it, run the following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will import the image and name it `mobycounter`; you can check whether
    the image is available by running this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should see something like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Building with Packer](img/B05468_06_20.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'Once you have confirmed the image has been imported and is called `mobycounter`,
    you can launch a container by running this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Again, you will be able to open your browser and start clicking around to place
    logos by running this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: While there may not seem to be much difference, let's take a look at what's
    going on under the hood.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Packer versus Docker Build
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go into detail about the difference between the two methods of building
    images, let's try running Packer again.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'This time though, let''s to try and reduce the image size: rather than using
    the `russmckendrick/nodejs` image, which has nodejs preinstalled, let''s use the
    base image that this was built on, `russmckendrick/base`.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'This image just has bash installed; install NodeJS and the application using
    Packer:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, we have added a few more commands to the shell provisioner;
    these use Alpine Linux's package manager to perform an update, install nodejs,
    configure the application, and finally, clean both the apk and npm caches.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like, you can build the image using the following command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will leave us with two image files. I also exported a copy of the container
    we built using the `Dockerfile` using the following command while the container
    was running:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'I now have three image files, and all three are running the same application,
    with the same software stack installed, using as close to the same commands as
    possible. As you can see from the following list of file sizes, there is a difference
    in the image size:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile** (using `russmckendrick/nodejs`) = 52 MB'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packer** (using `russmckendrick/nodejs`) = 47 MB'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packer** (installing the full stack using packer) = 40 MB'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 MB may not seem like a lot, but when you are dealing with an image that is
    only 52 MB big, that's quite a decent saving.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: So why is there a difference? Let's start by discussing the way in which Docker
    images work.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: They are essentially made up of layers of changes on top of a base. When we
    built our first image using the `Dockerfile`, you may have noticed that each line
    of the `Dockerfile` generated a different step in the build process.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Each step is actually Docker starting a new filesystem layer to store the changes
    for that step of the build. So, for example, when our `Dockerfile` ran, we had
    six filesystem layers:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first layer contains the base operating system along with the layers on
    which NodeJS is installed, and the second layer contains the files for the application
    itself.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The third layer just contains the metadata for setting the `workdir` variable;
    next up, we have the layer that contains the NodeJS dependencies for the application.
    The fifth and sixth layers just contain the metadata needed to configure which
    ports are exposed and what the "entry point" is.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: As each of these layers is effectively a separate archive within the image file,
    we also have the additional overhead of these archives within our image file.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: A better example of how the layers work is to look at some of the most popular
    images from the Docker Hub in the ImageLayers website, which can be found at [https://imagelayers.io/](https://imagelayers.io/).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: This site is a tool provided by Century Link Labs ([https://labs.ctl.io/](https://labs.ctl.io/))
    to visualize Docker images that have been built from a `Dockerfile`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following screenshot, some of the official images are
    quite complex and also quite large:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Packer versus Docker Build](img/B05468_06_21.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: 'You can view the previous page at the following URL:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[https://imagelayers.io/?images=java:latest,golang:latest,node:latest,python:latest,php:latest,ruby:latest](https://imagelayers.io/?images=java:latest,golang:latest,node:latest,python:latest,php:latest,ruby:latest).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Even while the official images should be getting smaller thanks to Docker hiring
    the creator of Alpine Linux and moving the official images over to the smaller
    base operating system (check out the following hacker news post for more information
    [https://news.ycombinator.com/item?id=11000827](https://news.ycombinator.com/item?id=11000827)),
    it does not change the amount of layers required for each image. It's also worth
    pointing out that each image can have a maximum of 127 layers.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does Packer do differently? Rather than creating a separate filesystem
    layer for each step, it produces only two: the first layer is the base image you
    define, and the second one is everything else—this is where our space savings
    come in.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage of using Packer over Dockfiles is that you can reuse your
    scripts. Imagine you were doing your local development work using Docker but when
    you launched into production, you for one reason or another had to launch on one
    of the containerized virtual machines. Using Packer, you can do exactly that knowing
    that you could actually use the same set of build scripts to bootstrap your virtual
    machines as you did for your development containers.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: As I have already mentioned, I have been using Packer for a while and it helps
    to no end to have a single tool that you can use to target different platforms
    with the same set of build scripts. The consistency this approach brings is well
    worth the initial effort of learning a tool such as Packer as you will end up
    saving a lot of time in the long run; it also helps with eliminating the whole
    "worked in development" meme we discussed at the start of [Chapter 1](ch01.html
    "Chapter 1. Introduction to Extending Docker"), *Introduction to Extending Docker*.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: There are some downsides to using this approach, which may put some people off.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The biggest one in my opinion is that while you are able to push the final image
    automatically to the Docker Hub, you will not be able to add it as an automated
    build.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: This means that while it may be available for people to download, it might not
    be considered trusted as people cannot see exactly what has been added to the
    image.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the lack of support for metadata—functions that configure runtime
    options such as exposing ports and the command executed by default when the container
    launches are not currently supported.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: While this can be seen as a drawback, it is easily overcome by defining what
    you would have defined in your `Dockerfile` in a Docker Compose file or passing
    the information directly using the `docker run` command.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Image summary
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, to summarize, if you need to build not only container images but also target
    different platforms, then Packer is exactly the tool you are after. If it's just
    container images you need to build, then you may be better off sticking with the
    `Dockerfile` build.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other tools we have looked at in this chapter, such as Ansible
    and Puppet, also support building images by issuing a `docker build` command against
    a `Dockerfile`, so there are plenty of ways to build that into your workflow,
    which leads us to the next tool we are going be looking at: Jenkins.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let''s quickly just double-check that you are not running
    any Docker hosts. To do this, run the following commands to check for any Docker
    hosts and then remove them:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Don't forget to only remove hosts that you are using for following along with
    this book; don't remove any you are using for you own projects!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Serving up Docker with Jenkins
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is quite a big topic to cover in a small section of a single chapter,
    so the walkthrough is going to be really basic and will only deal with building
    and launching containers.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to note is that I am going to be covering Jenkins 2.0; at the
    time of writing this, the first beta has just been released, which means that
    while things may change slightly as themes and such are refined, all of the features
    and basic functionality are locked in.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The reason for covering Jenkins 2.0 rather than the Jenkins 1.x branch is that
    as far as Jenkins is concerned, Docker is now a first-class citizen, meaning that
    it fully supports and embraces the Docker way of working. A full overview of the
    current status of Jenkins 2.0 can be found at [https://jenkins.io/2.0/](https://jenkins.io/2.0/).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: So what is Jenkins? Jenkins is an open source continuous integration tool written
    in Java, and it has a lot of uses.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I am really late to the Jenkins party; being from an operations
    background, I have always just shrugged it off a tool used for running unit tests
    on code; however, as I have moved more into orchestration and automation, I am
    finding the need for a tool that can run tasks based on the results of unit tests.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'As I have already mentioned, I am not going to go into much detail about the
    testing side of Jenkins; there are plenty of resources that cover this functionality,
    such as the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '*Mastering Jenkins* by Jonathan McAllister'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jenkins* *Continuous Integration Cookbook* by Alan Mark Berg'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are both available from [https://www.packtpub.com/](https://www.packtpub.com/).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than running it locally, let''s launch a DigitalOcean droplet and install
    Jenkins there. First off, we need to use Docker Machine to launch the droplet:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once the droplet has been launched, we don't need to bother configuring our
    local Docker client to talk on the droplet by running the Docker engine as Jenkins
    will be handling everything to do with Docker.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we need Jenkins to run Docker, we will need to install it directly
    on our droplet rather than run it as a container; first of all, we will need to
    SSH onto the droplet. To do this, run the following command:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, on the droplet, we need to install Docker Compose, Jenkins, and all of
    its prerequisites. Let''s start by installing Docker Compose. I have written a
    quick script to do this, which can be executed by running the following command:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we have Docker Compose installed, it's time to install Jenkins. As
    version 2 is currently in beta, it is not in any of the main repositories yet;
    however, there is a DEB package for it.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, we need to download a local copy and run the following commands:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This will install the `gdebi` tool, which we will then use to install Jenkins
    and its dependencies:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that Jenkins is installed, we need to add the Jenkins user to the Docker
    group so that the user has permissions to interact with Docker:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, to ensure that Jenkins picks up that it has been added to the group,
    we need to restart it using this command:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can now open your browser to complete the installation:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When your browser opens, you should be greeted with a screen that looks like
    the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_23.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: 'For security reasons, when the Jenkins container was launched, a random string
    was generated; before you can proceed with the installation, Jenkins requires
    you to confirm what this string is. You can find it out by running this command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You can quit `less` by pressing the *Q* key.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: This feature is a most welcome one as not securing your Jenkins installation
    correctly from the start can have quite bad implications, as I found out when
    a third party hijacked a test Jenkins 1.x installation I had up running and forgotten
    about—whoops!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered the initial admin password, click on the **Continue**
    button.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'The next page you come to will ask you which plugins you would like to install:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_24.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
- en: 'For our purposes, just click on **Install suggested Plugins**, which is highlighted.
    The next page will show you the progress of the suggested plugins:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_25.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: 'It will take a minute or two to complete. Once it has completed, you will be
    asked to create a Jenkins user:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_26.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: 'As I have already mentioned, it''s important to secure your Jenkins installation
    from the start, so I recommend you don''t skip this step. Once you have filled
    in the requested information, click on the **Save and Finish** button. If all
    has gone well, you will be presented with the following screen:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_27.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
- en: 'All you have to do now is click on **Start using Jenkins** and you will be
    logged in and taken to the start screen, which looks like this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_28.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: This installation process is one of the many improvements that Jenkins 2 brings
    to the table; earlier, you would have had to install Jenkins and then manually
    work through several wizards and procedures to both secure and configure the software,
    which as I have already mentioned can have bad consequences if you don't get it
    right.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The final step of the setup is to install the CloudBees Docker Pipeline plugin;
    to do this, click on the **Manage Jenkins** button from the left-hand side menu,
    and then click on **Manage Plugins** button.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: As this is a new installation, you will probably see a message about plugins
    being updated at some point. Ignore the request to restart Jenkins; we will be
    doing this as part of the installation.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: There are four tabs on the main screen; click on **Available** button and you
    will be presented with a list of all of the Jenkins plugins.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: In the top right-hand portion of the main screen, there is a search box labelled
    **Filter**. Type in `Docker Pipeline` here, and you should receive one result.
    Tick the install box and then click on the **Download now and install after restart**
    button.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the environment](img/B05468_06_29.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
- en: It will take a minute or two to restart Jenkins; after it has started back up,
    you will be prompted to log back in using the credentials you provided during
    the installation.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have Jenkins installed and configured, it's time to add our pipeline.
    To do this, we need an application to add.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a sample application based on Moby Counter available at the following
    GitHub repository: `https://github.com/russmckendrick/jenkins-docker-example/tree/master`.
    The main page looks like this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an application](img/B05468_06_30.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: Before we add the application, it is best that you fork the code, as we will
    be making changes to the codebase later on. To do this, click on the **Fork**
    button in the top right of the screen. You will be asked where you want to fork
    the repository. Once you have forked it, make a note of the URL.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: As I own the repository, I was not able to fork it. Because of this, I have
    created a copy called `jenkins-pipeline`, so you will see references to this in
    the following section.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pipeline
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that Jenkins is configured and we have a GitHub repository that contains
    the application, we would like to deploy. It's time to roll our sleeves up and
    configure the pipeline within Jenkins.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: To start, click on the **create new jobs** button on the main page, you will
    be taken to a screen that has several options on it, enter the name of the pipeline
    in the top box.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'I am calling mine `Docker Pipeline`, and then click on **Pipeline** button.
    You should see a small box that says **OK** button at the bottom of the screen,
    click on the **OK** button to create the pipeline, which will take you to the
    configuration screen:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_31.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
- en: 'You will now be on the pipeline configuration screen, as you can see, there
    are a lot of options. We are going to be keeping things really simple and will
    be just adding a pipeline script. The script looks similar to the following code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Before you add the script to the Pipeline section of the configuration page,
    replace the Git URL with the one of your own repository. Leave all the other options
    as they are and click on the **Save** button:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_32.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: 'That''s it, our pipeline is now configured. We have told Jenkins to perform
    the following three tasks each time a build is triggered:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkout**: This downloads the latest code for our application from your
    GitHub repository.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: This uses `Dockerfile` that is in the GitHub repository to build
    the `Mobycounter` image.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy**: This runs a script that clears down any currently running containers
    and then uses the included Docker Compose file to relaunch the application. When
    launching Redis, the Docker Compose file uses the built-in volume driver for `/data`,
    meaning that the position of the Docker logos will persist between the containers
    being relaunched.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To trigger a build, click on the **Build Now** button option on the left-hand
    side menu. If everything goes well, you should see something similar to the following
    screenshot:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_33.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, all three tasks are executed without error. You should be able
    to see the application by opening your browser using the following command:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Place some logos to test that everything is working as expected, and that''s
    it, you have deployed your application using Jenkins:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_34.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: Hold on a minute—there is a problem! As you may have already noticed, the page
    title is wrong.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and fix that. To do so, navigate to the following page in your
    GitHub repository: `your-github-repo` | `src` | `client` | `index.html`. From
    here, click on the **Edit** button. Once in the editing screen, update the title
    between the `<title>` and `</title>` tags, and then click on the **Commit changes**
    button.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_35.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: Now that you have updated your application code, go back to Jenkins and click
    on **Build Now** again. This will trigger a second build, which will deploy the
    changes we made in GitHub.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_36.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
- en: As you can see from the second browser tag in the previous screenshot, the title
    of our application has changed and the second build was successful. If you refresh
    your application window, you should see that your title has been updated and the
    Docker logos are where you left them.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: A few other things to note are that that the second build confirms that there
    is one commit difference between our initial build and the current one. Also,
    the build itself took less time than our original build; this is because Docker
    didn't have to download the base image for a second time.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view logs for each task by hovering your mouse over the stage you want
    to see the logs for and clicking on the **Logs** link. This will make a dialog
    pop up with the logs for the task:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_37.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
- en: 'You can also look at the full console output for each build by clicking on
    the build number, say `#2`, in the left-hand side menu and then clicking on the
    **Console Output** button:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_38.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
- en: This is useful if your build has errors. Try clicking on some of the options,
    such as **Docker Fingerprints** and **Changes**, to look at the other information
    that is recorded during each build.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the main Jenkins page, you should see a quick summary of your
    builds. You should also see a sun icon next to your pipeline, meaning that everything
    is OK.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pipeline](img/B05468_06_39.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
- en: What if everything wasn't okay with the second build? Consider that we had made
    a syntax error within the Dockerfile when we edited the page title, what would
    have happened?
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins would have checked the update files from GitHub, started the build of
    the updated image, detected the error, and then failed. As this stage would have
    given an error, the deploy stage would not have been executed, meaning that our
    application would still be running in its current state, wrong title and all.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: This is where Jenkins' strength lies, if you configure enough tests with both
    your code and deployment pipelines, you can stop any potential service affecting
    changes being deployed, it also records enough information to be an extremely
    valuable resource when it comes to tracking down errors.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Summing up Jenkins
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, we have only touched the tip of the iceberg when it
    comes to Jenkins, there is a lot of functionality we haven't covered as it is
    out of scope of this book.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: However, from the little we have discussed, I hope you can see the value of
    using a continuous integration and deployment platform such as Jenkins to help
    build and deploy your containers and code. Don't be late to the party like I was,
    if you deploy any type of code, then consider using Jenkins to assist you, don't
    wait until you have deployed a serious application-breaking bug.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common thread among all the tools we have looked at in this chapter is that
    they all quickly evolved to offer support for Docker, filling in gaps in functionality,
    which was missing from the core Docker toolset.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Over the past 12 months, the rapid development of Docker has meant that some
    of these tools may not necessarily be required any more.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: However, as they all provide a wide range of functionality outside of Docker,
    it means that they can still be a valuable part of your day-to-day workflow should
    Docker only be one of the technologies you are working with.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: There is one thing using that the tools in this chapter does not provide and
    that's some intelligence around where your containers are launched, you still
    have to instruct the tools to *place container A on Docker host Z*.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will be looking at schedulers that make the decision
    as to where a container should be launched for you, based on host availability,
    utilization, and other rules such as *don't place Container A on the same host
    as Container B*, meaning that you are no longer confined to a fixed infrastructure.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
