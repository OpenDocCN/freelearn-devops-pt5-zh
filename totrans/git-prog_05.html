<html><head></head><body>
  <div><h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-104" class="chapterTitle">Rebasing, Amend, and Cherry-Picking</h1>
    <p class="normal">If you say "rebasing" to most novice Git programmers, they burst into tears and run screaming from the room. But the truth is that this is only because of how it is explained in so many books and magazines, where rebasing is (correctly but confusingly) shown with diagrams of commits being copied and moved along with dense and technical text.</p>
    <p class="normal">In truth, rebasing is not hard to understand, and it is not hard to do if you understand what it is for. In this chapter, we will review rebasing without fear. </p>
    <p class="normal"><strong class="keyword">Rebasing</strong> is a command that allows <a id="_idIndexMarker154"/>you to take a feature branch and place it on the tip of another branch. We'll discuss how, and more importantly <em class="italic">why</em>, you would do this.</p>
    <p class="normal"><strong class="keyword">Amending</strong> is a quick command<a id="_idIndexMarker155"/> that allows you to modify the most recent commit. You can use this to add a file you forgot to put in the commit or to fix up a botched message.</p>
    <p class="normal"><strong class="keyword">Cherry-picking</strong> is the ability to<a id="_idIndexMarker156"/> take one or more commits from a branch and apply them onto the tip of another branch.</p>
    <p class="normal">Git programmers describe these three commands as <strong class="keyword">rewriting history</strong> and that is what they all have in common. Each has the ability to change how commits were added to the repository, and thus clean up your list of commits.</p>
    <h1 id="_idParaDest-105" class="title">Rebasing</h1>
    <p class="normal">Rebasing is nothing more than<a id="_idIndexMarker157"/> taking one branch and adding it to the tip of another, where the tip is simply the last commit in the branch. For example, suppose you have the following structure:</p>
    <figure class="mediaobject"><img src="img/B17741_05_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.1: Git structure</p>
    <p class="normal">You can't do a fast forward<a id="_idIndexMarker158"/> here, because <strong class="keyword">Main</strong> has moved on since you branched from it. You can do a true merge, but a true merge adds a commit to your history every time you do one:</p>
    <figure class="mediaobject"><img src="img/B17741_05_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.2: True merges</p>
    <p class="normal">A rebase solves the same problem, but without adding merges to the commit history.</p>
    <p class="normal">Notice that <a id="_idIndexMarker159"/>as you review this history, you have to skip over a significant number of commits since they are just merges. Rebase eliminates most of these commits.</p>
    <p class="normal">Here comes the important part:</p>
    <ul>
      <li class="bullet">You merge branch <strong class="keyword">Feature1</strong> <em class="italic">into</em> <strong class="keyword">Main</strong>, but you rebase <strong class="keyword">Feature1</strong> <em class="italic">onto</em> <strong class="keyword">Main</strong>.</li>
      <li class="bullet">Returning to our earlier example, if you rebase <strong class="keyword">Feature1</strong> onto <strong class="keyword">Main</strong>, it looks like this:<figure class="mediaobject"><img src="img/B17741_05_03.png" alt=""/></figure>
      </li>
    </ul>
    <p class="packt_figref">Figure 5.3: After the rebase</p>
    <ul>
      <li class="bullet">There is now a clear path from the first commit of <strong class="keyword">Main </strong>to the last commit of <strong class="keyword">Feature1</strong> without leaving anything out. This is most often drawn like this:<figure class="mediaobject"><img src="img/B17741_05_04.png" alt=""/></figure>
      </li>
    </ul>
    <p class="packt_figref">Figure 5.4: Another way to look at the commits after rebasing</p>
    <ul>
      <li class="bullet">This emphasizes that you have rebased <strong class="keyword">Feature1</strong> onto the tip of <strong class="keyword">Main</strong> (the tip is <strong class="keyword">Main</strong>'s latest commit).</li>
    </ul>
    <p class="normal">That is all there is to<a id="_idIndexMarker160"/> rebasing. Honest.</p>
    <h2 id="_idParaDest-106" class="title">How Git does it </h2>
    <p class="normal">Generally, I don't spend time or brain cells on how Git does what it does, but here it is worth noting that to rebase, Git rolls <a id="_idIndexMarker161"/>back history to the first <strong class="keyword">Feature1</strong> commit and then makes a copy and adds it to the tip of <strong class="keyword">Main</strong>. It then makes a copy of the second <strong class="keyword">Feature1</strong> commit and puts that on top of the latest commit, and so forth.</p>
    <p class="normal">The reason this is important is that a copy is made, and thus will have a different ID. Okay, you are now free to forget all this and treat rebasing as the magic it is.</p>
    <h2 id="_idParaDest-107" class="title">Getting your head around it</h2>
    <p class="normal">Rebasing is not hard, as you have seen. But truly grokking what is happening and why it is okay takes anywhere from five minutes to five years. We are taking our feature and putting it on top of Main. Remember that our feature started as a branch off of Main. </p>
    <p class="normal">Now we're incorporating all that is in Main into our feature.</p>
    <p class="normal">That is the critical part. Because we <a id="_idIndexMarker162"/>do this locally, we are just saying "no matter how much Main has advanced, I will eventually need to merge into it. For now, I'm going to rebase onto Main, making it one long branch, and make sure there are no conflicts."</p>
    <h2 id="_idParaDest-108" class="title">Rebase early and rebase often</h2>
    <p class="normal">It is very good practice to rebase frequently, so as to surface any conflicts that might arise. Each time you rebase, you <a id="_idIndexMarker163"/>end up with a stack of commits that has all that came before and then your new commits at the tip. If a conflict arises between what you just added and what was there, you will see it immediately and can fix it on the spot.</p>
    <h2 id="_idParaDest-109" class="title">Rebase locally only</h2>
    <p class="normal">You rebase <em class="italic">only</em> on your local machine, and <em class="italic">never</em> on the shared repository in the cloud (for example, GitHub). This is<a id="_idIndexMarker164"/> because rebasing "rewrites history" – remember that it makes copies of Feature1 – and if another programmer is working on that branch, they will not be happy with you if you rebase. This is the kind of "not happy" that can lead to felony charges.</p>
    <h2 id="_idParaDest-110" class="title">Rebasing in practice</h2>
    <p class="normal">Let's create a new repository<a id="_idIndexMarker165"/> named Rebasing. We're going to watch Adam as he creates a branch named <code class="Code-In-Text--PACKT-">Person</code> by taking the following steps:</p>
    <ol>
      <li class="numbered">Go to the main root directory</li>
      <li class="numbered">Create a branch named <code class="Code-In-Text--PACKT-">Person</code></li>
      <li class="numbered">Open Visual Studio and create a project named <code class="Code-In-Text--PACKT-">Person</code></li>
      <li class="numbered">Create a new class named <code class="Code-In-Text--PACKT-">Person</code></li>
      <li class="numbered">Add the <code class="Code-In-Text--PACKT-">Rebasing</code> repo to your local repository</li>
      <li class="numbered">Add the repository and commit it (which will also commit <code class="Code-In-Text--PACKT-">Person</code>)</li>
      <li class="numbered">Add an age property to <code class="Code-In-Text--PACKT-">Person</code> and commit (but don't push):
        <pre class="programlisting code"><code class="hljs-code">namespace Rebasing
{
    public class Person
    {
        public double Age {get; set;}
    }
}
</code></pre>
      </li>
      <li class="numbered">Add a name property and commit but don't push</li>
    </ol>
    <p class="normal">After we add a height property, we<a id="_idIndexMarker166"/> are in this situation:</p>
    <figure class="mediaobject"><img src="img/B17741_05_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.5: History of commits in Visual Studio</p>
    <p class="normal">We could push now, but there is more work to be done on the <code class="Code-In-Text--PACKT-">Person</code> class. On the other hand, we don't want main to have moved so far away from us that we'll have too many conflicts when we are done with person. The answer: rebase. Make sure you are on person, then right-click on main and choose <strong class="screenText">Rebase 'person' onto 'main'</strong>:</p>
    <figure class="mediaobject"><img src="img/B17741_05_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.6: Rebasing in Visual Studio</p>
    <p class="normal">With that done, we can continue working on the <code class="Code-In-Text--PACKT-">Person</code> branch.</p>
    <p class="normal">Notice that you have only four outgoing commits:</p>
    <figure class="mediaobject"><img src="img/B17741_05_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.7: Rebasing does not add a commit</p>
    <p class="normal">The rebase did <a id="_idIndexMarker167"/>not add a commit, and keeps your history clean.</p>
    <h2 id="_idParaDest-111" class="title">Seeing the rebase at work</h2>
    <p class="normal">To see that your rebase did actually rewind the<a id="_idIndexMarker168"/> history of your commits and then add each commit back on top of main, go to the command line and issue the command <code class="Code-In-Text--PACKT-">git log --name-only --oneline</code>:</p>
    <figure class="mediaobject"><img src="img/B17741_05_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.8: Rebase rewinds history</p>
    <p class="normal">What we see here <a id="_idIndexMarker169"/>going from top to bottom is the addition of the final property (height) and then we rebase <code class="Code-In-Text--PACKT-">Person.cs</code> and add the name property. Next, we rebase and add the age property. We continue this all the way back until we've rebased all of the files onto the tip of main.</p>
    <h2 id="_idParaDest-112" class="title">Conflicts</h2>
    <p class="normal">When rebasing we may <a id="_idIndexMarker170"/>well run into conflicts. You will remember that we have one branch: <code class="Code-In-Text--PACKT-">Person.</code> Let's have a second programmer clone the repository. That second programmer is happily working away in their branch (teacher) when they realize they need person to have a different age. They add this to the file (okay, no one is quite that stupid, but this kind of thing happens in more subtle ways):</p>
    <figure class="mediaobject"><img src="img/B17741_05_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.9: Rebasing caused conflicts</p>
    <p class="normal">Fortunately, Git tells you what to do. </p>
    <p class="normal">Remember, you can at any time enter <code class="Code-In-Text--PACKT-">git rebase --abort</code> and go back to where you were before you started the<a id="_idIndexMarker171"/> rebase.</p>
    <p class="normal">This time, however, we'll fix the problem by hand. Open the file pointed to <code class="Code-In-Text--PACKT-">Person.cs</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">namespace Rebasing
{
    public class Person
    {
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
        public double Age { get; set; } = 35;
=======
        public double Age { get; set; } = 30;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; cb76bd6 (set age to 30)
        public string Name { get; set; }
        public double Height { get; set; }
        public double Weight { get; set; }
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
=======
&gt;&gt;&gt;&gt;&gt;&gt;&gt; cb76bd6 (set age to 30)
    }
}
</code></pre>
    <p class="normal">The part that looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
        public double Age { get; set; } = 35;
=======
</code></pre>
    <p class="normal">is the code in the current revision; the next set of code:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt;&gt;&gt;&gt;&gt;&gt;&gt; cb76bd6 (set age to 30)
        public string Name { get; set; }
        public double Height { get; set; }
        public double Weight { get; set; }
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</code></pre>
    <p class="normal">is coming from the code to be rebased.</p>
    <p class="normal">Bleh. What a mess. You can fix this by hand, making the adjustments and then removing the conflict markers, or you can use a tool as mentioned in the previous chapter. </p>
    <p class="normal">To fix this, we'll adjust the age in the branch onto which we rebase the patches; i.e. 35 is the authoritative age, therefore the 35 line is the one we want to keep, and we want to remove the rest.</p>
    <p class="normal">In any case, once you have resolved the conflicts, return to the command line and enter <code class="Code-In-Text--PACKT-">git rebase --continue</code>. This will resume the rebase, checking for other conflicts. If there are none, Git will ask you to<a id="_idIndexMarker172"/> enter a message and the rebase will be completed:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt; git rebase --continue
[detached HEAD 5843a73] Rebased, set age to 30
 1 file changed, 1 insertion(+)
Successfully rebased and updated refs/heads/person.
</code></pre>
    <p class="normal">The key with rebase conflicts is not to panic, but to work your way through them one by one. Take heart, had you not done the rebase, you would have run into these issues and more when trying to merge into main once you were done with your feature branch.</p>
    <h1 id="_idParaDest-113" class="title">Amending</h1>
    <p class="normal">If you check in a change and then<a id="_idIndexMarker173"/> realize you've left out a file or have mangled the message, you can use the <code class="Code-In-Text--PACKT-">amend</code> command. However, you can only amend the most recent commit.</p>
    <p class="normal">Let's say we return to person and we add a weight property and then commit it. Before we push it, we realize we left out a change to <code class="Code-In-Text--PACKT-">Program.cs</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">namespace Rebasing
{
    class Program
    {
        static void Main(string[] args)
        {
            var person = new Person();
            person.Name = "Jesse";
        }
    }
}
</code></pre>
    <p class="normal">Since the error was in the most recent commit, we can amend that commit. All we need to do is put the <code class="Code-In-Text--PACKT-">Program.cs</code> file into the index and then issue the command <code class="Code-In-Text--PACKT-">git commit --amend</code>.</p>
    <p class="normal">Because amend rewrites history, <strong class="keyword">you must do this only before you push</strong> (that is, while the commit is only <a id="_idIndexMarker174"/>in your local repo), for the same reasons as noted above:</p>
    <figure class="mediaobject"><img src="img/B17741_05_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.10: Amending (before pushing!)</p>
    <p class="normal">Let's take this one line at a time from the top. First we notice that one commit is waiting to be pushed. That is the commit we're going to amend.</p>
    <p class="normal">On the second line, we add the file we want to amend to the index.</p>
    <p class="normal">Next, we add the amend command: <code class="Code-In-Text--PACKT-">git commit --amend</code>.</p>
    <p class="normal">Git will respond by opening your editor so that you can amend the message (which we see here: <code class="Code-In-Text--PACKT-">add person and in person add weight</code>).</p>
    <p class="normal">Finally, it tells you all the usual information about the commit.</p>
    <p class="normal">Notice, however, that you still have only one commit waiting to be pushed. The amend did not appear to create a new commit (okay, technically it did, but you can safely ignore that).</p>
    <p class="normal">If you use a commit with no file name but with the message flag, you change only the message for that most recent commit. You don't even need the flag; if there are no new, modified, or deleted files in the index, it will open your editor for you:</p>
    <figure class="mediaobject"><img src="img/B17741_05_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.11: This will cause your editor to open</p>
    <p class="normal">If you get the history now, with log, you'll see the amended message:</p>
    <figure class="mediaobject"><img src="img/B17741_05_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.12: The message amended in the editor</p>
    <p class="normal">Amend can save you a lot of work<a id="_idIndexMarker175"/> down the road, and it is important to have a well-written message to clarify the purpose of the commit.</p>
    <h1 id="_idParaDest-114" class="title">Cherry-picking</h1>
    <p class="normal">Sometimes you just need one or a<a id="_idIndexMarker176"/> small number of commits from one branch to be added to the tip of another branch. A common case is this: you have a release branch and a feature branch. The release branch is "frozen" but then you need to add a commit from a feature branch to the release branch (possibly a patch to fix a problem). When you cherry-pick, the picked commit goes to the tip of the branch you are cherry-picking onto.</p>
    <p class="normal">An illustration will help. Here's our starting point:</p>
    <figure class="mediaobject"><img src="img/B17741_05_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.13: Before cherry-picking</p>
    <p class="normal">We discover that<a id="_idIndexMarker177"/> we do not want all of <strong class="keyword">Feature1</strong> on <strong class="keyword">Main</strong>, but we do want <strong class="keyword">Feature1B</strong> (it has the fix or feature set we need). To do this at the command line you enter <code class="Code-In-Text--PACKT-">git cherry-pick a2cb5f3</code> where <code class="Code-In-Text--PACKT-">a2cb5f3</code> is the ID of the feature commit you want to cherry-pick.</p>
    <p class="normal">What you end up with looks like this:</p>
    <figure class="mediaobject"><img src="img/B17741_05_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.14: After the cherry-pick</p>
    <p class="normal">Notice that <strong class="keyword">Feature1B</strong> is now added to the tip <a id="_idIndexMarker178"/>of main, but it is also left on the feature branch.</p>
    <h2 id="_idParaDest-115" class="title">Visual Studio cherry-picking</h2>
    <p class="normal">Visual Studio has terrific<a id="_idIndexMarker179"/> support for cherry-picking. Just go to the branch you want<a id="_idIndexMarker180"/> and then open the history. Right-click on the commit you want and choose <strong class="screenText">Cherry-Pick</strong>:</p>
    <figure class="mediaobject"><img src="img/B17741_05_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.15: Cherry-picking in Visual Studio</p>
    <p class="normal">Cherry-picking can be<a id="_idIndexMarker181"/> essential when you've branched off your develop <a id="_idIndexMarker182"/>branch but create something on a feature branch that you realize you need.</p>
    <h1 id="_idParaDest-116" class="title">Summary</h1>
    <p class="normal">In this chapter, we looked at a few advanced topics:</p>
    <ul>
      <li class="bullet">Rebasing</li>
      <li class="bullet">Amending</li>
      <li class="bullet">Cherry-picking</li>
    </ul>
    <p class="normal">What all three of these have in common is that they all rewrite history. Rebasing does so by copying all the commits of one branch onto the tip of another. Amending does so by allowing you to add files and/or change the message on a commit. Finally, cherry-picking acts like rebasing, but using just one or a few commits.</p>
    <p class="normal">You saw that many of these activities are easier in Visual Studio but that some things you want to do are much clearer at the command line.</p>
    <p class="normal">Finally, we explained why you merge <em class="italic">into</em> main, but you rebase <em class="italic">onto</em> main.</p>
    <h1 id="_idParaDest-117" class="title">Challenge</h1>
    <p class="normal">Create a new repository called Panofy, which supplies MP3 music to its subscribers. There will be three branches: main, which you get when you create the repo, and two feature branches. Demonstrate the following:</p>
    <ul>
      <li class="bullet">Creating the repository</li>
      <li class="bullet">Two programmers creating feature branches</li>
      <li class="bullet">Frequent rebasing</li>
      <li class="bullet">Amending a commit to add a file</li>
      <li class="bullet">Amending a commit to change the message</li>
      <li class="bullet">Cherry-picking one commit onto main</li>
    </ul>
    <h1 id="_idParaDest-118" class="title">Answer</h1>
    <p class="normal">Once again, there are many ways to solve this challenge. Here is how I went about it.</p>
    <h2 id="_idParaDest-119" class="title">Creating a new repository on GitHub</h2>
    <p class="normal">We've seen this before, so I'll do it quickly. I'll navigate to <a href="http://GitHub.com">GitHub.com</a> and fill in the usual form, making this demo program public:</p>
    <figure class="mediaobject"><img src="img/B17741_05_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.16: Creating a new repository</p>
    <p class="normal">Once you've created the repository, you and anyone else who wants to develop against it (and has the right permissions) can clone it locally.</p>
    <h2 id="_idParaDest-120" class="title">Creating two feature branches with fake programmers</h2>
    <p class="normal">To do this, I'll create two directories, and clone to each. My first directory I'll call <code class="Code-In-Text--PACKT-">GitHub/DirA</code> and my second <code class="Code-In-Text--PACKT-">GitHub/DirB</code>. I will then clone into each:</p>
    <figure class="mediaobject"><img src="img/B17741_05_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.17: Cloning the program to the local repository</p>
    <p class="normal">Only Mateo will program in <code class="Code-In-Text--PACKT-">DirA</code>, and only Kim will program in <code class="Code-In-Text--PACKT-">DirB</code>.</p>
    <p class="normal">Create a C# program in both <code class="Code-In-Text--PACKT-">DirA</code> and <code class="Code-In-Text--PACKT-">DirB</code>. Once done, use <code class="Code-In-Text--PACKT-">git status</code> to ensure they are both pointing to main. To be certain, make a small change in <code class="Code-In-Text--PACKT-">DirA</code> and make sure it is reflected in <code class="Code-In-Text--PACKT-">DirB</code>. It is easy to become confused as to which directory your Visual Studio is pointing to. You can always right-click on the project and choose <strong class="screenText">Open folder in File Explorer</strong> to double-check.</p>
    <p class="normal">The steps I'll take to confirm that both directories have the same main branch are:</p>
    <ol>
      <li class="numbered" value="1">In branch B I will make a change and push it</li>
      <li class="numbered">In branch A I will pull the change to make my local repository</li>
      <li class="numbered">Finally, I will inspect Visual Studio in branch A to prove that it is identical to branch B:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17741_05_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.18: Cloning to ensure the two repositories are identical</p>
    <p class="normal">To keep track of what I'm looking at, I changed the name of the project for B to <code class="Code-In-Text--PACKT-">PanofyB</code>. I then pushed that and on A I pulled it, so that both stay in sync.</p>
    <p class="normal">This approach is fraught with danger, not least of which is that it is easy to overwrite the work of another developer, or to create conflicts. To avoid that, I'll create a branch for each programmer. I'll create a branch called <code class="Code-In-Text--PACKT-">Calculator</code> on A and a branch called <code class="Code-In-Text--PACKT-">Converter</code> on B.</p>
    <h2 id="_idParaDest-121" class="title">Frequent rebasing</h2>
    <p class="normal">Now that we have two branches, and to keep this simple, we'll build a new version of UtilityKnife, this time with small features and frequent merging. Mateo will go first, creating the structure of the calculator, checking it in and you would merge it into main (you would not normally do it this way – you would build a few aspects of the feature, checking it in frequently, and then when you are done merging it, but we need some demo code).</p>
    <p class="normal">When I first add to <code class="Code-In-Text--PACKT-">Calculator</code>, main is identical, so when I rebase, essentially nothing happens:</p>
    <figure class="mediaobject"><img src="img/B17741_05_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.19: Rebase early and Rebase often</p>
    <p class="normal">Let's do a bit of work on <code class="Code-In-Text--PACKT-">Calculator</code> and then get ready to push it. Before we do, however, let's do a rebase, in case work was done and pushed to main on a different thread:</p>
    <figure class="mediaobject"><img src="img/B17741_05_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.20: Pull changes and then get calculator, remembering to rebase onto main</p>
    <p class="normal">Yes! Even though another thread (in this case converter) is added to main, we were able to rebase calculator's code on top of it. We now know that there will be no conflicts, at least so far in development.</p>
    <h2 id="_idParaDest-122" class="title">Amending a commit to add a file</h2>
    <p class="normal">Let's return to the <code class="Code-In-Text--PACKT-">Calculator</code> class. We'll add a division example using doubles, check it in, and commit it:</p>
    <figure class="mediaobject"><img src="img/B17741_05_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.21: Using amend to add a file to the most recent commit</p>
    <p class="normal">After we make the commit, we realize that we intended to add a square root method as well:</p>
    <pre class="programlisting code"><code class="hljs-code">public double SquareRoot(double x)
{
    return Math.Sqrt(x);
}
</code></pre>
    <p class="normal">We'd rather not create a new commit just for that. What we want to do is amend the most recent commit. We do that with the <code class="Code-In-Text--PACKT-">--amend</code> command.</p>
    <p class="normal">To do this, we put the file(s) we want to add into the index and issue the <code class="Code-In-Text--PACKT-">git commit --amend</code> command:</p>
    <figure class="mediaobject"><img src="img/B17741_05_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.22: Amending the commit to include the change in Calculator.cs</p>
    <p class="normal">We take the following steps in the code shown above:</p>
    <ol>
      <li class="numbered" value="1">Call <code class="Code-In-Text--PACKT-">git status</code>. Note that we have a modified file, so add it to the index with <code class="Code-In-Text--PACKT-">git add</code>.</li>
      <li class="numbered">Invoke <code class="Code-In-Text--PACKT-">git commit --amend</code>, which commits the new code as part of the previous commit.</li>
      <li class="numbered">The editor will open; put in the new message. Notice that the new message is now displayed (second arrow).</li>
    </ol>
    <p class="normal">This allows us to amend the message to something more meaningful. You'll see another way to do this in the chapter on interactive rebasing.</p>
    <h2 id="_idParaDest-123" class="title">Amending a commit to change the message</h2>
    <p class="normal">If there is nothing new in the index then <code class="Code-In-Text--PACKT-">git commit --amend</code> will just give you an opportunity to change the message:</p>
    <figure class="mediaobject"><img src="img/B17741_05_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.23: Using amend to modify the message of the most recent commit</p>
    <p class="normal">We do a <code class="Code-In-Text--PACKT-">git status</code> to make sure that nothing is in the index. We then call <code class="Code-In-Text--PACKT-">git commit --amend</code> just as we did before, but we add a message (if we didn't add a message our editor would come up). Since there was nothing in the index, Git just changes the messages.</p>
    <h2 id="_idParaDest-124" class="title">Cherry-picking one commit onto main</h2>
    <p class="normal">Here is the log for main and for calculator:</p>
    <figure class="mediaobject"><img src="img/B17741_05_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.24: Cheryy-pick onto main</p>
    <p class="normal">We don't want to merge all of calculator into main but we do want to add the multiply and divide commits.</p>
    <div><p class="Information-Box--PACKT-">Okay, that is silly, but for a real-world example imagine that main is your release branch, and calculator has an important function that you want to add.</p>
    </div>
    <p class="normal">Notice the seven-integer ID next to each commit. To cherry-pick <code class="Code-In-Text--PACKT-">972d77a</code> into main, we make sure main is the current branch and then we issue the cherry-pick command with the ID of the commit we want to add:</p>
    <figure class="mediaobject"><img src="img/B17741_05_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.25: Issuing the cherry-pick command</p>
    <p class="normal">You have committed <code class="Code-In-Text--PACKT-">972d77a</code> into main, and main has one commit to push. Before we push let's look at those logs again:</p>
    <figure class="mediaobject"><img src="img/B17741_05_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.26: Examining the log after the cherry-pick</p>
    <p class="normal">Three things to notice here:</p>
    <ol>
      <li class="numbered" value="1">Main now has the add multiply and divide commit</li>
      <li class="numbered">Multiply and divide have not been removed from calculator</li>
      <li class="numbered">The ID is different for the two commits, meaning they are separate commits and manipulation of one will not affect the other</li>
    </ol>
    <p class="normal">This example answer meets the requirements of creating two feature branches off a new repo, and the "programmers" rebase frequently. We also amended a message (while local) and used cherry-picking to copy one commit onto the main branch.</p>
  </div>
</body></html>