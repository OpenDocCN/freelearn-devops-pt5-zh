- en: Using Secrets to Hide Confidential Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We cannot treat all information equally. Sensitive data needs to be handled
    with additional care. Kubernetes provides an additional level of protection through
    Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: A Secret is a relatively small amount of sensitive data. Some of the typical
    candidates for Secrets would be passwords, tokens, and SSH keys.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets are very similar to ConfigMaps. If you compare the differences
    in the syntax, you'll notice that there are only a few (if any). Conceptually,
    both ConfigMaps and Secrets are, more or less, the same. If you are familiar with
    ConfigMaps, you should have no trouble applying that knowledge to Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: We already used Secrets without even knowing. Every Pod we created so far had
    a Secret mounted automatically by the system. We'll start by exploring auto-generated
    Secrets and proceed to produce some ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll continue using Minikube, so the instructions for creating a cluster are
    still the same. They should be engraved in the back of your brain so we'll just
    execute them without any explanation.
  prefs: []
  type: TYPE_NORMAL
- en: All the commands from this chapter are available in the [`10-secret.sh`](https://gist.github.com/37b3ef7afeaf9237aeb2b9a8065b10c3)
    ([https://gist.github.com/vfarcic/37b3ef7afeaf9237aeb2b9a8065b10c3](https://gist.github.com/vfarcic/37b3ef7afeaf9237aeb2b9a8065b10c3))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll start by deploying an application without creating any user-defined Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring built-in Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create the same Jenkins objects we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We created an Ingress, a Deployment, and a Service object. We also executed
    the `kubectl rollout status` command that will tell us when the deployment is
    finished.
  prefs: []
  type: TYPE_NORMAL
- en: The `secret/jenkins-unprotected.yml` definition does not use any new feature
    so we won't waste time going through the YAML file. Instead, we'll open Jenkins
    UI in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Upon closer inspection, you'll notice that there is no login button. Jenkins
    is currently unprotected. The image does allow the option to define an initial
    administrative username and password. If the files `/etc/secrets/jenkins-user`
    and `/etc/secrets/jenkins-pass` are present, the init script will read them, and
    use the content inside those files to define the username and the password. Since
    we're already familiar with ConfigMaps, we could use them to generate those files.
    However, since the user and the password should be better protected than other
    configuration entries, we'll switch to Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in details, please explore the [`jenkins/Dockerfile`](https://github.com/vfarcic/docker-flow-stacks/blob/master/jenkins/Dockerfile)
    ([https://github.com/vfarcic/docker-flow-stacks/blob/master/jenkins/Dockerfile](https://github.com/vfarcic/docker-flow-stacks/blob/master/jenkins/Dockerfile))
    from the [`vfarcic/docker-flow-stack`](https://github.com/vfarcic/docker-flow-stacks)
    ([https://github.com/vfarcic/docker-flow-stacks](https://github.com/vfarcic/docker-flow-stacks))
    repository. The important part is that it expects `/etc/secrets/jenkins-user`
    and `/etc/secrets/jenkins-pass` files. If we can provide them, in a relatively
    secure manner, our Jenkins will be (more) secured by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by checking whether we already have some Secrets in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We did not create any Secret, and yet one is available in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The `default-token-l9fhk` Secret was created automatically by Kubernetes. It
    contains credentials that can be used to access the API. Moreover, Kubernetes
    automatically modifies the Pods to use this Secret. Unless we tweak Service Accounts,
    every Pod we create will have this Secret. Let's confirm that is indeed true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, limited to the relevant sections, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can see that two volumes are mounted. The first one (`/var/jenkins_home`)
    was defined by us. It's the same mount volume we used in the previous chapter,
    and it is meant to preserve Jenkins' state by mounting its home directory.
  prefs: []
  type: TYPE_NORMAL
- en: The second mount is the more interesting one. We can see that it references
    the auto-generated Secret `default-token-l9fhk` and that it mounts it as `/var/run/secrets/kubernetes.io/serviceaccount`.
    Let's take a look at that directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By auto-mounting that Secret, we got three files. They are required if we'd
    like to access the API server from within the containers. `ca.crt` is the certificate,
    the `namespace` contains the namespace the Pod is running in, and the last one
    is the token we'd need to establish communication with the API.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into examples that prove those files can be used to access the API
    server securely. Just remember that if you ever need to do that, Kubernetes has
    you covered through that auto-generated Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to the task at hand. We want to make Jenkins more secure by providing
    it with an initial username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting generic Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The commands to create Secrets are almost the same as those we used to create
    ConfigMaps. We can, for example, generate Secrets based on literal values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The major difference is that we specified the type of the Secret as `generic`.
    It could also be `docker-registry` or `tls`. We won't explore those two, but only
    say that the former can be used to provide `kubelet` with credentials it needs
    to pull images from private registries. The latter is used for storing certificates.
    In this chapter, we'll focus on the `generic` type of secrets which happen to
    use the same syntax as ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with ConfigMaps, generic Secrets can use `--from-env-file`, `--from-file`,
    and `--from-literal` as sources. They can be mounted as files, or transformed
    into environment variables. Since creating Secrets is so similar to creating ConfigMaps,
    we won't go into all the permutations we can do. I expect that you'll consult
    the ConfigMaps chapter if you have already forgotten the arguments we can use.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we created a Secret called `my-creds` which holds two literal values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Secrets we now have in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the newly created Secret is available and that it has two pieces
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the `json` representation of the Secret and try to find out how to
    retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows (`metadata` is removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `data` field contains the `password` and the `username`.
    They coincide with the literal values we specified in the command that created
    the Secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that the values are "strange". They are encoded. If we''d like
    to see the original values we stored as secrets, we''ll need to decode them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We used `jsonpath` to filter the output so that only the `username` data is
    retrieved. Since the value is encoded, we piped the output to `base64` command
    that decoded it for us. The result is `jdoe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the command that will retrieve and decode the second Secret data
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is `incognito`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we could mount the Secret we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, limited to the relevant parts, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We added `jenkins-creds` that mounts the `/etc/secrets` directory. The `jenkins-creds`
    Volume references the Secret named `my-creds`. Since we want the process inside
    the container to only read the Secret, we set the `defaultMode` to `0444`. That
    will give read permissions to everyone. Typically, we'd set it to `0400`, thus
    giving the read permissions only to the `root` user. However, since the Jenkins
    image uses the `jenkins` user, we gave read permissions to everyone instead of
    only to the `root` user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since the image expected files named `jenkins-user` and `jenkins-pass`,
    we made explicit paths. Otherwise, Kubernetes would create files `username` and
    `password`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply the new definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We applied the definition and waited until the new objects were rolled out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can check whether the correct files are indeed stored in the `/etc/secrets`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the latter command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The files we need are indeed injected. To be on the safe side, we''ll also
    check the content of one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The output is `jdoe`, the username of our newly deployed Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's confirm that the application is indeed secured.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You'll see that, this time, the link to create new jobs is gone.
  prefs: []
  type: TYPE_NORMAL
- en: Please use `jdoe` and `incognito` if you'd like to login to your newly deployed
    and (more) secured Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets compared to ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, Kubernetes Secrets do not seem to differ from ConfigMaps. From a functional
    perspective, they are, indeed, the same. Both allow us to inject some content.
    Both can use files, literal values, and files with environment variables as data
    sources. Both can output data into containers as files or as environment variables.
    Even the syntax for using Secrets is almost the same as the one used for ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: The only significant difference between ConfigMaps and Secrets is that the latter
    creates files in a tmpfs. They are constructed as in-memory files, thus leaving
    no trace on the host's files system. That, in itself, is not enough to call Secrets
    secure, but it is a step towards it. We'd need to combine them with *Authorization
    Policies* to make the passwords, keys, tokens, and other never-to-be-seen-by-publicly
    types of data secure. Even then, we might want to turn our attention towards third-party
    Secret managers like HashiCorp Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: Secrets are almost the same as ConfigMaps. The main difference is that the secret
    files are created in tmpfs. Kubernetes secrets do not make your system secure.
    They are only a step towards such a system.
  prefs: []
  type: TYPE_NORMAL
- en: Not so secretive Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost everything Kubernetes needs is stored in etcd ([https://github.com/coreos/etcd](https://github.com/coreos/etcd)).
    That includes Secrets. The problem is that they are stored as plain text. Anyone
    with access to etcd has access to Kubernetes Secrets. We can limit the access
    to etcd, but that's not the end of our troubles. *etcd* stores data to disk as
    plain text. Restricting the access to etcd still leaves the Secrets vulnerable
    to who has access to the file system. That, in a way, diminishes the advantage
    of storing Secrets in containers in tmpfs. There's not much benefit of having
    them in tmpfs used by containers, if those same Secrets are stored on disk by
    etcd.
  prefs: []
  type: TYPE_NORMAL
- en: Even after securing the access to etcd and making sure that unauthorized users
    do not have access to the file system partition used by etcd, we are still at
    risk. When multiple replicas of etcd are running, data is synchronized between
    them. By default, etcd communication between replicas is not secured. Anyone sniffing
    that communication could get a hold of our secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets are a step in the right direction. It is, without a doubt,
    better to use Secrets than to expose confidential information as environment variables
    or other less secure methods. Still, Secrets can give us a false sense of security.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to take additional precautions to protect ourselves. That might include,
    but is not limited to, the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure the communication between etcd instances with SSL/TLS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the access to etcd and wipe the disk or partitions that were used by it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not define Secrets in YAML files stored in a repository. Create Secrets through
    ad-hoc `kubectl create secret` commands. If possible, delete commands history
    afterward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the applications using Secrets do not accidentally output them
    to logs or transmit them to other applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create policies that allow only trusted users to retrieve secrets. However,
    you should be aware that even with proper policies in place, any user with permissions
    to run a Pod could mount a Secret and read it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did not yet explore etcd configuration, nor did we learn how to set up authorization
    policies. For now, just remember that Secrets are not as secured as one might
    think. At least, not those provided by Kubernetes community. I do encourage you
    to use them, as long as you're aware of their shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: What now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There isn''t much left to say, so we''ll enter into the destructive mode and
    eliminate the cluster we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you'd like to know more about Secrets, please explore Secret v1 core ([https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#secret-v1-core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#secret-v1-core))
    API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4078c60-a951-4aa5-8c6b-0cf6fd8939a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: The components explored so far'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets compared to Docker Swarm Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets are very similar to Kubernetes ConfigMaps and Docker Swarm configs.
    Everything we said for configurations applies to Secrets, with a few additional
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Both Kubernetes and Docker Swarm stores Secrets in tmpfs inside containers.
    From that aspect, they are equally secure. The significant difference is in the
    way Secrets are stored internally.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes stores Secrets in etcd. By default, they are exposed, and we need
    to take extra precautions to protect them. Docker Swarm secrets are, on the other
    hand, more secure by default. They are synchronized between managers using SSL/TLS,
    and they are encrypted at rest. I prefer "secured by default" approach behind
    Docker Swarm secrets. In Kubernetes, we need to take extra steps to reach a similar
    level of security as with Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Kubernetes integration with third-party solutions for secrets
    is much better. For example, plugging in HashiCorp Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/))
    into a Kubernetes workflow is much smoother than if we'd try to integrate it with
    Docker Swarm. Using Vault is a better solution than what Kubernetes and Swarm
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Kubernetes can be made more secure with Vault and similar products,
    for now, we are evaluating secrets management that comes with Kubernetes and Docker
    Swarm. If we exclude third-party solutions, Docker Swarm has a clear advantage
    over Kubernetes. Its secrets are more secure by default. Even after tweaking Kubernetes
    (especially etcd), Docker Swarm is still more secure. That does not mean that
    secrets management with both products does not have a lot to be desired. Both
    have their shortcomings. However, I must proclaim Docker Swarm as a winner in
    this round. Its secrets are more secretive.
  prefs: []
  type: TYPE_NORMAL
