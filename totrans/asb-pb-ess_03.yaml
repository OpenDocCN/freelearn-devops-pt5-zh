- en: Chapter 2. Going Modular with Ansible Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you learned about writing a simple playbook with Ansible.
    You also learned about the concepts of plays which map hosts to tasks. Writing
    tasks in a single playbook may work fine for a very simple setup. However, if
    we have multiple applications spanning across number of hosts, this will quickly
    become unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will be introduced to the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: What makes a role and what are roles used for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create roles to provide abstraction?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing content to provide modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using include statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing simple tasks and handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing packages, managing services, and serving files with Ansible modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real-life scenarios, we will mostly be configuring web servers, database
    servers, load balancers, middleware queues, and so on. If you take one step back
    and look at the big picture, you will realize that you are configuring groups
    of identical servers in a repeatable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: To manage such infrastructures in the most efficient way, we need some abstraction
    which allows us to define what we need to configure in each of these groups, and
    call them by name. That's exactly what roles do. Ansible roles allow us to configure
    groups of nodes at the same time, without repeating ourselves. Roles also provide
    a way to create modular code, which then can then be shared and reused.
  prefs: []
  type: TYPE_NORMAL
- en: Naming roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common practice is to create roles that map to each application or component
    of your infrastructure that you would like to configure. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tomcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directory layout for roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roles are nothing but directories laid out in a specific manner. Roles follow
    predefined directory layout conventions and expect each component to be in the
    path meant for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a role, called Nginx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The directory layout for roles](img/B03800_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now look at the rules of the game and what each of the components in
    the preceding diagram is for:'
  prefs: []
  type: TYPE_NORMAL
- en: Each role contains a directory which is named after itself, for example, `Nginx`,
    with `roles/` as its parent directory. Each named role directory contains one
    or more optional subdirectories. The most common subdirectories to be present
    are tasks, templates, and handlers. Each of these subdirectories typically contain
    the `main.yml` file, which is a default file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks contain the core logic, for example, they will have code specifications
    to install packages, start services, manage files, and so on. If we consider a
    role to be a movie, a task would be the protagonist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks alone cannot do everything. Considering our analogy with movies, it's
    incomplete without the supporting cast. Protagonists have friends, cars, lovers,
    and antagonists to complete the story. Similarly, tasks consume data, call for
    static or dynamic files, trigger actions, and so on. That's where files, handlers,
    templates, defaults, and `vars` come in. Let's look at what these are for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vars and defaults provide data about your application/role, for example, which
    port your server should run on, the path for storing the application data, which
    user to run the service as, and so on. Default variables were introduced in version
    1.3 and these allow us to provide sane defaults. These can later be overridden
    from other places, for example, `vars`, `group_vars`, and `host_vars`. Variables
    are merged and precedence rules apply. This gives us a lot of flexibility to configure
    our servers selectively. For example, running the web server on port `80` on all
    hosts except for the ones in the staging environment, which should run it on port
    `8080`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files and templates subdirectories provide options for managing files. Typically,
    the files subdirectory is used to copy over static files to destination hosts,
    for example, some application installers archive static text files, and so on.
    In addition to static files, frequently you may need to manage files that are
    are generated on the fly. For example, a configuration file that has parameters
    such as port, user, and memory, which can be provided dynamically using variables.
    Generating such files requires a special type of primitive, called templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks can trigger actions based on the change of a state or a condition. In
    a movie, the protagonist may chase the antagonist and take revenge based on the
    provocation or an event. An example event is kidnapping the protagonist's lady
    love. Similarly, you may need to perform an action on your hosts, for example,
    restarting a service based on what happened earlier, which could be a change in
    the state of a configuration file. This trigger-action relationship can be specified
    using a handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing our analogy, many popular movies have sequels and sometimes even
    prequels. In such cases, one should watch it in a particular order, as the storyline
    of a sequel depends on something that happened in the previous movie. Similarly,
    a role can have a dependency on another role. A very common example is, before
    installing Tomcat, Java should be present on the system. These dependencies are
    defined in the meta subdirectory of a role.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get hands-on with this by creating a role for the Nginx application. Let's
    take a problem statement, try to solve it, and learn about roles in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following scenario. With the onset of the soccer world cup, we
    need to create a web server to serve up a page on sports news.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a follower of agile methodologies, we will do this in phases. In the
    first phase, we will just install a web server and serve up a home page. Let''s
    now break this down into the steps we need to take to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Install a web server. In this case, we will use 'Nginx' as it is a lightweight
    web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manage configuration for the Nginx web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the web server after installing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy over an HTML file, which will be served as a home page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have identified what steps to take, we also need to map them to
    the respective module types we will use to achieve each of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Nginx = Package module (apt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Nginx = File module (file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting Nginx = Systems module (service)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve Webpage = Files module (file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start writing code, we will start creating a layout to organize our
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a site-wide playbook, nesting, and using include statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a best practice, we will create a top-level file, which will contain the
    blueprint of our complete infrastructure. Technically, we can include everything
    that we need to configure inside just one file. However, that would have two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: It would quickly get out of control as we start adding tasks, variables, and
    handlers to this single file. It would be a nightmare to maintain such code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would also be difficult to reuse and share such code. One of the advantages
    of using a tool such as Ansible is its ability to separate data from code. Data
    is organization-specific, and code is generic. This generic code can then be shared
    with others. However, if you write everything in a single file, it would be impossible
    to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To avoid this problem, we will start organizing our code in a modular fashion,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We will create roles for each of the applications that we need to configure.
    In this case, it is Nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our web server may need to install more than one application in addition to
    Nginx, for example, PHP and OpenSSL. To encapsulate all of these, we will create
    a playbook named `www.yml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding playbook that we created will map hosts with the Nginx role. We
    may add more roles to it later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will add this playbook to the top-level playbook, that is, `site.yml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram depicts the preceding steps in a very simple manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a site-wide playbook, nesting, and using include statements](img/B03800_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is our `site.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `include` directive assists us with modularizing the code. Instead
    of writing it all in one file, we split the logic and import what is required.
    In this case, we will include another playbook, which is called a **nested playbook**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some guidelines on what can be included and how:'
  prefs: []
  type: TYPE_NORMAL
- en: The `include` directive can be used to include tasks, handlers, and even other
    playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you include a playbook inside another like we did in the `site.yml` file,
    you cannot substitute the variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `include` keyword can be used in combination with regular task/handler specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to pass parameters with include statements. This is called as
    **parameterized** **include**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Roles and auto-includes**'
  prefs: []
  type: TYPE_NORMAL
- en: Roles have implicit rules to auto include files. So long as you follow the directory
    layout conventions, you are assured that all your tasks, handlers, and the rest
    of the files are included automatically. Hence, it's important to create the subdirectories
    with the exact names as specified by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the www playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created a site-wide playbook and used an include statement to call another
    playbook by the name `www.yml`. We will now create this file with one play, which
    maps our web server hosts to the Nginx role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run this code on any host that maps to the `[www]` group specified in the hosts
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each directory inside the `roles/nginx/*` file, include `roles/nginx/*/main.yml`
    to the play. This includes `tasks`, `handlers`, `vars`, `meta`, `default,` and
    so on. This is where the auto include rules apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default and custom role paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Ansible looks inside the `roles/` subdirectory of the project that
    we create playbooks for. Being top-class devops engineers, we will follow the
    best practice to have a centralized, version-controlled repository to store all
    your roles. We may also end up reusing the roles created by community. Once we
    do this, we can reuse these roles across multiple projects. In such cases, we
    will check out the code at one or more locations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/deploy/ansible/roles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/deploy/ansible/community/roles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For nondefault paths, we will need to add the `roles_path` parameter to `ansible.cfg`
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Parameterizing the roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, we may need to override default parameters specified inside vars
    or the default directory of a role, for example, running web servers on port 8080
    instead of 80\. In such cases, we can also pass parameters to roles in the preceding
    playbook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a base role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a simple playbook with all plays written
    inside the same file. After discovering new and exciting information about roles,
    we will start refactoring our code and making it modular.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our code – creating a base role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have written two plays in the `simple_playbook.yml` file. We intended to
    run the first play on all hosts. This play has tasks to create users, install
    essential packages, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring our code – creating a base role](img/B03800_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s a good practice to combine all such essential tasks and create a base
    role. You can name it as base, common, essential, or whatever you please, but
    the concept remains the same. We will now move this code to the base role:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directory layout for the base role. Since we are only going to specify
    tasks, we just need one subdirectory inside the base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `main.yml` file inside `roles/base/tasks` to specify tasks for the
    base role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `main.yml` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating an Nginx role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now create a separate role for Nginx and move the previous code that
    we wrote in the `simple_playbook.yml` file to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directory layout for the Nginx role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `install.yml` file inside `roles/base`. Move the Nginx-related tasks
    to it. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also create the `service.yml` file to manage the state of the Nginx
    daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We looked at the `include` directive earlier. We will use it to include both
    the `install.yml` and `service.yml` files in the `main.yml` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best Practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Why are we creating multiple files to hold the code that installs packages and
    manages services, separately? That's because well-factored roles allow you to
    selectively enable specific features. For example, at times, you may want to deploy
    services in multiple phases. In the first phase, you may just want to install
    and configure applications, and start services only in the second phase of your
    deployment. In such cases, having modular tasks can help. You can always include
    them all in the `main.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding role dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have some essential tasks specified in the base role. We may keep on adding
    more tasks which are a prerequisite for the applications that follow. In such
    cases, we would like our Nginx role to be dependent on the base role. We will
    now specify this dependency inside the meta subdirectory. Let''s take a look at
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `main.yml` file inside the `roles/nginx/meta/main.yml` path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `main.yml` file inside the `meta` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding specification will ensure that the base role is always applied
    before any task in Nginx starts running.
  prefs: []
  type: TYPE_NORMAL
- en: Managing files for Nginx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As per our solution to the scenario, we already have Ansible tasks to install
    Nginx and to start the service. We still don't have a web page to serve yet, and
    we did not think about the Nginx site configurations. We don't expect Nginx to
    magically know about how and where to serve the web page from, do we?
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to perform the following steps to serve the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a site configuration that lets Nginx know which port to listen to for
    requests, and what to do when a request comes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create some HTML content, which will be served when an HTTP request comes in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to `tasks/main.yml` to copy over these files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might have noticed, both steps 1 and 2 require that you create and manage
    some files on the host, which will run the Nginx web server. You also learned
    about the file and the subdirectory of a role. You guessed it right. We will use
    this subdirectory to host our files and have them copied over to all the Nginx
    hosts with Ansible. So, let''s create these files now using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `default.configuration` file to manage the default Nginx site configurations.
    This file should contain parameters such as port, server name, and web root configurations,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create an `index.html` file, which we will push to all web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created these files, we will add tasks to copy these over
    and put them in `roles/nginx/tasks/configure.yml,` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also update the `main.yaml` file inside tasks to include the newly
    created file, and add it before the `service.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Automating events and actions with handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we are managing Nginx manually, and that we have to change
    the port that Nginx listens to from the default site to `8080`. What would we
    do to make this happen? Sure, we would edit the `default.conf` file and change
    the port from 80 to 8080\. However, would that be enough? Would that make Nginx
    listen to port 8080 immediately after editing this file? The answer is no. There
    is one more step involved. Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating events and actions with handlers](img/B03800_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we change a configuration file, we will typically also restart/reload the
    service so that it reads our modifications and applies those.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. Now let's come back to our Ansible code. We are going to run
    this code in an automated fashion on a large number of servers, possibly hundreds.
    Considering this, it's not feasible for us to log in to each system to restart
    services after every change. This defeats the purpose of automating the process.
    Now, how do we ask Ansible to take action when an event occurs? That's where handlers
    can help.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that Ansible modules are idempotent. They will enforce a change
    in state only if there is a configuration drift. When managing with Ansible, we
    will commit the preceding port change in the `default.conf` file inside `roles/nginx/files`.
    If we launch an Ansible run after making this change then, while executing, it
    will compare the file inside our role with the one on the system, detect the configuration
    drift, and copy it over to the changed file. With Ansible, this is where we will
    add a notification that will trigger a handler to run. In this case, we will call
    a handler to restart the Nginx service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add this handler to `roles/nginx/handlers/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Handlers are similar to regular tasks. They specify a module's name, instance,
    and state. Why do we not add them with regular tasks then? Well, we only need
    to execute handlers,when an event occurs, not every time we run, ansible. And
    that's the exact reason why we create a separate section for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have written the handler, we also need to add a trigger for it.
    We will do this by adding the `notify` directive to `roles/tasks/nginx/configure.yml`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating events and actions with handlers](img/B03800_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even when multiple tasks notify the handler, it will be called only once, toward
    the end. This will avoid multiple restarts of the same service unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, our Nginx role layout looks more complete and has files, handlers,
    tasks, and directories with individual tasks to manage each phase of the Nginx
    setup. The role layout is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating events and actions with handlers](img/B03800_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding pre-tasks and post-tasks to playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would like to print status messages before and after we begin applying Nginx.
    Let''s add it to our `www.yml` playbook with the `pre_tasks` and `post_tasks`
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we only printed some messages using the `echo` command.
    However, we can create tasks using any of the modules available with Ansible,
    which can run before, or after, applying roles.
  prefs: []
  type: TYPE_NORMAL
- en: Running playbooks with roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now apply the refactored code to our hosts. We are going to launch only
    the site-wide playbook, that is, the `site.yml` file and then rely on the include
    statements and roles to do the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running playbooks with roles](img/B03800_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the output we saw last time, there are some new messages this
    time. Let''s analyze those:'
  prefs: []
  type: TYPE_NORMAL
- en: Before and after, roles are applied, pre-tasks and post-tasks get triggered;
    this prints messages using the shell module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have the code to copy to the `config` and .`html` file for our Nginx
    web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also see that the handler triggers an Nginx service restart. This is due
    to the change in the state for the `configuration` file, which triggers the handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you notice that tasks in the base role also get triggered, even when we
    have not mentioned the base role in the `www` playbook? This is where meta information
    is useful. Remember we had specified a dependency on the base role inside `meta/main.yml`
    for Nginx? That's what did the trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: Roles contain ___ and ___ subdirectories to specify variables/parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you specify a dependency on another role?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we add roles to a play, why is it not required that we use the `include`
    directives? How do the tasks, handlers, and so on, get added to the play automatically?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we have a separate section for handlers if they resemble regular tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module can be used to copy over static files to destination hosts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you specify the tasks to be run before applying a role in a playbook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use roles to provide abstraction and to
    help modularizing code for reuse. That's exactly what you see community doing.
    Creating roles, and sharing them with you. You also learned about `include` directives,
    directory layout for roles, and adding role dependencies. We then went on to refactor
    our code and created a base role, the Nginx role. We also looked at how to manage
    events and take actions using handlers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend the concepts of roles and start adding dynamic
    data with variables and templates.
  prefs: []
  type: TYPE_NORMAL
