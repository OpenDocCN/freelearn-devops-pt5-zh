- en: Enhancing Your Daily Work with Git Hooks, Aliases, and Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a branch description in a commit message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic commit message template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external information in a commit message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing the push of specific commits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and using Git aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and using Git scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and using a commit template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to work efficiently in a corporate environment, there are certain prerequisites,
    or rules, regarding any code that is produced. It should be able to compile and
    pass specific sets of unit tests. There should also be certain documentation in
    the commit messages, such as references to a bug fix ID or an instance. Most of
    these rules can be automated using scripts. But why not put these rules into the
    process? In this chapter, you will see some examples of how to transfer data from
    one location to a commit message before you see the message. You will also learn
    how you can verify whether you are pushing your code to the right location. Finally,
    you will see how you can add scripts to Git.
  prefs: []
  type: TYPE_NORMAL
- en: A hook in Git is a script that will be triggered on events, such as pushing,
    committing, or rebasing. If these scripts exit with a non-zero value, it is probably
    best to cancel the current Git operation. You can find these hook scripts in the
    `.git/hooks` folder in any Git clone. If they have the `.sample` file extension,
    they are not active.
  prefs: []
  type: TYPE_NORMAL
- en: Using a branch description in a commit message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](05533902-404c-4c14-9755-7137337e8190.xhtml), *Branching, Merging,
    and Options*, we mentioned that you can set a description on your branch, and
    this information can be retrieved from a script using the `git config --get branch.<branchname>
    description` command. In this example, we will take this information and use it
    for the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the `prepare-commit-msg` hook. The `prepare-commit-msg` hook
    is executed every time you want to commit, and the hook can be set to anything
    you wish to check, before you actually see the commit message editor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a clone and a branch to get started on this exercise, hence we will
    clone `jgit` again to the `chapter7.5` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out a local `descriptioInCommit` branch that tracks the `origin/stable-3.2`
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by setting the description of our local branch. Then, we will
    create the hook that can extract this information and put it in the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our local `descriptioInCommit` branch, for which we need to set a description.
    We will use the `--edit-description` Git branch to add a description to our local
    branch. This opens the description editor, and you can type in a message by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the command, the description editor will open and you can
    type in a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, type in the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should write your branch description just as you write your commit messages. It
    make sense then to reuse the description in the commit. Now, we will verify whether
    we have a message with the following description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we have the desired output. Now, we can continue creating the hook
    that will take the description and use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will check whether we have a description for the hook and, if we do,
    we will use that description as the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will ensure that we can get the information into the commit message
    at our desired position. There are many ways to do this and we have settled on
    the following method: open the `.git/hook/prepare-commit-msg` hook file, type
    in the following script, and make it executable (`chmod +x`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try to create a commit and see whether the message is being displayed
    as predicted. Use `git commit --allow-empty` to generate an empty commit, but
    also to trigger the prepare-commit-msg hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the message editor with our branch description as the commit
    message, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is as we expected. Save the commit message and close the editor. Try using
    the `git log -1` command to verify whether we have the following message in our
    commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get something similar to a commit message that is the same as our
    branch description. However, what about an empty branch description? How will
    our hook handle that? We can try again with a new branch named `noDescriptionBranch`.
    Use `git checkout` to create it, and check it as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will make yet another empty commit to see whether the commit message
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the commit message editor with the default commit message text,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is all as we expected. This script can be combined with the next exercise,
    which will take content from a defective system as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic commit message template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers can be encouraged to do the right thing, or developers can be forced
    to do the right thing. However, in the end, developers need to spend time coding.
    So, if a good commit message is required, we can use the `prepare-commit-msg`
    hook to assist the developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will create a commit message for developers that contains
    information about the state of the work area. It will also insert some information
    from a web page. This could just as well be defect information from Bugzilla.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start this exercise, we will not be cloning a repository, but creating one. To
    do this, we will be using `git init`, as shown in the following code. You can
    use `git init <directory>` to create a new repository somewhere, or you can go
    to a directory and execute `git init` and Git will create a repository for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have our `chapter7` directory, where we just initialized our repository.
    In this directory, the hooks are already available. Just look in the `.git/hooks`
    directory. We will be using the `prepare-commit-msg` hook. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by looking in the folder with the following hooks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are plenty of hooks in each of the hook files. There
    is an example script, and a short explanation of what the hook does and when it
    is executed. To enable `prepare-commit-msg`, rename the file as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Open the `prepare-commit-msg` file in your preferred editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can read the information in the file, but for our examples, we will clear
    the file so that we can include the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, include the following command in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, try to commit either something or nothing. Usually, you cannot make
    a commit that is empty, but with the `--allow-empty` option, you can create an
    empty commit as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we get the message we put in the `prepare-commit-msg` script
    file. You can check whether or not we have a commit by using `git log -1` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is no commit, and we get an error message that we have not seen before.
    The message has to be there because there is no commit so far in this repository.
    Before we make further changes to the script, we should know that the `prepare-commit-msg`
    hook takes some arguments, depending on the situation. The first argument is always
    `.git/COMMIT_EDITMSG`, and the second argument can be merge, commit, squash, or
    template, depending on the situation. We can use these in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the script so that we can reject amending commits as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have changed the script, let''s create a commit and try to amend
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a commit, let''s try to amend it using `git commit --amend`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we expected, we were not allowed to amend the commit. If we wish to extract
    some information, for instance, from a bug handling system, we will have to put
    this information into the file before opening the editor. So, again, we will change
    the script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This script downloads a commit message from `http://www.whatthecommit.com/`
    and inserts it into the commit message. Every time you commit, you will get a
    new message from the web page. Let''s give it a try by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the commit message editor opens, you should see a message from `whatthecommit.com`.
    Close the editor and, using `git log -1`, verify whether we have the commit, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we have succeeded with the commit. Obviously, this is not the
    best message to have for the committer. A more typical usage is to list the bugs
    assigned to the developer, as follows, in the commit message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This way, the developer can easily select the correct bug ID, or the artefact
    ID, from TeamForge in this case, using the correct format for the other systems
    that will look into the commit messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can extend the functionality of the `prepare-commit-msg` hook easily, but
    you should bear in mind that the waiting time for fetching some information should
    be worth the benefits. One thing that is usually easy to check is a dirty work
    area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we need to use the `git status` command in the prepare commit message
    hook, and we need to predict whether we will have modified files after the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check this, we need to have something staged for committing and some unstaged
    changes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify the `fishtank.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `git status --porcelain` to check the work area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the file to the staging area using `git add`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try `git status --porcelain`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What you should note is the space before `M` the first time we use the `--porcelain`
    option for Git status. The `porcelain` option provides a machine-friendly output
    that shows the state of the files for Git status. The first character is the status
    in the staging area, whereas the second character is the status in the work area.
    So, `MM fishtank.txt` would mean the file is modified in the work area and in
    the staging area. So, if you modify `fishtank.txt` again, the following is the
    result you can expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the output from Git status is `MM fishtank.txt`. We can use this
    in the hook to tell whether or not the work area will have uncommitted changes
    after we commit. Add the following command to the `prepare-commit-msg` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we list all the files that have changed with `git status --porcelain`.
    Then, for each of these files, we check whether there is a second character. If
    this is true, we will have a dirty work area after the commit. In the end, we
    just insert the message into the commit message so that it is available for the
    developer to see. Let''s try and commit the change by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that you have a message similar to the following. The first line might
    be different, as we still have the message from `http://www.whatthecommit.com/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving the file and closing the editor will create the commit. Verify this
    with `git log -1`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the information we expected. The text about the dirty work area is
    in the commit message . To clean up nicely before the next exercise, we should
    reset our work area to `HEAD`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is just a matter of finding out what suits you. Is there any information
    you would like to check before you commit and potentially push the code to a remote
    branch? This may include:'
  prefs: []
  type: TYPE_NORMAL
- en: Style checks in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Pylint to check your Python scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for files that you are not allowed to add to Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is not exhaustive; there is probably something to add for every organization
    or development team in the world. However, this clearly is one way of taking tedious
    manual work away from the developer so that he or she can focus on coding.
  prefs: []
  type: TYPE_NORMAL
- en: Using external information in a commit message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The commit hook is executed when you close the commit message editor. It can,
    among other things, be used to manipulate the commit message or do an automatic review
    of the commit message to check whether it has a specific format.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be manipulating and checking the content of a commit
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start this exercise, we just need to create a branch and check it out. We
    need to disable the current `prepare-commit-msg` hook; we can do this by simply
    renaming it. Now, we can start working on the `commit-msg` hook by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we want to do in the first example is to check whether or not the defect
    information is correct. There is no need to release a commit that refers to a
    defect that does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by testing the `commit-msg` hook. First, make a copy of the current
    hook, then we will force the hook to exit with a non-zero value that will abort
    the creation of the commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the file in your preferred editor and add the following lines to
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will try to make a commit and see what happens, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The editor will open, you can write a small commit message, and then close
    the editor. You should see the `you are not allowed to commit` message, and if
    you check with `git log -1`, you will see that you don''t have a commit with the
    message you just wrote, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the commit message hook is executed after you close the message
    editor, whereas the `prepare-commit-msg` hook is executed before the message editor.
    To validate, if we have a proper reference to the hook in our commit message,
    we will be checking whether a specific error is available for the Jenkins-CI project.
    Replace the lines in the `commit-msg` hook so that it looks like the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using curl to retrieve the web page and, if it is empty, we know that
    the ID does not exist. Now, we should create a commit and see what happens if
    we put in the wrong ID, `jenkins 384895`, or an ID that exists as `jenkins 3157`.
    To check this, we will create a commit as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the commit message, write something such as `Feature cascading...` as a
    commit message subject. Then, in the body of the commit message, insert `jenkins
    384895`. This is the important part, as the hook will use that number to look
    it up on the Jenkins issue tracker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You should end up with the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we expected. Now, verify whether the change has been committed
    or not with `git status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will try to commit again; this time, we will be using the correct JIRA
    ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Key in a commit message like the previous one; this time, make sure the Jenkins
    issue ID is one that exists. You can use `51444`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving the commit message should result in an output as follows. We can clean
    it some more by removing the title HTML tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can get information to output. We could also add this information
    to the commit message itself. Then, we can change and insert this as the `else`
    clause in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, we will create a commit again, and, in the message, we need to
    specify the JIRA ID that exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify whether we got the information in the message, we will use `git log
    -1` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we have the information at the end of the commit. In these examples,
    we are just discarding the commit message if the JIRA ID does not exist. This
    is a little harsh to the developer. So, you can combine this with the `prepare-commit-msg`
    hook. If `commit-msg` halts the commit process, then save the message temporarily
    so that the `prepare-commit-msg` hook can use that message when the developer
    tries again.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing the push of specific commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pre-push hooks are triggered whenever you use the push command and the script
    execution happens before the push. So, we can prevent a push if we find a reason
    to reject it.
  prefs: []
  type: TYPE_NORMAL
- en: One reason could be that you have a commit with the `nopush` text in the commit
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the Git pre-push, we need to have a remote repository. We will be cloning
    `jgit` again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to be able to push to a remote branch but, unfortunately, Git will
    try to authenticate through HTTPS for the `jgit` repository before the hooks are
    executed. Because of this, we will create a local clone from the `chapter7.1`
    directory, as follows. This will make our remote a local folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We are cloning the `chapter7.1` directory in a folder named `chapter7.2`, and
    will check the `master` branch when the clone has finished.
  prefs: []
  type: TYPE_NORMAL
- en: What we now want to do is to create a commit with a commit message that has
    `nopush` as part of it. By adding this word to the commit message, the code in
    the hook will automatically stop the push. We will be doing this on top of a branch.
    So, to start with, you should check out a `prepushHook` branch that tracks the
    `origin/master` branch and then creates a commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try to push it to the remote when we have the pre-push commit in place,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new branch named `prepushHook`, which tracks `origin/master`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use `reset` to go back to an earlier commit. It is not important how
    far back we go. So, we have just selected a random commit as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a commit. We will do a simple inline replace with `sed`,
    and then add `pom.xml` and commit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify whether we have the commit with the text, run `git log -1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We have what we want in the commit message. Now, we just need to prepare the
    hook. We will start by copying the sample hook to the real name so that it will
    be executed on push:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the hook so that its code is as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to push. We will be pushing our current branch `HEAD` to the
    `master` branch in the remote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the hook is being executed, and the push is being denied by the
    hook. Now, we can implement the check we want to carry out. If we have the word
    `nopush` in any commit message, we want to exit. We can use `git log --grep` to
    search for commits with the keyword `nopush` in the commit message, as shown in
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We have our newly created commit with the keyword `nopush`. Now, we will perform
    a simple check for this in the hook and edit the pre-push hook so that it has
    the following text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try to push again to see what the result will be. We will try to
    push our `HEAD` to the master branch on the remote `origin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we are not allowed to push as we have the `nopush` message in the
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a hook to prevent you from pushing commits that you don't want to push
    is very handy. You can specify any keywords you want. Words such as `reword`,
    `temp`, `nopush`, `temporary`, or `hack` can all be things you want to stop, but
    sometimes you want to get them through anyway.
  prefs: []
  type: TYPE_NORMAL
- en: What you can do is have a small checker that checks for specific words, then
    lists the commits, and asks if you want to push anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change the script to the following snippet, the hook will try to find
    commits with the keyword `nopush` and list them. If you wish to push them in any
    case, you can answer the question and Git will push anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it with the `git push` command again, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Type `n` and press *Enter*. Then, expect the push to be aborted with the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As predicted, it will not push. However, if you press y, Git will push to the
    remote. Try this now using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As predicted, the push will be tried, but, as you can see from the output, it
    is rejected by the remote. This is because we diverged, and the push was not working
    at the tip of the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: So, with this hook, you can make your life a little easier by having the hook
    prevent you from accidentally pushing something you are not interested in being
    pushed. This example also considers commits that have been released; so, if you
    select a different keyword, then other commits—not only the locally created ones—will
    be taken into consideration by the script.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and using Git aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git aliases, like Unix aliases, are short commands that can be configured on
    a global level or for each repository. It is a simple way of renaming some Git
    commands to use short abbreviations, for example, `git checkout` could be `git
    co`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very simple and straightforward to create an alias. You simply need to
    configure it with `git config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we will do is check a branch and then create its aliases one by one and
    execute them to view their output by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: So, we will start by checking a branch named `gitAlias`, which tracks the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`origin/stable-3.2` branch:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can start creating some aliases. We will start with the following
    one, which will simply just amend your commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this alias will open the commit message editor with the following
    message from the `HEAD` commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it can be very simple to speed up the process of your daily
    workflow with Git aliases. The following command will just work on the last 10
    commits using `--oneline` as an option for `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the alias will give you the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also perform a simple checkout. Thus, instead of using the Git checkout, you
    can use `git co <branch>.` Configure it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the aliases take arguments, just as the regular Git command
    does. Let''s try the alias using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The command works as expected. You may wonder why we diverged after checking
    out the `gitAlias` branch again. Then, we diverged when we amended the `HEAD`
    commit. The next alias is creating a commit with everything that has not been
    committed in the work area, except for the untracked files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can test the alias, we should create a file and modify it to show
    what it actually does. So, create a file as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify what you want, run `git status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test the alias using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify whether the `aquarium` file was part of the commit or not, use `git
    status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `git log -1` to see the commit we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is just as we expected. The next alias is a little different, as
    it will count the number of commits in the repository, and this can be done with
    the `wc` (`wordcount`) tool. However, since this is not a built-in Git tool, we
    have to use the exclamation mark and also specify Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'So, currently, we have `3008` commits in the repository. This also means you
    can execute external tools as if they were Git tools just by creating a Git alias;
    for instance, if you are using Windows, Mac, or Linux, you can create an alias
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This alias will open up an Window Explorer at the path you are currently at.
    The next one shows what changed in the `HEAD` commit. It executes this with the
    `--name-status` option for `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try it using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it simply lists the commit and the files, including what happened
    to the files in the commit. As the aliases take arguments, we can actually reuse
    this functionality to list the information for another branch. Let''s try it with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get the expected output. So, for instance, if you have been
    using a specific set of options for `git diff`, then you can make it an alias
    to use it with ease.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is as simple as inserting text in the `config` file. So, you can try and
    open the `.git/config` configuration file, or you can list the configuration with
    `git config -list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The `alias` feature is very strong, and the idea behind it is that you should
    use it to shorten those long one-liners that you often use. You can also use this
    feature to cut down those one-liners to shorter aliases so that you can use the
    command frequently and with more precision. If you have a long and complex Git
    comment as an alias, you will run it the same way every time, where keying a long
    command is bound to fail once in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and using Git scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, we have aliases, and aliases do what they do best – take short one-liners
    and convert them into short, useful Git commands. However, when it comes to longer
    scripts that are also a part of your process, and you would like to incorporate
    them into Git, you can simply name the script `git-scriptname`, and then use it
    as `git scriptname`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few things to remember. The script has to be in your path so that
    Git can use the script. Besides this, only imagination sets the boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite editor and insert the following lines into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file with the name `git-likeaboss`. This is a very simple script that
    will list random commit subjects with either passed or failed as the result. It
    will not stop until you press *Ctrl* + *C*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can also tab complete these commands, and Git will take them
    into consideration when you slightly misspell commands, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this script, in itself, is not so useful in a day-to-day environment,
    but we hope you get the point we are trying to make. All scripts revolve around
    the software delivery chain and you can name them Git as they are part of Git.
    This makes it much easier to remember which of the scripts you have are available
    for your job.
  prefs: []
  type: TYPE_NORMAL
- en: Both Git aliases and Git scripts will show up as Git commands when using tab
    completion. Type in `git <tab> <tab>` to see the list of possible Git commands.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and using a commit template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been using dynamic templates, but Git also has the
    option of a static commit template. A static template is essentially just a text
    file configured as a template. Using the template is very easy and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need a template. This has to be a text file that you know
    the location of. Create a file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This is our take on a simple commit message template. You might find that there
    are other templates out there that prefer to have the bug in the title or at the
    bottom of the commit message. The reason for having this at the top is that people
    often tend not to read the important parts of the text! The important part here
    is the formatting of the references to systems outside Git. If we get these references
    correct, we can automatically update the defect system as well. Save the file
    as `~/committemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will configure our newly created template, and then we will make a commit
    that will utilize the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the template, we need to use `git config commit.template <pathtofile>`
    to set it, and, as soon as it is set, we can try to create a commit and see how
    it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by configuring the template as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now list the `config` file to see that it has been set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'As we predicted, the configuration was a success. The template, just like any
    other configuration, can be set at a global level using `git config --global`,
    or it can be set at a local repository level by leaving out the `--global` option.
    We configured our commit template for this repository only. Let''s try and make
    a commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the commit message editor should open, and you should see our template
    in the commit message editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: It's really as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to prevent pushing when there are special
    words in commit messages. We have also seen how you can dynamically create a commit
    message with valid information for you or another developer when you are committing.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to see how you can build functionality into your own Git by adding
    short scripts or aliases that are all executed using Git. Hopefully, this information
    will help you to work smarter instead of harder.
  prefs: []
  type: TYPE_NORMAL
