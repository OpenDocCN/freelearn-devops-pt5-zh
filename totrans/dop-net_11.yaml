- en: Chapter 11. Securing the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With many businesses transitioning to software-defined networks and using APIs
    to make network changes, the importance of securing the network is a prominent
    concern. Security implementations need to evolve too, as the network is virtualized
    and modern protocols are used to build Leaf-Spine architectures to scale out multi-tenant
    cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of network security and debunking myths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing a software-defined network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network security and Continuous Delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution of network security and debunking myths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As network engineers become accustomed to a flat layer 2 network and Spanning
    Tree protocol as discussed in [Chapter 1](ch01.html "Chapter 1. The Impact of
    Cloud on Networking"), *The Impact of Cloud on Networking*, network security and
    approaches towards securing an enterprise network have become very mature and
    well understood by security teams over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Most security engineers are well versed in the best practices that should be
    implemented when dealing with physical networks. A security team will normally
    look to implement a rigid set of security best practices on the network, which
    network teams must comply with, to pass necessary accreditations. But how applicable
    are these best practices when implementing software-defined networking?
  prefs: []
  type: TYPE_NORMAL
- en: It is fair to say that there is still a knowledge gap that exists regarding
    software-defined networking at the moment and there is a degree of fear and uncertainty
    of the unknown from security engineers and even some network engineers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will hopefully help demystify some of those concerns. This is coming
    from someone that helps run a software-defined network in production, so this
    isn't talking about theories or aspirations, it is based on hard facts.
  prefs: []
  type: TYPE_NORMAL
- en: So first let's review some of the requests from security teams around network
    security and look at how these requests should be adapted when dealing with software-defined
    networking.
  prefs: []
  type: TYPE_NORMAL
- en: Account management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In terms of account management, security teams will normally stipulate that
    the following best practices are adhered to when setting up user access:'
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication should be used when accessing production servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User accounts should respect the least privileges necessary for users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique user accounts should be used between test and production environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DenyAll** should be default on Access Control Lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **Terminal Access Controller Access Control System** (**TACACS**) or equivalent
    authentication to access network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When reviewing account management, all points outlined by security practitioners
    remain valid. Any **Software-defined Networking** (**SDN**) controller or modern
    switch vendor should meet the account management requirements when they are being
    evaluated. If they don't meet these requirements, they simply should not be implemented
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: When using software-defined networking always aligned with a Continuous Delivery
    model, service accounts will be used by orchestration and configuration management
    tools such as **Ansible** to setup subnets, networks, and **ACL** policies to
    carry out any network changes.
  prefs: []
  type: TYPE_NORMAL
- en: The user committed to the source control management system will inevitably be
    the person that invoked the network changes even though it will be invoked by
    a service account. This in itself is a cultural shift, so privileges on the source
    control management repository should be reviewed to set up **Active Directory
    Domain Services** (**ADDS**) or **Lightweight Directory Access Protocol** (**LDAP**)
    access so commits are tracked and can be traced back to the user that made the
    change. Continuous Delivery tooling such as **Jenkins**, **ThoughtWorks**, **Go**,
    or a Plethora of other continuous integration build servers can cater for this
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Separate service accounts can be used to orchestrate test and production environments
    to meet security best practices. All other user accounts in a Continuous Delivery
    model should be read-only, so users can view the outcome of a Continuous Delivery
    deployment, which is driven by automation, with a break glass account being the
    exception to the rule and available for use in a state of emergency.
  prefs: []
  type: TYPE_NORMAL
- en: It is important for security teams to understand that if users are manually
    intervening in immutable software-defined networks, then the overall Continuous
    Delivery model could break, so there is no appetite to do manual configuration
    . All desired state should be controlled via source control management systems
    and pushed out to systems accordingly. This, again, is a mindset change and security
    practitioners generally find this hard to believe, as they have spent years seeing
    network engineers push manual changes to devices to make any changes, but this
    is a new approach and a huge change for some.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was illustrated in [Chapter 9](ch09.html "Chapter 9. Using Continuous
    Delivery Pipelines to Deploy Network Changes"), *Using Continuous Delivery Pipelines
    to Deploy Network Changes*, when utilizing configuration management tools such
    as Ansible to push out network changes to test and production environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Account management](img/B05559_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This concept is initially difficult for security practitioners to grasp, but
    the **DevSecOps** movement is helping security practitioners see the window of
    opportunity that an automated Continuous Delivery process brings.
  prefs: []
  type: TYPE_NORMAL
- en: Automation should mean users have fewer individual privileges and approved workflow
    actions are hardened and signed off, which govern what kind of interaction is
    allowed. All of this is controlled via the Continuous Delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Network device configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security best practices with regards to the configuration of network devices
    focus on keeping an up-to-date auditable inventory of the network, with security
    patching being applied on a regular basis to each network device at an operating
    system level, and secure protocols and **Public Key Infrastructure** (**PKI**)
    certificates being applied from relevant trust stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, a common set of requirements from a security team for configuration
    of network devices may include:'
  prefs: []
  type: TYPE_NORMAL
- en: A network hardware list should be available in an **IP Address Management**
    (**IPAM**) solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All network devices should be patched regularly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure SNMP version 3 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable ports not in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **Transport Layer Security** (**TLS**) to encrypt network traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The security approaches to network device configuration should also not change
    in terms of setup, as SDN controllers and modern switch vendors should look to
    use TLS, be patched regularly, and be accessible via DNS.
  prefs: []
  type: TYPE_NORMAL
- en: An underlay network when utilizing a Leaf-Spine architecture and overlay network
    is still comprised of physical network devices, so the configuration and best
    practices associated with securing these devices are still completely valid and
    integral.
  prefs: []
  type: TYPE_NORMAL
- en: SDN controllers, like network switches, are deployed on the layer 2 underlay
    network, so should follow the same conventions as network switches, have secure
    protocols, and adhere to patching schedules.
  prefs: []
  type: TYPE_NORMAL
- en: Firewalling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the major sources of confusion from security teams in industry when looking
    at software-defined networking seems to be around firewalling and some fear and
    uncertainty exists as they are used to using physical **stateful** firewalls in
    production networks.
  prefs: []
  type: TYPE_NORMAL
- en: However, as long as a virtual firewall meets security requirements, there should
    be no issue implementing SDN controllers and allowing them to control firewalling
    and segmentation of the network using virtualized micro-segmentation policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Security teams will traditionally mandate the following requirements from firewalls:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a stateful firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use explicit permits and implicit denies on ACL rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the ability to audit teams' ACL access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log all denied attempts on the firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall best practices should always be adhered to when implementing software-defined
    networking; traditionally though, security teams have always pushed for stateful
    physical firewalls to separate three-tier models, which are segregated into frontend,
    business logic, and backend tiers.
  prefs: []
  type: TYPE_NORMAL
- en: With the move towards microservices and the adoption of software-defined networking,
    applications have tended not to fit into this structure and **Open vSwitch** has
    allowed OpenFlow to be used to implement **Ingress** and **Egress** policies at
    the hypervisor level or operating system host level.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen that this same process can be applied to containers in [Chapter
    11](ch11.html "Chapter 11. Securing the Network"), *The Impact of Containers on
    Networking,* and Open VSwitch can be installed on container hosts such as Core
    OS, or even on bare metal servers to control firewall polices.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the same best practice principles of using explicit permits and implicit
    denies on ACL rules are adhered to, and a process is set up to log all denied
    attempts on the firewall, then there should be no reasons to argue against the
    merits of using virtualized firewalling.
  prefs: []
  type: TYPE_NORMAL
- en: Open vSwitch now offers stateful firewalling, which is now as secure as iptables
    on a Linux operating system or a physical firewall, so there is now no reason
    why firewalling cannot be virtualized for enterprise networks. This mirrors the
    debate about the use of hypervisors initially for infrastructure services, but
    the gains it brings a business in terms of scalability, programmability, auditability,
    and manageability make it hard to argue against firewall virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overlay networks, in terms of the detection of vulnerabilities and attacks,
    should also not change in terms of security requirements, although the method
    for acquiring the data may need to change slightly, as protocols such as **Border
    Gateway Protocol** (**BGP**) and **Virtual Extensible LAN** (**VXLAN**) need different
    tooling to track packets in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking at vulnerability detection and data sampling, the following activities
    should be scheduled on a regular basis:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular vulnerability scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep packet inspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of vulnerability scanning, scanning of the network and network devices
    should be carried out frequently. Ideally security scanners themselves should
    have separate responsibilities in a software-defined network. A security scanner
    should have access to the underlay to do a full scan and another profile of the
    scanner should be used for the overlay. If a scanner has access to the underlay
    and overlay, it becomes an attack vector, which if compromised would allow an
    attacker complete access to the network. So this is an important point often ignored;
    the overlay and underlay network devices and compute should not be routable to
    one another if possible.
  prefs: []
  type: TYPE_NORMAL
- en: It is often a requirement of a security team to be able to inspect network packets
    using deep packet inspection to make sure that there is no malicious activity.
    This has been done on flat layer 2 networks by inspecting packets that are transmitted
    between VLANs.
  prefs: []
  type: TYPE_NORMAL
- en: However, with overlay transporting packets using VXLAN encapsulation, networks
    can scale out network and alleviate the 4096 VLAN limit. This means that network
    and security teams will require tools that can de-encapsulate VXLAN packets so
    they can able to inspect packets, as they have with VLAN packets, otherwise security
    tools will see data is being transmitted but it won't be able to be read it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up tooling that does VXLAN de-encapsulation is by no means an insurmountable
    challenge. Tooling is available to do this, it will just require that network
    and security teams alter the tools they are currently used to using.
  prefs: []
  type: TYPE_NORMAL
- en: Network segmentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the biggest changes when implementing a software-defined overlay network
    is a shift away from the principles of a flat layer 2 network and VLAN segregation
    between networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Security teams are used to dealing with physical networks, so they will normally
    stipulate that the following requirements need to be met:'
  prefs: []
  type: TYPE_NORMAL
- en: Use VLANs to segregate traffic types (frontend, business logic, and backend)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to segregate **Test** and **Production**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use firewalls between different network tiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, SDN controllers create VXLAN tunnels between hardware **Virtual Tunnel
    End Points** (**VTEPs**) on network switches and stretches them to each hardware
    compute node to build a virtualized overlay underlay network over the network.
  prefs: []
  type: TYPE_NORMAL
- en: SDN controllers are used to translate the **Open vSwitch Database** (**OVSDB**)
    information from switch vendors and push the flow data down to each compute node
    (hypervisor, container, or bare metal server), which is dictated by the SDN controller's
    policy engine to create firewalls and micro-segmentation.
  prefs: []
  type: TYPE_NORMAL
- en: It is a differing approach; firewalling per microservice application is dictated
    by **OpenFlow** and used to control Ingress and Egress policies. Using overlay
    networks, applications can communicate with another application's micro-segmented
    zone as illustrated by the **Nuage Networks** **Virtual Service Platform** (**VSP**)
    in [Chapter 2](ch02.html "Chapter 2. The Emergence of Software-defined Networking"),
    *The Emergence Of Software, Defined Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see the **Application 1** micro-subnet communicating
    with **Application 2** by communicating subnet to zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network segmentation](img/B05559_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using micro-segmentation of firewall rules per application moves away from having
    physical, stateful firewalls segmenting zones for all applications. Instead, individual
    firewalls are created per application to govern segmentation between the network,
    with layer 3 domains segmenting **Test** and **Production** from each other at
    a layer above.
  prefs: []
  type: TYPE_NORMAL
- en: Each application has their own policy in this micro-segmentation model, which
    means security teams have the ability to audit firewall policies and understand
    what each application is communicating with.
  prefs: []
  type: TYPE_NORMAL
- en: Overlay networks for this reason should bring security gains, as it becomes
    completely clear the connectivity requirements for an application and connectivity
    topologies are not lost in a set of monolithic ACL rules on a physical stateful
    firewall, which aren't clearly mapped to each application.
  prefs: []
  type: TYPE_NORMAL
- en: Software-defined networking should mean that each application has an initial
    deny all and opens up only the minimum amount of explicit access so they can access
    other applications or services in the network.
  prefs: []
  type: TYPE_NORMAL
- en: This is far more secure than opening up port ranges on a stateful firewall,
    so overlay networks should, in theory, improve complex network security when implemented
    correctly. If immutable networks are used as highlighted by A/B subnets in [Chapter
    6](ch06.html "Chapter 6. Orchestrating SDN Controllers Using Ansible"), *Orchestrating
    SDN Controllers Using Ansible,* then automatic cleanup of old ACL rules is also
    implemented by default, which has been a challenge for network and security teams
    as they are afraid to remove old policies in the fear of creating an outage for
    a particular application.
  prefs: []
  type: TYPE_NORMAL
- en: Security teams can audit that policy with development teams and advise on any
    changes that need to be made, safe in the knowledge that as far as a development
    team is concerned, all of the ACL policies they are implementing are required
    to deploy their application with the bare minimum amount of explicit Ingress and
    Egress ACL rules being used.
  prefs: []
  type: TYPE_NORMAL
- en: Securing a software-defined network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have focused on a set of minimal network security
    requirements to make sure that a software-defined network is secure.
  prefs: []
  type: TYPE_NORMAL
- en: But to maximize the security of a software-defined network, we should look at
    how overlay and underlay networks could potentially be exploited in new ways by
    attackers and look at different mechanisms that can be put in place to prevent
    this from happening.
  prefs: []
  type: TYPE_NORMAL
- en: Software-defined Networks are split into the overlay (which holds all the virtualized
    networks that houses virtual, physical machines, and containers) and the underlay
    (which holds all bare metal machines such as hypervisors, network devices, and
    SDN controllers).
  prefs: []
  type: TYPE_NORMAL
- en: Attacks at Overlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Overlay** networks are created to allow networks to be automated programmatically
    via APIs and increase the speed of change by simplifying the network in software.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the remit of Continuous Delivery, self-service ACL rules can be set up
    by developers to govern north to south and east to west ACL policies.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to have implicit controls that make sure that common workflow
    actions only allow teams to set ACL rules from their micro-subnet to different
    locations in the network, and that they can't compromise the integrity of any
    other network in the overlay except their own. So this should be demonstrable
    by testing the self-service automation to security teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Micro-segmentation is powerful in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: When using implicit allows, team A with application 1 can only communicate with
    application 2, which is maintained by team B, if team B allows explicit Ingress
    rules that allow application 1 to communicate with it. So teams will have to coordinate
    between themselves, and their applications will only be able to communicate with
    one another if there is both an Egress and Ingress rule on each microservice application's
    firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from this, some applications may need northbound Internet access, so it
    is important that network teams put in place a mechanism to proxy out to the Internet
    and not give teams the ability to directly access it. A controlled proxy mechanism
    should be implemented by the network team so that there is a fixed mechanism to
    govern northbound Internet access.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers may try and compromise a virtual machine or physical server that is
    part of the overlay network. Once they gain access to a machine, they could attempt
    to download software and compromise the network. An attacker could potentially
    attempt a **Denial of Service** (**DoS**) on a particular micro-subnet, which
    could be used to compromise a key service by compromising all virtual machines
    in the micro-subnet.
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of micro-segmentation over a layer 2 network is that if one box was
    compromised in production, an attacker could have access to the whole frontend,
    business logic, or backend zone, while with micro-segmentation they would be isolated
    to the particular application.
  prefs: []
  type: TYPE_NORMAL
- en: With regards to outbound Internet access and setting up a proxy, it is imperative
    that upstream repositories used to download software packages to hosts go via
    a controlled proxy server, using an artifact repository with **Role Based Access
    Control** (**RBAC**) using Active Directory Domain Services or LDAP such as **Artifactory**
    or **Nexus**.
  prefs: []
  type: TYPE_NORMAL
- en: This means that servers within the overlay network can only access a set of
    approved third-party software repositories that have been given the blessing of
    the infrastructure team. Repositories not on the approved list cannot be accessed
    via the overlay network servers, as they are not proxied by the artifact repository,
    thus preventing the installation of dubious packages onto servers in the overlay
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying via an artifact repository means network and security teams can take
    measures to prevent packet sniffing software being downloaded onto a server to
    discover adjacent services or open ports dictated by the Ingress and Egress flow
    data.
  prefs: []
  type: TYPE_NORMAL
- en: It may also be desirable to disable **Internet Control Message Protocol** (**ICMP**)
    in the overlay network so that an attacker cannot work out the IP addresses of
    adjacent servers in a micro-subnet or underlay network devices such as top-of-rack
    switches and SDN controllers by doing a trace route.
  prefs: []
  type: TYPE_NORMAL
- en: If a server in the overlay network is logging drops, then appropriate alerting
    should be set up to notify the network or security team that some illicit activity
    is occurring within a micro-subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms can be put in place to tag compromised boxes with metadata in this
    case and use tools such as Ansible dynamic inventory to target them altogether
    by issuing a shut down or moving them to a quarantined network using live migration,
    which will stop a potential network attacker from gaining access to other servers
    in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Attacks on the underlay network?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **underlay** network could be targeted by potential attackers by gaining
    access to a hypervisor and looking to compromise Open vSwitch. This would allow
    them to directly instantiate new flows into the Open vSwitches flow-table, allowing
    access to multiple different locations in the network.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker could sniff traffic and perform a **Man in the Middle** (**MitM**)
    attack on different network components as a result, so hypervisors should ideally
    be on a separate network, which will isolate access to compute servers and not
    allow them to be directly routable from the overlay network.
  prefs: []
  type: TYPE_NORMAL
- en: In the underlay network, switches now utilize centralized management systems
    to push updates to switches. For example, the **Arista CloudVision** platform
    **CloudVision eXchange** (**CVX**) servers are used to push configuration to all
    Arista switches, so it is imperative that access control to its API endpoints
    is done over HTTPs and that the management of switches is done on a completely
    dedicated network.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker could potentially drop the whole configuration of every switch if
    the CVX cluster was compromised to create a DoS attack on the network, which would
    also mean that all routing would be dropped by the SDN controller.
  prefs: []
  type: TYPE_NORMAL
- en: An **Out Of Band** (**OoB**) network should ideally be implemented to govern
    access to network appliances with access provided via TACCs accounts. Using an
    OOB network for the northbound and southbound communications can help secure network
    devices and provide an extra degree of security for network devices.
  prefs: []
  type: TYPE_NORMAL
- en: The underlay and overlay network should be on completely different networks
    and not routable; this means that if a hypervisor is compromised in the underlay
    network, then an attacker will not be able to directly jump from an underlay box
    to the overlay. Underlay boxes should ideally be protected using bastion servers
    with two-factor authentication so no servers are directly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: SDN controllers are typically x86 compute, and talk via REST API calls, so it
    should be mandatory to implement TLS on the SDN controllers and if possible issue
    a PKI CA to manage trust, authenticity, and revocation of access.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see that the **Arista CVX** platform communicates
    with the Nuage **VSC** SDN controller using **OVSDB** with **TLS** on the underlay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacks on the underlay network?](img/B05559_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If underlay devices communicate using HTTP sessions, it will make the network
    susceptible to attacks in the Overlay network not just the underlay network.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the **OpenStack** platform as an example, an SDN controller communicating
    with the OpenStack Neutron plug in will exchange all Ingress and Egress information
    for the entire overlay network. If this connection is using unencrypted REST API
    calls, it would mean that an attacker could intercept or track all flow information,
    and this can be used to compromise any number of tenant networks within the overlay.
  prefs: []
  type: TYPE_NORMAL
- en: Attacks on the SDN controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The northbound API on an SDN controller is a desirable attack vector that could
    be used to compromise the whole overlay network.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, RBAC should be put in place with sufficient password best practices
    adhered to. If the SDN controller's northbound API is compromised, then attackers
    could create new flow data programmatically against the overlay.
  prefs: []
  type: TYPE_NORMAL
- en: This would allow an attacker to traverse the network and target multiple services,
    allowing the attacker to bypass denying firewall policies and access multiple
    tenant networks.
  prefs: []
  type: TYPE_NORMAL
- en: Default admin accounts should have their passwords changed from day one, to
    avoid attackers guessing default accounts passwords. Complex passwords should
    be used at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Audit trails should be set up on the SDN controller and logged to a **syslog**
    server, which will allow network and security engineers to check for unauthorized
    changes by attackers. If any irregular behavior occurs, then subsequent alerts
    should be triggered and the account should be disabled immediately.
  prefs: []
  type: TYPE_NORMAL
- en: On SDN controllers, SNMPv3 should be enabled as opposed to earlier versions
    and LDAP accounts, or SSH keys set up to allow access to Linux-based operating
    systems as opposed to using single service accounts or root access for underlay
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Network security and Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network security should be improved when using automation to push network changes
    out to network devices, or to change the desired state of overlay networks. It
    should increase the visibility of changes, as all changes are done from a centralized
    process, with no exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery processes, by design, should allow security teams to see
    clearly which user committed a network change. When a change is pushed to network
    devices or SDN controllers using the Continuous Delivery process, it will allow
    easy roll back to a previous version if the security team don't approve of the
    changes. However, this is still very reactive and continuous integration and delivery
    processes should include compliance and security checks as part of the continuous
    integration and delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: Having compliance checks as part of Continuous Delivery provides a lot of flexibility
    for network and security teams. This will enable security teams to utilize some
    of the continuous integration and delivery best practices to help secure a network,
    such as continual testing and validation of changes integrated as part of the
    deployment pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Application connectivity topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a software-defined network, each application is micro-segmented, so they
    have individual application policies that can be audited by security or network
    teams. This will help with security compliance, as it allows security practitioners
    to see all the Ingress or Egress rules for a particular application in the overlay
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was highlighted in [Chapter 2](ch02.html "Chapter 2. The Emergence of
    Software-defined Networking"), *The Emergence Of Software-defined Networking,*
    showing micro-segmented policies per application with egress policies for **Application1**
    defined as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application connectivity topology](img/B05559_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The applications Ingress and Egress ACL rules should be readable and auditable
    in source control management systems using YAML files, or any other chosen configuration
    file used to control the SDN controller's desired state.
  prefs: []
  type: TYPE_NORMAL
- en: The live state of the system will also be present on SDN controller GUIs, which
    can be observed to make sure it matches what is defined in source control management
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: It is important for security practitioners to be able to read and understand
    the configuration files that are being used to determine the current connectivity
    and state of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Network and security teams have unique goals such as passing security audits
    to keep the business operational. It is important for Security teams to be able
    to see the application connectivity matrix and be able to have full visibility
    over connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when processing credit card transactions, only specific users
    should have access to that particular tenant network. Having the ability to enforce
    this via the SDN and demonstrate this is the case with an easy to understand SDN
    policy makes the network and security team's jobs easier as they have a real-time
    connectivity matrix for each application.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping security checks into continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security checks should ideally be built into continuous integration processes,
    a concept covered in depth in [Chapter 7](ch07.html "Chapter 7. Using Continuous
    Integration Builds for Network Configuration"), *Using Continuous Integration
    Builds for Network Configuration*. Otherwise, security teams would not be able
    to keep up with the daily changes being made to dynamic overlay networks and ever-changing
    network policies.
  prefs: []
  type: TYPE_NORMAL
- en: Compliance can be integrated with continuous integration processes by disallowing
    an allow-all policy when applied by a developer on their self-service ACL file
    for an application.
  prefs: []
  type: TYPE_NORMAL
- en: When a user commits this change to a source control management system, the **CI
    Build Server** starts a new continuous integration build. A validation on the
    continuous integration build for the SDN configuration build could be set up by
    the security team to reject this configuration and provide instant feedback to
    the user, as this breaks compliance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user would instead have to alter the self-service ACL policy rules to be
    implicit, so compliance then becomes just another validation of the continuous
    integration process, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping security checks into continuous integration](img/B05559_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is opposed to security teams auditing the ACL rules as a separate manual
    check, which would of course let ACL rules that breach security policy, slip through
    into production environments and allow attackers the potential to compromise a
    particular application, as its ACL rules are too open. This validation could even
    be done prior to a **CI Build Server** by running a simple Git hook, which would
    reject the commit after detecting an allow-all on the ACL policies by parsing
    the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cloud metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of cloud metadata is commonplace in public and private clouds such as
    AWS, Microsoft Azure, Google Cloud, and OpenStack as well as other cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging boxes with specific metadata has a variety of different use cases, and
    a subset of those use cases could greatly benefit a network or security team when
    dealing with particular network security challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud metadata, as covered already in this book, is a series of key-value pairs
    that are applied to a cloud server. If we take the example of a security vulnerability
    such as shell shock, which caused a series of DoS attacks when exploited in 2014,
    it is important that security vulnerabilities such as these are fixed immediately,
    to prevent attackers exploiting Linux boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Within the remits of Continuous Delivery, it is important to make sure that
    if an issue occurs, then the mean time to recover is quick.
  prefs: []
  type: TYPE_NORMAL
- en: Take the scenario of vulnerability scanning. Each week, the whole overlay and
    underlay network will be scanned on a daily, or at worst, a weekly basis, using
    a security scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Every time that the weekly network security scan runs on all boxes, it generates
    a report documenting a list of vulnerabilities for each server. This is subsequently
    reviewed by the service owners, and the security team will recommend specific
    patches or remediation over a number of days, so the mean time to resolve is high
    if important vulnerabilities are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: If instead of generating a separate report, the network security scan tagged
    the servers with a specific list of vulnerability IDs on their cloud metadata,
    then a complete inventory of vulnerabilities for the whole network would be available
    that could be acted upon to make real-time updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using OpenStack as an example, the following command line could be executed
    to set metadata against a server when vulnerabilities are detected by using the
    `qualys_vul_ids` key value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example would be executed as part of a script that would be run
    against all servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This key value pair is then passed to the OpenStack metadata service, which
    will tag the OpenStack instance with all the relevant vulnerabilities that have
    been discovered as part of the **Qualys** vulnerability scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will result in the OpenStack instance containing the following metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Cloud metadata](img/B05559_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a vulnerability such as shell shock was exposed by the security scan, then
    the network and security team could identify all servers with that vulnerability.
    In this case, `Qualys ID` `122` relates to shell shock, and targets the servers
    affected with an immediate patch.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible dynamic inventory could be used to target the vulnerable boxes using
    a bespoke `ad_hoc_patch.yml` playbook with a when condition only, which executes
    patch commands to Linux servers if `Qualys ID` `122` is tagged on the `qualys_vul_ids`
    metadata tag on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ad_hoc_patch.yml` playbook would have the following steps to set a fact
    from the metadata and execute the commands only when the metadata tag contains
    the correct metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Cloud metadata](img/B05559_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This playbook can be used to fix the shell shock **Bashdoor** bug immediately
    by executing following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: which would execute the playbook against all customer-facing servers in the
    `Prod` availability zone that contain the vulnerability, so target only production
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook would only execute against servers in the production availability
    zone that match the metadata value of `122` as an active vulnerability using `Ansible
    jinja2` when filters, which would allow infrastructure engineers to remove the
    vulnerability in minutes. Imagine if security scanners did this metadata tagging
    as a feature of their scanner; it would help security massively.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud metadata has many other use cases such as using an owner metadata tag
    on servers to send targeted e-mails or alerts if security teams detect any suspicious
    activity, or flag servers for re-deployment to install new patches when using
    immutable infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Compromised servers can also be tagged as **quarantined** using metadata by
    security monitoring tools. Put simply, metadata allows teams to set server profiles
    using metadata, so a variety of actions can be carried out on them.
  prefs: []
  type: TYPE_NORMAL
- en: If a server is tagged as quarantined, a trigger could be set up to power down
    the server and migrate it to a quarantined micro-subnet in the Overlay network
    with no external access. This would allow a security team to carry out root cause
    analysis to ascertain how the box was compromised and mitigate the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The important point to note is all these security processes can be automated
    to help maximize the features provided by public and private clouds. They should
    be looked upon as tools that can help automate and facilitate security processes
    rather than inhibit security.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at network security and ways in which security
    practices need to evolve to meet the demands of modern software-defined networks,
    as the industry has started to move away from flat layer 2 networks and instead
    utilize virtualized overlay networks.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has also hopefully debunked some of the fear and uncertainty associated
    with securing software-defined networks, while tackling hot topics such as the
    separation of test and production environments and the use of virtual firewalling
    for micro-segmentation as opposed to physical firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of the chapter then shifted to strategies that can be adopted above
    and beyond minimum security requirements and looked at ways to secure SDN controllers
    and minimize the attack vectors. This can be achieved by isolating networks, creating
    out of band networks for network devices, appropriate authentication, and using
    TLS for inter-network device communication.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter has also looked at the gains brought by implementing software-defined
    networking, such as the transparency and auditability of application to application
    connectivity. It has also explored opportunities to automate compliance checks
    by utilizing continuous integration best practices to validate ACL policies as
    part of continuous integration builds, rather than being a completely separate
    process. It has also explored leveraging cloud metadata to carry out emergency
    patching as opposed to it being a manual overhead, and covered other use casesfor
    using cloud metadata such as quarantining servers and sending security notifications
    to teams.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter brings us to the end of the book, which has looked at applying
    DevOps and Continuous Delivery principles to networking. The book has hopefully
    showed readers that networking does not need to be a manual set of tasks that
    slow down the whole Continuous Delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: This book has covered a wide variety of topics that should hopefully give some
    food for thought and ideas that can be taken and implemented to improve network
    operations. Network automation is still relatively sparse in industry, but it
    doesn't need to be; the same automation principles that were applied to development,
    infrastructure, and testing are equally applicable to network operations.
  prefs: []
  type: TYPE_NORMAL
- en: Network teams shouldn't settle or accept the status quo, instead, be bold and,
    initiate real cultural change, and help improve network operations in the industry
    by embracing change and learning new skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blog: [http://devarmstrongops.blogspot.co.uk/](http://devarmstrongops.blogspot.co.uk/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LinkedIn: [https://uk.linkedin.com/in/steven-armstrong-918629b1](https://uk.linkedin.com/in/steven-armstrong-918629b1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is a Software-defined Network: [https://www.youtube.com/watch?v=lPL_oQT9tmc](https://www.youtube.com/watch?v=lPL_oQT9tmc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SDN Fundamentals: [https://www.youtube.com/watch?v=Np4p1CDIuzc](https://www.youtube.com/watch?v=Np4p1CDIuzc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SDN and OpenFlow: [https://www.youtube.com/watch?v=l-DcbQhFAQs](https://www.youtube.com/watch?v=l-DcbQhFAQs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
