- en: Running Your Private Docker Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](../Text/Ch04.xhtml), *Publishing Images,* we discussed Docker
    images and clearly explained that Docker containers are the runtime implementations
    of Docker images. Docker images and containers are plenty these days as the containerization
    paradigm has taken the IT domain by storm. Therefore, there is a need for worldwide
    enterprises to keep their Docker images in their own private infrastructure for
    security considerations. So, the concept of deploying Docker Hub to our own infrastructure
    has emerged and evolved. Docker Hubs are paramount and pertinent to registering
    and then depositing the growing array of Docker images. Primarily, Docker Hub
    is specially made to centralize and centrally manage information on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checksums of the images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter is developed with a focus on providing all the relevant information
    to enable you and the Docker container crafters to design, populate, and run your
    own private Docker Hubs in your own backyards. This chapter covers the following
    important topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Registry use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your own Docker Registry and pushing the image to a newly created registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webhook notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Registry HTTP API support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker Registry implementation has completely changed from the previous
    version mentioned in the earlier edition of this book. Docker Registry 2.0 is
    the new implementation for storing and distributing Docker images. It supersedes
    the previous Docker Registry implementation ([https://github.com/docker/docker-registry](https://github.com/docker/docker-registry)).
    The new implementation is available at [https://github.com/docker/distribution](https://github.com/docker/distribution).
    This is open source under the Apache license. The registry is a stateless, highly
    scalable server-side application that stores and lets you distribute Docker images.
    The Docker Registry index is deprecated in the new release. Previously, the Docker
    Registry used index internally to authenticate the user.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry 2.0 is completed, new, and implemented in Go and supports the
    Docker Registry HTTP API v2\. The current Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    is based on the new Docker Registry 2.0 with Docker Engine 1.6 or above. This
    makes it more reliable and transparent to its users. All cloud providers have
    adopted this new Docker Registry including AWS and IBM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new registry implementation provides the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Faster push and pull
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure and efficient implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluggable storage backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webhook notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general architecture of Docker Registry shows, as in the following image,
    how it is integrated with Nginx at frontend and storage at backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The salient features of the registry are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The registry is compatible with Docker Engine version 1.6.0 or higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default storage driver is the local POSIX filesystem, which is suitable
    for development or small deployments. It also supports different storage backends
    (S3, Microsoft Azure, OpenStack Swift, and Aliyun OSS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It natively supports TLS and basic authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the new version, the registry also supports a robust notification system.
    The registry supports sending Webhook notifications in response to events happening
    within the registry. Notifications are sent in response to manifest pushes and
    pulls and layer pushes and pulls. These actions are serialized into events. The
    events are queued into a registry-internal broadcast system, which queues and
    dispatches events to endpoints ([https://docs.docker.com/registry/notifications/#endpoints](https://docs.docker.com/registry/notifications/#endpoints)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latest Docker Registry releases two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Trusted Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s talk about the two options in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Trusted Registry** (**DTR**): This is the enterprise grade solution
    from Docker. DTR supports high availability and is installed on the Docker **Universal
    Control Plane** (**UCP**) cluster. The details are available at the following
    website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/docker-trusted-registry/](https://docs.docker.com/docker-trusted-registry/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DTR supports image management and it has built-in security and access control.
    It can also be integrated with LDAP and **Active Directory** (**AD**) and supports
    **Role Based Access Control** (**RBAC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The general architecture of DTR is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'DTR has a built-in authentication mechanism. DTR running on a node consists
    of the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dtr-api-<replica_id>`: Executes the DTR business logic. It serves the DTR
    web application, and API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-garant-<replica_id>`: Manages DTR authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-jobrunner-<replica_id>`: Runs cleanup jobs in the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-nautilusstore-<replica_id>`: Stores security scanning data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-nginx-<replica_id>`: Receives HTTP and HTTPS requests and proxies them
    to other DTR components. By default it listens to ports `80` and `443` of the
    host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-notary-server-<replica_id>`: Receives, validates, and serves content trust
    metadata, and is consulted when pushing or pulling to DTR with content trust enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-notary-signer-<replica_id>`: Performs server-side timestamp and snapshot
    signing for content trust metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-registry-<replica_id>`: Implements the functionality for pulling and pushing
    Docker images. It also handles how images are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-rethinkdb-<replica_id>`: A database for persisting repository metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DTR uses the following internal named volumes for persistence of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dtr-ca`: The private keys and certificates are stored here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-etcd`: This is used by etcd for storing DTR internal configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-registry`: This is the volume where images are stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtr-rethink`: This is used by RethinkDB to persist DTR data, such as users
    and repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, DTR stores the images on the local filesystem of the host machine.
    For highly available installations of DTR, it supports cloud storage or network
    filesystems also. DTR can be configured to support Amazon S3, OpenStack Swift,
    and Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Registry**: The registry is a stateless, highly scalable server-side
    application that stores and distributes Docker images. The registry is open source,
    under the permissive Apache License ([http://en.wikipedia.org/wiki/Apache_License](http://en.wikipedia.org/wiki/Apache_License)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will focus on the second option of the open source Docker Registry.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Registry stores the Docker images and provides the basic functionalities
    of pulling, pushing, and deleting the images. In a typical workflow, a commit
    to your source revision control system would trigger a build on your CI system,
    which would then push a new image to your registry if the build is successful.
    A notification from the registry would then trigger a deployment on a staging
    environment or notify other systems that a new image is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Registry is used when the user needs to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tighten control where images are kept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Own the images distribution pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate image storage and distribution with the backend development workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The important use cases of registry are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pull or download an image**: The user requests an image using the Docker
    client from Docker Registry, the registry in turn responds back to the user with
    the registry details. Then, the Docker client will directly request the registry
    to get the required image. The registry authenticates the user with an index internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push or upload an image**: A user requests to push the image, gets the registry
    information, and then pushes the image directly to the registry. The registry
    authenticates the user and finally, responds to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete an image**: The user can also request to delete an image from the
    repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user has the option to use the registry with or without the index. Using
    the registry without the index is best suited for storing private images.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the preceding use cases, Docker Registry also supports version
    control for images. It can be integrated with **Continuous Integration** (**CI**)
    and **Continuous Development** (**CD**) systems. When a new image is successfully
    pushed to the registry, then a notification from the registry will trigger a deployment
    on a staging environment or notify other systems that a new image is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Docker Registry V2, the following new use cases are also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image verification**: Docker Engine would like to run the verified image
    so it wants to ensure that the image is downloaded from a trusted source and no
    tampering has occurred. Docker Registry V2 returns a manifest and Docker Engine
    verifies the manifest''s signature before downloading the image. After each layer
    is downloaded, the Engine verifies the digest of the layer ensuring that the content
    is as specified by the manifest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resumable push**: It is possible to lose network connectivity while uploading
    the image to Docker Registry. Now, Docker Registry has the ability to inform Docker
    Engine that the file upload has already started. Therefore, Docker Engine will
    respond by only sending the remaining data to complete the image upload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resumable pull**: When downloading an image, the connection is interrupted
    before the completion. Docker Engine keeps the partial data and requests to avoid
    downloading the repeated data. This is implemented as the HTTP range requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer upload deduplication**: Company Y''s build system creates two identical
    Docker layers from build processes A and B. Build process A completes uploading
    the layer before B. When process B attempts to upload the layer, the registry
    indicates that it''s not necessary because the layer is already known. If processes
    A and B upload the same layer at the same time, both the operations will proceed
    and the first to complete will be stored in the registry (note that we may modify
    this to prevent dogpile with some locking mechanism).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the reason why Docker Registry V2 needs Docker Engine version 1.6 or
    above to support these features.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker Registry and pushing the image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is fairly easy to install and run Docker Registry, but operating in a production
    environment requires other non-functional requirements also such as security,
    availability, and scalability. Also, logging and log processing, systems monitoring,
    and Security 101 are the required features for production grade systems. Most
    of the providers use DTR, as explained earlier in the production system. However,
    Docker Registry is good enough to use in your non-production environment preferably
    in the intranet environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will use the Ubuntu 14.04 machine to install, run, and
    test Docker Registry. Docker Engine will be installed as described in [Chapter
    1](../Text/Ch01.xhtml), *Getting Started with Docker*. We will perform the following
    steps to run our own registry, and finally, push the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running Docker Registry on localhost**: Like most servers, Docker Registry
    does not need to be installed on client systems where Docker client is running.
    Docker Registry can be installed to any server which supports Docker and is network
    reachable. So multiple Docker clients can access the running Docker Registry.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Registry accepts the connection on TCP port `5000`, so this is not blocked
    by the firewall in your system.
  prefs: []
  type: TYPE_NORMAL
- en: If you push a lot of images to Docker Registry, they will fill up the space
    quickly, so it is recommended that you configure enough space where the images
    are kept. On the local file system, the storage path is normally `/var/lib/registry`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Start the registry**: The following command downloads the registry image
    from Docker Hub and starts a container in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Check Docker Registry is running on localhost**: The following command verifies
    that Docker Registry is up and running at port `5000` on localhost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Get and tag the image**: The most common image to test Docker is the `hello-world`
    image available from Docker Hub. Pull the image from the local registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command tags the image with `localhost:5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the list of images available on the localhost machine are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Push the image**: This `hello-world` image can now be pushed to the newly
    created Docker Registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Pull the image**: This `hello-world` image can now be pulled back from the
    newly created Docker Registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Stop Docker Registry and delete**: Now use the following command to stop
    and delete Docker Registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Storage**: Docker Registry retains all the registry data as Docker volume
    on the host filesystem. The Docker volume can be mounted on the `/var/lib/registry`
    path, and use the following command to direct Docker Registry to point to this
    path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The storage drivers can be configured for `inmemory`, `s3`, `azure`, `swift`,
    `oss`, and `gcs`: [https://github.com/docker/distribution/blob/master/docs/storage-drivers/index.md](https://github.com/docker/docker.github.io/blob/master/registry/storage-drivers/index.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Docker Registry on localhost with an SSL certificate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will emulate the concept of running Docker Registry securely
    using SSL. In the current scenario of running Docker Registry on localhost, Docker
    Engine needs to be secured using TLS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to run Docker Registry securely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting certificates**: We will be using self-signed certificates for TLS
    certificates. First create the `certs` directory, then run the `openssl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `certs` directory to the certificates directory of Ubuntu 16.o4 in
    the `/usr/local/share/ca-certificates` path. This path is specific to Ubuntu (Debian)
    systems and you may need to use a different path if using Red Hat systems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Also copy the `domain.crt` file to `/etc/docker/certs.d/myregistrydomain.com:5000/ca.crt`.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure to create the `certs.d` and `myregistrydomain.com:5000` directories before
    running the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart Docker Engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Registry can be started, as follows, in the secure mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should be able to push the images from the remote Docker host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Point your `myregistrydomain.com` to localhost (`127.0.0.1`) by updating `/etc/hosts` 
    by adding `127.0.0.1 myregistrydomain.com`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Running Docker Registry with restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The security of Docker Registry is very vital. It is recommended that you run
    it behind the secure firewall and **Intrusion Protection System** (**IPS**) /
    **Intrusion Defense System** (**IDS**) in a secure network. Also, it is assumed
    that registry will only accept a secure connection on HTTPS. In addition to these,
    Docker Registry can provide access restriction, and the simplest way to implement
    this is through basic authentication. The basic authentication is standard authentication
    with web servers using a login name and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we list out the steps to be done for securely accessing Docker Registry:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are running this registry in the secure mode, use a self-signed certificate
    and enable TLS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, restart the Docker process to get the updated configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now rerun the registry and make sure the current running registry is stopped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The user needs to log in from a remote machine to test registry user authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Push and pull the images from the remote machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Managing Docker Registry with Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Docker Registry grows more complex, dealing with its configuration will be
    tedious. So it is highly recommended that you use Docker Compose. Docker Compose
    will be discussed later in [Chapter 8](../Text/Ch08.xhtml), *Orchestrating Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker-compose.yml` file is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the command to run the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This ensures Docker Registry is up and running again.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing consideration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the enterprise deployments of Docker Registry, the load balancer is required
    to distribute loads across registry clusters. To make load balancer work correctly,
    we need to consider storage driver, HTTP secret, and Redis cache (if configured)
    to be same for the cluster of registries. If any of these parameters are different,
    the registry will have trouble serving the requests.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the storage driver used for Docker images should be the same across
    all instances of registry. If a particular mount point is used as a filesystem,
    it should be accessible and attached to all instances of registries. Similarly,
    if an S3 or IBM object storage is used, registries should be able to access the
    same storage resource. The HTTP secret coordinates uploads also must be the same
    across instances. Actually, configuring different Redis cache for different registry
    instances may work as of now. However, this is not a good practice and it will
    be expensive in terms of more requests being redirected to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Webhook notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker Registry has the in-built capability of sending notifications based
    on registry activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Notifications are sent to the endpoints via HTTP. This complete notification
    is based on the listener and broadcaster architecture. Each endpoint has its own
    queue and all actions (push/pull/delete) trigger the events. These events are
    queued and once the event reaches the end of the queue, it triggers an HTTP request
    to the endpoint. The events are sent to each endpoint, but the order is not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Events have a well-defined JSON structure and are sent as the body of the notification.
    One or more events are sent in the structure and are called an **envelope**. An
    envelope may contain one or more events. The registry is also capable of receiving
    responses from endpoints. The responses with 2XX or 3XX response codes are considered
    as valid responses and consider the message delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry HTTP API support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Registry has an HTTP interface to interact with Docker Engine. This is
    used to manage information about Docker images and enable their distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The key update from V1 is the set of changes in the Docker image format and
    concept of signed manifest. The new, self-contained image manifest simplifies
    image definition and improves security. This specification will build on that
    work, leveraging new properties of the manifest format to improve performance,
    reduce bandwidth usage, and decrease the likelihood of backend corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete documentation of the Docker Registry V2 APIs can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/docker/distribution/blob/master/docs/spec/api.md.](https://github.com/docker/distribution/blob/master/docs/spec/api.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The important APIs are discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'API version check:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /v2/`: This API provides version support information based on its response
    statuses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `curl` command to check the Docker Registry API version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The supported error codes are `401 Unauthorized` and `404 Not Found`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing repositories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /v2/_catalog`: This API provides the content of repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `curl` command to get the contents of repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The reader may recall that while starting Docker Registry, we uploaded only
    one file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pulling an image: The Docker image mainly consists of two parts—a JSON manifest
    and individual layer files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pulling an image manifest can be fetched using the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `curl` command to get the image manifest details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Pulling the layers of an image stored in blob:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will be an exercise for the reader to download the image using `<digest>`
    received in the preceding pulling manifest API.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of methods and URIs are covered in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Path** | **Entity** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v2/` | Base | Check that the endpoint implements the Docker Registry
    API V2 |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v2/<name>/tag/list` | Tags | Fetch the tags under the repository
    identified by name |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v2/<name>/manifests/<reference>` | Manifest | Fetch the manifest
    identified by name and reference, where reference can be a tag or digest |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/v2/<name>/manifests/<reference>` | Manifest | Put the manifest
    identified by name and reference, where reference can be a tag or digest |'
  prefs: []
  type: TYPE_TB
- en: '| `Delete` | `/v2/<name>/manifests/<reference>` | Manifest | Delete the manifest
    identified by name and reference, where reference can be a tag or digest |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v2/<name>/blobs/<digest>` | Blob | Retrieve the blob from the registry
    identified by a digest |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/v2/<name>/blobs/<digest>` | Blob | Delete the blob from the
    registry identified by a digest |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/v2/<name>/blobs/uploads` | Initiate blob upload | Initiate a resumable
    blob upload; if successful, an upload location will be provided to complete the
    upload |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v2/<name>/blobs/uploads/<uuid>` | Blob upload | Retrieve the status
    of upload identified by `uuid` |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | `/v2/<name>/blobs/uploads/<uuid>` | Blob upload | Update a chunk
    of data for the specified upload |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/v2/<name>/blobs/uploads/<uuid>` | Blob upload | Complete the upload
    specified by `uuid` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/v2/<name>/blobs/uploads/<uuid>` | Blob upload | Cancel outstanding
    upload processes, releasing associated resources |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v2/_catalog` | Catalog | Retrieve a sorted JSON list of repositories
    from the registry |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Engine allows every value-adding software solution to be containerized,
    indexed, registered, and stocked. Docker is turning out to be a great tool for
    systematically developing, shipping, deploying, and running containers everywhere.
    While `docker.io` lets you upload your Docker creations to its registry for free,
    anything you upload there is publicly discoverable and accessible. Innovators
    and companies aren't keen on this and therefore insist on private Docker Hubs.
    In this chapter, we explained all the steps, syntaxes, and semantics for you in
    an easy-to-understand manner. We showed how to retrieve images to generate Docker
    containers, and described how to push our images to Docker Registry in a secure
    manner in order to be found and used by authenticated developers. The authentication
    and authorization mechanisms, a major part of the whole process, have been explained
    in detail. Precisely speaking, this chapter is conceived and concretized as a
    guide for setting up your own Docker Hubs. As world organizations are showing
    exemplary interest in having containerized clouds, private container hubs are
    becoming more essential.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in time, we understand that distribution and management of Docker
    images is possible using Docker Hub, DTR, and the Docker open source registry.
    Both Docker Hub and DTR are commercial products that incorporate the open source
    registry capabilities into their respective solutions. Docker Hub is a multi-tenant
    service while DTR and the open source registry provide users with the option to
    host private registries behind their own firewall or a dedicated cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deep into containers, which is the natural
    progression from images. We will demonstrate the capability to run services, such
    as a web server in a Docker container and its interaction with the host machine
    and the outside world.
  prefs: []
  type: TYPE_NORMAL
