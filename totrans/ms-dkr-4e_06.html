<html><head></head><body><div><div><p id="_idParaDest-116" class="chapter-number"><a id="_idTextAnchor187"/><em class="italic">Chapter 6</em></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor188"/>Docker Machine, Vagrant, and Multipass</h1>
			<p>In this chapter, we will take a deeper look at Docker Machine. It can be used to easily launch and bootstrap Docker hosts targeting various platforms, including locally or in a cloud environment. We will also look at both Vagrant and Multipass, which are alternatives that can be used to launch local Docker hosts.</p>
			<p>Let's take a look at what we will be covering in this chapter. We will be looking at the following topics:</p>
			<ul>
				<li>An introduction to Docker Machine</li>
				<li>Deploying local Docker hosts with Docker Machine</li>
				<li>Launching Docker hosts in the cloud using Docker Machine</li>
				<li>Using Vagrant and Multipass to launch local Docker hosts</li>
				<li>Introducing and using Multipass</li>
			</ul>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor189"/>Technical requirements</h1>
			<p>As in previous chapters, we will continue to use our local Docker installations. Again, the screenshots in this chapter will be from my preferred operating system, macOS. We will be looking at how we can use Docker Machine to launch Docker-based <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>) locally using VirtualBox, as well as in public clouds, so you will need an account with DigitalOcean if you would like to follow along with the examples in this chapter.</p>
			<p>As before, the Docker commands we will be running will work on all three operating systems on which we have installed Docker so far. However, some of the supporting commands, which will be few and far between, may only apply to macOS- and Linux-based operating systems.</p>
			<p>Check out the following video to see the Code in Action:<a href="https://bit.ly/2R6QQmd">https://bit.ly/2R6QQmd</a></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor190"/>An introduction to Docker Machine</h1>
			<p>Before we roll our <a id="_idIndexMarker460"/>sleeves up and get stuck in with Docker Machine, we should take a moment to discuss what place it now occupies in the overall Docker ecosystem and what it actually is.</p>
			<p>Docker Machine's biggest strength was that it provided a consistent interface to several public cloud providers, such as <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), <strong class="bold">DigitalOcean</strong>, <strong class="bold">Microsoft Azure</strong>, and <strong class="bold">Google Cloud</strong>, as well <a id="_idIndexMarker461"/>as <a id="_idIndexMarker462"/>self-hosted VM/cloud <a id="_idIndexMarker463"/>platforms (including <strong class="bold">OpenStack</strong> and <strong class="bold">VMware vSphere</strong>) to quickly <a id="_idIndexMarker464"/>launch <a id="_idIndexMarker465"/>and configure individual Docker hosts. Being able to target all of these<a id="_idIndexMarker466"/> technologies using a single command with minimal user interaction is a very big-time saver. If you need to quickly access a Docker host in AWS one day and then in DigitalOcean the next, you know you are going to get a consistent experience.</p>
			<p>Also, it allows you to launch a local Docker host, which was useful for operating systems such as the non-Professional versions of Windows 10, where Docker<a id="_idTextAnchor191"/><a id="_idTextAnchor192"/> could natively run because of a lack of hypervisor support.</p>
			<p>As with Docker Compose, it used to be bundled with Docker for Windows and Docker for Mac— however, this has been dropped from recent releases. This is due to there being less of a requirement for end users to launch and manage individual Docker hosts. Now, people are using clustering technologies such as Docker Swarm or Kubernetes, or using a cloud provider's native Docker-based hosted tools, all of which we are going to be covering in detail across the remaining chapters.</p>
			<p class="callout-heading"> Important note </p>
			<p class="callout">A few of the tools we are going to be covering in this section of the chapter are now considered legacy, and support for them has started to be phased out. The reason they are mentioned is because for users with older hardware, they may the only way they can experience Docker.</p>
			<p>We are going to start by quickly discussing one of these legacy tools.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor193"/>Installing Docker Machine using Docker Toolbox</h2>
			<p>If you are running<a id="_idIndexMarker467"/> a version of macOS or Windows that does <a id="_idIndexMarker468"/>not support the versions of Docker for Windows and Docker for Mac we have been using in previous chapters, then you can download and install Docker Toolbox, which will install the Docker client, Docker Compose, and Docker Machine. You can download Docker Toolbox from <a href="https://github.com/docker/toolbox/">https://github.com/docker/toolbox/</a>releases; however, please do not install it if you are already running Docker, as it may create conflicts and create problems with your existing installation.</p>
			<p>Docker Toolbox is now considered legacy, and the versions of Docker and the supporting tools that are installed are<a id="_idIndexMarker469"/> old; therefore, we will not be covering their<a id="_idIndexMarker470"/> installation here.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor194"/>Installing Docker Machine using the command line </h2>
			<p>If you are<a id="_idIndexMarker471"/> already running Docker, before we can start using<a id="_idIndexMarker472"/> Docker Machine, we need to install it. Here is the command that you need to run to install Docker Machine on macOS and Linux, starting with macOS:</p>
			<pre>$ base=https://github.com/docker/machine/releases/download/v0.16.2 &amp;&amp;
  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/local/bin/docker-machine &amp;&amp;
  chmod +x /usr/local/bin/docker-machine</pre>
			<p>You would use a similar command for Linux, as follows:</p>
			<pre>$ curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;
    chmod +x /tmp/docker-machine &amp;&amp;
    sudo cp /tmp/docker-machine /usr/local/bin/docker-machine</pre>
			<p>For Windows, the following command assumes t<a id="_idTextAnchor195"/><a id="_idTextAnchor196"/>hat you have Git bash installed:</p>
			<pre>$ if [[ ! -d '$HOME/bin' ]]; then mkdir -p '$HOME/bin'; fi &amp;&amp; \
curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-Windows-x86_64.exe &gt; '$HOME/bin/docker-machine.exe' &amp;&amp; \
chmod +x '$HOME/bin/docker-machine.exe'</pre>
			<p>As you can see, all three commands are downloading an executable from the project's release page. To make sure that you are using the latest version, you can check <a href="https://github.com/docker/machine/releases/">https://github.com/docker/machine/releases/</a>.</p>
			<p>Now that we have Docker Machine installed on your chosen operating system, we can start to deploy VMs that run Docker.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor197"/>Deploying local Docker hosts with Docker Machine</h1>
			<p>Before we <a id="_idIndexMarker473"/>journey out into the cloud <a id="_idIndexMarker474"/>experience, we are going to look at the basics of Docker Machine locally by launching it, using Oracle VirtualBox to provide the VM.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">VirtualBox is a free virtualization product from Oracle. It allows you to install VMs across many different platforms and <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) types. Download and install VirtualBox from <a href="https://www.virtualbox.org/wiki/Downloads/">https://www.virtualbox.org/wiki/Downloads/</a>.</p>
			<p>To launch the <a id="_idIndexMarker475"/>machine, all you need to do is run the following command:</p>
			<pre>$ docker-machine create --driver virtualbox docker-local</pre>
			<p>This will start the deployment, during which you will get a list of tasks that Docker Machine is running. To launch your Docker host, each host launched with Docker Machine goes through the same steps.</p>
			<p>First of all, Docker Machine runs a few basic checks, such as confirming that VirtualBox is installed, and creating certificates and a directory structure in which it will store all of its files and VMs, as follows:</p>
			<pre>Creating CA: /Users/russ.mckendrick/.docker/machine/certs/ca.pem
Creating client certificate: /Users/russ.mckendrick/.docker/machine/certs/cert.pem
Running pre-create checks...
(docker-local) Image cache directory does not exist, creating it at /Users/russ.mckendrick/.docker/machine/cache...</pre>
			<p>It then checks for the presence of the image it will use for the VM. If it is not there, the image will be downloaded, as illustrated in the following code snippet:</p>
			<pre>(docker-local) No default Boot2Docker ISO found locally, downloading the latest release...
(docker-local) Latest release for github.com/boot2docker/boot2docker is v19.03.5
(docker-local) Downloading /Users/russ.mckendrick/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso...
(docker-local) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%</pre>
			<p>Once the checks<a id="_idIndexMarker476"/> have passed, it creates the VM <a id="_idIndexMarker477"/>using the selected driver, as illustrated in the following code snippet:</p>
			<pre>Creating machine...
(docker-local) Copying /Users/russ.mckendrick/.docker/machine/cache/boot2docker.iso to /Users/russ.mckendrick/.docker/machine/machines/docker-local/boot2docker.iso...
(docker-local) Creating VirtualBox VM...
(docker-local) Creating SSH key...
(docker-local) Starting the VM...
(docker-local) Check network to re-create if needed...
(docker-local) Found a new host-only adapter: 'vboxnet0'
(docker-local) Waiting for an IP...
Waiting for machine to be running, this may take a few minutes...</pre>
			<p>As you can see, Docker Machine creates a unique <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) key for the VM. This means that you<a id="_idIndexMarker478"/> will be able to access the VM over SSH, but more on that later. Once the VM has booted, Docker Machine then makes a connection to the VM, as illustrated in the following code snippet:</p>
			<pre>Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with boot2docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...</pre>
			<p>As you can see, Docker Machine detects the operating system being used and chooses the appropriate<a id="_idIndexMarker479"/> bootstrap script to deploy Docker. Once <a id="_idIndexMarker480"/>Docker is installed, Docker Machine generates and shares certificates between your localhost and the Docker host. It then configures the remote Docker installation for certificate authentication, meaning that your local client can connect to and interact with the remote Docker server.</p>
			<p>Once Docker is installed, Docker Machine generates and shares certificates between your localhost and the Docker host. It then configures the remote Docker installation for certificate authentication, meaning that your local client can connect to and interact with the remote Docker server. This is illustrated in the following code snippet:</p>
			<pre>Docke<a id="_idTextAnchor198"/>r<a id="_idTextAnchor199"/> is up and running!
To see how to connect your Docker Client to the Docker Engine running on this VM, run: docker-machine env docker-local</pre>
			<p>Finally, it checks whether your local Docker client can make the remote connection, and completes the task by giving you instructions on how to configure your local client to the newly launched Docker host.</p>
			<p>If you open VirtualBox, you should be able to see your new VM, as illustrated in the following screenshot:</p>
			<div><div><img src="img/Figure_6.01_B15659.jpg" alt="Figure 6.1 – The Docker VM running in VirtualBox&#13;&#10;" width="1540" height="886"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The Docker VM running in VirtualBox</p>
			<p>Next, we need to <a id="_idIndexMarker481"/>configure our local Docker client <a id="_idIndexMarker482"/>to connect to the newly launched Docker host; as already mentioned in the output of launching the host, running the following command will show you how to make the connection:</p>
			<pre>$ docker-machine env docker-local</pre>
			<p>This command returns the following:</p>
			<pre>export DOCKER_TLS_VERIFY='1'
export DOCKER_HOST='tcp://192.168.99.100:2376'
export DOCKER_CERT_PATH='/Users/russ.mckendrick/.docker/machine/machines/docker-local'
export DOCKER_MACHINE_NAME='docker-local'
# Run this command to configure your shell:
# eval $(docker-machine env docker-local)</pre>
			<p>This overrides the local Docker installation by giving the IP address and port number of the newly launched Docker host, as well as the path to the certificates used for authentication. At the end of the output, it gives you a command to run and to configure your Terminal session in order to make the connection.</p>
			<p>Before we run<a id="_idIndexMarker483"/> the command, let's run <code>docker version</code> to get<a id="_idIndexMarker484"/> information on the current setup, as follows:</p>
			<div><div><img src="img/Figure_6.02_B15659.jpg" alt="Figure 6.2 – Checking the versions on Docker on my local installation&#13;&#10;" width="1213" height="1330"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Checking the versions on Docker on my local installation</p>
			<p>This is basically the Docker for Mac installation I am running. Running the following command and then <code>docker version</code> again should show some changes to the server:</p>
			<pre>$ eval $(docker-machine env docker-local)</pre>
			<p>The output of the command is given in the following screenshot:</p>
			<div><div><img src="img/Figure_6.03_B15659.jpg" alt="Figure 6.3 – Checking the versions of Docker on the new VM&#13;&#10;" width="1215" height="1374"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Checking the versions of Docker on the new VM</p>
			<p>As you can see, the <a id="_idIndexMarker485"/>server launched by <a id="_idIndexMarker486"/>Docker Machine is pretty much in line with what we have installed locally; in fact, the only difference is that it is a few minor versions behind. As you can see, the Docker Engine binary on my Docker for Mac installation is running version <code>19.03.8</code> and the Docker Machine launched host is running <code>19.03.5</code>.</p>
			<p>From here, we can interact with the Docker host in the same way as if it were a local Docker installation. Before we move on to launching Docker hosts in the cloud, there are a few other basic Docker Machine commands to cover.</p>
			<p>The first command lists the currently configured Docker hosts, and is shown here:</p>
			<pre>$ docker-machine ls</pre>
			<p>The output of the command is given here:</p>
			<div><div><img src="img/Figure_6.04_B15659.jpg" alt="Figure 6.4 – Listing the VMs&#13;&#10;" width="1632" height="198"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Listing the VMs</p>
			<p>As you can see, it <a id="_idIndexMarker487"/>lists details of the machine name, the driver used, and the Docker endpoint <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>), as well as the version of Docker the hosts are running.</p>
			<p>You will also notice that there is a <code>*</code> in the <code>ACTIVE</code> column; this indicates which Docker host your local <a id="_idIndexMarker488"/>client is currently configured to <a id="_idIndexMarker489"/>interact with. You can also find out the active machine by running <code>docker-machine active</code>.</p>
			<p>The next command connects you to the Docker host using SSH, and is shown here:</p>
			<pre>$ docker-machine ssh docker-local</pre>
			<p>The output of the command is given here:</p>
			<div><div><img src="img/Figure_6.05_B15659.jpg" alt="Figure 6.5 – Connecting to the VM using SSH&#13;&#10;" width="1216" height="305"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Connecting to the VM using SSH</p>
			<p>This is useful if you need to install additional software or configuration outside of Docker Machine. It is also useful if you need to look at logs, and so on. You can exit the remote shell by running <code>exit</code>. You can find out the IP address of your Docker host by running the following command once back on your local machine:</p>
			<pre>$ docker-machine ip docker-local</pre>
			<p>We will be using this command a lot throughout the chapter as part of other commands to get the IP addresses of our VMs. There are also commands for establishing more details about your Docker host, and these are shown in the following code snippet:</p>
			<pre>$ docker-machine inspect docker-local
$ docker-machine config docker-local
$ docker-machine status docker-local
$ docker-machine url docker-local</pre>
			<p>Finally, there are also commands to stop, start, restart, and remove your Docker host. Use the final command in the following code snippet to remove your locally launched host:</p>
			<pre>$ docker-machine stop docker-local
$ docker-machine start docker-local
$ docker-machine restart docker-local
$ docker-machine rm docker-local</pre>
			<p>Running <a id="_idIndexMarker490"/>the <code>docker-machine rm</code> command<a id="_idIndexMarker491"/> will prompt you to determine whether you really want to remove the instance, as illustrated here:</p>
			<pre>About to remove docker-local
WARNING: This action will delete both local reference and remote instance.
Are you sure? (y/n): y
Successfully removed docker-local</pre>
			<p>Now that we have had a very quick rundown of the basics, let's try something more adventurous.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor200"/>Launching Docker hosts in the cloud using Docker Machine</h1>
			<p>In this <a id="_idIndexMarker492"/>section, we are going to take<a id="_idIndexMarker493"/> a look at just one of the <a id="_idIndexMarker494"/>public cloud drivers supported by Docker Machine. As already mentioned, there are plenty available, but part of the appeal of Docker Machine is that it offers consistent experiences, so there are not too many differences between the drivers.</p>
			<p>We are going to be <a id="_idIndexMarker495"/>launching a Docker host in <strong class="bold">DigitalOcean</strong> using Docker <a id="_idIndexMarker496"/>Machine. To do this, we need an <strong class="bold">application programming in<a id="_idTextAnchor201"/><a id="_idTextAnchor202"/>terface</strong> (<strong class="bold">API</strong>) access token with the necessary permissions to access and launch resources within your DigitalOcean account. Rather than explaining how to generate one here, you can follow the instructions at <a href="https://www.digitalocean.com/help/api/.">https://www.digitalocean.com/help/api/.</a></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Launching a Docker host using the API token will incur a cost; ensure you keep track of the Docker hosts you launch. Details on DigitalOcean's pricing can be found at <a href="https://www.digitalocean.com/pricing/">https://www.digitalocean.com/pricing/</a>. Also, keep your API token secret as it could be used to gain unauthorized access to your account. All of the tokens used in this chapter have been revoked.</p>
			<p>The first thing we are going to do is set our token as an environment variable so that we don't have to keep using it. To do thi<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/>s, run the following command:</p>
			<pre>$ DOTOKEN=191e004d9a58b964198ab1e8253fc2de367a70fceb9847b7fd44ebf </pre>
			<p>Make sure you replace the API token with your own.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Due to the additional flags that we need to pass to the <code>docker-machine</code> command, I will be using <code>/</code> to split the command across multiple lines to make it more readable.</p>
			<p>The command to launch the Docker host in DigitalOcean is as follows:</p>
			<pre>$ docker-machine create \
     --driver digitalocean \
     --digitalocean-access-token $DOTOKEN \
     docker-digitalocean</pre>
			<p>As the Docker <a id="_idIndexMarker497"/>host is a remote <a id="_idIndexMarker498"/>machine, it will take a little <a id="_idIndexMarker499"/>while to launch, configure, and be accessible. As you can see from the following output, there are also a few changes to how Docker Machine bootstraps the Docker host:</p>
			<pre>Running pre-create checks...
Creating machine...
(docker-digitalocean) Creating SSH key...
(docker-digitalocean) Creating Digital Ocean droplet...
(docker-digitalocean) Waiting for IP address to be assigned to the Droplet...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with ubuntu(systemd)...
Installing Docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this VM, run: docker-machine env docker-digitalocean</pre>
			<p>Once<a id="_idIndexMarker500"/> launched, you should be<a id="_idIndexMarker501"/> able to see the Docker host in <a id="_idIndexMarker502"/>your DigitalOcean control panel, as illustrated in the following screenshot:</p>
			<div><div><img src="img/Figure_6.06_B15659.jpg" alt="Figure 6.6 – Viewing the droplet in the DigitalOcean portal&#13;&#10;" width="1608" height="935"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Viewing the droplet in the DigitalOcean portal</p>
			<p>Reconfigure your local client to connect to the remote host by running the following command:</p>
			<pre>$ eval $(docker-machine env docker-digitalocean)</pre>
			<p>Also, you can run <code>docker version</code> and <code>docker-machine inspect docker-digitalocean</code> to find out more information about the Docker host.</p>
			<p>Finally, running <code>docker-machine ssh docker-digitalocean</code> will SSH you into the host. As you can see from the following output, and also from the output when you first launched the Docker host, there is a difference in the operating system used:</p>
			<div><div><img src="img/Figure_6.07_B15659.jpg" alt="Figure 6.7 – SSHing into our DigitalOcean machine&#13;&#10;" width="1326" height="714"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – SSHing into our DigitalOcean machine</p>
			<p>You can exit<a id="_idIndexMarker503"/> the remote shell by<a id="_idIndexMarker504"/> running <code>exit</code>. As you can <a id="_idIndexMarker505"/>see, we didn't have to tell Docker Machine which operating system to use, the size of the Docker host, or even where to launch it. That is because each driver has some pretty sound defaults.</p>
			<p>Adding these defaults to our com<a id="_idTextAnchor205"/><a id="_idTextAnchor206"/>mand makes it look like the following:</p>
			<pre>docker-machine create \
     --driver digitalocean \
     --digitalocean-access-token $DOTOKEN \
     --digitalocean-image ubuntu-16-04-x64 \
     --digitalocean-region nyc3 \
     --digitalocean-size 512mb \
     --digitalocean-ipv6 \
     --digitalocean-backups \
     --digitalocean-ssh-user root \
     --digitalocean<a id="_idTextAnchor207"/><a id="_idTextAnchor208"/>-ssh-port 22 \
     docker-digitalocean</pre>
			<p>As you can see, there is scope for you to customize the size, region, and operating system, and even the network your Docker host is launched with. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The command in the code snippet that follows will give an error if you have a droplet already launched.</p>
			<p>Let's say we <a id="_idIndexMarker506"/>wanted to change the <a id="_idIndexMarker507"/>operating system and the size <a id="_idIndexMarker508"/>of the droplet. In this instance, we can run the following:</p>
			<pre>$ docker-machine create \
      --driver digitalocean \
      --digitalocean-access-token $DOTOKEN \
      --digitalocean-image ubuntu-18-04-x64 \
      --digitalocean-size 1gb \
      docker-digitalocean</pre>
			<p>As you can see in the <strong class="bold">DigitalOcean</strong> control panel, this launches a machine that looks like the following:</p>
			<div><div><img src="img/Figure_6.08_B15659.jpg" alt="Figure 6.8 – Viewing the droplet with a different specification&#13;&#10;" width="1623" height="960"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Viewing the droplet with a different specification</p>
			<p>You can <a id="_idIndexMarker509"/>remove the DigitalOcean <a id="_idIndexMarker510"/>Docker host by running<a id="_idIndexMarker511"/> the following command:</p>
			<pre>$ docker-machine rm docker-digitalocean</pre>
			<p>It will take a minute or two to properly remove the host.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Please double-check in the DigitalOcean portal that your host has been properly terminated; otherwise, you may incur unexpected costs.</p>
			<p>That concludes our look at Docker Machine. Before we move on, let's discuss how secure it is.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor209"/>Docker Machine summary</h2>
			<p>As already<a id="_idIndexMarker512"/> mentioned, Docker Machine is now considered a legacy tool. As well as the aforementioned reason that people no longer want to launch single Docker hosts, there are also some other reasons for the change in direction.</p>
			<p>The most important one is security. As you may have noticed, when Docker Machine was launching our Docker hosts it generated not only an SSH key but also certificates, and then configured the Docker server component with these, meaning that our local Docker client could interact with the host. Now, with the localhost this was not a problem; however, on the DigitalOcean-hosted instance, we were exposing our Docker server to the internet.</p>
			<p>While it was securely configured, if there were ever to be a zero-day exploit with the version of Docker that was installed we could end up with a few problems, as untrusted third parties may be able to take over our Docker installation. Because of this, I would recommend only using <a id="_idIndexMarker513"/>Docker Machine to quickly spin up an instance, test something, and then spin the instance down.</p>
			<p>We will be looking at some better options for running containerized applications on clouds in <a href="B15659_10_Final_JM_ePub.xhtml#_idTextAnchor277"><em class="italic">Chapter 10</em></a>, <em class="italic">Running Docker in Public Clouds,</em> and <a href="B15659_13_Final_JM_ePub.xhtml#_idTextAnchor626"><em class="italic">Chapter 13</em></a>, <em class="italic">Running Kubernetes in Public Clouds</em>.</p>
			<p>Let's now look at a few alternatives to using Docker Machine to launch a local Docker host.</p>
			<p>Using Vagrant and Multipass to launch local Docker hosts</p>
			<p>Before we <a id="_idIndexMarker514"/>finish the chapter, we are going to<a id="_idIndexMarker515"/> look at two different tools that can<a id="_idIndexMarker516"/> be used to launch a machine locally, and <a id="_idIndexMarker517"/>then provision and configure a local Docker host for you to experiment with in later chapters.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor210"/>Introducing and using Vagrant</h2>
			<p>Vagrant, by <strong class="bold">HashiCorp</strong>, is the granddaddy of host management tools. First released in early 2010, what <a id="_idIndexMarker518"/>started <a id="_idIndexMarker519"/>as a side project for <strong class="bold">Mitchell Hashimoto</strong> has turned into a quite important piece of software in modern software development as it allows developers to quickly and easily launch and remove local VMs for use as development environments. In May 2014, version 1.6 was released, which introduced support for Docker. </p>
			<p>The installation differs slightly depending on your operating system. If you are running macOS, then you can use Homebrew and Cask. The command to use these is shown in the following code snippet:</p>
			<pre>$ brew cask install vagra<a href="https://www.vagrantup.com/downloads.html">nt</a></pre>
			<p><a href="https://www.vagrantup.com/downloads.html">Windows and Linux users can download </a>the installers from <a href="https://www.vagrantup.com/downloads.html">https://www.vagrantup.com/downloads.html</a>. There, you can find both 32-bit and 64-bit <code>MSI</code>, <code>deb</code>, and <code>RPM</code> packages for your preferred operating system, as well as 64-bit static binaries for macOS and Linux if you would prefer not to use a package manager.</p>
			<p>Vagrant uses a <code>Vagrantfile</code>, which defines what the VM looks like; the machines themselves, packaged up into a format called a Vagrant Box—a box containing the machine<a id="_idIndexMarker520"/> image; and<a id="_idIndexMarker521"/> also, the metadata needed to launch the host using VirtualBox, VMWare, or any other supported hypervisor or cloud service. Boxes are typically downloaded from Vagrant Cloud and are created by another HashiCorp <a id="_idIndexMarker522"/>product called <strong class="bold">Packer</strong>.</p>
			<p>To create a <code>Vagrantfile</code>, you can simply run the following command in a folder in which you wish to store the files relating to your Vagrant Box:</p>
			<pre>$ vagrant init ubuntu/bionic64</pre>
			<p>The default <code>Vagrantfile</code> is heavily commented; however, the majority of the options are  commented out. Removing these gives us something that should look like the following:</p>
			<pre>Vagrant.configure('2') do |config|
  config.vm.box = 'ubuntu/bionic64'
end</pre>
			<p>As you can see, there isn't much to it and there certainly isn't anything to do with Docker, so let's fix that. Update the <code>Vagrantfile</code> so that it looks like the following:</p>
			<pre>Vagrant.configure('2') do |config|
  config.vm.box = 'ubuntu/bionic64'
  config.vm.provision :docker
end</pre>
			<p>Once updated, run the following command and wait:</p>
			<pre>$ vagrant up</pre>
			<p>If you don't already have the <code>ubuntu/bionic64</code> box downloaded, then Vagrant will download that for you. Once downloaded, it will launch a VM in VirtualBox, which is its default provider. You should see something like the following as an output:</p>
			<pre>Bringing machine 'default' up with 'virtualbox' provider...
==&gt; default: Importing base box 'ubuntu/bionic64'...
==&gt; default: Matching MAC address for NAT networking...
==&gt; default: Checking if box 'ubuntu/bionic64' version '20200402.0.0' is up to date...
==&gt; default: Setting the name of the VM: vagrant_default_1586094728360_48806
==&gt; default: Clearing any previously set network interfaces...
==&gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==&gt; default: Forwarding ports...
    default: 22 (guest) =&gt; 2222 (host) (adapter 1)
==&gt; default: Running 'pre-boot' VM customizations...
==&gt; default: Booting VM...</pre>
			<p>Once the VM <a id="_idIndexMarker523"/>has booted, Vagrant will SSH into the machine and replace the default<a id="_idIndexMarker524"/> Vagrant key file with a more secure self-generated one, as illustrated in the following code snippet:</p>
			<pre>==&gt; default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222
    default: SSH username: vagrant
    default: SSH auth method: private key
    default:
    default: Vagrant insecure key detected. Vagrant will automatically replace
    default: this with a newly generated keypair for better security.
    default:
    default: Inserting generated public key within guest...
    default: Removing insecure key from the guest if it's present...
    default: Key inserted! Disconnecting and reconnecting using new SSH key...
==&gt; default: Machine booted and ready!</pre>
			<p>Now that the SSH<a id="_idIndexMarker525"/> key is secure, Vagrant will check that the VM is running the <a id="_idIndexMarker526"/>VirtualBox guest additions. These will allow it to share your local machine's filesystem with the VM. The process is illustrated in the following code snippet:</p>
			<pre>==&gt; default: Checking for guest additions in VM...
    default: The guest additions on this VM do not match the installed version of
    default: VirtualBox! In most cases this is fine, but in rare cases it can
    default: prevent things such as shared folders from working properly. If you see
    default: shared folder errors, please make sure the guest additions within the
    default: VM match the version of VirtualBox you have installed on
    default: your host and reload your VM.
    default:
    default: Guest Additions Version: 5.2.34
    default: VirtualBox Version: 6.1
==&gt; default: Mounting shared folders...
    default: /vagrant =&gt; /Users/russ.mckendrick/vagrant</pre>
			<p>The final step is <a id="_idIndexMarker527"/>to run the provisioner we added to our <code>Vagrantfile</code>, as <a id="_idIndexMarker528"/>follows:</p>
			<pre>==&gt; default: Running provisioner: docker...
    default: Installing Docker onto machine...</pre>
			<p>So, we now have an Ubuntu 18.04 (Bionic Beaver) VM with Docker installed. To access the VM, simply run the following command:</p>
			<pre>$ vagrant ssh</pre>
			<p>This will open an SSH session to the VM. From there, you can use Docker, as we have been doing when running it locally. See the following terminal output for an example:</p>
			<div><div><img src="img/Figure_6.09_B15659.jpg" alt="Figure 6.9 – Logging in to our Vagrant Box and interacting with Docker&#13;&#10;" width="1293" height="1065"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Logging in to our Vagrant Box and interacting with Docker</p>
			<p>Once you have<a id="_idIndexMarker529"/> finished with the VM, type <code>exit</code> to return to your host machine's <a id="_idIndexMarker530"/>Command Prompt, and then run the following command to terminate the VM:</p>
			<pre>$ vagrant destroy</pre>
			<p>This will remove all of the resources associated with the VM. You will see the following messages:</p>
			<pre>    default: Are you sure you want to destroy the 'default' VM? [y/N] y
==&gt; default: Forcing shutdown of VM...
==&gt; default: Destroying VM and associated drives...</pre>
			<p>Should you wish to just stop the VM, you can use the following commands to stop and start it:</p>
			<pre>$ vagrant stop
$ vagrant up</pre>
			<p>Now that we<a id="_idIndexMarker531"/> have learned how to create a VM and provision Docker using<a id="_idIndexMarker532"/> Vagrant, let's look at an alternative called <strong class="bold">Multipass</strong>.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor211"/>Introducing and using Multipass</h1>
			<p><strong class="bold">Multipass</strong> is a <a id="_idIndexMarker533"/>tool provided by <em class="italic">Canonical</em>, the makers of Ubuntu, to quickly launch <a id="_idIndexMarker534"/>and manage multiple Ubuntu VMs locally. It works slightly differently from Vagrant in that rather than defaulting to using VirtualBox, it will use your operating system's default hypervisor. Where one is not available, as with non-Professional versions of Windows 10, it has the ability to fall back to using VirtualBox—more on that in a moment.</p>
			<p>To install Multipass on macOS, you can run the following command, which again uses Homebrew and Cask:</p>
			<pre>$ brew cask install multipass</pre>
			<p>To install on an existing Ubuntu desktop, you can use the Snap package manager by running the following command:</p>
			<pre>$ snap install multipass --classic</pre>
			<p>Finally, to install on Windows, you can download the installer from the project's release page at GitHub, where <a id="_idIndexMarker535"/>you will also find the macOS installer, at <a href="https://github.com/canonical/multipass/releases">https://github.com/canonical/multipass/releases</a>.</p>
			<p>Once installed, if you need to use VirtualBox over your local machine's native hypervisor, you can run the following command:</p>
			<pre>$ multipass set local.driver=virtualbox</pre>
			<p>Now that we have Multipass and installed, and—if needed—configured to use VirtualBox, we can start a VM up and install Docker. To launch a VM, simply run the following command:</p>
			<pre>$ multipass launch --name docker-host</pre>
			<p>Once launched, we can run the following command to bootstrap Docker onto the newly created VM:</p>
			<pre>$ multipass exec docker-host -- /bin/bash -c 'curl -s https://get.docker.com | sh - &amp;&amp; sudo usermod -aG docker ubuntu'</pre>
			<p>This will download and install the latest community version of Docker. Once installed, it will then add the <code>ubuntu</code> user to the <code>docker</code> group, meaning that when connected to the VM we<a id="_idIndexMarker536"/> will be ready to use Docker straight away. You will see the output<a id="_idIndexMarker537"/> of the commands being executed during the installation, and, once complete, you will be returned to your local machine's shell.</p>
			<p>To connect to the VM, run the following command:</p>
			<pre>$ multipass shell docker-host</pre>
			<p>Once connected, you will notice that by default, and as with our Vagrant VM, Multipass has downloaded and launched an <code>Ubuntu 18.04</code> (Bionic Beaver) VM. Once logged in, you will be able to run Docker commands as expected. The process is illustrated in the following screenshot:</p>
			<div><div><img src="img/Figure_6.10_B15659.jpg" alt="Figure 6.10 – SSHing to our Multipass VM and interacting with Docker&#13;&#10;" width="1593" height="1200"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – SSHing to our Multipass VM and interacting with Docker</p>
			<p>As with Vagrant, once<a id="_idIndexMarker538"/> you have finished, type in <code>exit</code>, and you will be returned to your<a id="_idIndexMarker539"/> local machine's shell. To remove the <code>docker-host</code> VM and all of its resources, you can run the following command:</p>
			<pre>$ multipass delete docker-host --purge </pre>
			<p>If you want to stop and start the VM, you can use the following:</p>
			<pre>$ multipass stop docker-host
$ multipass start docker-host</pre>
			<p>As you can see, using Multipass is a nice and simple way to both launch and interact with Ubuntu VMs locally on any host.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor212"/>Summary</h1>
			<p>In this chapter, we looked at how to use Docker Machine to create Docker hosts locally on VirtualBox and reviewed the commands you can use to both interact with and manage your Docker Machine-launched Docker hosts. We then looked at how to use Docker Machine to deploy Docker hosts to a cloud environment—namely, <strong class="bold">DigitalOcean</strong>.</p>
			<p>We also discussed why using Docker Machine may also not be a great idea, depending on the age of your host machine. Because of this, we also discussed how to launch and configure a local Docker host using both <strong class="bold">Vagrant</strong> and <strong class="bold">Multipass</strong>.</p>
			<p>In later chapters, we are going to move away from interacting with a single Docker host and move on to launching and running multiple Docker hosts. However, before we do so, we are first going to move away from Linux-based containers and take a whistle-stop tour of Windows containers in the next chapter. Don't worry if you don't have a Windows-based host, as we will be using Vagrant to launch one.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor213"/>Questions</h1>
			<ol>
				<li>Which flag, when running <code>docker-machine create</code>, lets you define which service or provider Docker Machine uses to launch your Docker host?</li>
				<li>True or false: Running <code>docker-machine env my-host</code> will reconfigure your local Docker client to interact with <code>my-host</code>.</li>
				<li>True or false: Multipass has native support for Docker out of the box.</li>
				<li>Name the HashiCorp tool that can be used to create Vagrant Boxes.</li>
				<li>Explain why using Docker Machine to create Docker hosts in the cloud is no longer considered best practice.</li>
			</ol>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor214"/>Further reading</h1>
			<p>For information on the various tools we have used and referred to in this chapter, refer to the following:</p>
			<ul>
				<li>Homebrew: <a href="https://brew.sh">https://brew.sh</a></li>
				<li>Cask: <a href="https://github.com/Homebrew/homebrew-cask">https://github.com/Homebrew/homebrew-cask</a></li>
				<li>Git BASH for Windows: <a href="https://gitforwindows.org">https://gitforwindows.org</a></li>
				<li>VirtualBox: <a href="https://www.virtualbox.org">https://www.virtualbox.org</a></li>
				<li>Docker Machine: <a href="https://docs.docker.com/machine/">https://docs.docker.com/machine/</a></li>
				<li>Docker Toolbox: <a href="https://docs.docker.com/toolbox/overview/">https://docs.docker.com/toolbox/overview/</a></li>
				<li>DigitalOcean: <a href="https://www.digitalocean.com/">https://www.digitalocean.com/</a></li>
				<li>Vagrant: <a href="https://www.vagrantup.com">https://www.vagrantup.com</a></li>
				<li>Vagrant Cloud: <a href="https://app.vagrantup.com/boxes/search">https://app.vagrantup.com/boxes/search</a></li>
				<li>Packer: <a href="https://packer.io">https://packer.io</a></li>
				<li>HashiCorp: <a href="https://www.hashicorp.com">https://www.hashicorp.com</a></li>
				<li>Multipass: <a href="https://multipass.run">https://multipass.run</a></li>
				<li>Snap: <a href="https://snapcraft.io">https://snapcraft.io</a></li>
				<li>Canonical: <a href="https://canonical.com">https://canonical.com</a></li>
			</ul>
		</div>
	</div>



  
<div><div><h1 id="_idParaDest-130"><strong class="bold"><a id="_idTextAnchor215"/>Section 2</strong>: Clusters and Clouds</h1>
			<p>In this section, we will be taking everything we have learned in the first part and applying it to the two main Docker clustering technologies, Docker Swarm and Kubernetes, as well as looking at running containers on public clouds.</p>
			<p>This section comprises the following chapters:</p>
			<p><a href="B15659_07_Final_JM_ePub.xhtml#_idTextAnchor216"><em class="italic">Chapter 7</em></a>, <em class="italic">Moving from Linux to Windows Containers</em></p>
			<p><a href="B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230"><em class="italic">Chapter 8</em></a>, <em class="italic">Clustering with Docker Swarm</em></p>
			<p><a href="B15659_09_Final_JM_ePub.xhtml#_idTextAnchor261"><em class="italic">Chapter 9</em></a>, <em class="italic">Portainer – A GUI for Docker</em></p>
			<p><a href="B15659_10_Final_JM_ePub.xhtml#_idTextAnchor277"><em class="italic">Chapter 10</em></a>,<em class="italic"> Running Docker in Public Clouds</em></p>
			<p><a href="B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294"><em class="italic">Chapter 11</em></a>, <em class="italic">Clustering with Docker and Kubernetes</em></p>
			<p><a href="B15659_12_Final_JM_ePub.xhtml#_idTextAnchor394"><em class="italic">Chapter 12</em></a>, <em class="italic">Discovering Other Kubernetes Options</em></p>
			<p><a href="B15659_13_Final_JM_ePub.xhtml#_idTextAnchor626"><em class="italic">Chapter 13</em></a>, <em class="italic">Running Kubernetes in Public Clouds</em></p>
		</div>
	</div>



  </body></html>