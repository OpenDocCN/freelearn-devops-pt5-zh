- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying to Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After deploying our WordPress infrastructure into Microsoft Azure, we are now
    ready to explore how to deploy the same infrastructure to **Amazon Web Services**
    (**AWS**). However, while the high-level design of the infrastructure remains
    the same, there are some key differences between Azure and AWS that will require
    us to approach the deployment differently.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, we focused on using Terraform to deploy to Azure. In this chapter, we
    will be diving deeper into Ansible, another popular infrastructure-as-code tool,
    to deploy our workload to AWS. Ansible allows us to define the desired state of
    our infrastructure in a declarative manner and manage the configuration and orchestration
    of our AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of how to use
    Ansible and Terraform to deploy a WordPress workload on AWS. You will also be
    familiar with the key differences between Azure and AWS and how to adapt your
    deployment approach to your infrastructure-as-code deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Amazon Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing our cloud environment for deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing the low-level design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible – writing the code and deploying our infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform – reviewing the code and deploying our infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in the previous chapter, due to the amount of code needed to deploy our
    project, when it comes to the Terraform and Ansible sections of the chapter, we
    will only be covering some pieces of code needed to deploy the project. The code
    repository accompanying this book will contain the complete executable code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS is a cloud infrastructure platform owned and operated by the e-commerce
    giant Amazon, which you probably already guessed, given the name.
  prefs: []
  type: TYPE_NORMAL
- en: The company began experimenting with cloud services in 2000, developing and
    deploying **application programming interfaces** (**APIs**) for their internal
    and external retail partners to consume. As more and more of the Amazon retail
    partners consumed more of the software services and grew at an exponential rate,
    they realized they would need to build a better and more standardized infrastructure
    platform to not only host the services they had been developing but also ensure
    that they could quickly scale as well.
  prefs: []
  type: TYPE_NORMAL
- en: Off the back of this requirement, Amazon engineers Chris Pinkham and Benjamin
    Black wrote a white paper, which Jeff Bezos personally approved in early 2004\.
    The paper described an infrastructure platform where the compute and storage elements
    could all be deployed programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: The first public acknowledgment of AWS’s existence was made in late 2004\. Still,
    at that time, the term was used to describe a collection of tools and APIs that
    would allow first and third parties to interact with Amazon’s retail product catalog
    rather than the fully formed public cloud service it is today. It wasn’t until
    2006 that a rebranded AWS was launched, due mainly to the service starting to
    expand beyond offering an API to Amazon’s retail services and instead starting
    to offer services that allowed users to use the services for their applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Storage Service** (**S3**) was the first of these new services; this
    was, and still is, albeit a little more feature-rich, a service that allows developers
    to write and serve individual files using a web API rather than having to write
    and read from a traditional local filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: The next service to launch is also still around, Amazon **Simple Queue Service**
    (**SQS**). It initially formed part of the original AWS collection of API endpoints.
    It is a distributed message system that again could be controlled and consumed
    by developers using an API.
  prefs: []
  type: TYPE_NORMAL
- en: The final service, launched in 2006, was a beta version of the Amazon **Elastic
    Compute Cloud** (**EC2**) service, which was limited to existing AWS customers
    – again, you could use the APIs developed by Amazon to launch and manage resources.
  prefs: []
  type: TYPE_NORMAL
- en: This was the final piece of the jigsaw for Amazon. They now had the foundations
    of a public cloud platform, which had initially been envisioned in the whitepaper
    that Chris Pinkham and Benjamin Black produced a few years earlier. They could
    not only use this new service for their retail platform but also sell space to
    other companies and the public, such as you and me. The bonus was that this new
    service could have a recurring revenue stream not only to pay for the initial
    development but also so that Amazon could maximize its hardware investment by
    *renting* out its idle compute resources.
  prefs: []
  type: TYPE_NORMAL
- en: AWS has grown from the 3 services mentioned in 2006 to over 200 in 2023\. All
    these 200+ services are aligned with the core principles laid out in the original
    white paper. Each service is software-defined, meaning that a developer simply
    needs to make an API request to launch, configure, sometimes consume, and terminate
    the service.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the API is also precisely what we will do in this chapter,
    as many of the principles laid out in that original white paper are also at the
    core of infrastructure as code.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our cloud environment for deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to Microsoft Azure*, we will be running Ansible and Terraform on our local machine,
    which means we can install and configure the AWS **command-line** **interface**
    (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and Terraform will use the credentials configured in the AWS CLI to
    authenticate against the AWS APIs. For details on how to install the AWS CLI,
    see [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you need to generate and enter your credentials. This process
    is documented at [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once configured, you should be able to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run them on my own machine, I get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The output of running the AWS version command to check the version](img/Figure_5.01_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The output of running the AWS version command to check the version
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second command, there is quite a lot of output, which should look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The output of running the AWS version command to describe the
    regions](img/Figure_5.02_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The output of running the AWS version command to describe the regions
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the AWS CLI configured and hooked into our AWS account, we
    can discuss the services we will be deploying and configuring within AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Producing the low-level design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From an architecture point of view, the services that are going to be deployed
    are not too dissimilar from those we covered in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to* *Microsoft Azure*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – An overview of the services we will be deploying into AWS](img/Figure_5.03_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – An overview of the services we will be deploying into AWS
  prefs: []
  type: TYPE_NORMAL
- en: 'The core services we are going to be deploying are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon **Elastic Load Balancing** (**ELB**) is the first difference in the services
    we will be deploying. Azure Load Balancer only distributed TCP requests between
    our WordPress instances. However, in AWS, we will launch ELB configured as Application
    Load Balancer, which will terminate our HTTP requests and distribute them across
    our WordPress instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon EC2** is the compute service. For our WordPress deployment, we will
    be deploying a single Amazon EC2 instance, which will be used to bootstrap WordPress,
    and then the rest of the Amazon EC2 instances will be auto-scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using a combination of Amazon EC2 **Auto Scaling groups** (**ASGs**)
    and launch configurations to manage the deployment of the Amazon EC2 instances,
    which will host the web instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Elastic File System** (**EFS**) is the service that will provide the
    NFS share hosting of the WordPress installation, which will be shared across all
    of our instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Relational Database Service** (**RDS**) will be used to host the MySQL
    database we will use for WordPress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Virtual Private Cloud** (**VPC**) is the underlying network service
    that hosts the services that will be deployed throughout this chapter. There are
    a few different services that come under this umbrella, and those will be covered
    in more detail when we do a deep dive into the Ansible code in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an idea of the services we are going to be using and also which
    part of the WordPress deployment they will be hosting, we can start to look at
    how we approach the project using Ansible – this time going in into a little more
    detail than we did in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to* *Microsoft Azure*.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible – writing the code and deploying our infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, we briefly covered the Ansible code to deploy our Azure environment. Let’s
    take a step back and cover some of the basics we skipped.
  prefs: []
  type: TYPE_NORMAL
- en: While we can have one big YAML file containing our playbook code, I tend to
    split mine into more manageable chunks using roles. Roles can be used for a few
    things. In some cases, they can be stand-alone distributable tasks that can be
    reused across multiple projects; or, in our case, they can be used to manage more
    complex playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A copy of the `site.yml` file that will be used to deploy our WordPress environment
    in AWS looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are several roles, all of which I have grouped in the
    logical order we need to deploy our resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look in one of the role folders, for example, `roles/create-randoms`,
    you will notice that there are several folders and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defaults`: This is where the default variables for the role are stored. These
    can be overridden by any variables with the same name called in the `vars` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files`: This folder contains any static files we wish to copy to the target
    hosts using the `copy` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handlers`: These are tasks that are executed once a playbook has been executed,
    for example, restarting services on a target host when a configuration file has
    changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta`: This folder contains information about the role itself. This information
    would be used if it was ever published to Ansible Galaxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tasks`: This contains the primary set of instructions or actions that will
    be executed on the target hosts. These instructions are usually defined in YAML
    files, including installing packages, creating users, and copying files. Tasks
    can be organized into different files based on their functionality or the specific
    actions they perform. They can also include variables and conditional statements
    to make them more dynamic and flexible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: This folder contains the Jinja2 templates used by the `template`
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: If you are publishing your role to Ansible Galaxy, then it is a good
    idea to set up some tests. These are stored here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars`: You can override any of the variables defined in the `default` folder
    using the variables defined here. Variables defined here can also be overridden
    by any variables loaded from the `group_vars` folder at the top level of the playbook.
    These, in turn, can be overridden by variables passed in at runtime using the
    `ansible-playbook` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: This is the file used to create any documentation about the role
    when the role is checked into a service such as GitHub. This is useful when publishing
    the role to Ansible Galaxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that is a lot of folders and files to create when you want to add a role.
    Luckily, the `ansible-galaxy` command can bootstrap a role quickly. To do this,
    simply run the following command in the top level of your `playbook` folder, making
    sure to replace `role-name` with the name you want for your role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will create the folder and file structure we just covered and is an excellent
    starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the roles, let’s quickly discuss the variables. At the
    top of the `group_vars/aws.yml` file, we have some basic variables defined. These
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are defining a top level and have multiple keys and values
    attached to them. So, anywhere in our code, or even in other top-level variables,
    we can simply use something such as `{{ app.name }}`, which will be replaced by
    `iac-wordpress` when our playbook runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen when defining the resource names, as these are mostly made
    up of groups of variables defined elsewhere. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s look at the playbook roles in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbook roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s dive straight in and look at the first role.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Randoms role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This role, which we already covered in detail in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, does the same tasks as covered in that chapter.
    The role was copied straight from the Microsoft Azure deployment folder.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS Network role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The primary variable we are defining in `group_vars/aws.yml` for this role
    is a lot more simplistic than the one we defined for the Azure deployment. It
    contains the CIDR range we want to use for our VPC network and nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The tasks we are running in the role take care of the rest of the information
    using some of Ansible’s built-in functions. The first task is a relatively straightforward
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it uses the `amazon.aws.ec2_vpc_net` module from the Amazon
    collection on Ansible Galaxy to create the VPC – so nothing too special or complicated
    there. The output of the task is registered as `vpc`; we will use this output
    register throughout the remainder of the playbook run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task gathers some information on the region in which we are going
    to be deploying our workload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a few outputs registered, we can add the subnets and start
    doing more exciting things.
  prefs: []
  type: TYPE_NORMAL
- en: As part of our deployment, we need to add four subnets – two for the web services
    and two for the database services. Like our Azure deployment, the subnets will
    be /27s, and we will deploy each subnet in different Availability Zones.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: When we deployed the Azure version of our WordPress workload, we didn’t have
    to worry about how the subnets were distributed across Availability Zones (which
    are different data centers within a region), as virtual networks in Azure can
    span multiple Availability Zones. However, AWS is different; subnets need to be
    pinned to Availability Zones, meaning you will need to have more than one per
    server role or service function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task to add the first subnet looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Things start simple enough in that we use the output register from when we created
    the VPC to get the ID of the VPC to attach the subnet to by using `"{{` `vpc.vpc.id
    }}"`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the output register again to get the CIDR range from the VPC output
    register; however, we take that value and use the `ansible.utils.ipsubnet` function
    to work out what the first `/27` in the CIDR range will be.
  prefs: []
  type: TYPE_NORMAL
- en: As we have passed in `10.0.0.0/24`, running `ansible.utils.ipsubnet(27, 0)`
    should give us `10.0.0.0/27`. The keen-eyed among you may have noticed that we
    passed in `0` rather than `1`. Ansible always counts from 0, so if we had used
    `1`, then we would have gotten `10.0.0.32/27`, which is what we need to use for
    the second subnet.
  prefs: []
  type: TYPE_NORMAL
- en: The second exciting thing we are doing is taking the output of the `zone` register,
    which contains information on the region we are using, including a list of the
    Availability Zones. So, when we use `{{ zones.availability_zones[0].zone_name
    }}`, it is taking the zone name for the first result, that is, `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach in populating information for the CIDR and Availability
    Zone for the subnet is that we do not have to hardcode those details as variables.
    If we change the CIDR range or regions, the information would be programmatically
    generated to consider those changes.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your Ansible playbooks, anything you can do to have your playbook
    adapt to user input or change dynamically is considered a best practice as it
    not only simplifies the information your consumers need to know but also makes
    the code reusable.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the task is populated using mostly static variables, so less interesting
    than what we have just covered.
  prefs: []
  type: TYPE_NORMAL
- en: This is then repeated for the second web subnet and the two subnets used with
    Amazon RDS – all we do is increment the numbers being passed to `ansible.utils.ipsubnet`
    and `zones.availability_zones`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the subnets have been defined, we create an internet gateway using `amazon.aws.ec2_vpc_igw`.
    Following that, we create a route table to take advantage of the gateway using
    `amazon.aws.ec2_vpc_route_table`.
  prefs: []
  type: TYPE_NORMAL
- en: This is attached to the two web subnets and forwards all outgoing traffic to
    our internet gateway.
  prefs: []
  type: TYPE_NORMAL
- en: The next batch of tasks creates three security groups using the `amazon.aws.ec2_security_group`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The first of the three security groups will be assigned to the admin/web EC2
    instances and the elastic load balancer. It opens ports `80` and `22` to the world,
    making them publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: For ease of use, I am opening port `22` to the world. In your production deployments,
    you should not do this and lock access down to one or more trusted IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The next two security groups will be attached to the Amazon RDS and EFS services.
  prefs: []
  type: TYPE_NORMAL
- en: However, rather than defining source IP range(s), we are passing in the ID of
    the first security group we created, which means that ports `3306` (MySQL) and
    `2049` (NFS) will only be access to resources, which in our case is going to be
    the admin and web EC2 instances. The first security group attached will be able
    to access those services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final two tasks configure and launch the application load balancer. The
    first of the following two tasks is shown here and creates an empty ELB target
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: On the face of it, there does not appear to be anything too special about that,
    so why have I called it out?
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there is no module for creating an ELB target group
    using the `amazon.aws` collection; so instead, we have switched to using the `community.aws`
    collection. The developers use this collection as a staging ground for new features,
    and we will bounce between these two collections throughout the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: As modules may be promoted from being hosted in the `community.aws` collection
    to the `amazon.aws` collection in the future, please refer to the code in the
    GitHub repository that accompanies this book for the most recent updates.
  prefs: []
  type: TYPE_NORMAL
- en: The final task of the role is to create the application load balancer. Here,
    we use the `amazon.aws.elb_application_lb` module and several output registers
    we have created so far in the playbook run.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes all the tasks we need to run to deploy the underlying network
    and supporting services. Now that we have those resources in place, we can deploy
    the storage for our WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS Storage role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a simple role that contains a single task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it uses the `community.aws.efs` module to create the Amazon
    EFS share, creating a target endpoint in our two web subnets. This step is important
    as EFS has a different DNS endpoint in each availability zone, so without this,
    we would be unable to connect to the NFS share in both of our web subnets.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS Database role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we launch our EC2 instances, we need to have the MySQL Amazon RDS instance
    ready. This role contains two tasks – the first of which creates an RDS subnet
    group using the `amazon.aws.rds_subnet_group` module. Once we have the subnet
    group, the `amazon.aws.rds_instance` module is then used to create the RDS instance
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t much to this role, but we now have an Amazon RDS instance and can
    start deploying our EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS VM Admin role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, we will deploy a single instance using a `cloud-init` script to bootstrap
    our WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables that we are going to be using for both this role and the next,
    which configures the ASG-managed EC2 instances, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first task that we will perform is generating a temporary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will render the template file in `templates/vm-cloud-init-admin.yml.j2`
    and place the rendered contents in the temporary file we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `cloud-init` file prepared, we can move on to the next step: figure
    out the ID of the **Amazon Machine Image** (**AMI**) we need to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As the AMI’s maintainer, **Canonical**, which also develops Ubuntu, keeps the
    AMI up to date with patches and so on, a long list of AMIs will be returned as
    there are multiple versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task sorts that list and takes the last item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, we are using the `sort` function
    to sort the list, which is JSON, by the `creation_date` attribute and then taking
    the `last` result. This leaves us with the details of the most recent AMI that
    Canonical has published.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have everything we need to launch our admin EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most all the information needed to deploy the instance is a
    variable, either a hardcoded one, such as `instance_type`, or one that is an output
    variable, like the one for `image_id`, which is the one we just gathered the information
    for.
  prefs: []
  type: TYPE_NORMAL
- en: For `user_data`, we are using the `lookup` function to read the contents of
    the temporary file we populated with the `cloud-init` script, which we will talk
    about in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an EC2 instance, we need to register it in the ELB target group
    we created in the Network role, but we can only do this if the instance has a
    state of `running`.
  prefs: []
  type: TYPE_NORMAL
- en: Our Ansible playbook can progress a little too quickly, and the instance may
    not yet have entered that state, so we need to create a bit of logic that will
    pause the playbook execution and wait for the instance to have the correct state
    before progressing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The task itself is quite simple; it uses the `amazon.aws.ec2_instance_info`
    module to gather information on the EC2 instance we have just launched.
  prefs: []
  type: TYPE_NORMAL
- en: On its own, this task would be pretty useless as it would gather the information
    once and then move on. The three lines at the end are bits that add the logic
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `until` function, we take our output register, `admin_ec2_instance_state`,
    and check whether `state.name` is equal to `running`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `state.name` variable does not equal `running`, then retry 50 times
    every 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Continue until `state.name` equals `running`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this condition is met, we know it will be safe to move on to the next
    task, and we won’t get any errors because the state of the instance is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we now have our admin EC2 instance running and registered with the ELB
    target group and the `cloud-init` script running. Well, sort of – we need to make
    a few adjustments to the `cloud-init` script from when we last looked at it in
    [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft Azure*.
    Most of it is as we used it when deploying to Azure, with one additional piece
    of logic we needed to build in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, there is a change to the line
    that mounts the NFS share provided by the Amazon EFS service – why have we needed
    to make this change?
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, back when we launched the Amazon EFS service, we talked about
    the unique DNS endpoints being registered automatically in each subnet. To get
    around having to build the logic into our deployment to figure out which availability
    zone we are running our instances in so we can use the right DNS name for our
    Amazon EFS endpoint, a generic endpoint, `CNAME`, is created, which resolves to
    the appropriate endpoint for the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Great, you might be thinking that that saves us the hassle of having to code
    something to take this into account – and you would be correct, but it can take
    a while for this DNS alias to propagate.
  prefs: []
  type: TYPE_NORMAL
- en: As the `cloud-init` script is running completely independently of our Ansible
    playbook run, we can’t use a conditional like the one that we just discussed for
    waiting, for instance, to have the correct state before progressing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get around this, we are adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the Bash equivalent of the condition we added before. It will run the
    netcat (`nc`) command to see whether `somedns.domain.com` is responding on port
    `2049`. If it isn’t, it will wait for two seconds using the `sleep` command and
    then repeat until we get the correct response.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed that we are using another Ansible function to get
    the details on the Amazon EFS endpoint from our output register.
  prefs: []
  type: TYPE_NORMAL
- en: By default, if we were to just use `{{ efs.efs.filesystem_address }}`, it would
    return the fully qualified domain name for our Amazon EFS endpoint with the filesystem
    path appended to the end of it, which in our case is `:/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a valid address for the `nc` command to use, so we need to remove
    the `:/` from the address. To do this, we can use Ansible’s `regex_replace` function,
    as we want to remove everything that isn’t a regular character, dot, or hyphen.
    Then, this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code should leave us with, for example, `somedns.domain.com` rather than
    `somedns.domain.com:/`.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the script remains intact. We also must use the same logic as previously
    for the cut-down version of the `cloud-init` script being used for the web EC2
    instances being deployed using the ASG, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS ASG role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This role follows a similar pattern to the AWS VM Admin role, starting with
    generating the `cloud-init` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to create a launch configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this uses the `community.aws.autoscaling_launch_config` module
    as there is currently no official support in the `amazon.aws` collection for the
    creation of launch configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final task in the role, and also the final one where we will target AWS
    directly, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This creates the ASG, which will immediately start to launch however many instances
    we have defined in the `{{ ec2.asg.desired_capacity }}` variable.
  prefs: []
  type: TYPE_NORMAL
- en: All values are again filled using hardcoded variables like the one we just mentioned
    or output registers.
  prefs: []
  type: TYPE_NORMAL
- en: The Output role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All that is left now is to print some information to the terminal containing
    the URL we need to open to visit our WordPress installation and the credentials
    needed to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our Ansible playbook, so let’s look at executing it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Ansible playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command to run the playbook is the same as we used in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to* *Microsoft Azure*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once finished, you should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The last few lines of the playbook run output](img/Figure_5.04_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The last few lines of the playbook run output
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were watching the output, you might have noticed where we put in the
    logic to wait for the admin EC2 instances to enter the `running` state. Those
    lines can be found in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Waiting for the instance to have a state of running](img/Figure_5.05_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Waiting for the instance to have a state of running
  prefs: []
  type: TYPE_NORMAL
- en: You can now follow the URL in the output and take a look at your WordPress installation.
    It should look like the Azure installation did in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, and the AWS resources in the AWS Management Console
    at [http://console.aws.amazon.com](http://console.aws.amazon.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are finished looking around, you can terminate all of the resources
    launched by the playbook by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that a lot more is happening, as seen in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Deleting all of the resources](img/Figure_5.06_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Deleting all of the resources
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there are nearly 20 tasks compared to the small handful when we ran
    the same playbook in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to Microsoft Azure*; why is that?
  prefs: []
  type: TYPE_NORMAL
- en: This is another difference between Microsoft Azure and AWS. When we deployed
    the resources in Microsoft Azure, we deployed them to a single resource group,
    which acts as a logical container for your workload, collecting all its resources
    together.
  prefs: []
  type: TYPE_NORMAL
- en: When we came to terminate our Microsoft Azure deployment, we had to remove the
    resource group and all the resources contained within it in a single task.
  prefs: []
  type: TYPE_NORMAL
- en: However, AWS is very different, and we need to build a playbook to terminate
    the resources in the reverse order in which we deployed them.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the tasks used in the `destroy.yml` file reuse a little of the logic
    we used in the roles to deploy the resources, so before we look at using Terraform
    in AWS, let’s quickly discuss the `destroy.yml` playbook, starting with the Auto
    Scaling group which will remove the instances we have launched.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Scaling group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three tasks that deal with removing the ASG; the first task uses the
    `amazon.aws.autoscaling_group_info` module to get information on the ASG.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second task uses the `amazon.aws.autoscaling_group` module with just enough
    configuration to allow us to set `state` to `absent` – but only when there are
    more than 0 results returned from the previous task. To do this, we use the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This means that the task will be skipped if the ASG has been removed, but we
    need to rerun the playbook because of another failed task. We will be using this
    logic throughout this playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The final of the three tasks removes the launch configuration using the `community.aws.autoscaling_launch_config`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: EC2 instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just the two tasks are required here, one that uses `amazon.aws.ec2_instance_info`
    to get information on our EC2 instances, and the second that uses `amazon.aws.ec2_instance`
    to set `state` to `absent` if the first task returns a result.
  prefs: []
  type: TYPE_NORMAL
- en: RDS instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three tasks here. The first gets information, the second terminates
    the RDS instance, and the third removes the RDS subnet group.
  prefs: []
  type: TYPE_NORMAL
- en: EFS instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just a single task is required here; it uses `community.aws.efs` to ensure that
    any resources matching `{{ efs_name }}` in the region defined by `{{ region }}`
    are absent.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic load balancer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we have two more simple tasks that use `amazon.aws.elb_application_lb`
    and `community.aws.elb_target_group` to set our `state` resource to `absent`.
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remember, when we added the security groups, we used the ID of the Web
    security group to allow access to the RDS and EFS resources. Also, as we discussed
    when launching the EC2 instance, the Ansible playbook can sometimes be a little
    ahead of the AWS API when it comes to completing tasks, meaning that Ansible could
    be trying to move on to the next task before AWS has completed processing an earlier
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, there is the risk that either the RDS or EFS security group
    may not be fully removed before the playbook attempts to remove the web security
    group, which would result in a dependency error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, we have a little checking built into the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are using `with_items` to loop through our three security
    groups and set their `state` to `absent`. We also have an `until` set, which will
    repeat whichever part of the loop fails until it has successfully removed the
    security group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Setting the state of the security groups to absent](img/Figure_5.07_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Setting the state of the security groups to absent
  prefs: []
  type: TYPE_NORMAL
- en: It will allow for 25 failures and will try every 10 seconds. As you can see
    from the preceding screenshot, it should only fail once or twice before moving
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Private Cloud
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The remaining tasks all work in the same pattern as we defined previously, apart
    from the route table. Like other resources, we use a module, `amazon.aws.ec2_vpc_route_table_info`
    in this case, to get information on the route tables. However, the difference
    here is that it will return the default route table, which was created when we
    first launched the VPC. This one will error if we try to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this, we have to extend the `when` clause in the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this will remove the route table if there are more than zero
    of them listed and it is not the `main` association. This looks something like
    the following when run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Removing our custom route table but skipping the main one](img/Figure_5.08_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Removing our custom route table but skipping the main one
  prefs: []
  type: TYPE_NORMAL
- en: The remaining tasks follow the same patterns we used elsewhere in the chapter
    when we launched the resources.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Remember to make sure that all the resources have been removed by checking to
    see whether they are still listed in the AWS Management Console at [http://console.aws.amazon.com](http://console.aws.amazon.com),
    as you could incur unexpected costs if the preceding playbook failed for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: That is the end of the playbook, which removes the resources and concludes our
    deep dive into running Ansible on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to move on to Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform – reviewing the code and deploying our infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we did a deep dive into Terraform in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, we aren’t going to dig too deep into the code
    here, and instead will just highlight any considerations we need to make when
    targeting AWS or if there is a function we didn’t use when deploying our workload
    to Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Walk-through of Terraform files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What follows is a walk-through of each of the Terraform files. Just as we did
    for Microsoft Azure, I have grouped each logical group of resources in its own
    `.``tf` file.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is not too dissimilar to the one we defined for Azure. There are a few
    obvious differences – the biggest of which is that we are using the AWS provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we are hardcoding the region we want to launch our resources in as a
    provider configuration option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are a few omissions in that we are not loading any helper providers or
    modules to assist us with resource naming; that is going to be up to us to define
    as we launch our resources.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several tasks here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resource "aws_vpc" "vpc"`, which launches the VPC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_subnet" "web01"`, which adds the `web01` subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_subnet" "web02"`, which adds the `web02` subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_subnet" "rds01"`, which adds the `rds01` subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_subnet" "rds02"`, which adds the `rds02` subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The four subnet tasks all look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is a slight difference in the way we are defining the
    CIDR range for each subnet; rather than hardcode it as we did for Microsoft Azure,
    we are following a similar pattern as we did when using Ansible and are using
    a Terraform function called `cidrsubnet` to generate the correct CIDR range for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: The only other to note is that we are taking the list of `default_tags` we are
    defining in our `tfvars` file and merging it with a map we are dynamically creating
    using the `tomap` function. This map name contains the `Name` tag. We will be
    reusing this approach throughout the remainder of the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining tasks are very similar to the ones we performed when deploying
    using Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resource "aws_internet_gateway" "vpc_igw"`, which deploys an internet gateway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_route_table" "vpc_igw_route"`, which adds a route table to route
    all outgoing traffic to the internet gateway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_route_table_association" "rta_subnet_public01"`, which associates
    the route table we just created with the `web01` subnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_route_table_association" "rta_subnet_public02"`, which associates
    the route table we just created with the `web02` subnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_security_group" "sg_vms"`, which creates a security group opening
    ports `80` and `22` to everyone, that is, `0.0.0.0/0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_security_group" "sg_efs"`, which adds the EFS security group
    opening port `2049` to any resource with the web security group attached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_security_group" "sg_rds"`, which creates the RDS security group
    opening port `3306` to any resource with the web security group attached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_lb" "lb"`, which creates an elastic load balancer with a type
    of `application`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_lb_target_group" "front_end"`, which creates the target group
    we will be registering our EC2 instances with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_lb_listener" "front_end"`, which configures the frontend listener
    for port `80` on the elastic load balancer. When we launched our workload using
    Ansible, this was defined in line when creating the ELB resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is all the network resources we need to launch and configure to support
    the remaining services for our workload. Now we can start defining the resources
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three tasks in this file, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resource "aws_efs_file_system" "efs"`, which creates the Amazon EFS volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_efs_mount_target" "efs_mount_targets01"`, which creates the
    mount target in the `web01` subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_efs_mount_target" "efs_mount_targets02"`, which creates the
    mount target in the `web02` subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that our storage is in place, we can move into the Amazon RDS instance.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again, we have just three tasks defined here to configure and launch our Amazon
    RDS instance. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resource "aws_db_subnet_group" "database"`, which creates the subnet group
    so that our Amazon RDS instance is accessible from within our VPC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "random_password" "database_password"`, which randomly generates
    the password we will be using when launching the Amazon RDS service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource "aws_db_instance" "database"`, which deploys the Amazon RDS instance
    into the subnet group we defined and configures it per the variables we have defined
    in the `variables` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you already know, as we are following the steps we took when launching the
    workload with Ansible, it is now time to launch the Admin EC2 instance and bootstrap
    WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machine (admin)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, we need to find the right AMI to use. This slightly differs from
    how we achieved this using Ansible, as Terraform can pick the latest one for us
    as part of the task execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are setting the `most_recent` key to be the value of the
    `var.ami_most_recent` variable, which by default is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we launch the EC2 instance, we have one last bit of housekeeping to
    do, and that is to create the WordPress admin password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have everything we need to launch our EC2 instance. To start, we define
    the basics needed to launch the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the task is where the user data is defined. More on that in
    a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the tags, which include the resource name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using a similar logic to when we launched the workload
    in Microsoft Azure when injecting `user_data` by using the `templatefile` function.
    However, we are not having to Base64 encode it this time around.
  prefs: []
  type: TYPE_NORMAL
- en: The template for the `cloud-init` file contains the same changes we made when
    launching the workload using Ansible, again using `nc` to check that the DNS endpoint
    for the NFS share is responding on port `2048` before mounting the volume. The
    only other differences are related to the templating functions between the two
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final task, like Ansible, is to register the newly launched EC2 instance
    with our ELB target group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The final difference between using Terraform and Ansible is that we do not have
    to build the logic to wait for the EC2 instance to have a state of `running` in
    our code, as Terraform continues to poll the state of the EC2 instance until it
    is as desired – which by default is `running`.
  prefs: []
  type: TYPE_NORMAL
- en: Any dependencies on the EC2 task, like our `"aws_lb_target_group_attachment"
    "admin"` task, will not error as the Ansible deployment did because the deployment
    won’t progress until the state is met.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Scaling group (web)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with Ansible, the final set of AWS resources we will launch is the ASG for
    the web servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we start with a launch configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Like when we deployed in Microsoft Azure, the only variable we needed to pass
    into the template file was the DNS endpoint for the Amazon EFS endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the launch configuration is in place, we can create the ASG, which
    will immediately launch the number of EC2 instances we have defined in the `var.min_number_of_web_servers`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With that task in place, we have everything needed to launch the workload, apart
    from the output, which tells us how to access WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three outputs defined here – one of which is being marked as `sensitive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will give you the URL you can use to access your WordPress site, along
    with the username and password. Now we can run our Terraform script.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To deploy the environment, we simply need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Answering `yes` when prompted after running `terraform apply` will proceed
    with the deployment, and once complete, you should see something like the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Deploying the environment using Terraform](img/Figure_5.09_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Deploying the environment using Terraform
  prefs: []
  type: TYPE_NORMAL
- en: Again, like we did when deploying to Microsoft Azure, running `terraform output
    -json` will show the content of the `sensitive` value, meaning you can browse
    and log in to WordPress and review the resources in the AWS Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have finished, you just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will remove all the resources that we created using the `terraform apply`
    command. As always, double-check in the AWS Management Console that all of the
    resources have been removed correctly, as you do not want to incur any unexpected
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have done a deep dive into using Ansible to deploy our WordPress
    environment in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing what our deployment looks like, we walked through the Ansible
    playbook and expanded on the quick overview that we had in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*. We discussed Ansible roles and how to bootstrap
    one using the `ansible-galaxy` `init` command.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed some of the built-in functions and utilities, such as `ipsubnet`,
    `sort`, and `regex_replace`, which we used to manipulate hardcoded and output
    variables. We also covered a few different approaches for building logic into
    our playbook tasks using functions such as `until` to make sure that our playbook
    does not error both when launching the resources and, just as importantly, when
    terminating resources. After all, we don’t want stray resources hanging around
    and costing money.
  prefs: []
  type: TYPE_NORMAL
- en: We then took a quick look at how we would deploy the same resources using Terraform,
    as we had already done a deeper dive into Terraform, highlighting some additional
    approaches we can take when deploying resources.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout both walk-throughs, we also discussed the differences in the approach
    we needed to take to deploy our workload in AWS as opposed to Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play around with both the Ansible and Terraform code; for example,
    try and update the number of servers being launched, update the various SKUs,
    change the network addressing, and so on, and see what effects your changes have
    on the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will expand on what we have covered in this chapter
    and [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft Azure*,
    by looking further at how the two cloud-agnostic tools we have been looking at
    work and what considerations we need to make when approaching the cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: We will also examine how we can make our Ansible and Terraform code more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more details on the services and documentation we have mentioned
    in this chapter at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon services:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon ELB: [https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon EC2: [https://aws.amazon.com/ec2/](https://aws.amazon.com/ec2/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon EFS: [https://aws.amazon.com/efs/](https://aws.amazon.com/efs/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon RDS: https://aws.amazon.com/rds/'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon VPC: [https://aws.amazon.com/vpc/](https://aws.amazon.com/vpc/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon EC2 ASGs: [https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html](https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible collections:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon AWS collection: [https://galaxy.ansible.com/amazon/aws](https://galaxy.ansible.com/amazon/aws)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Community AWS collection: [https://galaxy.ansible.com/community/aws](https://galaxy.ansible.com/community/aws)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform provider:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HashiCorp AWS: [https://registry.terraform.io/providers/hashicorp/aws/](https://registry.terraform.io/providers/hashicorp/aws/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
