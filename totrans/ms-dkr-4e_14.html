<html><head></head><body><div><div><p id="_idParaDest-264" class="chapter-number"><a id="_idTextAnchor787"/><em class="italic">Chapter 14</em></p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor788"/>Docker Security</h1>
			<p><a id="_idTextAnchor789"/><a id="_idTextAnchor790"/><a id="_idTextAnchor791"/><a id="_idTextAnchor792"/>In this chapter, we will take a look at Docker security, a topic at the forefront of everyone's mind these days. We will split the chapter up into the following five sections:</p>
			<ul>
				<li>Container considerations</li>
				<li>Docker commands</li>
				<li>Best practices</li>
				<li>The Docker Bench security "applications"</li>
				<li>Third-party security services</li>
			</ul>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor793"/>Technical requirements</h1>
			<p>In this chapter, we will be using Docker Desktop, and w<a id="_idTextAnchor794"/><a id="_idTextAnchor795"/>e will be using <a id="_idTextAnchor796"/><a id="_idTextAnchor797"/>Multipass to launch a Docker host that we will then launch some poorly configured container on. As in the previous chapters, I will be using my preferred operating system, which is macOS.</p>
			<p>As previously, the Docker commands that we will run will work on all three of the operating systems that we have installed Docker on so far. However, some of the supporting commands, which will be few and far between, may only apply to macOS and Linux-based operating systems.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3m8ubVd">https://bit.ly/3m8ubVd</a></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor798"/>Container considerations</h1>
			<p>When Docker was first released, there was a lot of talk about Docker versus <a id="_idTextAnchor799"/><a id="_idIndexMarker997"/>virtual machines. I remember reading articles in magazines, commenting on threads on Reddit, and reading endless blog posts. In the early days of the Docker alpha and beta versions, people used to approach Docker containers like virtual machines, because there weren't really any other points of reference, and we viewed them as tiny VMs.</p>
			<p>In the past, I would enable SSH, run multiple processes in containers, and even create my container images by launching a container and running the commands to install my software stack. We discussed in <a href="B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Container Images</em>, that you should never install, configure, and export SSH on your containers as it is regarded as a bad practice as Docker provides ways for you to access your containers without having to use SSH.</p>
			<p>So, rather <a id="_idIndexMarker998"/>than discussing containers versus virtual machines, let's look at some of the considerations that you need to make when running containers, rather than virtual machines.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor800"/>The advantages</h2>
			<p>When you<a id="_idIndexMarker999"/> start a Docker container, Docker Engine does a lot of work behind the scenes. One of the tasks that Docker Engine performs when launching your containers is setting up namespaces and control groups. What does that mean? By setting up namespaces, Docker keeps the processes isolated in each container, not only from other containers but also from the host system. The control groups ensure that each container gets its own share of items, such as CPU, memory, and disk <code>I/O</code>. More importantly, they ensure that one container doesn't exhaust all of the resources on a given Docker host.</p>
			<p>As we saw in <a href="B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 4</em></a><em class="italic">, Managing Containers</em>, being able to launch your containers in a Docker controlled network means that you can isolate your containers at the application level; all of the containers for Application A will not have any access, at the network layer, to the containers for Application B.</p>
			<p>Additionally, this network isolation can run on a single Docker host by using the default network driver, or it can span multiple Docker hosts by using Docker Swarm's built-in, multi-host networking driver, or the Weave Net driver from Weave.</p>
			<p>Lastly, what I consider one of the most significant advantages of Docker over a typical virtual machine is that you shouldn't have to log in to the container. Docker is trying its hardest to keep you from needing to log in to a container to manage the process that it is running. With commands such as <code>docker container exec</code>, <code>docker container top</code>, <code>docker container logs</code>, and <code>docker container stats</code>, you can do everything that you need to do, without exposing any more services than you have to.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor801"/>Your Docker hosts</h2>
			<p>When you are dealing with virtual machines, you can control who has access to which virtual machine. Let's <a id="_idIndexMarker1000"/>suppose that you only want <strong class="bold">User 1</strong>, who is a developer, to have access to the development VMs.</p>
			<p>However, <strong class="bold">User 2</strong> is an operator who is responsible for both the development and production environments, so they need access to all of the VMs. Most virtual machine management tools allow you to grant role-based access to your VMs.</p>
			<p>With Docker, you are at a slight disadvantage because everyone who has access to Docker Engine on your host, either through being granted sudo access or by having their user added to the Docker Linux group, will have access to every Docker container that you are running on that host. </p>
			<p>They can run new containers, they can stop existing containers, and they can delete images as well. Be careful to whom you grant permission to access Docker Engine on your hosts. They mostly hold the keys to the kingdom, concerning all of your containers. Knowing this, it is recommended to use Docker hosts only for Docker; keep other services separate from your Docker hosts.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor802"/>Image trust</h2>
			<p>If <a id="_idIndexMarker1001"/>you are running virtual machines, you will most likely be setting them up yourself, from scratch. It's likely that, due to the size of the download (and also the effort in launching it), you will not download a prebuilt machine image that some random person on the internet created. Typically, if you were to do this, it would be a prebuilt virtual appliance from a trusted software vendor.</p>
			<p>So, you will be aware of what is inside the virtual machine and what isn't, as you were responsible for building and maintaining it.</p>
			<p>Part of the appeal of Docker is its ease of use; however, this ease of use can make it easy to ignore a quite crucial security consideration – do you know what it is running inside your container?</p>
			<p>We have already touched upon image trust in earlier chapters. For example, we spoke about not publishing or downloading images that haven't been defined using Dockerfiles, and not embedding custom code or secrets (and so on) directly into an image that you will be pushing to Docker Hub.</p>
			<p>While containers have the protection of namespaces, control groups, and network isolation, we discussed how a poorly judged image download could introduce security concerns and risk into your environment. For example, a legitimate container running an unpatched piece of software can add risk to the availability of your application and data.</p>
			<p>Now that we have covered some basic principles, let's take a look at the Docker commands that can be used to help tighten up security, as well as to view information about the images that you might be using.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor803"/>Docker commands</h1>
			<p>There are two commands <a id="_idIndexMarker1002"/>that we will be looking at. The first will be the <code>docker container run</code> command so that you can see some of the items that you can use to your advantage with this command. Secondly, we will take a look at the <code>docker container diff</code> command, which you can use to view what has been done with the image that you are planning to use.</p>
			<p>Let's take a look at how we can use these two commands to help secure our containers.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor804"/>The Docker Run command</h2>
			<p>With respect<a id="_idIndexMarker1003"/> to the <code>docker run</code> command, we will mainly focus on the option that allows you to set everything inside the container as read-only, instead of a specified directory or volume. This helps to limit the amount of damage that can be caused by malicious "applications" that could also hijack a vulnerable application by updating its binaries.</p>
			<p>Let's take a look at how to launch a read-only container, and then break down what it does, as follows:</p>
			<pre>$ docker container run -d --name mysql --read-only -v /
var/lib/mysql -v /tmp -v /var/run/mysqld -e MYSQL_ROOT_
PASSWORD=password mysql</pre>
			<p>Here, we are running a MySQL container and setting the entire container as read-only, except for the following folders:</p>
			<ul>
				<li><code>/var/lib/mysql</code></li>
				<li><code>/var/run/mysqld</code></li>
				<li><code>/tmp</code></li>
			</ul>
			<p>These will be created as three separate volumes, and then mounted as read/write. If you do not add these volumes, then MySQL will not be able to start, as it needs read/write access to be able to create the socket file in <code>/var/run/mysqld</code>, some temporary files in <code>/tmp</code>, and finally, the databases themselves, in <code>/var/lib/mysql</code>.</p>
			<p>Any other location inside the container won't allow you to write anything in it. If you tried to run the following, it would fail:</p>
			<pre>$ docker container exec mysql touch /trying_to_write_a_file</pre>
			<p>The preceding command would give you the following message:</p>
			<pre>touch: cannot touch '/trying_to_write_a_file': Read-only file 
system</pre>
			<p>This can be extremely helpful if you want to control where the containers can write to (or not write to). Be sure to use this wisely. Test thoroughly, as there can be consequences when "applications" can't write to certain locations.</p>
			<p>Similar to the previous command, with <code>docker container run</code>, where we set everything to read-only (except for a specified volume), we can do the opposite and set just a single volume (or more, if you use more <code>-v</code> switches) to read-only. </p>
			<p>The thing to <a id="_idIndexMarker1004"/>remember about volumes is that when you use a volume and mount it in a container, it will mount as an empty volume over the top of the directory inside the container, unless you use the <code>--volumes-from</code> switch or add data to the container in some other way after it has been launched; for example, you could use something like the following command (which will not work):</p>
			<pre>$ docker container run -d -v /local/path/to/html/:/var/www/
html/:ro nginx</pre>
			<p>This will mount <code>/local/path/to/html/</code> from the Docker host to <code>/var/www/html/</code> and will set it to read-only. This can be useful if you don't want a running container to write to a volume, to keep the data or configuration files intact.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor805"/>The docker diff command</h2>
			<p>Let's take<a id="_idIndexMarker1005"/> another look at the <code>docker diff</code> command; since it relates to the security aspects of containers, you may want to use the images that are hosted on Docker Hub or other related repositories.</p>
			<p>Remember that whoever has access to your Docker host and the Docker daemon has access to all of your running Docker containers. That being said, if you don't have monitoring in place, someone could be executing commands against your containers and doing malicious things.</p>
			<p>Let's take a look at the MySQL container that we launched in the previous section:</p>
			<pre>$ docker container diff mysql</pre>
			<p>You will notice that no files are returned. Why is that?</p>
			<p>Well, the <code>docker diff</code> command tells you the changes that have been made to the image since the container was launched. In the previous section, we launched the MySQL container with the image read-only and then mounted volumes to where we knew MySQL would need to be able to read and write – meaning that there are no file differences between the image that we downloaded and the container that we are running.</p>
			<p>Stop and remove <a id="_idIndexMarker1006"/>the MySQL container, then prune the volumes by running the following:</p>
			<pre>$ docker container stop mysql
$ docker container rm mysql
$ docker volume prune</pre>
			<p>Then, launch the same container again, minus the read-only flag and volumes; this gives us a different story, as follows:</p>
			<pre>$ docker container run -d --name mysql -e MYSQL_ROOT_
PASSWORD=password mysql
$ docker container exec mysql touch /trying_to_write_a_file
$ docker container diff mysql</pre>
			<p>As you can see, there were two folders created, and several files added:</p>
			<pre>C /run
C /run/mysqld
A /run/mysqld/mysqld.pid
A /run/mysqld/mysqld.sock
A /run/mysqld/mysqld.sock.lock
A /run/mysqld/mysqlx.sock
A /run/mysqld/mysqlx.sock.lock
A /trying_to_write_a_file</pre>
			<p>This is a great way to spot anything untoward or unexpected that may be going on within your container. Now that we have looked at how we can launch our containers more securely, let's discuss some of the other best practices we can apply.</p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor806"/>Best practices</h1>
			<p>In this section, we will look at best practices when it comes to Docker. Some of these we have already mentioned in previous chapters. We will then discuss the <strong class="bold">Center for Internet Security</strong> guide, which documents how to properly secure all aspects of your Docker environment.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor807"/>Docker best practices</h2>
			<p>Before we dive into the <a id="_idIndexMarker1007"/>Center for Internet<a id="_idIndexMarker1008"/> Security guide, let's go over some of the best practices for using Docker, as follows:</p>
			<ul>
				<li><strong class="bold">Only launch one application per container</strong>: Docker was built for this, and it makes everything easier, at the end of the day. The isolation that we discussed earlier is where this is key.</li>
				<li><strong class="bold">Only install what you need</strong>: As we already covered in previous chapters, if you have to install more services to support the one process your container should be running, I would recommend that you review the reasons why. This not only keeps your images small and portable, but it also reduces the potential attack surface.</li>
				<li><strong class="bold">Review who has access to your Docker hosts</strong>: Remember, whoever has root or sudo access to your Docker hosts has access to manipulate all of the images and running containers on the host, as well the ability to launch new ones.</li>
				<li><strong class="bold">Always use the latest version of Docker</strong>: This will ensure that all security holes have been patched and that you have the latest features as well. While fixing security issues, keeping up to date using the community version may introduce problems caused by changes in functionality or new features. If this is a concern for you, then you might want to look at the LTS Enterprise versions available from Docker.</li>
				<li><strong class="bold">Use the resources available if you need help</strong>: The Docker community is huge and immensely helpful. Use their website, documentation, and the Slack chat rooms<a id="_idIndexMarker1009"/> to your advantage <a id="_idIndexMarker1010"/>when planning your Docker environment and assessing platforms. For more information on how to access Slack and other parts of the community, see <a href="B15659_16_Final_JM_ePub.xhtml#_idTextAnchor922"><em class="italic">Chapter 16</em></a>, <em class="italic">Next Steps with Docker</em>.</li>
			</ul>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor808"/>The Center for Internet Security benchmark</h2>
			<p>The Center for Internet Security (CIS) is an<a id="_idIndexMarker1011"/> independent, non-profit organization whose goal is to provide a secure online experience. They publish benchmarks and controls that are considered best practices for all aspects of IT.</p>
			<p>The CIS benchmark for Docker is available for download, for free. You should note that it is currently a 257-page PDF, released under the Creative Commons license, and it covers Docker CE 18.09 and later.</p>
			<p>You will be referring to this guide when you actually run the scan (in the next section of this chapter) and get results back as to what needs to (or should be) fixed. The guide is broken down into the following sections:</p>
			<ul>
				<li><strong class="bold">Host configuration</strong>: This part of the guide is about the configuration of your Docker hosts. This is the part of the Docker environment where all your containers run. Thus, keeping it secure is of the utmost importance. This is the first line of defense against attackers.</li>
				<li><strong class="bold">Docker daemon configuration</strong>: This part of the guide has the recommendations that secure the running Docker daemon. Everything that you do to the Docker daemon configuration affects each and every container. These are the switches that you can attach to the Docker daemon that we saw previously, and to the items you will see in the next section when we run through the tool.</li>
				<li><strong class="bold">Docker daemon configuration files</strong>: This part of the guide deals with the files and directories that the Docker daemon uses. This ranges from permissions to ownership. Sometimes, these areas may contain information that you don't want others to know about, which could be in a plain text format.</li>
				<li><strong class="bold">Container images/runtime and build files</strong>: This part of the guide contains both the information for securing the container images and the build files. The first part contains images, covering base images, and the build files that were used. As we<a id="_idIndexMarker1012"/> covered previously, you need to be sure about the images that you are using, not only for your base images, but for any aspect of your Docker experience. This section of the guide covers the items that you should follow while creating your own base images.</li>
				<li><strong class="bold">Container runtime</strong>: This section was previously a part of a later section, but it has been moved into its own section in the CIS guide. The container runtime covers a lot of security-related items. Be careful with the runtime variables that you are using. In some cases, attackers can use them to their advantage, when you think you are using them to your own advantage. Exposing too much in your containers, such as exposing application secrets and database connections as environment variables, can compromise the security of not only your container but the Docker host and the other containers running on that host.</li>
				<li><strong class="bold">Docker security operations</strong>: This part of the guide covers the security areas that involve deployment; the items are more closely tied to Docker best practices. Because of this, it is best to follow these recommendations.</li>
			</ul>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor809"/>The Docker Bench Security application</h1>
			<p>In this section, we will <a id="_idIndexMarker1013"/>cover the Docker Bench Security application that you can install and run. The tool will inspect the following:</p>
			<ul>
				<li>The host configuration</li>
				<li>The Docker daemon configuration files</li>
				<li>Container images and build files</li>
				<li>The container runtime</li>
				<li>The Docker security operations Docker Swarm configuration</li>
			</ul>
			<p>Looks familiar? It should, as these are the same items that we reviewed in the previous section, only built into an application that will do a lot of the heavy lifting for you. It will show you what warnings arise within your configurations and will provide information on other configuration items, and even the items that have passed the test.</p>
			<p>Now, we will look at how to run the tool, a live example, and what the output of the process means.</p>
			<h3>Running the tool on Docker for macOS and Docker for Windows</h3>
			<p>Running the tool <a id="_idIndexMarker1014"/>is simple. It's already <a id="_idIndexMarker1015"/>been packaged for us, inside a Docker container. While you can get the source code and customize the output or manipulate it in some way (say, emailing the output), the default may be all that you need.</p>
			<p>The tool's GitHub project can be found at <a href="https://github.com/docker/docker-bench-security/">https://github.com/docker/docker-bench-security/</a>, and to run the tool on a macOS or Windows machine, you simply have to copy and paste the following into your Terminal. The following command is missing the line needed to check <code>systemd</code>, as Moby Linux, which is the underlying operating system for Docker for macOS and Docker for Windows, does not run <code>systemd</code>. We will look at a <code>systemd</code>-basedsystem when we run the container on an Ubuntu Docker host:</p>
			<pre>docker container run -it --net host --pid host \
	--cap-add audit_control \
	-e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
	-v /var/lib:/var/lib \
	-v /var/run/docker.sock:/var/run/docker.sock \
	-v /etc:/etc \
	--label docker_bench_security \
	docker/docker-bench-security</pre>
			<p>Once the image<a id="_idIndexMarker1016"/> has been downloaded, it will<a id="_idIndexMarker1017"/> launch and immediately start to audit your Docker host, printing the results as it goes, as shown in the following screenshot:</p>
			<div><div><img src="img/image_00_0014.jpg" alt="Figure 14.1 – Running a Docker Bench Security check&#13;&#10;" width="1254" height="821"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – Running a Docker Bench Security check</p>
			<p>As you can see, there are a few warnings <strong class="bold">[WARN]</strong>, as well as notes <strong class="bold">[NOTE]</strong> and information <strong class="bold">[INFO]</strong>; however, as this host is managed by Docker, as you would expect, there is not too much to worry about.</p>
			<h3>Running on Ubuntu Linux</h3>
			<p>Before we look into <a id="_idIndexMarker1018"/>the output of the audit in a little more detail, I am going to launch a vanilla Ubuntu server using <code>multipass</code> and perform a clean installation of Docker using the official installer by running the following commands:</p>
			<pre>$ multipass launch --name docker-host
$ multipass exec docker-host -- /bin/bash -c 'curl -s https://
get.docker.com | sh - &amp;&amp; sudo usermod <a id="_idTextAnchor810"/><a id="_idTextAnchor811"/>-aG docker ubuntu'
$ multipass shell docker-host</pre>
			<p>Once installed, I will launch a few containers, all of which don't have very sensible settings. I will launch the following two containers from Docker Hub:</p>
			<pre>$ docker container run -d --name root-nginx -v /:/mnt nginx
$ docker container run -d --name priv-nginx --privileged=true 
nginx</pre>
			<p>Then, I will build a custom image, based on Ubuntu 16.04, that runs SSH using the following <code>Dockerfile</code>:</p>
			<pre>FROM ubuntu:16.04
RUN apt-get update &amp;&amp; apt-get install -y openssh-server
RUN mkdir /var/run/sshd
RUN echo 'root:screencast' | chpasswd
RUN sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin
 yes/' /etc/ssh/sshd_config
RUN sed 's@session\s*required\s*pam_loginuid.so@session 
optional pam_loginuid.so@g' -i /etc/pam.d/sshd
ENV NOTVISIBLE 'in users profile'
RUN echo 'export VISIBLE=now' &gt;&gt; /etc/profile
EXPOSE 22
CMD ['/usr/sbin/sshd', '-D']</pre>
			<p>I will build and launch the preceding Dockerfile using the following commands: </p>
			<pre>$ docker image build --tag sshd .
$ docker container run -d -P --name sshd sshd</pre>
			<p>As you can see, in one image, we are mounting the root filesystem of our host with full read/write access in the <code>root-nginx</code> container. We are also running with extended privileges in <code>priv-nginx</code>, and <a id="_idIndexMarker1019"/>finally, running SSH in <code>sshd</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Please do run the previous Dockerfile or containers outside of this test; we are purposely launching containers that ignore best practices to get results from the scan.</p>
			<p>To start the audit on our Ubuntu Docker host, I ran the following:</p>
			<pre>$ docker container run -it --net host --pid host \
    --cap-add audit_control \
    -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
    -v /var/lib:/var/lib \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v /usr/lib/systemd:/usr/lib/systemd \
    -v /etc:/etc --label docker_bench_security \
    docker/docker-bench-security</pre>
			<p>As we are running on an operating system that supports <code>systemd</code>, we are mounting <code>/usr/lib/systemd</code> so that we can audit it.</p>
			<p>There is a lot of output and a lot to digest, but what does it all mean? Let's take a look and break down each section.</p>
			<h3>Understanding the output</h3>
			<p>There are four types of<a id="_idIndexMarker1020"/> output that we will see, as follows:</p>
			<ul>
				<li><code>[PASS]</code>: These items are solid and good to go. They don't need any attention but are good to read, to make you feel warm inside. The more of these, the better!</li>
				<li><code>[WARN]</code>: These are those items that need to be fixed. These are the items that we don't want to see.</li>
				<li><code>[INFO]</code>: These are items that you should review and fix if you feel they are pertinent to your setup and security needs.</li>
				<li><code>[NOTE]</code>: These give best-practice advice.</li>
			</ul>
			<p>As mentioned, there are seven main sections that are covered in the audit, as follows:</p>
			<ul>
				<li>Host configuration</li>
				<li>Docker daemon configuration</li>
				<li>Docker daemon configuration files</li>
				<li>Container images and build files</li>
				<li>The container runtime</li>
				<li>Docker security operations</li>
				<li>Docker Swarm configuration</li>
			</ul>
			<p>Let's take a look at what we see in each section of the scan. These scan results are from a default Ubuntu Docker host, with no tweaks made to the system at this point. We want to focus on the <code>[WARN]</code> items in each section.</p>
			<p>Other warnings may come up when you run yours, but these will be the ones that come up for most people (if not for everyone) at first.</p>
			<h4>Host configuration</h4>
			<p>I had five<a id="_idIndexMarker1021"/> items with a <code>[WARN]</code> status for my host configuration, as follows:</p>
			<pre>[WARN] 1.1  - Ensure a separate partition for containers has
 been created</pre>
			<p>By default, Docker uses <code>/var/lib/docker</code> on the host machine to store all of its files, including all images, containers, and volumes created by the default driver. This means that this folder may grow quickly. As my host machine is running a single partition (and depending on what your containers are doing), this could potentially fill the entire drive, which would render my host machine unusable:</p>
			<pre>[WARN] 1.5  - Ensure auditing is configured for the Docker 
daemon
[WARN] 1.6  - Ensure auditing is configured for Docker files 
and directories - /var/lib/docker
[WARN] 1.7  - Ensure auditing is configured for Docker files 
and directories - /etc/docker
[WARN] 1.10  - Ensure auditing is configured for Docker files 
and directories - /etc/default/docker</pre>
			<p>These warnings are being flagged because <code>auditd</code> is not installed, and there are no audit rules for the Docker daemon and associated files; for more <a id="_idIndexMarker1022"/>information on <code>auditd</code>, see the blog post at <a href="https://www.linux.com/topic/desktop/customized-file-monitoring-auditd/">https://www.linux.com/topic/desktop/customized-file-monitoring-auditd/</a>.</p>
			<h4>Docker daemon configuration</h4>
			<p>My Docker <a id="_idIndexMarker1023"/>daemon configuration flagged up seven <code>[WARN]</code> statuses, as follows:</p>
			<pre>[WARN] 2.1  - Ensure network traffic is restricted between 
containers on the default bridge</pre>
			<p>By default, Docker allows traffic to pass between containers unrestricted, on the same host. It is possible to change this behavior; for more information<a id="_idIndexMarker1024"/> on Docker networking, see <a href="https://docs.docker.com/network/">https://docs.docker.com/network/</a>:</p>
			<pre>[WARN] 2.8  - Enable user namespace support</pre>
			<p>By default, the user namespace is not remapped. Mapping them, while possible, can currently cause issues with several Docker features; see <a href="https://docs.docker.com/engine/reference/commandline/dockerd/">https://docs.docker.com/engine/reference/commandline/dockerd/</a> for more details on known restrictions:</p>
			<pre>[WARN] 2.11  - Ensure that authorization for Docker client commands is enabled</pre>
			<p>A default installation of Docker allows unrestricted access to the Docker daemon; you can limit access to authenticated users by enabling an authorization plugin. For more details, see <a href="https://docs.docker.com/engine/extend/plugins_authorization/">https://docs.docker.com/engine/extend/plugins_authorization/</a>:</p>
			<pre>[WARN] 2.12  - Ensure centralized and remote logging is configured</pre>
			<p>As I am only running a <a id="_idIndexMarker1025"/>single host, I am not using a service such as <code>rsyslog</code> to ship my Docker host's logs to a central server, nor have I configured a log driver on my Docker daemon; see <a href="https://docs.docker.com/config/containers/logging/configure/">https://docs.docker.com/config/containers/logging/configure/</a> for more details:</p>
			<pre>[WARN] 2.14  - Ensure live restore is Enabled</pre>
			<p>The <code>--live-restore</code> flag enables full support of daemon-less containers in Docker; this means that, rather than stopping containers when the daemon shuts down, they continue to run, and it properly reconnects to the containers when restarted.</p>
			<p>It is not enabled by default, due to backward compatibility issues. For more details, see <a href="https://docs.docker.com/config/containers/live-restore/%20">https://docs.docker.com/config/containers/live-restore/</a>:</p>
			<pre>[WARN] 2.15  - Ensure Userland Proxy is Disabled</pre>
			<p>There are two ways that your containers can route to the outside world: either by using a hairpin NAT, or a userland proxy. For most installations, the hairpin NAT mode is the preferred mode, as it takes advantage of iptables and has better performance. Where this is not available, Docker uses the userland proxy. Most Docker installations on modern operating systems will support hairpin NAT. For details on how to disable the userland proxy, see <a href="https://docs.docker.com/config/containers/container-networking/">https://docs.docker.com/config/containers/container-networking/</a>:</p>
			<pre>[WARN] 2.18  - Ensure containers are restricted from acquiring 
new privileges</pre>
			<p>This stops the processes within the containers from potentially gaining any additional privileges by setting <code>suid</code> or <code>sgid</code> bits; this could limit the impact of any dangerous operations trying to access privileged binaries.</p>
			<h4>Docker daemon configuration files</h4>
			<p>I had no <code>[WARN]</code> statuses<a id="_idIndexMarker1026"/> in this section, which is to be expected, as Docker was deployed using the Docker installer.</p>
			<h4>Container images and build files</h4>
			<p>I had three <code>[WARN]</code> statuses <a id="_idIndexMarker1027"/>for container images and<a id="_idIndexMarker1028"/> build files; you may notice that multi-line warnings are prefixed with <code>*</code> after the status:</p>
			<pre>[WARN] 4.1  - Ensure a user for the container has been created
[WARN]      * Running as root: sshd
[WARN]      * Running as root: priv-nginx
[WARN]      * Running as root: root-nginx</pre>
			<p>The processes in the containers that I am running are all running as the root user; this is the default action of most containers. For more information, see <a href="https://docs.docker.com/engine/security/security/">https://docs.docker.com/engine/security/security/</a>:</p>
			<pre>[WARN] 4.5  - Ensure Content trust for Docker is Enabled</pre>
			<p>Enabling Content Trust for Docker ensures the provenance of the container images that you are pulling, as they are digitally signed when you push them; this means that you are always running the images that you intended to run. For more information on Content Trust, see <a href="https://docs.docker.com/engine/security/trust/content_trust/">https://docs.docker.com/engine/security/trust/content_trust/</a>:</p>
			<pre>[WARN] 4.6  - Ensure HEALTHCHECK instructions have been added 
to the container image
[WARN]      * No Healthcheck found: [sshd:latest]
[WARN]      * No Healthcheck found: [nginx:latest]
[WARN]      * No Healthcheck found: [ubuntu:16.04]</pre>
			<p>When building your image, it is possible to build in a <code>HEALTHCHECK</code>; this ensures that when a container launches from your image, Docker will periodically check the status of your container and, if needed, it will restart or relaunch it. More details can be found at <a href="https://docs.docker.com/engine/reference/builder/#healthcheck">https://docs.docker.com/engine/reference/builder/#healthcheck</a>.</p>
			<h4>The container runtime</h4>
			<p>As we were a little <a id="_idIndexMarker1029"/>silly when launching our containers on the Docker host that we audited, we know that there will be a lot of vulnerabilities here, and there are 11 of them altogether:</p>
			<pre>[WARN] 5.2  - Ensure SELinux security options are set, if 
applicable
[WARN]      * No SecurityOptions Found: sshd
[WARN]      * No SecurityOptions Found: root-nginx</pre>
			<p>The preceding vulnerability is a false positive – we are not running SELinux, as it is an Ubuntu machine, and SELinux is only applicable to Red Hat-based machines. Instead, 5.1 shows us the result, which is a <code>[PASS]</code>, which we want:</p>
			<pre>[PASS] 5.1 - Ensure AppArmor Profile is Enabled</pre>
			<p>The next <code>[WARN]</code> status is of our own making, as follows:</p>
			<pre>[WARN] 5.4  - Ensure privileged containers are not used
[WARN]      * Container running in Privileged mode: priv-nginx</pre>
			<p>The following is also of our own making:</p>
			<pre>[WARN] 5.6  - Ensure ssh is not run within containers
[WARN]      * Container running sshd: sshd</pre>
			<p>These can be safely ignored; it should be very rare that you have to launch a container running in <code>Privileged mode</code>. It is only if your container needs to interact with Docker Engine running on your Docker host; for example, when you are running a GUI (such as Portainer), which we covered in <a href="B15659_09_Final_JM_ePub.xhtml#_idTextAnchor261"><em class="italic">Chapter 9</em></a>, <em class="italic">Portainer – A GUI for Docker</em>.</p>
			<p>We have also discussed that you should not be running SSH in your containers. There are a few use cases, such as running a jump host within a certain network; however, these should be the exception.</p>
			<p>The next two <code>[WARN]</code> statuses are flagged because, by default on Docker, all running containers on your Docker hosts share the resources equally; setting limits on memory and the CPU priority for your containers will ensure that the containers that you want to have a higher priority are not starved of resources by lower-priority containers:</p>
			<pre>[WARN] 5.10  - Ensure memory usage for container is limited
[WARN]      * Container running without memory restrictions: 
sshd
[WARN]      * Container running without memory restrictions: 
priv-nginx
[WARN]      * Container running without memory restrictions: 
root-nginx
[WARN] 5.11  - Ensure CPU priority is set appropriately on the 
container
[WARN]      * Container running without CPU restrictions: sshd
[WARN]      * Container running without CPU restrictions: priv-
nginx
[WARN]      * Container running without CPU restrictions: root-
nginx</pre>
			<p>As we already discussed earlier in the chapter, if possible, you should be launching your containers as read-only, and<a id="_idIndexMarker1030"/> mounting volumes for where you know your process needs to write data to:</p>
			<pre>[WARN] 5.12  - Ensure the container's root filesystem is 
mounted as read only
[WARN]      * Container running with root FS mounted R/W: sshd
[WARN]      * Container running with root FS mounted R/W: priv-
nginx
[WARN]      * Container running with root FS mounted R/W: root-
nginx</pre>
			<p>The reason the following flags are raised is that we are not telling Docker to bind our exposed port to a specific IP address on the Docker host:</p>
			<pre>[WARN] 5.13  - Ensure incoming container traffic is binded to a 
specific host interface
[WARN]      * Port being bound to wildcard IP: 0.0.0.0 in sshd</pre>
			<p>As my test Docker host only has a single NIC, this isn't too much of a problem. However, if my Docker host had multiple interfaces, then this container would be exposed to all of the networks, which could be a problem if I had, for example, an external and internal network. See <a href="https://docs.docker.com/network/">https://docs.docker.com/network/</a> for more details:</p>
			<pre>[WARN] 5.14  - Ensure 'on-failure' container restart policy is 
set to '5'
[WARN]      * MaximumRetryCount is not set to 5: sshd
[WARN]      * MaximumRetryCount is not set to 5: priv-nginx
[WARN]      * MaximumRetryCount is not set to 5: root-nginx</pre>
			<p>Although I haven't launched my containers using the <code>--restart</code> flag, there is no default value for <code>MaximumRetryCount</code>. This means that if a container failed over and over, it would quite happily sit there attempting to restart. This could have a negative effect on the Docker host; adding a <code>MaximumRetryCount</code> of <code>5</code> will mean that the container will attempt to restart five times before giving up:</p>
			<pre>[WARN] 5.25  - Ensure the container is restricted from 
acquiring additional privileges
[WARN]      * Privileges not restricted: sshd
[WARN]      * Privileges not restricted: priv-nginx
[WARN]      * Privileges not restricted: root-nginx</pre>
			<p>By default, Docker does <a id="_idIndexMarker1031"/>not put a restriction on a process or its child processes gaining new privileges via <code>suid</code> or <code>sgid</code> bits. To find out details on how you can stop this behavior, see <a href="https://www.projectatomic.io/blog/2016/03/no-new-privs-docker/">https://www.projectatomic.io/blog/2016/03/no-new-privs-docker/</a>:</p>
			<pre>[WARN] 5.26  - Ensure container health is checked at runtime
[WARN]      * Health check not set: sshd
[WARN]      * Health check not set: priv-nginx
[WARN]      * Health check not set: root-nginx</pre>
			<p>Again, we are not using any health checks, meaning that Docker will not periodically check the status of your containers. To see the GitHub issue for the pull request that introduced this feature, see <a href="https://github.com/moby/moby/pull/22719">https://github.com/moby/moby/pull/22719</a>:</p>
			<pre>[WARN] 5.28  - Ensure PIDs cgroup limit is used
[WARN]      * PIDs limit not set: sshd
[WARN]      * PIDs limit not set: priv-nginx
[WARN]      * PIDs limit not set: root-nginx</pre>
			<p>Potentially, an attacker could trigger a fork bomb with a single command inside your container. This has the potential to crash your Docker host, and the only way to recover would be to reboot the host. You can protect against this by using the <code>--pids-limit</code> flag. For more information, see the pull request at <a href="https://github.com/moby/moby/pull/18697">https://github.com/moby/moby/pull/18697</a>.</p>
			<h4>Docker security operations</h4>
			<p>This <a id="_idIndexMarker1032"/>section includes <code>[INFO]</code> about best practices, as follows:</p>
			<pre>[INFO] 6.1  - Avoid image sprawl
[INFO]      * There are currently: 4 images
[INFO] 6.2  - Avoid container sprawl
[INFO]      * There are currently a total of 4 containers, with 
4 of them currently running</pre>
			<h4>Docker Swarm configuration</h4>
			<p>This section<a id="_idIndexMarker1033"/> includes <code>[PASS]</code> information, as we don't have Docker Swarm enabled on the host.</p>
			<h3>Removing the Multipass machine</h3>
			<p>Once you have<a id="_idIndexMarker1034"/> finished with the Ubuntu server, you can remove it by running the following:</p>
			<pre>$ multipass delete docker-host –purge</pre>
			<p>Remember, there is no warning when running the preceding command; it will delete the running machine straight away.</p>
			<h3>Summing up Docker Bench</h3>
			<p>As you have seen, running<a id="_idIndexMarker1035"/> Docker Bench against your Docker host is a much better way to get an understanding of how your Docker host stacks up against the CIS Docker Benchmark; it is certainly a lot more manageable than manually working through every single test in the 257-page document.</p>
			<p>Now that we have covered how you can assess and secure your Docker host, let's quickly discuss how we can secure images.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor812"/>Third-party security services</h1>
			<p>Before we finish this chapter, we are going to take a look at some of the third-party services available to help you with the vulnerability assessment of your images.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor813"/>Quay</h2>
			<p>Quay, an image<a id="_idIndexMarker1036"/> registry by Red Hat, is similar to Docker Hub/Registry; one<a id="_idIndexMarker1037"/> difference is that Quay actually performs a security scan of each image after it is pushed/built.</p>
			<p>You can see the results of the scan by viewing the <strong class="bold">Repository Tags</strong> for your chosen image. Here you will see a column for <strong class="bold">Security Scan</strong>. As you can see in the following screenshot, in the example image that we created, there are no problems:</p>
			<div><div><img src="img/image_00_0024.jpg" alt="Figure 14.2 – A passed security scan on Quay&#13;&#10;" width="851" height="431"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 – A passed security scan on Quay</p>
			<p>Clicking on <strong class="bold">Passed</strong> will take you to a more detailed breakdown of any vulnerabilities that have been detected within the image. As there are no vulnerabilities at the moment (which is a good thing), this screen does not tell us much. However, clicking on the <strong class="bold">Packages</strong> icon in the left-hand menu will present us with a list of the packages that the scan has discovered. </p>
			<p>For our test image, it has found 34 packages with no vulnerabilities, all of which are displayed here, along with confirmation of the version of the package, and how they were introduced to the image:</p>
			<div><div><img src="img/image_00_0034.jpg" alt="Figure 14.3 – A list of all packages installed&#13;&#10;" width="930" height="508"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 – A list of all packages installed</p>
			<p>As you can also see, Quay is <a id="_idIndexMarker1038"/>scanning our publicly available image, which is being hosted on the <a id="_idIndexMarker1039"/>free-of-charge open source plan that Quay offers. Security scanning comes as standard with all plans on Quay.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor814"/>Clair</h2>
			<p>Clair is an open<a id="_idIndexMarker1040"/> source project from Red Hat. In essence, it is a service that provides the static <a id="_idIndexMarker1041"/>analysis functionality for both the hosted version of Quay and the commercially supported, enterprise version.</p>
			<p>It works by creating a local mirror of the following vulnerability databases:</p>
			<ul>
				<li>Debian <a id="_idIndexMarker1042"/>Security Bug Tracker: <a href="https://security-tracker.debian.org/tracker/">https://security-tracker.debian.org/tracker/</a> </li>
				<li>Ubuntu<a id="_idIndexMarker1043"/> CVE Tracker: <a href="https://launchpad.net/ubuntu-cve-tracker/%20">https://launchpad.net/ubuntu-cve-tracker/ </a></li>
				<li>Red Hat <a id="_idIndexMarker1044"/>Security Data: <a href="https://www.redhat.com/security/data/metrics/">https://www.redhat.com/security/data/metrics/</a> </li>
				<li>Oracle Linux<a id="_idIndexMarker1045"/> Security Data: <a href="https://linux.oracle.com/security/">https://linux.oracle.com/security/</a> </li>
				<li>Alpine<a id="_idIndexMarker1046"/> SecDB: <a href="https://git.alpinelinux.org/cgit/alpine-secdb/">https://git.alpinelinux.org/cgit/alpine-secdb/</a> </li>
				<li>NIST<a id="_idIndexMarker1047"/> NVD: <a href="https://nvd.nist.gov/">https://nvd.nist.gov/</a></li>
			</ul>
			<p>Once it has mirrored the data sources, it mounts the image's filesystem, and then performs a scan of the installed packages, comparing them to the signatures in the preceding data sources.</p>
			<p>Clair is not <a id="_idIndexMarker1048"/>a straightforward service; it only has an API-driven interface, and there are no fancy web-based or command-line tools that ship with Clair by default. The documentation for the API can be found at <a href="https://app.swaggerhub.com/apis/coreos/clair/3.0">https://app.swaggerhub.com/apis/coreos/clair/3.0</a>.</p>
			<p>The installation instructions can be found at the project's GitHub page, at <a href="https://github.com/quay/clair/">https://github.com/quay/clair/</a>. </p>
			<p>Also, you can find a list of tools that support Clair on its integration page, at <a href="https://github.com/quay/clair/blob/master/Documentation/integrations.md">https://github.com/quay/clair/blob/master/Documentation/integrations.md</a>.</p>
			<p>Before we finish, there is one more tool to look at, and this is one we can run locally.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor815"/>Anchore</h2>
			<p>The final tool that we<a id="_idIndexMarker1049"/> are going to cover is Anchore. This comes in several versions; there are<a id="_idIndexMarker1050"/> cloud-based offerings and an "on-premises" enterprise version, both of which come with a full, web-based graphical interface. There is a version that hooks into Jenkins, and also the open source command-line scanner, which is what we are going to take a look at now.</p>
			<p>This version is distributed as a Docker Compose file, so we will start by creating the folders that we need, and we will also download the Docker Compose file:</p>
			<pre>$ mkdir anchore
$ cd anchore
$ curl https://docs.anchore.com/current/docs/engine/quickstart/
docker-compose.yaml -o docker-compose.yaml</pre>
			<p>Now that we have the basics in place, you can pull the images and start the containers, as follows:</p>
			<pre>$ docker-compose pull
$ docker-compose up -d</pre>
			<p>Before we can interact with our Anchore deployment, we need the command-line client. Luckily, the Docker Compose file we downloaded comes with a container running the client configured out of the box:</p>
			<pre>$ docker-compose exec api anchore-cli system status</pre>
			<p>This will show you the <a id="_idIndexMarker1051"/>overall status of your installation; it might take a minute or two from when you first launched for everything to show as up and running:</p>
			<div><div><img src="img/image_00_0044.jpg" alt="Figure 14.4 – Checking the status of the Anchore engine&#13;&#10;" width="944" height="336"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4 – Checking the status of the Anchore engine</p>
			<p>The next command <a id="_idIndexMarker1052"/>shows you where Anchore is in the database sync:</p>
			<pre>$ docker-compose exec api anchore-cli system feeds list</pre>
			<p>As you can see in the following screenshot, my installation is currently syncing the databases. This process can take up to a few hours; however, for our example, we are going to be scanning an Alpine Linux-based database, which are the first databases to be downloaded:</p>
			<div><div><img src="img/image_00_0054.jpg" alt=" Figure 14.5 – Checking the status of the feed download&#13;&#10;" width="948" height="336"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 14.5 – Checking the status of the feed download</p>
			<p>Next up, we have to grab an image to scan; let's grab an older image, as follows:</p>
			<pre>$ docker-compose exec api anchore-cli image add russmckendrick/
moby-counter:old</pre>
			<p>It will take a minute or two<a id="_idIndexMarker1053"/> to run its initial scan; you can check the status by running the following command:</p>
			<pre>$ docker-compose exec api anchore-cli image list</pre>
			<p>After a while, the status <a id="_idIndexMarker1054"/>should change from <strong class="bold">analyzing</strong> to <strong class="bold">analyzed</strong>:</p>
			<pre>$ docker-compose exec api anchore-cli image add russmckendrick/
moby-counter:old</pre>
			<p>This will show you an overview of the image, as follows:</p>
			<div><div><img src="img/image_00_0064.jpg" alt="Figure 14.6 – Viewing information on the analyzed image&#13;&#10;" width="1116" height="469"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 14.6 – Viewing information on the analyzed image</p>
			<p>You can then view a list of problems (if there are any) by running the following command:</p>
			<pre>$ docker-compose exec api anchore-cli image vuln 
russmckendrick/moby-counter:old os</pre>
			<p>As you can see in the following screenshot, each package that is listed has the current version, a link to the CVE issue, and also<a id="_idIndexMarker1055"/> confirmation of the version number that fixes the reported issue:</p>
			<div><div><img src="img/image_00_0074.jpg" alt=" Figure 14.7 – Reviewing the vulnerabilities found by Anchore&#13;&#10;" width="1184" height="474"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 14.7 – Reviewing the vulnerabilities found by Anchore</p>
			<p>You can use the following<a id="_idIndexMarker1056"/> commands to <a id="_idTextAnchor816"/><a id="_idTextAnchor817"/>remove the Anchore con<a id="_idTextAnchor818"/><a id="_idTextAnchor819"/>tainers and database volume:</p>
			<pre>$ docker-compose stop
$ docker-compose rm
$ docker volume rm anchore_anchore-db-volume</pre>
			<p>Also, don't forget to remove the <code>anchore</code> folder we created at the start of the section.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor820"/>Summary</h1>
			<p>In this chapter, we covered some aspects of Docker security. First, we took a look at some of the things that you must consider when running containers (versus typical virtual machines) with regard to security. We looked at the advantages and your Docker host, and then we discussed image trust. We then took a look at the Docker commands that we can use for security purposes.</p>
			<p>We launched a read-only container so that we could minimize any potential damage an intruder could do within our running containers. As not all "applications" lend themselves to running in read-only containers, we then looked at how we can track changes that have been made to the image since it was launched. It is always useful to be able to easily discover any changes that were made on the filesystem at runtime when trying to look into any problems.</p>
			<p>Next, we discussed the Center for Internet Security guidelines for Docker. This guide will assist you in setting up multiple aspects of your Docker environment. Lastly, we took a look at Docker Bench Security. We looked at how to get it up and running, and we ran through an example of what the output would look like. We then analyzed the output to see what it meant. Remember the seven items that the application covered: the host configuration, the Docker daemon configuration, the Docker daemon configuration files, the container images and build files, the container runtime, the Docker security operations, and the Docker Swarm configuration.</p>
			<p>In the next chapter, we will look at how Docker can fit into your existing workflows, as well as some new ways to approach working with containers.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor821"/>Questions</h1>
			<ol>
				<li>When launching a container, how can we make all of it, or parts of it, read-only?</li>
				<li>How many processes should you be running per container?</li>
				<li>What is the best way to check your Docker installation against the CIS Docker benchmark?</li>
				<li>When running the Docker Bench Security application, what should be mounted?</li>
				<li>True or false: Quay only supports image scanning for private images</li>
			</ol>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor822"/>Further reading</h1>
			<p>For more information, visit the website at <a href="https://www.cisecurity.org/">https://www.cisecurity.org/</a>. The Docker Benchmark can be found at <a href="https://www.cisecurity.org/benchmark/docker/">https://www.cisecurity.org/benchmark/docker/</a>.</p>
		</div>
	</div>



  </body></html>