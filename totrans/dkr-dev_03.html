<html><head></head><body>
		<div><h1 id="_idParaDest-28"><em class="italic"><a id="_idTextAnchor028"/>Chapter 2</em>: Using VirtualBox and Docker Containers for Development</h1>
			<p>In the previous chapter, we introduced virtualization and containerization. In this chapter, we'll demonstrate how you can use software such as VirtualBox to create virtual machines and we'll use Docker to create containers. The focus of this chapter will be on using these technologies for development on your workstation.</p>
			<p>A common problem among developers who work on multiple projects is that, over time, they end up with a lot of software installed on their workstations that they don't currently use. This can be so problematic that the developer might reformat their workstation's hard drive<a id="_idTextAnchor029"/> and reinstall the operating system.</p>
			<p>Both VirtualBox and Docker containers can be used to resolve this problem. The software you install stays within either the <strong class="bold">virtual machine's</strong> or the container's filesystem and is separate from the workstation's native filesystem. If you delete a virtual machine or container, all the files installed therein are removed – including any applications or development software that was installed.</p>
			<p>Another problem that arises for developers is the version of software required to work on a specific project. If the developer is working on one project that uses Node.js v12 and another that uses Node.js v10, they can't really run both projects on the workstation at the same time and switching between versions of Node.js is doable, but ugly. This is a non-issue with virtual machines or containers – you can have one virtual machine with Node.js v12 and another with Node.js v10 and run both virtual machines at the same time. It is similar with two containers, one for each version of Node.js.</p>
			<p>Virtualization is very useful when you need to model an entire machine. If your production systems are virtual machines or physical machines, a virtual machine is a good way to emulate that environment. Virtualization is terrific for running a complete alternate operating system on the workstation; that is, you can run Windows 10 in a virtual machine on a macOS or Linux workstation.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Host filesystem pollution problem</li>
				<li>Using VirtualBox for virtual machines</li>
				<li>Using Docker containers</li>
			</ul>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>The code for this chapter can be downloaded from: <a href="https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2">https://github.com/PacktPublishing/Docker-for-Developers/tree/master/chapter2</a></p>
			<p>Check out the following video to see the Code in Action:</p>
			<p><a href="https://bit.ly/3gX9dFE">https://bit.ly/3gX9dFE</a></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor031"/>Host filesystem pollution problem</h1>
			<p>Both virtualization and containerization solve certain problems developers face. There's no real point in installing <a id="_idIndexMarker041"/>server-style software systems on your workstation – that kind of software can be installed in a virtual machine or a Docker container. Using this strategy means you don't have to pollute your workstation's filesystem, you won't have software version conflicts, and you can run a different operating system than the one your workstation runs.</p>
			<p>The pollution problem is a real concern for developers – they end up with a lot of cruft, or installed software, that they don't use day to day, but that take up system resources. We will learn to use virtualization or containerization to install that software in a way that isn't installed on your host's filesystem.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor032"/>Using VirtualBox for virtual machines</h1>
			<p>There are several <a id="_idIndexMarker042"/>options for running virtual machines on your workstation. These include Parallels (for macOS), KVM/QEMU (for Linux), VMware (commercial for several host operating systems), and VirtualBox (an Oracle product). We'll use VirtualBox because it is open source and free to use. It's also portable in the sense that you can run VirtualBox and your virtual machines on Linux, Windows, macOS, and other host operating systems.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor033"/>Introduction to virtualization</h2>
			<p>Virtualization uses special <a id="_idIndexMarker043"/>instructions and features of your workstation's CPU to run a generic pseudo-computer system (virtual machine) on your host. Within this virtual machine, you can install a wide range of operating systems, including various versions of Windows Server, Linux, BSD, and so on. The operating system running in a <a id="_idIndexMarker044"/>virtual machine is called the guest operating system; the operating system running on your workstation <a id="_idIndexMarker045"/>is called the host operating system.</p>
			<p>As the guest operating system executes code, it will be required to perform disk and network access, execute privileged CPU instructions, and otherwise access shared resources with the host. The virtualization software effectively traps these guest operating system accesses and translates them into host operating system calls. Thus, code running in the virtual machine is mostly running at full native CPU speed until these shared access traps are executed – then there is some overhead for the translation to host accesses.</p>
			<p>The guest virtual machines may be configured before you install an operating system within. You can set how much RAM to use, one or more virtual disks, one or more Ethernet controllers, a graphics card, an ISO file (installation media) to insert in the virtual CD-ROM drive, and so on. </p>
			<p>You typically set RAM, disk space, and the number of virtual CPU cores to appropriate values for your guest <a id="_idIndexMarker046"/>operating system and the apps you intend to use within the guest. For example, if you are going to run Windows in a virtual machine, you might want to give it at least 2 virtual CPU cores and 8 gigabytes of RAM and 32 gigabytes of disk space. If you are going to run an application in the virtual machine that needs more than 8 gigabytes of memory, you would want to assign more RAM; if the app needs a lot of disk space, you would assign more disk space.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor034"/>Creating a virtual machine</h2>
			<p>To boot the virtual <a id="_idIndexMarker047"/>machine, use the VirtualBox program (user interface). When the virtual machine boots, it acts just like a physical PC – as far as the installer on the installation media is concerned, it is a physical PC. The installer will work as if you were installing on a new PC or reinstalling on your PC.</p>
			<p>A virtual machine may present its console or desktop within a window on your workstation's desktop, or it can be <strong class="bold">headless</strong>. A headless <a id="_idIndexMarker048"/>virtual machine is similar to a server machine – you access it via FTP, SSH, and so on. You would use a headless virtual machine when you have no use for the operating system console or graphical interface. The headless machine provides all the services of a server you would remotely access.</p>
			<p>You start a headless virtual machine from the command line instead of the VirtualBox user interface program. This is <a id="_idIndexMarker049"/>done via the <code>VBoxManage</code> command, which is documented here: <a href="https://www.virtualbox.org/manual/ch08.html">https://www.virtualbox.org/manual/ch08.html</a>. It is more likely that you will be using a guest operating system with a graphical user interface, though.</p>
			<p>A typical headless virtual machine might be used to run a <strong class="bold">LAMP</strong> application—<strong class="bold">Linux, Apache, MySQL, and PHP</strong> all contained neatly within the virtual machine and not within the filesystem of your workstation. You can model a scalable LAMP application by starting a headless virtual machine that runs MySQL and two headless virtual machines that run the HTTP server and the PHP code.</p>
			<p>A typical graphics/desktop virtual machine might be used to run Windows in a window on your Mac computer, to run Linux in a window on your Mac computer, to run Linux in a window on your Windows machine, and so on. If you like to use Linux, but you need to run Windows programs, doing it in a virtual machine is a good way to go.</p>
			<p>A non-headless install will have a few display options. The entire desktop can be displayed in a window <a id="_idIndexMarker050"/>on your host's desktop. This is the default display mode. The window can be resized like any other window on the desktop. However, within the interior of the window, the guest's desktop will not resize to fit until you install the VirtualBox guest additions in the guest.</p>
			<p>The guest window can be made full screen. This makes the guest look like it's the operating system running native on the workstation. If you are running macOS, you can switch desktops using the macOS gestures and go back and forth between full-screen Windows and full-screen macOS desktops.</p>
			<p>For some host operating systems, the guest can be put into seamless mode, where the desktop is not displayed at all, but any applications running in the virtual machine render their windows on top of the host desktop.</p>
			<p>The result is a mixture of virtual machine application windows and your host operating system application menus on your desktop, as shown in the following screenshot:</p>
			<div><div><img src="img/B11641_02_001.jpg" alt="Figure 2.1 – Microsoft Windows 10 running fullscreen in VirtualBox on a Linux host"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Microsoft Windows 10 running fullscreen in VirtualBox on a Linux host</p>
			<p>As you can see, you may run and manage a full Windows installation on your workstation within a virtual machine. You can access the files and directories on your host if you set up Samba for file sharing on the host.</p>
			<p>Incidentally, portions of this book were written using Microsoft Word 365, running in a Windows 10 virtual <a id="_idIndexMarker051"/>machine on a Linux host. The Docker examples that follow were executed on the Linux host. This is a great example of why you would run a virtual machine.</p>
			<p class="callout-heading">Note:</p>
			<p class="callout">Microsoft allows you to buy a Windows 10 license and use it to activate Windows 10 within a virtual machine.</p>
			<p class="callout">Apple only allows macOS to be run in a virtual machine on Apple hardware. It is a violation of their licensing terms to run macOS within a virtual machine on a PC running Windows or Linux.</p>
			<p class="callout">Linux and most BSD variants are generally free to use on a PC or within a virtual machine on a PC.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Guest additions</h2>
			<p>For Windows and Linux guest operating systems, you can install drivers that fully integrate the guest and host operating systems. These drivers are known as guest additions and you can download these from <a id="_idIndexMarker052"/>the VirtualBox site: <a href="https://virtualbox.org">https://virtualbox.org</a>. They are installed within the virtual machine as any program you install for Windows or Linux. The integration with the host is quite useful. </p>
			<p>The guest additions display <a id="_idIndexMarker053"/>drivers that allow you to use the full resolution of the host's screen and, if you're running in windowed mode (guest desktop in a host desktop window), resizing the window will cause the guest desktop to resize to fit the new window size. If you want to use the seamless windows feature, you are required to install the guest display drivers.</p>
			<p>The additions provide mouse pointer integration. This allows you to freely move the cursor between physical screens, from guest windows to host windows. Otherwise, the mouse would be captured by the virtual machine so that it can manage pointer events.</p>
			<p>The guest additions also share the host and guest clipboards as if they were one clipboard. You can select and copy text in a macOS host application and then paste that copied text into a Windows application running in the virtual machine.</p>
			<p>For Linux guests, the additions allow you to share host filesystem directories and files. This is particularly useful because you can use the host operating system tools and software to develop files seen by the host. For example, you create a shared folder on your macOS machine for your project's working directory. You can use your macOS editors to edit files in the project and, in the virtual machine, you can run Linux native compilers or tools to execute your project. Let's now begin by installing VirtualBox.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Installing VirtualBox</h2>
			<p>The URL for VirtualBox is <a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a>. There, you can find documentation and <a id="_idIndexMarker054"/>downloads for the various host platforms (workstation operating systems), add-ons, see screenshots, see recommended third-party software that works with VirtualBox, and so on.</p>
			<h3>Windows installation instructions</h3>
			<p>To install the Windows installation, go to the downloads page at the VirtualBox site, download the installer for <a id="_idIndexMarker055"/>the latest version, and then, when the download is complete, double-click on it. Then, follow the onscreen instructions.</p>
			<h3>macOS installation instructions</h3>
			<p>For macOS installation, you <a id="_idIndexMarker056"/>can use Homebrew or download the installer <code>.dmg</code> file from the VirtualBox site and install from that. To use Homebrew, you only need to enter one command:</p>
			<pre>$ brew cask install virtualbox</pre>
			<p>Homebrew (<a href="https://brew.sh/">https://brew.sh/</a>) is the missing <a id="_idIndexMarker057"/>package manager for macOS. It is a command-line system for installing software from Homebrew's repositories. It is a terrific tool for augmenting the software shipped with macOS. The software in those repositories is updated far more frequently than the Apple software updates.</p>
			<h3>Linux installation instructions</h3>
			<p>The installation <a id="_idIndexMarker058"/>instructions for VirtualBox on Linux varies depending on the Linux distribution that you use on your workstation. Since there are so many different distributions, we'll cover Ubuntu to give you an idea of what to do and provide you with helpful pointers for installing VirtualBox on other distributions (Arch Linux, Fedora, and suchlike).</p>
			<p>For Ubuntu, you can install VirtualBox from the Ubuntu Software Center, download a <code>.deb</code> file from the VirtualBox site, or use <code>apt</code>:</p>
			<pre>$ sudo apt install virtualbox</pre>
			<p>For Arch Linux <a id="_idIndexMarker059"/>and its variants, you can follow the instructions on the terrific Arch wiki at <a href="https://wiki.archlinux.org/index.php/VirtualBox">https://wiki.archlinux.org/index.php/VirtualBox</a>.</p>
			<p>For Fedora or other RPM-based Linux distributions, follow the instructions at the VirtualBox site: <a href="https://virtualbox.org">https://virtualbox.org</a>. Let's now learn how to use Docker containers.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor037"/>Using Docker containers</h1>
			<p>Docker is generally used to create containers, which run your application as if in a headless virtual machine<a id="_idIndexMarker060"/>. In fact, on host operating systems that are not Linux-based, Docker effectively runs Linux in a virtual machine and runs your containers within that virtual machine. This is done transparently.</p>
			<p class="callout-heading">Note:</p>
			<p class="callout">You don't have to install VirtualBox yourself. Docker is packaged in such a way that it will install or use any already-existing virtualization technology (for example, a hypervisor) for your operating system.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor038"/>Introduction to containers</h2>
			<p>Earlier versions of Docker installed VirtualBox to create its virtual machine, but more recent virtualization <a id="_idIndexMarker061"/>technology implemented within the operating systems allows Docker to use those technologies instead.</p>
			<p>Docker for Linux containers expects the host operating system or the virtual machine to be running Linux. The containers share the Linux kernel with the host. Docker can be used to run Windows native containers, in a similar manner to Linux containers. The Windows kernel is shared among the host and guests. For discussion purposes, we'll focus on the Linux host and guests.</p>
			<p>Docker containers are typically used to implement something like headless virtual machines. The use of virtual machines for each application you might create a container for is expensive – you must reserve a fixed amount of RAM and disk space for the virtual machine. On a 16 gigabyte RAM MacBook Pro, you can roughly fit three 4 gigabyte RAM virtual machines running at the same time. You do need to have some RAM for the host operating system to run. Starving the host or guest virtual machines of RAM will cause them to swap, which crushes performance:</p>
			<div><div><img src="img/B11641_02_002.jpg" alt="Figure 2.2 – Docker containers illustrated"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Docker containers illustrated</p>
			<p>Containers are separated from the host operating system using host operating system features. The containers use the Linux kernel's <a id="_idIndexMarker062"/>namespaces feature (<a href="https://manpages.debian.org/stretch/manpages/namespaces.7.en.html">https://manpages.debian.org/stretch/manpages/namespaces.7.en.html</a>) to separate the code running in containers from one another, and cgroups (see <a href="https://manpages.debian.org/stretch/manpages/cgroups.7.en.html">https://manpages.debian.org/stretch/manpages/cgroups.7.en.html</a>) to limit the resources that a container may use (including RAM and CPU). Containers also use the Linux <code>unionfs</code> (<a href="https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html">https://manpages.debian.org/buster/unionfs-fuse/unionfs.8.en.html</a>) filesystem <a id="_idIndexMarker063"/>to implement the layered filesystem our containers see when running under Docker.</p>
			<p>From the <a id="_idIndexMarker064"/>applications running within the container's point of view, the container is a whole and dedicated computer; there is no direct communication with the host operating system.</p>
			<p>Containers do not require the number of virtual CPUs or a dedicated block of RAM per container.</p>
			<p>You are only limited by how much RAM the containers need and how much RAM the host has.</p>
			<p>Containers share the host's Linux kernel, while virtual machines must have a whole operating system installed!</p>
			<p>You may choose to limit the resources used by a container instance, but this is not required.</p>
			<p>Host resources may be shared with the guest containers. The host's networking can be shared with any container, but this is only really needed for containers running applications that require this. For example, to use the host's Bonjour networking functionality, the guest would use the host's networking.</p>
			<p>The guest containers may expose ports to the host and any computers that can access the host. For example, a container running an HTTP server might expose port 80 and, when the host is accessed at port 80, the container responds.</p>
			<p>Containers have driven the concept of microservices. An application using microservice architecture implements a collection of services that communicate among themselves and the host. These <a id="_idIndexMarker065"/>services are meant to be trivial to implement – only the specific code required to support the service needs to be included in the program. It's not uncommon for microservices to be implemented in a single source code file with just a few lines of code.</p>
			<p>Container architecture is quite scalable. You can run multiple containers running the same application (horizontal scaling) and you can dedicate more host resources to the container system (vertical scaling). For example, you might create a container running an HTTP server; you can create a server farm by instantiating as many of these containers as you desire.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/>Using Docker for development</h2>
			<p>A great reason to use Docker for development is that you don't have to install any programs, other <a id="_idIndexMarker066"/>than Docker itself, on your host to enable development. For example, you can run Apache in a container without installing it on your workstation. </p>
			<p>You can also mix and match software versions within your containers. A microservices architecture might require one container to use Node.js version 8 and another container to use Node.js version 10. This is obviously problematic on a single host, but is straightforward when using Docker. One container installs and runs version 8, and another container installs and runs version 10.</p>
			<p>During development, you can share your project's development files with the container so that when you edit these files, the container sees that the files have changed. </p>
			<p>Each container has its own set of global environment variables. It's typical to configure the application using environment variables, rather than in source code or configuration files within the container.</p>
			<p>When you are ready to deploy or publish a container, you can push it to a container hosting service, such as Docker Hub. In fact, Docker Hub is a terrific source for already-existing containers that may aid you in your project development. There are pre-made container images for MongoDB, Node.js (various versions), Apache, and so on.</p>
			<p>Container construction is effectively object-oriented. You inherit from a base container and add the functionality you need to that. You can create a Node.js application in a container that starts with a <a id="_idIndexMarker067"/>ready-made Node.js container, install <code>npm</code> packages in the container, and run your custom code in the container.</p>
			<p>You can always develop your own base containers. For these, you can start with ready-made packages for a flavor of Linux. The Alpine Linux base container is popular because it is one of the most lightweight images to start from. There are base containers for Fedora, Ubuntu, Arch Linux, and more. Whichever of these Linux containers you start from, you can use that operating system's installation tools to add packages from the official repositories for that operating system; that is, <code>apt</code> for Ubuntu, <code>yum</code> for Fedora, and so on.</p>
			<p>It's a good idea to Dockerize an existing application that wasn't designed to run in a container. You can choose a flavor and version of Linux for the container that is compatible with the application, and you can split up the application into multiple container images to afford future scalability. </p>
			<p>For example, you might have an older LAMP application that requires specific versions of PHP, MySQL, and Apache, as well as an older version of Ubuntu. You would break this up into a distinct MySQL container, and a distinct Apache plus PHP container. You would want your Apache+PHP containers to use a shared volume so that they're all running the same and latest PHP source code. You can set up the MySQL container to use master-slave replication. You can set up a load balancer in another container that balances between as many Apache and PHP container instances as you choose.</p>
			<p>Time for a hands-on example, using Docker for development.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Getting started with Docker</h1>
			<p>We have created a GitHub repository to share code examples for this book. The repository can be found at <a href="https://github.com/PacktPublishing/Docker-for-Developers">https://github.com/PacktPublishing/Docker-for-Developers</a>. You should fork this repository, and then clone it to your host. Creating the fork means you can <a id="_idIndexMarker068"/>manage your copy of the repository as you see fit without requiring permissions. The code of interest for this section is in the <code>chapter2/</code> directory. The code here implements a small Apache+PHP application that is designed to run in a container. There are <code>sh</code> scripts to perform the Docker command lines, so you don't have to keep typing in a long string of command-line arguments.</p>
			<p>Before we get into the code, let's make sure that Docker is installed properly. The <code>docker ps</code> command prints a list of all running Docker containers. We can see we have no containers running and there is an actual <code>docker</code> command:</p>
			<pre>% docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
%</pre>
			<p>A Dockerfile is a text file <a id="_idIndexMarker069"/>that defines how to build a Docker container image. The container is not started; it is just created on disk. Once built, you can start as many instances as you wish.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Automating Docker commands via sh scripts</h2>
			<p>We're going to make heavy use of the <code>docker cli</code> command and <code>sh</code> scripts to automate <a id="_idIndexMarker070"/>command-line use. The use of <code>sh</code> script files has a few advantages. Once the script file is <a id="_idIndexMarker071"/>created, you don't have to remember what all the command-line switches to the command are. Once the script is correct, you won't have any issues due to typos or improper command-line switches. Typing the script filename is much shorter and your shell should autocomplete it when you type the first few characters of the name and hit the <em class="italic">Tab</em> key. Finally, the names of the scripts are mnemonic: <code>build.sh</code> means build the container, <code>run.sh</code> means run the container, and so on.</p>
			<p>The <code>sh</code> scripts we <a id="_idIndexMarker072"/>provide are as follows:</p>
			<ul>
				<li><code>./build.sh</code>: This builds the container <a id="_idIndexMarker073"/>from the Dockerfile. You will want to run this script whenever <a id="_idIndexMarker074"/>you edit the Dockerfile, or if the container otherwise needs to be built.</li>
				<li><code>./debug.sh</code>: This runs <a id="_idIndexMarker075"/>the container in debug mode. In debug mode, Apache is run in foreground mode <a id="_idIndexMarker076"/>and you can hit <code>^C</code> to stop the container.</li>
				<li><code>./run.sh</code>: This runs the container as a daemon. Unlike the <code>./debug.sh</code> script, you will be <a id="_idIndexMarker077"/>returned to the command-line prompt, with the <a id="_idIndexMarker078"/>container running in Docker. You will use this script to run the container locally, as if in production, so that you can test production behavior.</li>
				<li><code>./stop.sh</code>: When you have your <a id="_idIndexMarker079"/>container running in the background, this <a id="_idIndexMarker080"/>script can be used to stop it.</li>
				<li><code>./shell.sh</code>: Sometimes, when creating your container and editing the Dockerfile, things do not <a id="_idIndexMarker081"/>work as expected. You can use this script to <a id="_idIndexMarker082"/>get a Bash command line running within the container. From this command line, you can inspect and diagnose the problems.</li>
				<li><code>./persist.sh</code>: This script demonstrates using a named volume to persist the application state within the <a id="_idIndexMarker083"/>container. That is, with a named volume, you <a id="_idIndexMarker084"/>can stop and restart the container and the contents of the volume are persisted. The volume is mounted in the container as if it were a disk.</li>
			</ul>
			<p>To demonstrate how building a container using a Dockerfile works, we've created one in the GitHub repository, in the <code>chapter2/</code> directory (file named <code>Dockerfile</code>):</p>
			<pre># we will inherit from the Debian image on DockerHub FROM debian # set timezone so files' timestamps are correct ENV TZ=America/Los_Angeles # install apache and php 7.3 # we include procps and telnet so you can use these with shell.sh prompt RUN apt-get update &amp;&amp; apt-get install -y procps telnet apache2 php7.3 # add a user - this user will own the files in /home/app RUN useradd --user-group --create-home --shell /bin/false app # set up and copy files to /home/app ENV HOME=/usr/app WORKDIR /home/app COPY . /home/app # The PHP app is going to save its state in /data so we make a /data inside the container RUN mkdir /data &amp;&amp; chown -R app /data &amp;&amp; chmod 777 /data
 # we need custom php configuration file to enable userdirs COPY php.conf /etc/apache2/mods-available/php7.3.conf # enable userdir and php RUN a2enmod userdir &amp;&amp; a2enmod php7.3 # we run a script to stat the server; the array syntax makes it so ^C will work as we want CMD  ["./entrypoint.sh"]</pre>
			<p>Let's look at what <a id="_idIndexMarker085"/>the Dockerfile does, step by step:</p>
			<ol>
				<li value="1">The Dockerfile inherits from the Debian image on Docker Hub. </li>
				<li>We set the time zone for the container to match the time zone of the host; in other words, ensure that the timestamps of files inside the container and on the host match. This is important when mapping host directories to the container's filesystem.</li>
				<li>We then install Apache and PHP 7.3. These are installed in the container's filesystem and not on the host's filesystem. We have avoided the pollution problem of having a version of both installed on the host that later become unused when not working on this project.</li>
				<li>We also installed some command-line utilities that allow us to examine the state of the built container from a Bash shell running within the container.</li>
				<li>By default, the user and group that will be running the project in the container is <code>root</code>. In order to provide some typical Unix/Linux security, we want to run as an actual user; in our case, the username is <code>app</code>. So we add the user to the container's environment with <code>useradd</code>.</li>
				<li>We are going to put <a id="_idIndexMarker086"/>our PHP scripts in <code>/home/app</code>, with the ability to map our working directory with our PHP scripts on the host over <code>/home/app</code>.</li>
				<li>Our demo app writes its state to <code>/data</code>, so we need to create it and ensure that the PHP script running as a user app can read and write files there.</li>
				<li>We created a custom PHP configuration file that we want to use within the container, so we copy it to the container in the correct location in the filesystem.</li>
				<li>We need to enable the <code>userdir</code> and <code>php7.3</code> modules. This allows us to run PHP scripts from Apache as well as have our PHP scripts in <code>/home/app/public_html</code> accessed via a URL such as <code>http://localhost/~app/index.php</code>.</li>
				<li>When the container is started, it needs to run some program or script within the container. We use an <code>sh</code> script named <code>entrypoint.sh</code> in the <code>/home/app</code> directory to start the application. We can edit this file to suit our needs during development. </li>
			</ol>
			<p>We could have chosen from a variety of Linux flavors from which to start. We chose Debian here because the configuration commands should be familiar to most readers. If you install Debian in a virtual machine, you'd use the same commands to install and maintain your system. Debian isn't the smallest or most lightweight of Linux images to start from; Alpine is a great choice if you want to make your container use fewer resources. If you choose to use Alpine, be sure to read up on how to install packages and maintain the system using Alpine.</p>
			<p>Note that whichever Linux image you start from, it's sharing the Linux kernel with your host machine. Only within the container is it Debian – your host operating system can be some other Linux distribution. What you install inside the container is not installed on your workstation, only within the container. Obviously, you shouldn't mix, say, Debian commands and installed packages directly on an Arch Linux workstation.</p>
			<p>When you install Apache on an actual host or virtual machine, you configure it by using the <code>a2enmod</code> and <code>a2dismod</code> commands, as well as by editing the various configuration files in <code>/etc/apache2</code>. What we do here is edit the configuration file locally on our workstation, and then we copy that configuration file to the container.</p>
			<p>The Dockerfile installs a <a id="_idIndexMarker087"/>few Debian applications within the container using <code>apt-get</code>. The <code>RUN</code> command that spawns <code>apt-get</code> within the <a id="_idIndexMarker088"/>container uses the <code>-y</code> switch to answer <code>yes</code> to any questions <code>apt-get</code> might ask, the <code>-qq</code> switch to make the <code>apt-get</code> command less verbose, and the <code>&gt;/dev/null</code> redirection of <code>stdio</code> to make the Docker build (<code>build.sh</code>) output compact. Without the <code>-qq</code> and <code>stdout</code> redirection, the build output would contain every package and dependency downloaded, along with all the installation commands for all these packages.</p>
			<p>Note that the final line in the Dockerfile is a CMD, the command to run when the container is instantiated. In our case, we use an array with one item, <code>entrypoint.sh</code>. The array makes it so that you can hit <em class="italic">Ctrl</em> + <em class="italic">C</em> to stop the container. The <code>entrypoint.sh</code> script runs Apache in the container after performing the necessary initialization. Also note that we enabled both the <code>userdir</code> and <code>php7.3</code> modules in the Dockerfile.</p>
			<p>Now that we have a Dockerfile, we need to be able to build the container so that we can then use it. This is where the first of our <code>.sh</code> scripts comes into play.</p>
			<h3>Understanding build.sh</h3>
			<p>The <code>build.sh</code> script is used to <a id="_idIndexMarker089"/>build the container. You will need to build the container at least once so that we can edit files on the host and see the changes in action within the container. You will need to rebuild the container each time you want to try the container in production mode and have the latest versions of the files:</p>
			<pre>#!/bin/sh
 # build.sh
 # we use the "docker build" command to build a container named "chapter2" from . (current directory)# Dockerfile is found in the current directory, and determines how the conatiner is built.
 docker build -t chapter2 .</pre>
			<p>The <code>-t</code> flag says to name the container <code>chapter 2</code>. The Dockerfile is found in the current directory. The output of the <code>build.sh</code> script is lengthy, so it is omitted here.</p>
			<p>You can see that each step printed in the output while building the container corresponds to a line in the Dockerfile:</p>
			<pre>Sending build context to Docker daemon  15.87kB Step 1/11 : FROM debian  ---&gt; 67e34c1c9477 Step 2/11 : ENV TZ=America/Los_Angeles  ---&gt; Using cache  ---&gt; 7bfa02a200a8 Step 3/11 : RUN apt-get update -qq &gt;/dev/null &amp;&amp; apt-get install -y -qq procps telnet apache2 php7.3 -qq &gt;/dev/null  ---&gt; Running in 98a4e3192e22 debconf: delaying package configuration, since apt-utils is not installed Removing intermediate container 98a4e3192e22  ---&gt; 86aa2b03b3b1 Step 4/11 : RUN useradd --user-group --create-home --shell /bin/false app  ---&gt; Running in 917b16b86dc5 Removing intermediate container 917b16b86dc5  ---&gt; ef96ff367f1f Step 5/11 : ENV HOME=/usr/app  ---&gt; Running in c9706abf0afd Removing intermediate container c9706abf0afd  ---&gt; 4cc08031746b Step 6/11 : WORKDIR /home/app  ---&gt; Running in 08c2b9c79204 Removing intermediate container 08c2b9c79204  ---&gt; 9b68722d6776 Step 7/11 : COPY . /home/app  ---&gt; d6a7b4a1a4f3 Step 8/11 : RUN mkdir /data &amp;&amp; chown -R app /data &amp;&amp; chmod 777 /data  ---&gt; Running in fe824496056c Removing intermediate container fe824496056c  ---&gt; 75996f4d08bc Step 9/11 : COPY php.conf /etc/apache2/mods-available/php7.3.conf  ---&gt; c6a3b094a041 Step 10/11 : RUN a2enmod userdir &amp;&amp; a2enmod php7.3  ---&gt; Running in 1899c1d01a2e Removing intermediate container 1899c1d01a2e  ---&gt; ae6ddd93786c Step 11/11 : CMD  ["./entrypoint.sh"] ---&gt; Running in cb0ffeaefca6 Removing intermediate container cb0ffeaefca6  ---&gt; 9c64d1cb6bd3 Successfully built 9c64d1cb6bd3 Successfully tagged chapter2:latest</pre>
			<p>The container is incrementally built, as described by the Dockerfile. Each step is built in an image layer denoted with a <a id="_idIndexMarker090"/>hash value – those are the hex hash values printed. When you build the container again, Docker can start from the state of any of those layers' <code>/</code> hash values, reducing the need to constantly rebuild the container from scratch. Each layer is simply a diff (difference) between the current layer's requirements and the state of the previous layer.</p>
			<p>The first layer is the Debian image. The next layer is an intermediate image, the diff between the result of the <code>ENV</code> command in the Dockerfile and the original Debian image. The next layer is the diff between this previous intermediate image and the result of the <code>apt-get</code> installed packages. Note that we use <code>&amp;&amp;</code> to pack a few <code>apt-get</code> commands into one layer in the container. This greatly speeds up the build process. The layering continues as each command in the Dockerfile is processed by the Docker build command. </p>
			<p>Docker is smart about how it caches and works with the layers. It doesn't have to download the Debian image <a id="_idIndexMarker091"/>each time you build; it can start building from a previous intermediate stage if it knows the previous steps have not changed the state of the container to that point.</p>
			<p>Whenever we need to build the container, because we've made changes to the Dockerfile, we use the <code>build.sh</code> script. Once we have the container built, we have a few ways to use it. The <code>debug.sh</code> script is probably the most common script you'll use during development.</p>
			<h3>Understanding debug.sh</h3>
			<p>The <code>debug.sh</code> script runs the <a id="_idIndexMarker092"/>container image that is not in daemon mode. You can hit <em class="italic">Ctrl</em> + <em class="italic">C</em> to stop the program:</p>
			<pre>#!/usr/bin/env bash
 # debug.sh
 # run container without making it a daemon - useful to see logging output
 docker run \    --rm \    -p8086:80 \    --name="chapter2" \    -v `pwd`:/home/app \    chapter2</pre>
			<p>The <code>docker run</code> command takes many optional arguments that are too numerous to detail here. For more complete information on all of the possible command-line arguments to <code>docker run</code>, refer to the <code>docker run</code> documentation on the Docker site: <a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a>. We'll only cover the ones used in our scripts: </p>
			<ul>
				<li>Here, we use <code>–rm</code>, which tells Docker to clean up when the container exits, removing the container and filesystem for the container. </li>
				<li>The <code>-p</code> flag tells Docker to map port <code>80</code> from the container (HTTP) to port <code>8086</code> on the host; you can access the HTTP server in the container by using port <code>8086</code> on the host.</li>
				<li>The <code>–name</code> argument names the running container; if you don't provide a name, you'll have to <a id="_idIndexMarker093"/>use <code>docker ps</code> to get the hash that identifies the container to stop it using <code>docker stop</code>.</li>
				<li>The <code>-v</code> switch mounts volumes in the container. A volume can be a directory of a file on the host, a named volume that Docker manages for you. If you want to stop and restart the container and retain data that is written to the filesystem by the container, you must mount a volume and the container must write to this volume. You can mount multiple volumes, if you like. In our <code>debug.sh</code> script, we mount the current directory with the sources over <code>/home/app</code>, so we can modify the sources and the container programs see that the files are changed (because the file timestamps are newer) as if they were inside the container, too. For this demo, you can edit the <code>index.php</code> script and reload the page, and you'll see the change in action. If you don't mount this volume, then the container will access the files copied to <code>/home/app</code> by the Dockerfile and the <code>build.sh</code> script; this is what you want for production.</li>
				<li>The last argument to <code>docker run</code> is the name of the container to start – in our case, it's <code>chapter2</code>, the container image we created using the <code>build.sh</code> script.<p class="callout-heading">Note:</p><p class="callout">We do not persist <code>/data</code> in the container. We can do this by adding the <code>-v</code> switch to map a Docker volume to <code>/data</code>, which we will do in the <code>persist.sh</code> script.</p></li>
			</ul>
			<h4>Running our chapter2 container with debug.sh</h4>
			<p>Let's see the <a id="_idIndexMarker094"/>container in action. We run the <code>build.sh</code> script and see that it succeeds. Then, we use the <code>debug.sh</code> script to launch the <a id="_idIndexMarker095"/>container in <code>debug/foreground</code> mode. Note that we did not do any configuration of the hostname for the container, so there is a warning message printed by Apache:</p>
			<pre>%  ./debug.sh
entrypoint.sh
----&gt; Point your browser at http://localhost:8086/~app/index.php
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.5. Set the 'ServerName' directive globally to suppress this message</pre>
			<p>On the host, we can use a browser to fetch <code>http://localhost:8086/~app/index.php</code>.</p>
			<p>Remember, we mapped port <code>8086</code> to port <code>80</code> of the container, we enabled the <code>userdir</code> module, and, in the Dockerfile, we copied the <code>index.php</code> script to <code>/home/app/public_html</code> (the <code>userdir</code> module).</p>
			<p>We could have configured Apache with a default host and copied our files to <code>/var/www</code> in the Dockerfile and build process. This would have given us a cleaner URL, and this is what you would want to do for an actual production site. For our purposes, it's good to see the Apache modules enabled and working within the container:</p>
			<div><div><img src="img/B11641_02_003.jpg" alt="Figure 2.3 – Browser showing the output of our program"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Browser showing the output of our program</p>
			<p>When we reload the page in the browser a few times, we can see that the counter is being properly maintained:</p>
			<div><div><img src="img/B11641_02_004.jpg" alt="Figure 2.4 – Page after we reload"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Page after we reload</p>
			<p>Note that we aren't generating any HTML (yet). If you're trying this yourself, you can now edit the <code>index.php</code> file, change <code>Counterx:</code> to <code>Counter:</code> and reload the page, and you will see that the page prints <code>Counter:</code> now.</p>
			<p>We are now set up for PHP development.</p>
			<p>If we want to add, say, MySQL support, we'll have to modify the Dockerfile to install the PHP MySQL module, and <a id="_idIndexMarker096"/>enable it as we did with <code>userdir</code> and <code>php</code>. If we want to add a PHP framework, we either need to install it within the <a id="_idIndexMarker097"/>container via the Dockerfile, or add it to the <code>chapter2/</code> directory that is copied to the container's <code>/home/app</code> directory and, for development, mounted/bound in the container by replacing <code>/home/app</code>.</p>
			<p>We can check to see that the container is running by using the <code>docker ps</code> command:</p>
			<pre>% docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
54925e51e404        chapter2            "./entrypoint.sh"   2 seconds ago       Up 1 second         0.0.0.0:8086-&gt;80/tcp   chapter2</pre>
			<p>We can exit or kill the container by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> in the window where we started it with <code>debug.sh</code>.</p>
			<p>When we run the container with the <code>run.sh</code> script, we don't see any output from the container, not even the Apache warning:</p>
			<pre>% ./run.sh
1707b1ff84fabed4d9696aadbcd597cee08063eaa7ad22bfe572c922df 43997e</pre>
			<p>Again, we use <code>docker ps</code> to see that it is running:</p>
			<pre>% docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
1707b1ff84fa        chapter2            "./entrypoint.sh"   41 seconds ago      Up 39 seconds       0.0.0.0:8086-&gt;80/tcp   chapter2</pre>
			<p>Loading the same URL in the browser, we see that the counter is again <code>1</code>. Reloading a few times, we see the counter increments as we designed.</p>
			<p>We can restart the <a id="_idIndexMarker098"/>container using <a id="_idIndexMarker099"/><code>docker restart</code>. Note that the container was first instantiated 3 minutes ago, but since we restarted it, the status is <code>Up 1 second</code>:</p>
			<pre>% docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                  NAMES
1707b1ff84fa        chapter2            "./entrypoint.sh"   About a minute ago   Up 1 second         0.0.0.0:8086-&gt;80/tcp   chapter2</pre>
			<p>Since the container was only restarted, its filesystem remains intact. Reloading the URL in our browser, we see that the counter continues to increment. We can stop the container using <code>docker stop</code>, or the <code>stop.sh</code> script. The <code>docker ps</code> command shows no containers running. Then we start it up again:</p>
			<pre>% docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</pre>
			<p>Now, when we reload in our browser, the counter is reset to <code>1</code>. This is because we are writing to the container's filesystem. The filesystem goes away when the container exits.</p>
			<p>If we want the counter to persist between container start/restart, we'd have to write it to a volume that is mounted on the container.</p>
			<p>We write to <code>/data/container.txt</code>, so we can do the following: </p>
			<ul>
				<li>Mount our own <code>container.txt</code> on the host to <code>/data/container.txt</code> on the guest.</li>
				<li>Mount a <a id="_idIndexMarker100"/>directory on the host as <code>/data</code> on the guest.</li>
				<li>Have Docker <a id="_idIndexMarker101"/>create and maintain a named or anonymous volume for us.</li>
			</ul>
			<p>Since the advent of named volumes, they are the better choice. A named volume is created and maintained using the <code>-v</code> switch to <code>docker run</code> with just the name of the directory on the guest; for example, <code>-v name:/data</code>. We have a script, <code>persist.sh</code>, designed to make using the named volume easy.</p>
			<h3>persist.sh</h3>
			<p>The <code>persist.sh</code> script does <a id="_idIndexMarker102"/>the same thing as the <code>debug.sh</code> script, except that it adds the <code>-v name:/data</code> switch to the <code>docker run</code> command:</p>
			<pre>#!/usr/bin/env bash 
 # run container without making it a daemon - useful to see logging output # we are adding an anonymous volume for /data in the container so the # counter persists between runs.
 docker run \    --rm \    -p8086:80 \    --name="chapter2" \    -v `pwd`:/home/app \    -v name:/data \    chapter2</pre>
			<p>When we <a id="_idIndexMarker103"/>run it and point our browser at <code>http://localhost:8086/~app/index.php</code>, we see that the counter works, even if we stop and restart the container.</p>
			<h3>run.sh</h3>
			<p>The <code>run.sh</code> script runs the container in daemon mode – you won't be able to see the application's output <a id="_idIndexMarker104"/>without using the <code>docker log</code> command. It also does not mount the host directory as a volume in the container. This simulates the production environment:</p>
			<pre>#!/usr/bin/env bash
 # run.sh
 # run the container in the background # /data is persisted using a named container
 docker run \    --detach \    --rm \
    --restart always \     -p8086:80 \    -v name:/data \    --name="chapter2" \    chapter2</pre>
			<p>We are using the <code>docker run</code> command, once again, but with slightly different arguments:</p>
			<ul>
				<li>The <code>–detach</code> flag to Docker Run is what causes the container to run in the background.</li>
				<li>The named volume is used, so the data is persisted between starting and stopping the container.</li>
				<li>The development working directory is mounted on <code>/home/app</code> within the container.</li>
				<li>The <code>–restart</code> switch <a id="_idIndexMarker105"/>always tells Docker to restart the container when the system is rebooted. This is handy since you won't have to figure out some way to automatically start your container(s) when the operating system starts.</li>
			</ul>
			<p>The container is only able to run using the files copied to it using the Dockerfile and <code>build.sh</code>. If you edit files on your host, you will not see the changes within the running container, as with <code>persist.sh</code>. You will need to run the <code>build.sh</code> script every time you edit files and want them changed within the container for the purposes of <code>run.sh</code>.</p>
			<p>We'll need a way to stop our running container. This is where <code>stop.sh</code> comes in.</p>
			<h3>stop.sh</h3>
			<p>The <code>stop.sh</code> script will stop <a id="_idIndexMarker106"/>your <code>chapter2</code> container. This is particularly useful when you've used the <code>run.sh</code> script to launch your container in the background:</p>
			<pre>#!/bin/sh
 # stop.sh
 # stop running container - typing stop.sh is easier than the whole docker command
 docker stop chapter2</pre>
			<p>Let's see <code>run.sh</code> and <code>stop.sh</code> in action:</p>
			<pre>build.sh  debug.sh  Dockerfile  entrypoint.sh  install-virtualbox-macos.sh  persist.sh  php.conf  public_html  README.md  run.sh  shell.sh  stop.sh  % docker ps CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES  % ./run.sh 7d6bc5195a583b3979a2533b50708978d96981d3d9ac59b266055246b6 fad329  % docker ps CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES 7d6bc5195a58        chapter2            "./entrypoint.sh"   2 seconds ago       Up 1 second         0.0.0.0:8086-&gt;80/tcp   chapter2  % ./stop.sh chapter2  % docker ps CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES %</pre>
			<p>The <code>shell.sh</code> script runs the <a id="_idIndexMarker107"/>container and starts the Bash shell so that you can use command-line programs to diagnose issues with the container as it's built:</p>
			<pre>#!/usr/bin/env bash
 # shell.sh
 # This script starts a shell in an already built container.  Sometimes you need to poke around using the shell # to diagnose problems.
 # stop any existing running container ./stop.sh
 # fire up the container with shell (/bin/bash)docker run -it --rm --name chapter2 chapter2 /bin/bash</pre>
			<p>The following code snippet shows the <code>shell.sh</code> script in action:</p>
			<pre>% ./shell.sh Error response from daemon: No such container: chapter2 root@f10092244abe:/home/app# ls -l total 44 -rw-r--r-- 1 root root 871 Dec 13 10:28 Dockerfile -rw-r--r-- 1 root root 808 Dec  5 14:56 README.md -rwxr-xr-x 1 root root  38 Dec  4 12:15 build.sh -rwxr-xr-x 1 root root 197 Dec  4 16:12 debug.sh -rwxr-xr-x 1 root root 411 Dec 13 10:28 entrypoint.sh -rw-r--r-- 1 root root  75 Dec  2 17:31 install-virtualbox-macos.sh -rwxr-xr-x 1 root root 315 Dec 13 10:26 persist.sh -rw-r--r-- 1 root root 860 Dec  4 16:24 php.conf drwxr-xr-x 1 root root  18 Dec 13 10:27 public_html -rwxr-xr-x 1 root root 152 Dec  5 13:01 run.sh -rwxr-xr-x 1 root root 308 Dec  4 17:40 shell.sh -rwxr-xr-x 1 root root 115 Dec  4 17:41 stop.sh root@f10092244abe:/home/app# ls -ldg /data drwxrwxrwx 1 root 0 Dec 13 10:28 /data root@f10092244abe:/home/app# exit  %</pre>
			<p>We can see that <code>/data</code> was <a id="_idIndexMarker108"/>created and has world write permissions.</p>
			<p>These few <code>sh</code> scripts are enough to get you developing and using your own containers. As you work with Docker, you'll likely come up with additional scripts of your own! However,  we will see in <a href="B11641_04_Final_NM_ePub.xhtml#_idTextAnchor059"><em class="italic">Chapter 4</em></a>, <em class="italic">Composing Systems Using Containers</em>, a way to work with Docker without the <code>sh</code> scripts.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor042"/>Summary</h1>
			<p>In this chapter, we have learned about how VirtualBox can be used to create virtual machines on your workstation and how you can use it to run Windows (or Linux or other operating systems) in a virtual machine. We also learned enough about Docker to use it to build our first application.</p>
			<p>This chapter was written using Windows 10 running within a VirtualBox virtual machine, running on an Arch Linux host. Microsoft Word was used within Windows, while the Docker commands and scripts were run and edited on the Arch Linux host.</p>
			<p>We demonstrated how we can build a LAMP-style application, without MySQL, and containerize it. We can mount our source code directory from the host to the container so that we can edit files and see the changes immediately in the container. We learned how to persist data, meaning that stopping and starting the container would retain important files and state.</p>
			<p>In the next chapter, we'll explore Docker Hub and build a more complex application that requires more than one container.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor043"/>Further reading</h1>
			<ul>
				<li>This URL is for the official Docker documentation:<a href="https://docs.docker.com">https://docs.docker.com</a></li>
				<li>This URL is for the Dockerfile reference:<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
				<li>This URL is for the documentation for the Docker <code>ps</code> command:<a href="https://docs.docker.com/engine/reference/commandline/ps/">https://docs.docker.com/engine/reference/commandline/ps/</a></li>
				<li>This URL is for the documentation pertaining to volumes and storage in Docker:<a href="https://docs.docker.com/storage">https://docs.docker.com/storage</a></li>
				<li>This URL is for the documentation pertaining to the Docker <code>run</code> command:<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></li>
				<li>This URL is for the documentation pertaining to the Docker <code>restart</code> command:<a href="https://docs.docker.com/engine/reference/commandline/restart/">https://docs.docker.com/engine/reference/commandline/restart/</a></li>
				<li>This URL is for the documentation pertaining to the Docker <code>stop</code> command:<a href="https://docs.docker.com/engine/reference/commandline/stop/">https://docs.docker.com/engine/reference/commandline/stop/</a></li>
			</ul>
		</div>
	</body></html>