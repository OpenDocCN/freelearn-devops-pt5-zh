- en: '*Chapter 7*: Configuration Management with Ansible'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already covered the two most crucial phases of the continuous delivery
    process: the commit phase and automated acceptance testing. We also explained
    how to cluster your environments for both your application and Jenkins agents.
    In this chapter, we will focus on configuration management, which connects the
    virtual containerized environment to the real server infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible with Docker and Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing infrastructure as code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the instructions in this chapter, you''ll need the following
    hardware/software:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote machines with the Ubuntu operating system and SSH server installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples and solutions to the exercises can be found on GitHub at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3JkcGLE](https://bit.ly/3JkcGLE).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuration management is the process of controlling configuration changes
    in such a way that the system maintains integrity over time. Even though the term
    did not originate in the IT industry, currently, it is broadly used to refer to
    software and hardware. In this context, it concerns the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application configuration**: This involves software properties that decide
    how the system works, which are usually expressed in the form of flags or properties
    files passed to the application, for example, the database address, the maximum
    chunk size for file processing, or the logging level. They can be applied during
    different development phases: build, package, deploy, or run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server configuration**: This defines what dependencies should be installed
    on each server and specifies the way applications are orchestrated (which application
    is run on which server, and in how many instances).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure configuration**: This involves server infrastructure and environment
    configuration. If you use on-premises servers, then this part is related to the
    manual hardware and network installation; if you use cloud solutions, then this
    part can be automated with the **infrastructure as code** (**IaC**)e approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, we can think of the calculator web service, which uses the Hazelcast
    server. Let''s look at the following diagram, which presents how configuration
    management works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Sample configuration management'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Sample configuration management
  prefs: []
  type: TYPE_NORMAL
- en: The configuration management tool reads the configuration file and prepares
    the environment. It installs dependent tools and libraries and deploys the applications
    to multiple instances. Additionally, in the case of cloud deployment, it can provide
    the necessary infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, **Infrastructure Configuration** specifies the required
    servers and S**erver Configuration** defines that the **Calculator** service should
    be deployed in two instances, on **Server 1** and **Server 2**, and that the Hazelcast
    service should be installed on **Server 3**. **Calculator Application Configuration** specifies
    the port and the address of the Hazelcast server so that the services can communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The configuration can differ, depending on the type of the environment (QA,
    staging, or production); for example, server addresses can be different.
  prefs: []
  type: TYPE_NORMAL
- en: There are many approaches to configuration management, but before we look into
    concrete solutions, let's comment on what characteristics a good configuration
    management tool should have.
  prefs: []
  type: TYPE_NORMAL
- en: Traits of good configuration management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What should a modern configuration management solution look like? Let''s walk
    through the most important factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation**: Each environment should be automatically reproducible, including
    the operating system, the network configuration, the software installed, and the
    applications deployed. In such an approach, fixing production issues means nothing
    more than an automatic rebuild of the environment. What''s more, it simplifies
    server replications and ensures that the staging and production environments are
    exactly the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: Every change in the configuration should be tracked, so
    that we know who made it, why, and when. Usually, that means keeping the configuration
    in the source code repository, either with the code or in a separate place. The
    former solution is recommended because configuration properties have a different
    life cycle than the application itself. Version control also helps with fixing
    production issues; the configuration can always be rolled back to the previous
    version, and the environment automatically rebuilt. The only exception to the
    version control-based solution is storing credentials and other sensitive information;
    these should never be checked in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental changes**: Applying a change in the configuration should not
    require rebuilding the whole environment. On the contrary, a small change in the
    configuration should only change the related part of the infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server provisioning**: Thanks to automation, adding a new server should be
    as quick as adding its address to the configuration (and executing one command).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: The access to both the configuration management tool and the
    machines under its control should be well secured. When using the SSH protocol
    for communication, the access to the keys or credentials needs to be well protected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Every member of the team should be able to read the configuration,
    make a change, and apply it to the environment. The properties themselves should
    also be kept as simple as possible, and the ones that are not subject to change
    are better off kept hardcoded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to keep these points in mind while creating the configuration,
    and even beforehand while choosing the right configuration management tool.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of configuration management tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the classic sense, before the cloud era, configuration management referred
    to the process that started when all the servers were already in place. So, the
    starting point was a set of IP addresses with machines accessible via SSH. For
    that purpose, the most popular configuration management tools are Ansible, Puppet,
    and Chef. Each of them is a good choice; they are all open source products with
    free basic versions and paid enterprise editions. The most important differences
    between them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration language**: Chef uses Ruby, Puppet uses its own DSL (based
    on Ruby), and Ansible uses YAML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent-based**: Puppet and Chef use agents for communication, which means
    that each managed server needs to have a special tool installed. Ansible, on the
    other hand, is agentless and uses the standard SSH protocol for communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agentless feature is a significant advantage because it implies no need
    to install anything on servers. What's more, Ansible is quickly trending upward,
    which is why it was chosen for this book. Nevertheless, other tools can also be used successfully
    for the continuous delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: Together with cloud transformation, the meaning of configuration management
    widened and started to include what is called **IaC**. As the input, you no longer
    need a set of IP addresses, but it's enough to provide the credentials to your
    favorite cloud provider. Then, IaC tools can provision servers for you. What's
    more, each cloud provider offers a portfolio of services, so in many cases, you
    don't even need to provision bare-metal servers, but directly use cloud services.
    While you can still use Ansible, Puppet, or Chef for that purpose, there is a
    tool called Terraform that is dedicated to the IaC use case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first describe the classic approach to configuration management with Ansible,
    and then walk through the IaC solution using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is an open source, agentless automation engine for software provisioning,
    configuration management, and application deployment. Its first release was in
    2012, and its basic version is free for both personal and commercial use. The
    enterprise version is called **Ansible Tower**, which provides GUI management and dashboards,
    the REST API, role-based access control, and some more features.
  prefs: []
  type: TYPE_NORMAL
- en: We will present the installation process and a description of how Ansible can
    be used separately, as well as in conjunction with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible server requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible uses the SSH protocol for communication and has no special requirements
    regarding the machine it manages. There is also no central master server, so it's
    enough to install the Ansible client tool anywhere; we can then use it to manage
    the whole infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The only requirement for the machines being managed is to have the Python tool
    (and obviously, the SSH server) installed. These tools are, however, almost always
    available on any server by default.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation instructions will differ depending on the operating system.
    In the case of Ubuntu, it''s enough to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can find the installation guides for all the operating systems on the official
    Ansible page, at [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation process is complete, we can execute the `ansible` command
    to check that everything was installed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use Ansible, we first need to define the inventory, which represents
    the available resources. Then, we will be able to either execute a single command
    or define a set of tasks using the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An inventory is a list of all the servers that are managed by Ansible. Each
    server requires nothing more than the Python interpreter and the SSH server installed.
    By default, Ansible assumes that SSH keys are used for authentication; however,
    it is also possible to use a username and password by adding the `--ask-pass` option
    to the Ansible commands.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: SSH keys can be generated with the `ssh-keygen` tool, and they are usually stored
    in the `~/.ssh` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inventory is defined by default in the `/etc/ansible/hosts` file (but its
    location can be defined with the `–i` parameter), and it has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The inventory syntax also accepts ranges of servers, for example, `www[01-22].company.com`.
    The SSH port should also be specified if it's anything other than `22` (the default).
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be many groups in the inventory file. As an example, let''s define
    two machines in one group of servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create the configuration with server aliases and specify the remote
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file defines a group called `webservers`, which consists of two
    servers. The Ansible client will log into both of them as the user `ubuntu`. When
    we have the inventory created, let's discover how we can use it to execute the
    same command on many servers.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Ansible offers the possibility to dynamically pull the inventory from a cloud
    provider (for example, Amazon EC2/Eucalyptus), LDAP, or Cobbler. Read more about
    dynamic inventories at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html).
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest command we can run is a ping on all servers. Assuming that we
    have two remote machines (`192.168.64.12` and `192.168.64.13`) with SSH servers
    configured and the inventory file (as defined in the last section), let''s execute
    the `ping` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We used the `-m <module_name>` option, which allows for specifying the module
    that should be executed on the remote hosts. The result is successful, which means that the
    servers are reachable, and the authentication is configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we used `all`, so that all servers would be addressed, but we could
    also call them by the `webservers` group name, or by the single host alias. As
    a second example, let''s execute a shell command on only one of the servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `-a <arguments>` option specifies the arguments that are passed to the Ansible
    module. In this case, we didn't specify the module, so the arguments are executed
    as a shell Unix command. The result was successful, and `hello` was printed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If the `ansible` command is connecting to the server for the first time (or
    if the server is reinstalled), then we are prompted with the key confirmation
    message (the SSH message, when the host is not present in `known_hosts`). Since
    it may interrupt an automated script, we can disable the prompt message by uncommenting `host_key_checking
    = False` in the `/etc/ansible/ansible.cfg` file, or by setting the environment
    variable, `ANSIBLE_HOST_KEY_CHECKING=False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplistic form, the Ansible ad hoc command syntax looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of ad hoc commands is to do something quickly when it is not necessary
    to repeat it. For example, we may want to check whether a server is alive or power off
    all the machines for the Christmas break. This mechanism can be seen as a command
    execution on a group of machines, with the additional syntax simplification provided
    by the modules. The real power of Ansible automation, however, lies in playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **Ansible playbook** is a configuration file that describes how servers should
    be configured. It provides a way to define a sequence of tasks that should be
    performed on each of the machines. A playbook is expressed in the YAML configuration
    language, which makes it human-readable and easy to understand. Let's start with
    a sample playbook, and then see how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A playbook is composed of one or many plays. Each play contains a host group
    name, tasks to perform, and configuration details (for example, the remote username
    or access rights). An example playbook might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration contains one play, which performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only executes on the `web1` host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gains root access using the `sudo` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executes two tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt` Ansible module (called with two parameters, `name=apache2` and `state=latest`)
    checks whether the `apache2` package is installed on the server, and if it isn''t,
    it uses the `apt-get` tool to install it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service` Ansible module (called with three parameters, `name=apache2`, `state=started`,
    and `enabled=yes`) checks whether the `apache2` Unix service is started, and if
    it isn''t, it uses the `service` command to start it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that each task has a human-readable name, which is used in the console output,
    such that `apt` and `service` are Ansible modules, and `name=apache2`, `state=latest`,
    and `state=started` are module arguments. You already saw Ansible modules and
    arguments while using ad hoc commands. In the preceding playbook, we only defined
    one play, but there can be many of them, and each can be related to different
    groups of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Note that since we used the `apt` Ansible module, the playbook is dedicated
    to Debian/Ubuntu servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could define two groups of servers in the inventory: `database`
    and `webservers`. Then, in the playbook, we could specify the tasks that should
    be executed on all database-hosting machines, and some different tasks that should
    be executed on all the web servers. By using one command, we could set up the
    whole environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Executing the playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When `playbook.yml` is defined, we can execute it using the `ansible-playbook`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If the server requires entering the password for the `sudo` command, then we
    need to add the `--ask-sudo-pass` option to the `ansible-playbook` command. It's
    also possible to pass the `sudo` password (if required) by setting the extra variable,
    `-e ansible_become_pass=<sudo_password>`.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook configuration was executed, and therefore, the `apache2` tool was
    installed and started. Note that if the task has changed something on the server,
    it is marked as `changed`. On the contrary, if there was no change, the task is
    marked as `ok`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to run tasks in parallel by using the `-f <num_of_threads>` option.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook's idempotency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can execute the command again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output is slightly different. This time, the command didn't change
    anything on the server. That's because each Ansible module is designed to be idempotent.
    In other words, executing the same module many times in a sequence should have
    the same effect as executing it only once.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to achieve idempotency is to always check first whether the
    task has been executed yet, and only execute it if it hasn't. Idempotency is a
    powerful feature, and we should always write our Ansible tasks this way.
  prefs: []
  type: TYPE_NORMAL
- en: If all the tasks are idempotent, then we can execute them as many times as we
    want. In that context, we can think of the playbook as a description of the desired
    state of remote machines. Then, the `ansible-playbook` command takes care of bringing
    the machine (or group of machines) into that state.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some operations should only be executed if some other tasks are changed. For
    example, imagine that you copy the configuration file to the remote machine and
    the Apache server should only be restarted if the configuration file has changed. *How
    could we approach such a case?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible provides an event-oriented mechanism to notify about the changes. In
    order to use it, we need to know two keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`handlers`: This specifies the tasks executed when notified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify`: This specifies the handlers that should be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following example of how we could copy the configuration
    to the server and restart Apache only if the configuration has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create the `foo.conf` file and run the `ansible-playbook` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Handlers are always executed at the end of the play, and only once, even if
    triggered by multiple tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible copied the file and restarted the Apache server. It''s important to
    understand that if we run the command again, nothing will happen. However, if
    we change the content of the `foo.conf` file and then run the `ansible-playbook` command,
    the file will be copied again (and the Apache server will be restarted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We used the `copy` module, which is smart enough to detect whether the file
    has changed and then make a change on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There is also a publish-subscribe mechanism in Ansible. Using it means assigning
    a topic to many handlers. Then, a task notifies the topic to execute all related
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the Ansible automation makes things identical and repeatable for multiple
    hosts, it is inevitable that servers may require some differences. For example,
    think of the application port number. It can be different, depending on the machine.
    Luckily, Ansible provides variables, which are a good mechanism to deal with server
    differences. Let''s create a new playbook and define a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration defines the `http_port` variable with the value `8080`. Now,
    we can use it by using the `Jinja2` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `Jinja2` language allows for doing way more than just getting a variable.
    We can use it to create conditions, loops, and much more. You can find more details
    on the Jinja page, at [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `debug` module prints the message while executing. If we run the `ansible-playbook`
    command, we can see the variable usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from user-defined variables, there are also predefined automatic variables.
    For example, the `hostvars` variable stores a map with the information regarding
    all hosts from the inventory. Using the Jinja2 syntax, we can iterate and print
    the IP addresses of all the hosts in the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can execute the `ansible-playbook` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that with the use of the Jinja2 language, we can specify the flow control
    operations inside the Ansible playbook file.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can install any tool on the remote server by using Ansible playbooks. Imagine
    that we would like to have a server with MySQL. We could easily prepare a playbook
    similar to the one with the `apache2` package. However, if you think about it,
    a server with MySQL is quite a common case, and someone has surely already prepared
    a playbook for it, so maybe we can just reuse it. This is where Ansible roles
    and Ansible Galaxy come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An Ansible role is a well-structured playbook part prepared to be included
    in playbooks. Roles are separate units that always have the following directory
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about roles and what each directory means on the official
    Ansible page at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In each of the directories, we can define the `main.yml` file, which contains
    the playbook parts that can be included in the `playbook.yml` file. Continuing
    the MySQL case, there is a role defined on GitHub at [https://github.com/geerlingguy/ansible-role-mysql](https://github.com/geerlingguy/ansible-role-mysql).
    This repository contains task templates that can be used in our playbook. Let''s
    look at a part of the `tasks/setup-Debian.yml` file, which installs the `mysql`
    package in Ubuntu/Debian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is only one of the tasks defined in the `tasks/main.yml` file. Others tasks
    are responsible for the installation of MySQL into other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use this role in order to install MySQL on the server, it''s enough to
    create the following `playbook.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Such a configuration installs the MySQL database on all servers using the `geerlingguy.mysql` role.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible Galaxy is to Ansible what Docker Hub is to Docker—it stores common roles
    so that they can be reused by others. You can browse the available roles on the
    Ansible Galaxy page at [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a role from Ansible Galaxy, we can use the `ansible-galaxy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command automatically downloads the role. In the case of the MySQL example,
    we could download the role by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The command downloads the `mysql` role, which can later be used in the playbook
    file. If you defined `playbook.yml` as described in the preceding snippet, the
    following command installs MySQL into all of your servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know about the basics of Ansible, let's see how we can use it to
    deploy our own applications.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the most fundamental features of Ansible. Now, let's forget,
    just for a little while, about Docker, Kubernetes, and most of the things we've
    learned so far. Let's configure a complete deployment step by only using Ansible.
    We will run the calculator service on one server and the Hazelcast service on
    the second server.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Hazelcast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can specify a play in the new playbook. Let''s create the `playbook.yml` file,
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration is executed on the `web1` server and it requires root permissions.
    It performs a few steps that will lead to a complete Hazelcast server installation.
    Let''s walk through what we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prepare the environment**: This task ensures that the Java runtime environment
    is installed. Basically, it prepares the server environment so that Hazelcast
    will have all the necessary dependencies. With more complex applications, the
    list of dependent tools and libraries can be way longer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Download Hazelcast tool**: Hazelcast is provided in the form of a JAR, which
    can be downloaded from the internet. We hardcoded the version, but in a real-life
    scenario, it would be better to extract it to a variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/etc/init.d/` directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Start the Hazelcast service**: When Hazelcast is configured as a Unix service,
    we can start it in the standard way.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the same directory, let''s create `hazelcast.sh`, which is a script (shown
    as follows) that is responsible for running Hazelcast as a Unix service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After this step, we could execute the playbook and have Hazelcast started on
    the `web1` server machine. However, let's first create a second play to start
    the calculator service, and then run it all together.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a web service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We prepare the calculator web service in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the Hazelcast host address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add calculator deployment to the playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing the Hazelcast host address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, we hardcoded the Hazelcast host address as `hazelcast`, so now we
    should change it in the `src/main/java/com/leszko/calculator/CalculatorApplication.java`
    file to `192.168.64.12` (the same IP address we have in our inventory, as `web1`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In real-life projects, the application properties are usually kept in the `properties`
    file. For example, for the Spring Boot framework, it's a file called `application.properties` or `application.yml`.
    Then, we could change them with Ansible and therefore be more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Adding calculator deployment to the playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we can add the deployment configuration as a new play in the `playbook.yml` file.
    It is similar to the one we created for Hazelcast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The configuration is very similar to what we saw in the case of Hazelcast. One
    difference is that this time, we don't download the JAR from the internet, but
    we copy it from our filesystem. The other difference is that we restart the service
    using the Ansible handler. That's because we want to restart the calculator each
    time a new version is copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start it all together, we also need to define `calculator.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When everything is prepared, we will use this configuration to start the complete
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Running the deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, we can execute the playbook using the `ansible-playbook` command.
    Before that, we need to build the calculator project with Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After the successful deployment, the service should be available, and we can
    check that it's working at `http://192.168.64.13:8080/sum?a=1&b=2` (the IP address
    should be the same one that we have in our inventory as `web2`). As expected,
    it should return `3` as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have configured the whole environment by executing one command.
    What's more, if we need to scale the service, then it's enough to add a new server
    to the inventory and rerun the `ansible-playbook` command. Also, note that we
    could package it as an Ansible role and upload it to GitHub, and from then on,
    everyone could run the same system on their Ubuntu servers. That's the power of
    Ansible!
  prefs: []
  type: TYPE_NORMAL
- en: We have shown how to use Ansible for environmental configuration and application
    deployment. The next step is to use Ansible with Docker and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible with Docker and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, Ansible and Docker (along with Kubernetes) address similar software
    deployment issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Environmental configuration**: Both Ansible and Docker provide a way to configure
    the environment; however, they use different means. While Ansible uses scripts
    (encapsulated inside the Ansible modules), Docker encapsulates the whole environment
    inside a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: Ansible provides a way to deploy different services on the
    same or different hosts and lets them be deployed together. Kubernetes has similar
    functionality, which allows for running multiple containers at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Ansible helps to scale the services providing the inventory
    and host groups. Kubernetes has similar functionality to automatically increase
    or decrease the number of running containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook.yml`. In the case of Docker and Kubernetes, we have `Dockerfile` for
    the environment and `deployment.yml` for the dependencies and scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Both tools are very simple to use and provide a way to set
    up the whole running environment with a configuration file and just one command execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we compare the tools, Docker does a little more, since it provides isolation,
    portability, and a kind of security. We could even imagine using Docker/Kubernetes
    without any other configuration management tools. Then, *why do we need Ansible
    at all?*
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible may seem redundant; however, it brings additional benefits to the delivery
    process, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker environment**: The Docker/Kubernetes hosts themselves have to be configured
    and managed. Every container is ultimately running on Linux machines, which need
    kernel patching, Docker Engine updates, and network configuration, for example.
    What''s more, there may be different server machines with different Linux distributions,
    and the responsibility of Ansible is to make sure everything is up and running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-Dockerized applications**: Not everything is run inside a container.
    If part of the infrastructure is containerized and part is deployed in the standard
    way or in the cloud, then Ansible can manage it all with the playbook configuration
    file. There may be different reasons for not running an application as a container;
    for example, performance, security, specific hardware requirements, or working
    with the legacy software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory**: Ansible offers a very friendly way to manage the physical infrastructure
    by using inventories, which store information about all the servers. It can also
    split the physical infrastructure into different environments—production, testing,
    and development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud provisioning**: Ansible can be responsible for provisioning Kubernetes
    clusters or installing Kubernetes in the cloud; for example, we can imagine integration
    tests in which the first step is to create a Kubernetes cluster on **Google Cloud
    Platform** (**GCP**) (only then can we deploy the whole application and perform
    the testing process).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GUI**: Ansible offers GUI managers (commercial Ansible Tower and open source
    AWX), which aim to improve the experience of infrastructure management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improving the testing process**: Ansible can help with integration and acceptance
    testing, as it can encapsulate testing scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can look at Ansible as the tool that takes care of the infrastructure, while
    Docker and Kubernetes are tools that take care of the environmental configuration
    and clustering. An overview is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Ansible as the infrastructure manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Ansible as the infrastructure manager
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible manages the infrastructure: **Kubernetes clusters**, **Docker servers**,
    **Docker registries**, **servers without Docker**, and **cloud providers**. It
    also takes care of the physical location of the servers. Using the inventory host
    groups, it can link the web services to the databases that are close to their
    geographic locations.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can use Ansible to install Docker on a server and deploy
    a sample application.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Docker playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible integrates with Docker smoothly, because it provides a set of Docker-dedicated
    modules. If we create an Ansible playbook for Docker-based deployment, then the
    first task is to make sure that the Docker Engine is installed on every machine.
    Then, it should run a container using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's install Docker on an Ubuntu server.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can install the Docker Engine by using the following task in the Ansible
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The playbook looks slightly different for each operating system. The one presented
    here is for Ubuntu 20.04.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration installs Docker and Docker Python tools (needed by Ansible).
    Note that we used a new Ansible syntax, `loop`, in order to make the playbook
    more concise.
  prefs: []
  type: TYPE_NORMAL
- en: When Docker is installed, we can add a task that will run a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Docker containers is done with the use of the `docker_container` module,
    and it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about all of the options of the `docker_container` module
    at [https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.html](https://docs.ansible.com/ansible/latest/collections/community/docker/docker_container_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: With the two playbooks presented previously, we configured the Hazelcast server
    using Docker. Note that this is very convenient because we can run the same playbook
    on multiple (Ubuntu) servers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how Ansible can help with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Kubernetes playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to Docker, Ansible can help with Kubernetes. When you have your Kubernetes
    cluster configured, then you can create Kubernetes resources using the Ansible `k8s` module.
    Here''s a sample Ansible task to create a namespace in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The configuration here makes sure a namespace called `my-namespace` is created
    in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the Ansible `k8s` module at [https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_module.html](https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: We have covered configuration management with Ansible, which is a perfect approach
    if your deployment environment consists of bare-metal servers. You can also use
    Ansible with cloud providers, and there are a number of modules dedicated to that
    purpose. For example, `amazon.aws.ec2_instance` lets you create and manage AWS
    EC2 instances. However, when it comes to the cloud, there are better solutions.
    Let's see what they are and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IaC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IaC is the process of managing and provisioning computing resources instead
    of physical hardware configuration. It is mostly associated with the cloud approach,
    in which you can request the necessary infrastructure in a programmable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing computer infrastructure was always a hard, time-consuming, and error-prone
    activity. You had to manually place the hardware, connect the network, install
    the operating system, and take care of its updates. Together with the cloud, things
    became simple; all you had to do was to write a few commands or make a few clicks
    in the web UI. IaC goes one step further, as it allows you to specify in a declarative
    manner what infrastructure you need. To understand it better, let''s take a look
    at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – IaC'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – IaC
  prefs: []
  type: TYPE_NORMAL
- en: You prepare a declarative description of your infrastructure, for example, that
    you need three servers, a Kubernetes cluster, and a load balancer. Then, you pass
    this configuration to a tool that uses a cloud-specific API (for example, the
    AWS API) in order to make sure the infrastructure is as requested. Note that you
    should store the infrastructure configuration in the source code repository, and
    you can create multiple identical environments from the same configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the IaC idea is very similar to configuration management; however,
    while configuration management makes sure your software is configured as specified,
    IaC makes sure that your infrastructure is configured as specified.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look into the benefits of using IaC.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of IaC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of benefits that infrastructure brings into all DevOps activities.
    Let''s walk through the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Creating the whole infrastructure means nothing more than running
    a script, which significantly reduces the time needed before we can start deploying
    the applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost reduction**: Automating the infrastructure provisioning reduces the
    number of DevOps team members required to operate server environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: IaC configuration files become the single point of truth,
    so they guarantee that every created environment is exactly the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk reduction**: Infrastructure configuration is stored in the source code
    repository and follows the standard code review process, which reduces the probability
    of making a mistake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration**: Multiple people can share the code and work on the same
    configuration files, which increases work efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope these points have convinced you that IaC is a great approach. Let's now
    look into the tools you can use for IaC.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for IaC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to IaC, there are a number of tools you can use. The choice depends
    on the cloud provider you use and on your own preferences. Let''s walk through
    the most popular solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terraform**: The most popular IaC tool on the market. It''s open source and
    uses plugin-based modules called *providers* to support different infrastructure
    APIs. Currently, more than 1,000 Terraform providers exist, including AWS, Azure,
    GCP, and DigitalOcean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud provider specific**: Each major cloud provider has its own IaC tool:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CloudFormation**: An Amazon service that allows you to specify AWS resources
    in the form of YAML or JSON template files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Resource Manager** (**ARM**): A Microsoft Azure service that allows
    you to create and manage Azure resources with the use of ARM template files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Deployment Manager**: A Google service that allows you to manage
    Google Cloud Platform resources with the use of YAML files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General configuration management**: Ansible, Chef, and Puppet all provide
    dedicated modules to provision the infrastructure in the most popular cloud solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulumi**: A very flexible tool that allows you to specify the desired infrastructure
    using general-purpose programming languages, such as JavaScript, Python, Go, or
    C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vagrant**: Usually associated with virtual machine management, it provides
    a number of plugins to provision infrastructure using AWS and other cloud providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of all the solutions mentioned, Terraform is by far the most popular. That is
    why we'll spend some more time understanding how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is an open source tool created and maintained by HashiCorp. It allows
    you to specify your infrastructure in the form of human-readable configuration
    files. Similar to Ansible, it works in a declarative manner, which means that
    you specify the expected outcome, and Terraform makes sure your environment is
    created as specified.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into a concrete example, let's spend a moment understanding how
    Terraform works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Terraform reads a configuration file and adjusts the cloud resources accordingly.
    Let''s look at the following diagram, which presents this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Terraform workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Terraform workflow
  prefs: []
  type: TYPE_NORMAL
- en: A user creates **Configuration File** and starts the **Terraform** tool. Then,
    **Terraform** checks the **Terraform State** and uses **Terraform Provider** to
    translate the declarative configuration file into the requests called against
    **Target API**, which is specific for the given cloud provider. As an example,
    we can think of a configuration file that defines three AWS EC2 instances. Terraform
    uses the AWS provider, which executes requests to the AWS API to make sure that
    three AWS EC2 instances are created.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: There are more than 1,000 Terraform providers available, and you can browse
    them via the Terraform Registry at [https://registry.terraform.io/](https://registry.terraform.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terraform workflow always consists of three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write**: User defines cloud resources as a configuration file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan**: Terraform compares the configuration file with the current state
    and prepares the execution plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apply**: User approves the plan and Terraform executes the planned operations
    using the cloud API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach is very convenient because, with the plan stage, we can always
    check what Terraform is going to change in our infrastructure, before actually
    applying the change.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the idea behind Terraform, let's look at how it all works
    in practice, starting from the Terraform installation process.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation process depends on the operating system. In the case of Ubuntu,
    you can execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can find the installation guides for all the operating systems on the official
    Terraform website, at [https://www.terraform.io/downloads](https://www.terraform.io/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation process, we can verify that the `terraform` command
    works correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After Terraform is configured, we can move to the Terraform example.
  prefs: []
  type: TYPE_NORMAL
- en: Using Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example, let's use Terraform to provision an AWS EC2 instance. For this
    purpose, we need to first configure AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring AWS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access AWS from your machine, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS CLI installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can create a free AWS account at [https://aws.amazon.com/free](https://aws.amazon.com/free).
    To install the AWS CLI tool, please check the following instructions: [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s configure the AWS CLI with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The AWS command prompts your AWS access key ID and AWS secret access key.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: For instructions on how to create an AWS access key pair, please visit [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-creds](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-creds).
  prefs: []
  type: TYPE_NORMAL
- en: After these steps, access to your AWS account is configured and we can start
    playing with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Terraform configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a fresh directory, let''s create the `main.tf` file and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration, we defined the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The Terraform tool version should be at least `1.1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The configuration uses the `hashicorp/aws` provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider version needs to be at least `3.74`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform will automatically download it from the **Terraform Registry**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The credentials for the `aws` provider are stored in the `default` location
    created by the AWS CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider creates all resources in the `us-east-1` region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider creates `aws_instance` (an AWS EC2 instance) named `my_instance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An EC2 instance is created from `ami-04505e74c0741db8d` (Ubuntu 20.04 LTS in
    the `us-east-1` region).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instance type is `t2.micro`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that the whole configuration is declarative. In other words, we
    define what we want, not the algorithm for how to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: When the configuration is created, we need to download the required provider
    from the Terraform Registry.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Terraform configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads all required providers and stores them in the `.terraform`
    directory. Now, let's finally apply the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Terraform configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we make any Terraform changes, it''s good to first execute `terraform
    plan` to check what changes stand ahead of us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can see that by applying the configuration, we will create a resource in
    our infrastructure as described in the console output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now apply our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After confirming the change, you should see a lot of logs and the last `Apply
    complete!` message, which means that our infrastructure is created.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's verify that everything is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the Terraform perspective, we can execute the following command to see
    the state of our infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This prints all the information about the resource we created.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform, the same as Ansible, favors idempotent operations. That is why,
    if we execute `terraform plan` or `terraform apply` again, nothing will change.
    You will only see the following message: `No changes. Your infrastructure matches
    the configuration`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now verify that our AWS EC2 instance is really created. Since we already
    installed the AWS CLI, we can check it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer, you can also check in the AWS web console that the instance is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – AWS EC2 instance created with Terraform'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – AWS EC2 instance created with Terraform
  prefs: []
  type: TYPE_NORMAL
- en: We just verified that our Terraform configuration works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When working together with Ansible, we can make use of Ansible's dynamic inventories
    and let Ansible discover created EC2 instances. Read more at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html).
  prefs: []
  type: TYPE_NORMAL
- en: To make our example complete, let's also see how to delete created resources.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s remove the resources we created with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After the user confirmation, Terraform removed all the resources. You can check
    that our AWS EC2 instance does not exist anymore.
  prefs: []
  type: TYPE_NORMAL
- en: As the last thing with Terraform, let's see how it interacts with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform and Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two different use cases when it comes to the interaction between
    Terraform and Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's present them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each of the major cloud providers offers managed Kubernetes clusters, and we
    can provision them using Terraform. The following Terraform providers are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS**: This can provision clusters in Amazon **Elastic Kubernetes Service**
    (**EKS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google**: This can provision clusters in **Google Kubernetes Engine** (**GKE**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AzureRM**: This can provision clusters in **Azure Kubernetes Service** (**AKS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using each of these providers is relatively simple and works similarly to how
    we described in our Terraform example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you install Kubernetes on bare-metal servers, you should use a configuration
    management tool, such as Ansible. To provision a cloud-managed Kubernetes cluster,
    you can use either Ansible or Terraform, but the former is a better fit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also look at the second usage of Terraform with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with a Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to Ansible, we can use Terraform to interact with a Kubernetes cluster.
    In other words, instead of applying Kubernetes configurations using the `kubectl`
    command, we can use a dedicated Terraform Kubernetes provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample Terraform configuration to change Kubernetes resources looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration creates a namespace called `my-namespace` in the
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways you can interact with a Kubernetes cluster: `kubectl`,
    Ansible, Terraform, or some other tool. As a rule of thumb, I would always first
    try the simplest approach, which is the `kubectl` command, and only incorporate
    Ansible or Terraform if you have some special requirements; for example, you manage
    multiple Kubernetes clusters at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: We covered the basics of Terraform, so let's wrap up this chapter with a short
    summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered configuration management and IaC approaches, together with the
    related tooling. Note that whether you should use Ansible, Terraform, or neither
    of them inside your continuous delivery pipeline highly depends on your particular
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible shines when you have multiple bare-metal servers to manage, so if your
    release means making the same change into many servers at the same time, you'll
    most probably place Ansible commands inside your pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform works best when you use the cloud. Therefore, if your release means
    making a change to your cloud infrastructure, then Terraform is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your environment is only a single Kubernetes cluster, then there
    is nothing wrong with executing `kubectl` commands inside your pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other takeaway points from this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management is the process of creating and applying the configurations
    of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible is one of the most trending configuration management tools. It is agentless,
    and therefore, it requires no special server configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible can be used with ad hoc commands, but the real power lies in Ansible
    playbooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible playbook is a definition of how the environment should be configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of Ansible roles is to reuse parts of playbooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Galaxy is an online service to share Ansible roles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IaC is a process of managing cloud resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform is the most popular tool for IaC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will wrap up the continuous delivery process and complete
    the final Jenkins pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the fundamentals of Ansible and ways to use it
    with Docker and Kubernetes. As exercises, try the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the server infrastructure and use Ansible to manage it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a physical machine or run a VirtualBox machine to emulate the remote
    server.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure SSH access to the remote machine (SSH keys).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Python on the remote machine.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Ansible inventory with the remote machine.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Ansible ad hoc command (with the `ping` module) to check that the infrastructure
    is configured correctly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Python-based `hello world` web service and deploy it in a remote machine
    using Ansible playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service can look exactly the same as we described in the exercises for the
    chapter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a playbook that deploys the service into the remote machine.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `ansible-playbook` command and check whether the service was deployed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provision a GCP virtual machine instance using Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an account in GCP.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `gcloud` tool and authenticate (`gcloud init`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate credentials and export them into the `GOOGLE_APPLICATION_CREDENTIALS`
    environment variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Terraform configuration that provisions a virtual machine instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the configuration using Terraform.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the instance was created.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To verify your knowledge from this chapter, please answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is configuration management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean that the configuration management tool is agentless?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three most popular configuration management tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Ansible inventory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between Ansible ad hoc commands and playbooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an Ansible role?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Ansible Galaxy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is IaC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the most popular tools for IaC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read more about configuration management and IaC, please refer to the following
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Official Ansible documentation**: [https://docs.ansible.com/](https://docs.ansible.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Official Terraform documentation**: [https://www.terraform.io/docs](https://www.terraform.io/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Michael T. Nygard, Release It!**: ([https://pragprog.com/titles/mnee2/release-it-second-edition/](https://pragprog.com/titles/mnee2/release-it-second-edition/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Russ McKendrick, Learn Ansible**: ([https://www.packtpub.com/virtualization-and-cloud/learn-ansible](https://www.packtpub.com/virtualization-and-cloud/learn-ansible))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
