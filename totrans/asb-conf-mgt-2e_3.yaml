- en: Chapter 3. Advanced Playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The playbooks that we have looked at so far are simple and just run a number
    of modules in order. Ansible allows much more control over the execution of your
    playbook. Using the following techniques, you should be able to perform even the
    most complex deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: Running operations in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External data lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running operations in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Ansible will only fork up to five times, so it will only run an
    operation on five different machines at once. If you have a large number of machines,
    or you have lowered this maximum fork value, then you may want to launch things
    asynchronously. Ansible's method for performing this is to launch the task and
    then poll for it to complete. This allows Ansible to start the job across all
    the required machines while still using the maximum forks.
  prefs: []
  type: TYPE_NORMAL
- en: To run an operation in parallel, use the `async` and `poll` keywords. The `async`
    keyword triggers Ansible to run the job in parallel, and its value will be the
    maximum time that Ansible will wait for the command to complete. The value of
    `poll` indicates to Ansible how often to poll to check if the command has been
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to run `updatedb` across an entire cluster of machines, it might
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that when you run the previous example on more than five machines,
    the `yum` module acts differently to the `command` module. The `yum` module will
    run on the first five machines, then the next five, and so on. The `command` module,
    however, will run across all the machines and indicate the status once complete.
  prefs: []
  type: TYPE_NORMAL
- en: If your command starts a daemon that eventually listens on a port, you can start
    it without polling so that Ansible does not check for it to complete. You can
    then carry on with other actions and check for completion later using the `wait_for`
    module. To configure Ansible to not wait for the job to complete, set the value
    of `poll` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if your task takes an extremely long time to run, you can tell Ansible
    to wait for the job as long as it takes. To do this, set the value of `async`
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will want to use Ansible''s polling in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a long-running task that may hit the timeout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to run an operation across a large number of machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have an operation for which you don't need to wait to complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a few situations where you should not use `async` or `poll`:'
  prefs: []
  type: TYPE_NORMAL
- en: If your job acquires locks that prevent other things from running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your job only takes a short time to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows you to repeat a module several times with different inputs, for
    example, if you had several files that should have similar permissions set. This
    can save you a lot of repetition and allows you to iterate over facts and variables.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you can use the `with_items` key on an action and set the value
    to the list of items that you are going to iterate over. This will create a variable
    for the module named `item`, which will be set to each item in turn as your module
    is iterated over. Some modules such as `yum` will optimize this so that instead
    of doing a separate transaction for each package, they will operate on all of
    them at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `with_items`, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In addition to looping over fixed items, or a variable, Ansible also provides
    us a tool called **lookup plugins**. These plugins allow you to tell Ansible to
    fetch the data from somewhere externally. For example, you might want to find
    all the files that match a particular pattern, and then upload them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we upload all the public keys in a directory and then assemble
    them into an `authorized_keys` file for the root user, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeating modules can be used in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Repeating a module many times with similar settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over all the values of a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating many files for later use with the `assemble` module to combine into
    one large file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a directory of files when combined with the `with_fileglob` lookup plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some modules, such as the `copy` module, provide mechanisms to configure it
    to skip the execution of the module. You can also configure your own skip conditions
    that will only execute the module if they resolve to `true`. This can be handy
    if your servers use different packaging systems or have different filesystem layouts.
    It can also be used with the `set_fact` module to allow you to compute many different
    things.
  prefs: []
  type: TYPE_NORMAL
- en: To skip a module, you can use the `when` key; this lets you provide a condition.
    If the condition you set resolves to false, then the module will be skipped. The
    value that you assign to `when` is a Python expression. You can use any of the
    variables or facts available to you at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to process some of the items in the list depending on a condition,
    then simply use the `when` clause. The `when` clause is processed separately for
    each item in the list; the item being processed is available as a variable using
    `{{ item }}`.
  prefs: []
  type: TYPE_NORMAL
- en: The following code is an example showing how to choose between `apt` and `yum`
    for both Debian and Red Hat systems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is also a third clause to print a message and fail if the OS is not recognized.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This feature can be used to pause at a particular point and will wait for the
    user intervention to continue. Normally, when Ansible encounters an error, it
    will simply stop what it is doing without running any handlers. With this feature,
    you can add the `pause` module with a condition on it that triggers in unexpected
    situations. This way the `pause` module will be ignored in a normal situation;
    however, in unexpected circumstances, it will allow the user to intervene and
    continue when it is safe to do so. The task would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are numerous uses of skipping actions; here are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Working around differences in operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompting a user and only then performing actions that they request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance by avoiding a module that you know won't change anything
    but may take a while to do so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refusing to alter systems that have a particular file present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if custom scripts have already been run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible, by default, runs its tasks all at once on the configured machine. This
    is great when you have a whole bunch of separate machines to configure, or if
    each of your machines is responsible for communicating its status to the other
    remote machines. However, if you need to perform an action on a different host
    than the one Ansible is operating on, you can use a delegation.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can be configured to run a task on a different host other than the one
    that is being configured using the `delegate_to` key. The module will still run
    once for every machine, but instead of running on the target machine, it will
    run on the delegated host. The facts available will be the ones applicable to
    the current host. Here, we show a playbook that will use the `get_url` option
    to download the configuration from a bunch of web servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are delegating to the `localhost`, you can use a shortcut when defining
    the action that automatically uses the local machine. If you define the key of
    the action line as `local_action`, then the delegation to `localhost` is implied.
    If we were to have used this in the previous example, it would be slightly shorter
    and will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Delegation is not limited to the local machine. You can delegate to any host
    that is in the inventory. Some other reasons why you might want to delegate are:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a host from a load balancer before deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing DNS to direct traffic away from a server you are about to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an iSCSI volume on a storage device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an external server to check whether access outside the network works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have seen in our template example in the previous chapter that we used
    a variable named `group_names`. This is one of the magic variables that are provided
    by Ansible itself. At the time of writing, there are seven such variables, which
    are described in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: The hostvars variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `hostvars` variable allows you to retrieve variables of all the hosts that
    the current play has dealt with. If the `setup` module hasn't yet been run on
    that managed host in the current play, only its variables will be available. You
    can access it like you would access other complex variables, such as `${hostvars.hostname.fact}`,
    so to get the Linux distribution running on a server named `ns1`, it would be
    `${hostvars.ns1.ansible_distribution}`. The following example sets a variable
    called zone master to the server named `ns1`. It then calls the `template` module,
    which would use this to set the masters for each zone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `hostvars`, you can further abstract templates from your environment.
    If you nest your variable calls, then instead of placing an IP address in the
    variable section of the play, you can add the hostname. To find the address of
    a machine named in the `the_machine` variable you would use, `{{ hostvars.[the_machine].default_ipv4.address
    }}`.
  prefs: []
  type: TYPE_NORMAL
- en: The groups variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `groups` variable contains a list of all hosts in the inventory grouped
    by the inventory group. This lets you get access to all the hosts that you have
    configured. This is potentially a very powerful tool. It allows you to iterate
    across a whole group and for every host apply an action to the current machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `groups` variable does not contain the actual hosts in the group; it contains
    strings representing their names in the inventory. This means you have to use
    nested variable expansion to get to the `hostvars` variable, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even use this variable to create the `known_hosts` files for all of
    your machines containing the `host` keys of all the other machines. This would
    allow you to then SSH from one machine to another without confirming the identity
    of the remote host. It would also handle removing machines when they leave service
    or updating them when they are replaced. The following is a template for a `known_hosts`
    file that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The playbook that uses this template would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The group_names variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `group_names` variable contains a list of strings with the names of all
    the groups the current host is in. This is not only useful for debugging, but
    also for conditionals detecting group membership. This was used in the last chapter
    to set up a nameserver.
  prefs: []
  type: TYPE_NORMAL
- en: 'This variable is mostly useful for skipping a task or in a template as a condition.
    For instance, if you had two configurations for the SSH daemon, one secure and
    one less secure, but you only wanted the secure configuration on the machines
    in the secure group, you would do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, we used the `set_fact` module to set the fact for each
    case, and then used the `copy` module. We could have used the `copy` module in
    place of the `set_facts` modules and used one fewer task. The reason this was
    done is that the `set_fact` module runs locally and the `copy` module runs remotely.
    When you use the `set_facts` module first and only call the `copy` module once,
    the copies are made on all the machines in parallel. If you used two `copy` modules
    with conditions, then each would execute on the relevant machines separately.
    Since `copy` is the longer task of the two, it benefits the most from running
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory_hostname variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inventory_hostname` variable stores the hostname of the server as recorded
    in the inventory. You should use this if you have chosen not to run the `setup`
    module on the current host, or if for various reasons, the value detected by the
    `setup` module is not correct. This is useful when you are doing the initial setup
    of the machine and changing the hostname.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory_hostname_short variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inventory_hostname_short` variable is the same as the previous variable;
    however, it only includes the characters up to the first dot. So for `host.example.com`,
    it would return `host`.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory_dir variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inventory_dir` variable is the path name of the directory containing the
    inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory_file variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inventory_file` variable is the same as the previous one, except that it
    also includes the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Finding files with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All modules can take variables as part of their arguments by dereferencing
    them with `{{` and `}}`. You can use this to load a particular file based on a
    variable. For example, you might want to select a different `config` file for
    NRPE (a Nagios check daemon) based on the architecture in use. Here is how that
    would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `copy` and the `template` modules, you can also configure Ansible to
    look for a set of files, and it finds them using the first one. This lets you
    configure a file to look for; if that file is not found, a second will be used,
    and so on until the end of the list is reached. If the file is not found, then
    the module will fail. The feature is triggered using the `first_available_file`
    key, and referencing `{{ item }}` in the action. The following code is an example
    of this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that you can run the setup module from the Ansible command-line tool.
    This comes in handy when you are making heavy use of variables in your playbooks
    or templates. To check what facts will be available for a particular play, simply
    copy the value of the host pattern and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On a CentOS x86_64 machine, this configuration will first look for the `RedHat-x86_64.cfg`
    file upon navigating through `files/apache/`. If that file does not exist, it
    will look for the `default-x86_64.cfg` file upon navigating through `file/apache/`,
    and finally if nothing exists, it'll try and use `default.cfg`.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, Unix commands take advantage of certain environment variables. Prevalent
    examples of this are C makefiles, installers, and the AWS command-line tools.
    Fortunately, Ansible makes this really easy. If you want to upload a file on the
    remote machine to Amazon S3, you can set the Amazon access key as follows. You
    will also see that we install EPEL so that we can install pip, and pip is used
    to install the AWS tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, Ansible sets the environment variable into the Python code; this
    means any module that already uses environment variables can take advantage of
    the ones set here. If you write your own modules, you should consider if certain
    arguments would be better used as environment variables instead of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Ansible modules, such as `get_url`, `yum`, and `apt`, will also use environment
    variables to set their proxy server. Some of the other situations where you might
    want to set environment variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Running application installers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding extra items to the path when using the `shell` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading libraries from a place not included in the system library search path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an `LD_PRELOAD` hack while running a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External data lookups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible introduced the lookup plugins in version 0.9\. These plugins allow Ansible
    to fetch data from outside sources. Ansible provides several plugins, but you
    can also write your own. This really opens the doors and allows you to be flexible
    in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lookup plugins are written in Python and run on the controlling machine. They
    are executed in two different ways: direct calls and `with_*` keys. Direct calls
    are useful when you want to use them like you would use variables. Using the `with_*`
    keys is useful when you want to use them as loops. In an earlier section, we covered
    `with_fileglob`, which is an example of this.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we use a lookup plugin directly to get the `http_proxy`
    value from `environment` and send it through to the configured machine. This makes
    sure that the machines we are configuring will use the same proxy server to download
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use lookup plugins in the variable section. This doesn't immediately
    lookup the result and put it in the variable as you might assume; instead, it
    stores it as a macro and looks it up every time you use it. This is good to know
    if you are using something, the value of which might change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Using lookup plugins in the `with_*` form will allow you to iterate over things
    you wouldn't normally be able to. You can use any plugin like this, but ones that
    return a list are most useful. In the following code, we show how to dynamically
    register a `webapp` farm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you were using this example, you would append a task to create each as a
    virtual machine and then a new play to configure each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Situations where lookup plugins are useful are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying a whole directory of Apache config to a `conf.d` style directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using environment variables to adjust what the playbooks does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting configuration from DNS TXT records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching the output of a command into a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every module outputs something, even the `debug` module. Most of the
    time, the only variable used is the one named `changed`. The `changed` variable
    helps Ansible decide whether to run handlers or not and which color to print the
    output in. However, if you wish to, you can store the returned values and use
    them later in the playbook. In this example, we look at the mode in the `/tmp`
    directory and create a new directory named `/tmp/subtmp` with the same mode as
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Some modules, such as the `file` module in the previous example, can be configured
    to simply give information. By combining this with the register feature, you can
    create playbooks that can examine the environment and calculate how to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Combining the register feature and the `set_fact` module allows you to perform
    data processing on data you receive back from the modules. This allows you to
    compute values and perform data processing on these values. This makes your playbooks
    even smarter and more flexible than ever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register allows you to make your own facts about hosts from modules already
    available to you. This can be useful in many different circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a list of files in a remote directory and downloading them all with
    fetch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task when a previous task changes, before the handlers run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the contents of the remote host SSH key and building a `known_hosts`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible uses Jinja2 filters to allow you to transform data in ways that aren''t
    possible with basic templates. We use filters when the data available to us in
    our playbooks is not in the format we want, or require further complex processing
    before it can be used with modules or templates. Filters can be used anywhere
    we would normally use a variable, such as in templates, as arguments to modules,
    and in conditionals. Filters are used by providing the variable name, a pipe character,
    and then the filter name. We can use multiple filter names separated with pipe
    characters to use multiple pipes, which are then applied left to right. Here is
    an example where we ensure that all users are created with lowercase usernames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few popular filters that you may find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Filter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | When the argument is a list it returns only the smallest value. |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | When the argument is a list it returns only the largest value. |'
  prefs: []
  type: TYPE_TB
- en: '| `random` | When the argument is a list it picks a random item from the list.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `changed` | When used on a variable created with the register keyword, it
    returns `true` if the task changed anything; otherwise, it returns `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `failed` | When used on a variable created with the register keyword, it
    returns `true` if the task failed; otherwise, it returns `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `skipped` | When used on a variable created with the register keyword, it
    returns `true` if the task changed anything; otherwise, it returns `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `default(X)` | If the variable does not exist, then the value of X will be
    used instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `unique` | When the argument is a list, return a list without any duplicate
    items. |'
  prefs: []
  type: TYPE_TB
- en: '| `b64decode` | Convert the base64 encoded string in the variable to its binary
    representation. This is useful with the slurp modules, as it returns its data
    as a base64 encoded string. |'
  prefs: []
  type: TYPE_TB
- en: '| `replace(X, Y)` | Return a copy of the string with any occurrences of `X`
    replaced by `Y`. |'
  prefs: []
  type: TYPE_TB
- en: '| `join(X)` | When the variable is a list, return a string with all the entries
    separated by `X`. |'
  prefs: []
  type: TYPE_TB
- en: Debugging playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few ways in which you can debug a playbook. Ansible includes both
    a verbose mode and a `debug` module specifically for debugging. You can also use
    modules such as `fetch` and `get_url` for help. These debugging techniques can
    also be used to examine how modules behave when you wish to learn how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The debug module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `debug` module is really quite simple. It takes two optional arguments,
    `msg` and `fail.msg` to set the message that will be printed by the module and
    `fail`, if set to `yes`, indicates a failure to Ansible, which will cause it to
    stop processing the playbook for that host. We used this module earlier in the
    skipping modules section to bail out of a playbook if the operating system was
    not recognized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will show how to use the `debug` module to list
    all the interfaces available on the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `debug` module is easy to use to see the current value of
    a variable during the play.
  prefs: []
  type: TYPE_NORMAL
- en: The verbose mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your other option for debugging is the verbose option. When running Ansible
    with verbose, it prints out all the values that were returned by each module after
    it runs. This is especially useful if you are using the `register` keyword introduced
    in the previous section. To run `ansible-playbook` in verbose mode, simply add
    `--verbose` to your command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The check mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the verbose mode, Ansible also includes a check mode and a diff
    mode. You can use the check mode by adding `--check` to the command line, and
    `--diff` to use the diff mode. The check mode instructs Ansible to walk through
    the play without actually making any changes to remote systems. This allows you
    to obtain a listing of the changes that Ansible plans to make to the configured
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important here to note that the check mode of Ansible is not perfect.
    Any modules that do not implement the check feature are skipped. Additionally,
    if a module is skipped that provides more variables, or the variables depend on
    a module actually changing something (such as file size), then they will not be
    available. This is an obvious limitation when using the `command` or `shell` modules
  prefs: []
  type: TYPE_NORMAL
- en: The diff mode shows the changes that are made by the `template` module. This
    limitation is because the `template` file only works with text files. If you were
    to provide a diff of a binary file from the copy module, the result would almost
    be unreadable. The diff mode also works with the check mode to show you the planned
    changes that were not made due to being in check mode.
  prefs: []
  type: TYPE_NORMAL
- en: The pause module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another technique is to use the `pause` module to pause the playbook while you
    examine the configured machine as it runs. This way, you can see changes that
    the modules have made at the current position in the play, and then watch while
    it continues with the rest of the play.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the more advanced details of writing playbooks.
    You should now be able to use features such as delegation, looping, conditionals,
    and fact registration to make your plays much easier to maintain and edit. We
    also looked at how to access information from other hosts, configure the environment
    for a module, and gather data from external sources. Finally, we covered some
    techniques for debugging plays that are not behaving as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be covering how to use Ansible in a larger environment.
    It will include methods for improving the performance of your playbooks that might
    be taking a long time to execute. We will also cover a few more features that
    make plays maintainable, particularly splitting them into many parts by purpose.
  prefs: []
  type: TYPE_NORMAL
