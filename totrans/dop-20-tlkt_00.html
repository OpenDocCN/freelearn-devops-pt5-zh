<html><head></head><body><div class="preface" title="Preface"><div class="titlepage"><div><div><h1 class="title"><a id="pref04"/>Preface</h1></div></div></div><p>I started my career as a developer. During those early days, all I knew (and thought I should know) was to write code. I believed that a great software designer is a person that is proficient in writing code and that the path to the mastery of the craft was to know everything about a single programming language of choice. Later on, that changed and I started taking an interest in different programming languages. I switched from Pascal to Basic and then ASP. When Java and, later on, .Net came into existence, I learned benefits of object oriented programming. Python, Perl, Bash, HTML, JavaScript, Scala. Each programming language brought something new and taught me how to think differently and how to pick the right tool for the task at hand. With each new language I learned, I felt like I was closer to being an expert. All I wanted was to become a senior programmer. That desire changed with time. I learned that if I was to do my job well, I had to become a <span class="emphasis"><em>software craftsman</em></span>. I had to learn much more than to type code. Testing became my obsession for some time, and now I consider it an integral part of development. Except in very special cases, each line of code I write is done with <span class="strong"><strong>test-driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>). It became an indispensable part of my tool-belt. I also learned that I had to be close to the customer and work with him side by side while defining what should be done. All that and many other things led me to <span class="emphasis"><em>software architecture</em></span>. Understanding the big picture and trying to fit different pieces into one big system was the challenge that I learned to like.</p><p>Throughout all the years I've been working in the software industry, there was no single tool, framework or practice that I admired more than <span class="strong"><strong>continuous integration</strong></span> (<span class="strong"><strong>CI</strong></span>) and, later on, <span class="strong"><strong>continuous delivery</strong></span> (<span class="strong"><strong>CD</strong></span>). The real meaning of that statement hides behind the scope of what CI/CD envelops. In the beginning, I thought that CI/CD means that I knew <span class="emphasis"><em>Jenkins</em></span> and was able to write scripts. As the time passed I got more and more involved and learned that CI/CD relates to almost every aspect of software development. That knowledge came at a cost.</p><p>I failed (more than once) to create a successful CI pipeline with applications I worked with at the time. Even though others considered the result a success, now I know that it was a failure because the approach I took was wrong. CI/CD cannot be done without making architectural decisions. Similar can be said for tests, configurations, environments, fail-over, and so on. To create a successful implementation of CI/CD, we need to make a lot of changes that, on the first look, do not seem to be directly related. We need to apply some patterns and practices from the very beginning. We have to think about architecture, testing, coupling, packaging, fault tolerance, and many other things. CI/CD requires us to influence almost every aspect of software development. That diversity is what made me fall in love with it. By practicing CI/CD we are influencing and improving almost every aspect of the software development life cycle.</p><p>To be truly proficient with CI/CD, we need to be much more than experts in operations. The DevOps movement was a significant improvement that combined traditional operations with advantages that development could bring. I think that is not enough. We need to know and influence architecture, testing, development, operations and even customer negotiations if we want to gain all the benefits that CI/CD can bring. Even the name DevOps as the driving force behind the CI/CD is not suitable since it's not only about development and operations but everything related to software development. It should also include architects, testers, and even managers. DevOps was a vast improvement when compared to the traditional operations by combining them with development. The movement understood that manually running operations is not an option given current business demands and that there is no automation without development. I think that the time came to redefine DevOps by extending its scope. Since the name <span class="emphasis"><em>DevOpsArchTestManageAndEverythingElse</em></span> is too cumbersome to remember and close to impossible to pronounce, I opt for <span class="strong"><strong>DevOps 2.0</strong></span>. It's the next generation that should drop the heavy do-it-all products for smaller tools designed to do very specific tasks. It's the switch that should go back to the beginning and not only make sure that operations are automated but that the whole system is designed in a way that it can be automated, fast, scalable, fault-tolerant, with zero-downtime, easy to monitor, and so on. We cannot accomplish this by simply automating manual procedures and employing a single do-it-all tool. We need to go much deeper than that and start refactoring the whole system both on the technological as well as the procedural level.</p><div class="section" title="Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch00lvl1sec02"/>Overview</h1></div></div></div><p>This book is about different techniques that help us architect software in a better and more efficient way with <span class="emphasis"><em>microservices</em></span> packed as <span class="emphasis"><em>immutable containers</em></span>, <span class="emphasis"><em>tested</em></span> and <span class="emphasis"><em>deployed continuously</em></span> to servers that are <span class="emphasis"><em>automatically provisioned</em></span> with <span class="emphasis"><em>configuration management</em></span> tools. It's about fast, reliable and continuous deployments with <span class="emphasis"><em>zero-downtime</em></span> and ability to <span class="emphasis"><em>roll-back</em></span>. It's about <span class="emphasis"><em>scaling</em></span> to any number of servers, design of <span class="emphasis"><em>self-healing systems</em></span> capable of recuperation from both hardware and software failures and about <span class="emphasis"><em>centralized logging and monitoring</em></span> of the cluster.</p><p>In other words, this book envelops the whole microservices development and deployment lifecycle using some of the latest and greatest practices and tools. We'll use Docker, Kubernetes, Ansible, Ubuntu, Docker Swarm and Docker Compose, Consul, etcd, Registrator, confd, Jenkins, and so on. We'll go through many practices and, even more, tools.</p><p>Finally, while there will be a lot of theory, this is a hands-on book. You won't be able to complete it by reading it in a metro on a way to work. You'll have to read this book while in front of a computer getting your hands dirty. Eventually, you might get stuck and in need of help. Or you might want to write a review or comment on the book's content. Please post your thoughts on the The DevOps 2.0 Toolkit channel in Disqus. If you prefer one-on-one discussion, feel free to send me an email to <code class="email">&lt;<a class="email" href="mailto:viktor@farcic.com">viktor@farcic.com</a>&gt;</code>, or to contact me on HangOuts, and I'll give my best to help you out.</p></div></div>
<div class="section" title="Audience"><div class="titlepage"><div><div><h1 class="title"><a id="ch00lvl1sec03"/>Audience</h1></div></div></div><p>This book is for professionals interested in the full microservices lifecycle combined with continuous deployment and containers. Due to the very broad scope, target audience could be <span class="emphasis"><em>architects</em></span> who want to know how to design their systems around microservices. It could be <span class="emphasis"><em>DevOps</em></span> wanting to know how to apply modern configuration management practices and continuously deploy applications packed in containers. It is for <span class="emphasis"><em>developers</em></span> who would like to take the process back into their hands as well as for <span class="emphasis"><em>managers</em></span> who would like to gain a better understanding of the process used to deliver software from the beginning to the end. We'll speak about scaling and monitoring systems. We'll even work on the design (and implementation) of self-healing systems capable of recuperation from failures (be it of hardware or software nature). We'll deploy our applications continuously directly to production without any downtime and with the ability to rollback at any time.</p><p>This book is for <span class="emphasis"><em>everyone wanting to know more about the software development lifecycle</em></span> starting from requirements and design, through development and testing all the way until deployment and post-deployment phases. We'll create the processes taking into account best practices developed by and for some of the biggest companies.</p></div></body></html>