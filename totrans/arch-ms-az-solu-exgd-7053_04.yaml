- en: Implementing Serverless and Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the objective of web applications. You read
    about web applications, App Service plans, containers, Web APIs, and more. You
    should now be aware of when to use these different features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces serverless and microservices. It will cover serverless
    computing and what Azure has to offer regarding the creation of serverless applications,
    such as Azure Functions and Azure Logic Apps. You will read about how to design
    for serverless computing using Azure Containers and API Management. Finally, microservices-based
    solutions are covered. You will learn about containers for microservices and the
    different platforms that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven actions using Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing applications using Azure Functions and Logic Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing for serverless computing using Azure Container Instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container orchestrations and the different container orchestration platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Fabric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-native deployments versus migrating assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter uses the following tools for the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure PowerShell: [https://docs.microsoft.com/en-us/powershell/azure/install-azurerm-ps?view=azurermps-5.1.1](https://docs.microsoft.com/en-us/powershell/azure/install-azurerm-ps?view=azurermps-5.1.1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/SjoukjeZaal/AzureArchitectureBook/tree/master/Chapter%204](https://github.com/SjoukjeZaal/AzureArchitectureBook/tree/master/Chapter%204)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven actions using Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions is a serverless compute service that enables you to create event-driven
    actions and triggers without the need to provision or manage your own infrastructure.
    In Azure Functions, you can run a script or custom code that responds to events
    from Azure, third-party services, or on-premises systems. You can build HTTP-based
    API endpoints (called HTTP triggers) that can be accessed by a wide range of applications,
    as well as mobile and IoT devices. You can also create **timer triggers**, which
    can run based on a schedule. With Azure Functions, you pay only for the resources
    you consume.
  prefs: []
  type: TYPE_NORMAL
- en: Functions use an Azure storage account to store code and configuration bindings.
    It uses the standard Azure Storage, which provides blob, table, and queue storage
    for storing the files and triggers. You can use the same App Service plans for
    your functions as you use for web apps and APIs. Azure Functions can also be deployed
    in **App Service Environments** (**ASEs**).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about Azure Functions and which events and triggers it
    supports, you can refer to the following site: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the different App Service plans and ASEs, you can
    refer to [Chapter 3](de2f1b21-edb1-4616-a8ff-8fbf484459a0.xhtml), *Designing Web
    Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions can be created from the Azure Portal and from Visual Studio
    2017 and can be created in a variety of programming languages, such as C#, F#,
    Node.js, Java, PHP, Batch, PowerShell, JavaScript, Python, and TypeScript. They
    can be created using ARM templates as well. They can be deployed on Windows or
    Linux and by using continuous deployment. At the time of writing this book, it
    supports Bitbucket, Dropbox, external repositories (Git or Mercurial), a Git local
    repository, GitHub, OneDrive, and Visual Studio Team Services as a deployment
    source. Continuous deployment can be configured from the Azure Portal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5de12eaf-3a26-4d5b-889f-4d981dcf515e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Continuous deployment for Azure Functions
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Functions tools in Visual Studio have been included since the 15.3
    release. If you want to create them using Visual Studio 2017, update Visual Studio
    to at least version 15.3 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Consumption App Service plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Azure Functions, Microsoft introduced a new hosting plan where you share
    a pool of instances with functions from other customers. This plan is called the
    **Consumption plan**. This plan is more cost effective then the other available
    App Service plans because it automatically scales down and up, depending on the
    workload. When your function isn't running, you don't have to pay anything and
    when the function is running, instances are added dynamically and removed based
    on the number of incoming events. Functions hosted on the Consumption plan can
    run for a maximum of 10 minutes (the default timeout is 5 minutes, but this can
    be increased to 10 minutes). The Azure Function code and the binding configurations
    are stored on Azure File Storage on a separate storage account.
  prefs: []
  type: TYPE_NORMAL
- en: When you need your function to run continuously, or for it to run in the same
    App Service plan as other functions, or you need more CPU power, or you want to
    host your function on Linux, then it is best to use a dedicated App Service plan
    for your functions. All the other available App Service plans can be used for
    Azure Functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Designing application solutions using Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this demo, we are creating an Azure Function from the Azure Portal. This
    function is going to listen to an HTTP trigger and then add a message to a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Azure Portal by opening [https://portal.azure.com/](https://portal.azure.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New and and type `Function App` in the search bar. Click the Create
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A new blade opens up, where you can fill in the basic settings of the function.
    For the hosting plan, we are using a queue to store messages. When using the Consumption
    plan, queue storage is not part of your storage account, because it only uses
    Azure File Storage to store the function files. For the App Service plan, you
    can create a new App Service plan or pick an existing one. You can choose an ASE
    here as well. For the storage, by default, a new storage account is created. If
    you want to use an existing storage account, you can choose that as well. Add
    the following details and click on Create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f02aab3-b11f-4606-8b68-2e8cf231d3a8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an Azure Function from the Azure Portal
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, open the function from the Azure Portal and, in the left-hand
    menu, under Function Apps, select Functions | New function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22bd157f-d91c-4f40-9280-35ff67dce9ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Functions wizard from the Azure Portal
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, select HTTP trigger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/765be821-8502-44a7-a226-0a34dc34e7f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the HTTP trigger
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the HTTP trigger settings. Fill in the following values. For
    the Authorization level, you can choose Anonymous right now. However, this is
    only for demo purposes; you should not choose that for your production functions.
    Click on Create and the trigger is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb84923d-4f63-490e-90fa-aacf42e651fd.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTP trigger settings
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the queue settings, click on Integrate | New Output and then select
    Azure Queue Storage. Click on Select:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4a7f0fa-79f2-48cc-affd-b9cc0fd1cd2f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configure queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Azure Queue Storage output, keep the default settings and click on Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d74b84a-afab-47cf-a069-68c8c3c55eb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Configure queue
  prefs: []
  type: TYPE_NORMAL
- en: 'In the left-hand menu, select your function. The code editor will open. Replace
    the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds a message inside the queue and then you need to click
    on Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the code, click the Test tab on the right-hand side of the screen.
    You can provide a message inside the JSON call and click on Save and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09dc3fd5-8780-49b1-ac74-5faf6fae7d8d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the function
  prefs: []
  type: TYPE_NORMAL
- en: 'The default code generates an output message, which is displayed inside the
    output window. To see what is added to the queue, open the Azure Storage Explorer
    and connect to your Azure account using your credentials. In the left-hand tree
    view, navigate to the function storage account and click on Queues. The added
    message can be found there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9798bf78-5bfa-4905-9843-e4fe2527c72f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Queue message inside the Azure Storage Explorer
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Storage Explorer is part of the Azure Tools for Visual Studio. You
    can view blob, queue, and table data from your storage accounts in Azure. You
    can also download the Azure Storage Explorer from this direct link: [https://go.microsoft.com/fwlink/?LinkId=708343&clcid=0x409](https://go.microsoft.com/fwlink/?LinkId=708343&clcid=0x409).
  prefs: []
  type: TYPE_NORMAL
- en: Durable Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this book, Durable Functions is still in preview. Durable
    Functions is an extension of Azure Functions and Azure WebJobs, and it provides
    the ability to create stateful functions with state management capabilities, checkpoints,
    and a restarting mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'It introduces a new orchestrator function that has a couple of advantages.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Workflows can be created in code; JSON schemas are not needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can call other functions synchronously and asynchronously. The output can
    be stored in local variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It saves the state of the function when VMs are waiting and rebooting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workflow-driven applications using Logic Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logic Apps, another service for the serverless offering from Azure, has a lot
    of overlap with Azure Functions. They can both be used to integrate apps or services.
    The main difference between the two is that Azure Functions are event-driven and
    Logic Apps are more workflow-driven. You can use Logic Apps to automate your business
    processes using a visual designer from the Azure Portal (developers can create
    them in Visual Studio as well), whereas Azure Functions are completely written
    in code. You can, however, call Azure Functions from within a Logic App.
  prefs: []
  type: TYPE_NORMAL
- en: With Logic Apps, you can build apps that integrate numerous cloud services and
    on-premises applications. These can be Azure services, third-party cloud services,
    different data stores and databases, and LOB applications. Azure Logic Apps provide
    a number of pre-built connectors that you leverage inside your workflow. Besides
    that, you can also create your own connectors using Visual Studio. Each connector
    provides an API, which can be called from inside the Logic App. Authentication
    is added to this connector as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the following article for an overview of all the available
    connectors for Azure Logic Apps: [https://docs.microsoft.com/en-us/azure/connectors/apis-list](https://docs.microsoft.com/en-us/azure/connectors/apis-list).
  prefs: []
  type: TYPE_NORMAL
- en: Besides using the Visual Editor, you can create and make adjustments to the
    Workflow Definition Language schema manually as well. This schema is created using
    JSON and can be created from scratch using Visual Studio or can be adjusted inside
    the Azure Portal. They both use the Code View editor (Visual Studio uses the same
    editor as the Azure Portal).
  prefs: []
  type: TYPE_NORMAL
- en: Some capabilities can only be added to the schema directly and cannot be made
    from the Visual Editor. Examples of this are date and time formatting and string
    concatenation. Logic App definition files can be added to ARM templates and deployed
    using PowerShell, CLI, or REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the JSON code-behind file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Designing application solutions using Logic Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this demo, we are creating the same functionality as we did in the previous
    Azure Function demo. We are adding a message to a queue. This way, you can see
    the difference between an event-driven approach and a workflow-driven approach.
    The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Azure Portal by opening [https://portal.azure.com/](https://portal.azure.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New and and type `Logic App` in the search bar. Click on the Create button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A new blade opens up where you can fill in the basic settings of the Logic
    App. Add the following and click on Create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3f69971f-5971-41a5-b574-1da856d74de7.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Logic App settings
  prefs: []
  type: TYPE_NORMAL
- en: 'When you navigate to the Logic App in the Azure Portal, the designer is opened.
    Click on the HTTP request trigger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e231e0d-5d04-4438-aac2-ed2868c2e2a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Logic App designer
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow canvas will open. Click the top action, When a HTTP request is
    received, and add the following JSON schema to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0a3aa0c7-de34-4514-a8dc-80a604acd707.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Logic App designer
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on New step to add an action. Click Add an Action, and inside the search
    box type `Azure Queue`. Select Azure Queues - Put a message on a queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5fa5b0b3-6ad1-4259-bf9e-61a4d22709f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Add action in the Azure Logic App designer
  prefs: []
  type: TYPE_NORMAL
- en: Give your connection a name, such as `PacktQueueConnection`. You can then select
    a storage account from the different storage accounts that are available inside
    your Azure subscription. Pick the one that is used for the Azure Function as well.
    Click on Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the outqueue and add the following message: `Name passed to the Logic
    App:`. Then add the name parameter after the colon and click on Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/714baf35-dd8a-468e-9964-0df450cf5633.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the message
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Overview settings page of the Logic App and copy the Callback url
    to the clipboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/965e4a3d-c989-4e43-be2f-0a2ac117a3be.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving the API request URL
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open Postman, or some other tool for testing APIs, and paste the request
    URL. Add the same message to the Body as we used in the Azure Function example
    and click Enter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/775b194a-4793-4a33-bb98-d2643fc15d21.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a POST request in Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Azure Storage Explorer tool again and you''ll see the queue message
    created by the Logic App in there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90db17a5-c962-4042-955a-7c657e856fd8.png)'
  prefs: []
  type: TYPE_IMG
- en: Queue message created by the Logic App
  prefs: []
  type: TYPE_NORMAL
- en: Postman can be downloaded from the following URL: [https://www.getpostman.com/](https://www.getpostman.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Designing for serverless computing using Azure Container Instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are a broadly accepted open standard, and have significantly changed
    the way applications are developed and deployed. A container is an application
    packaging and deployment mechanism that simplifies the way we develop and deploy
    software. With the use of a container, we can add all the different artifacts
    that make the application run, such as configuration files, databases, and Web
    APIs, in an isolated package and deploy it everywhere. This eliminates unexpected
    failures that usually pop up when deploying software to different environments,
    such as development, test, or production environments. And any further knowledge
    of those different environments, such as which operating system it's using, is
    not needed anymore. If your application runs on your development environment,
    it will run on all environments. Because of the isolation, containers also solve
    the problem of running different versions of runtimes or applications that can
    interfere with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Azure provides **Azure Container Instances** (**ACI**), which provide a hosted
    environment for running containers in Azure without managing the VMs and the underlying
    infrastructure. One ACI is a single Docker container, and you pay only for the
    resources you consume (per second for each running instance). It offers **Role-Based
    Access Control **(**RBAC**) on the instance, and you can track the usage at the
    individual container level. Containers can be deployed on Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Containers can be created using PowerShell, CLI, and in the Azure Portal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers can be easily created. In this example, the container is created
    from the CLI, with only a few parameters. To create a container, open the Azure
    Cloud Shell from the Azure Portal, select the `Bash` tab, and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This step is optional. You can use this if you want to check and change the
    default selected Azure subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the resource group and the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also install CLI 2.0 on your Windows device using the following URL: [https://azure.microsoft.com/nl-nl/blog/azure-cli-2-0-new-commands-features-available-now-in-azure-cloud-shell/](https://azure.microsoft.com/nl-nl/blog/azure-cli-2-0-new-commands-features-available-now-in-azure-cloud-shell/).
  prefs: []
  type: TYPE_NORMAL
- en: Container orchestrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A set of containers is managed by a container orchestration. An orchestration
    provides a single entity from where you manage scheduling, scaling, health monitoring,
    failover, networking, and application upgrades for your container instances. Also,
    continuous integration and continuous deployment are handled at the orchestration
    level.
  prefs: []
  type: TYPE_NORMAL
- en: ACI offers a layered approach for orchestrating your containers. ACI provides
    you with the features to manage one single container. It can manage simple applications,
    task automation, and build jobs for the isolated containers. For more advanced
    scenarios, where you need full container orchestration, including service discovery
    across multiple containers, automatic scaling, and coordinated application upgrades,
    you need to use orchestration platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration platforms handle the tasks of managing a cluster of containers.
    The orchestration platform is only responsible for the multi-container architecture and
    doesn't have to worry about the underlying infrastructure because this is handled
    by Azure (using ACI).
  prefs: []
  type: TYPE_NORMAL
- en: 'Container orchestrations offer the following features and capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scaling**: The orchestrator can add or remove container instances. This can
    be done manually or automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery**: This allows containers to locate each other, even when
    the IP addresses are changed, and when the containers are moved between physical
    host machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: This provides a network that can be used by the underlying
    containers for communication across multiple host machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling**: The scheduler will use the container image and the resource
    request to locate a suitable VM to run the container on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health monitoring**: This monitors the health of the containers and can automatically
    provide rescheduling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application upgrades**: This provides coordinated container upgrades and
    rollbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failover**: This checks the current state of the machines and reschedules
    containers from unhealthy to healthy machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affinity/anti-affinity**: This determines that a set of containers should
    run near each other to improve the performance of the application, or far away
    from each other to improve the availability of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure offers support for different orchestration platforms. Platforms that are
    supported on Azure are Azure Container Service (AKS), Kubernetes, DC/OS (powered
    by Apache Mesos), Docker Swarm, and Azure Service Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Service Fabric is an orchestration platform from Microsoft that can be
    used to deploy, manage, and package microservices and containers. It is similar
    to Docker Cloud and Kubernetes, where Service Fabric is fully bound to the Azure
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the three is that Service Fabric is the only one that
    is fully bound to the Azure Platform. Examples of this tight integration with
    the Azure platform includes the fact that Azure Service Fabric can use API Management,
    Event Hub, and IoT Hub out of the box as stateless gateways. When using other
    providers, stateless gateways are mostly built manually. You can import Docker
    images in Azure Fabric as well, but the orchestration of the Docker containers
    is then fully handled by Azure Service Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Fabric offers a lightweight runtime for building distributed,
    scalable, stateless and stateful microservices that can run inside containers.
    Using Service Fabric, you can deploy the microservices and containers across a
    cluster of machines. On top of that, it offers comprehensive application management
    capabilities to deploy, provision, upgrade and patch, delete, and monitor applications
    and services on containers. Service Fabric is tailored to create full cloud-native
    applications that can start small and eventually scale up to thousands of machines
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: Service Fabric can be deployed inside your own data center as well, on Windows
    Server machines. On Azure, Service Fabric can be deployed on Windows, Linux, and
    Azure Stack. There are a number of Azure PaaS solutions or resources that run
    on Service Fabric, such as Azure SQL Database, Cosmos DB, Intune, IoT Hub, Event
    Hubs, Skype, Cortana, Power BI, and Microsoft Dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c371d310-5dc7-4462-b3c9-85f95f625075.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Service Fabric overview
  prefs: []
  type: TYPE_NORMAL
- en: Applications use the Service Fabric programming models to create and manage
    your services. There are Service Fabric APIs that can be used in custom applications
    to take full advantage of the platform's features and application frameworks.
    You can deploy guest executables, which don't use the Service Fabric APIs, but
    can use the capabilities of the underlying platform. Guest executables are treated as
    stateless services and are deployed across different nodes inside a cluster. They
    can benefit from the affinity, anti-affinity and failover, application life cycle
    management, and discovery capabilities, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Service Fabric supports two different programming models that can be used to
    build scalable and stateful services in Visual Studio 2017\. They are called the
    Reliable Services and the Reliable Actor programming model. By leveraging these
    models inside your code, Azure can guarantee that the services are consistent,
    scalable, reliable, and available inside Azure Service Fabric. Service Fabric
    integrates with ASP.NET Core as well, so you can write both stateless and stateful
    ASP.NET Core applications that take advantage of these reliable collections and
    the orchestration capabilities of Service Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the available programming models for Azure Service Fabric,
    you can refer to the Microsoft documentation: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction).
    For more information on the Reliable Actor programming model, you can refer to: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-actors-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-actors-introduction).
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Azure Service Fabric, you can manage the entire life cycles of your microservice
    applications. It supports all the different tasks, from developing the microservices
    to deployment, management, and maintenance. To accomplish this, Azure Service
    Fabric provides different roles that can operate independently. These different
    roles are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service developer**: Develops generic microservices that can be leveraged
    in different applications. The developer uses the Reliable Services and Reliable
    Actor programming model to create the microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application developer**: Creates applications by using the various services
    developed by the service developer. The application developer creates the application
    manifest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application administrator**: Creates the application configuration files
    and creates the deployment packages. The administrator uses PowerShell to create
    the application packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator**: Deploys the application, monitors the application''s health and
    performance after deployment, and maintains the physical infrastructure. The operator
    uses PowerShell, CLI, or the REST API to deploy the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the Service Fabric application life cycle features,
    you can refer to the following article: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle).
  prefs: []
  type: TYPE_NORMAL
- en: API Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Management is an Azure service that can be used to expose different types
    of apps to the outside world as APIs.  You can import your custom APIs or serverless
    apps, such as Azure Functions, Web APIs, Logic Apps, or Service Fabric Apps.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use API Management for your internal organization and use it as
    a service repository that all developers can use to compose their applications
    or services.
  prefs: []
  type: TYPE_NORMAL
- en: API Management offers an API Gateway, a Management portal, and a Developer portal,
    which are covered in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API Gateway acts as a bridge between your app and the outside world. This
    app can be a custom API, or any other backend application. The API Gateway accepts
    API calls and routes them to the backend. It provides extra features, such as
    enhanced security, by adding policies and authentication methods. It can verify
    API keys, JWT tokens, certificates, and more. You can create transformations without
    using code modifications, and enforce usage quotas and rate limits. It adds support
    for caching and throttling, and can log call metadata for analytics purposes.
  prefs: []
  type: TYPE_NORMAL
- en: API Management portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API Management portal is where you define and import your custom APIs. You
    can package your APIs into **products** in there as well. APIs inside API Management
    are exposed as products to developers and can be configured with a title, description,
    and terms of use. Products can even be **open** or **protected.** For protected
    APIs, developers need a subscription. OpenAPIs can be used without a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'API Management uses **groups** to manage the visibility of products to developers.
    There are three different types of group:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Administrators**: Administrators can create APIs, operations, and products
    that are used by developers and manage API Management service instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developers**: Developers are the customers that build applications using
    your APIs. Developer portal users are part of this group. They can be granted
    access to the Developer portal and leverage the APIs in their custom applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guests**: Guest users are only granted read-only access to the developer
    portal. They may be future customers or developers, or users that only need to
    have view access on the different products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the API Management portal, you can set up policies, such as access restriction
    policies and transformation policies. You can get insights from analytics and
    create different versions of the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Developer portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Management also offers a developer portal, from where developers can access
    your APIs and read API documentation. It provides a console from where APIs can
    be tested. From there, developers can subscribe to different products. Future
    customers can visit the portal, view the products with their included operations,
    and sign up for a subscription. Developers can get insights about their usage
    from there as well.
  prefs: []
  type: TYPE_NORMAL
- en: The look and feel of the Developer portal can be customized. You can add custom
    content and add custom styles and your company branding to the portal as well.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native deployments versus migrating assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most organizations are moving to the cloud for cost reduction and to speed up
    the development process of applications. To migrate an application to Azure, there
    are a couple of strategies you can use. Which one to use depends on the type of
    application and the priorities and needs of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations are moving to the cloud to reduce costs and speed up the development
    process of applications. There are a couple of strategies you can use to migrate
    your applications to the cloud. Which strategy you use will depend on the type
    of application and the needs and priorities of the organization. Not all applications
    are worth the investment of moving to a PaaS model or developing a cloud-native
    app. For modern applications, you can choose to migrate to a cloud-optimized or
    cloud-native app, but with applications that are existing or legacy assets, the
    key is to spend minimal time and money (no re-architecting or code changes) while
    moving them to the cloud in order to realize the significant benefit therein.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different migration levels from which you can choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud infrastructure-ready**: In this approach, you simply move your current
    application and host it inside of Azure VMs. There are no code changes needed
    for this approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud DevOps-ready**:By using this approach, you are using containers for
    developing and deploying your applications. This decouples your application from
    the infrastructure layer, which reduces the failures that are caused by the application
    dependencies. You can also leverage continuous development and integration on
    the orchestration level, which makes the deployment process a lot faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud-optimized**:This migration approach targets the modernizing of your
    mission-critical applications. This type of modernization usually requires you
    to re-architect your application for the cloud. New code needs to be written,
    and you can create cloud-native applications and leverage microservices architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered serverless and microservices. We covered Azure
    Function, Azure Logic Apps, and the main differences between them. We also covered
    Azure containers services and container orchestrations. We explained what Azure
    Service Fabric is and what API Management is. Next, we talked about when to choose
    to migrate your assets to the cloud and when to choose a cloud-native deployment
    model.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the design compute infrastructure objective and, in the next
    chapter we will proceed with the design networking implementation objective, starting
    with robust networking implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions to test your knowledge of the information in
    this chapter. You can find the answers in the *Assessments* section at the end
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Can you use API Management as a stateless gateway for your microservices hosted
    in Azure Service Fabric?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you deploy Kubernetes containers to Azure Container Instances?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is Azure Service Fabric suitable for DevOps environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics that
    are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introducing Azure Functions**: [https://azure.microsoft.com/nl-nl/blog/introducing-azure-functions/](https://azure.microsoft.com/nl-nl/blog/introducing-azure-functions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Functions Documentation**: [https://docs.microsoft.com/en-us/azure/azure-functions/](https://docs.microsoft.com/en-us/azure/azure-functions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durable Functions overview**: [https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Logic Apps Documentation**: [https://docs.microsoft.com/en-us/azure/logic-apps/ ](https://docs.microsoft.com/en-us/azure/logic-apps/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Management documentation**: [https://docs.microsoft.com/en-us/azure/api-management/](https://docs.microsoft.com/en-us/azure/api-management/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Instances Documentation**: [https://docs.microsoft.com/en-us/azure/container-instances/](https://docs.microsoft.com/en-us/azure/container-instances/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Instances and container orchestrators**: [https://docs.microsoft.com/en-us/azure/container-instances/container-instances-orchestrator-relationship](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-orchestrator-relationship)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Service Fabric Documentation**: [https://docs.microsoft.com/en-us/azure/service-fabric/](https://docs.microsoft.com/en-us/azure/service-fabric/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
