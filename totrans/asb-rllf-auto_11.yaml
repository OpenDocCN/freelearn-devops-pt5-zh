- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Kubernetes Using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the containerization of applications and the revolution in microservices,
    Kubernetes-based platforms have become popular. The containerization of applications
    and container orchestration using Kubernetes provide additional layers and complexity
    to infrastructure that requires automated solutions for managing a large number
    of components.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the capabilities of Ansible to build
    and manage container images and containers. When it comes to container orchestration
    tools, such as Kubernetes or Red Hat OpenShift, there are Ansible collections
    available with modules and plugins for supporting and managing your Kubernetes
    and Red Hat OpenShift clusters and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible for Kubernetes resource management will help you to implement
    more integrations in your DevOps workflow and **Continuous** **Integration/Continuous
    Deployment** (**CI/CD**) pipelines to deploy your applications very flexibly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Kubernetes clusters using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Ansible for Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying applications to Kubernetes using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling Kubernetes applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing commands inside a Kubernetes Pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn about using the Ansible collection for Kubernetes management and
    automating Kubernetes cluster operations and resource management with it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements to proceed with this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: One Linux machine for the Ansible control node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Kubernetes cluster with API access (refer to [https://minikube.sigs.k8s.io/docs/start](https://minikube.sigs.k8s.io/docs/start)
    to spin up a local Kubernetes cluster)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge about containers and Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the Ansible code, Ansible playbooks, commands, and snippets for this chapter
    can be found in the GitHub repository at [https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-11](https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-11).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kubernetes** is an open source container orchestration platform where we
    can deploy and manage our containerized applications without worrying about the
    underlying layers. This model of service is known as **Platform as a Service**
    (**PaaS**), where developers have the freedom to deploy their applications and
    other required resources, such as storage, network, and secrets, without assistance
    from the platform team.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes platform contains many components to manage container deployment
    and orchestration, as shown in *Figure 11.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The components of a Kubernetes cluster (source: https://kubernetes.io/docs/concepts/overview/components/)
    ](img/B18383_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1 – The components of a Kubernetes cluster (source: [https://kubernetes.io/docs/concepts/overview/components/](https://kubernetes.io/docs/concepts/overview/components/))'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly have a look at these components in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes control plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The control plane is responsible for making decisions on behalf of the cluster
    and application, such as scheduling the application Pods, detecting and responding
    to Pod failures, and managing cluster nodes. The control plane has multiple components
    to handle these operations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-apiserver** – Exposes the Kubernetes cluster API that will take care
    of all central management and communications. Each and every task inside a Kubernetes
    cluster is operated via the Kubernetes API server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-controller-manager** – Consists of several controller processes, such
    as a Node controller, Job controller, Service account controller, and Endpoints
    controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd** – A **high-availability** (**HA**) key-value store used for storing
    Kubernetes cluster data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-scheduler** – Helps to select nodes for deploying Pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components on the nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the Kubernetes components running on every node in the cluster, managing
    the application Pods and its network:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container runtime** – The actual software that is running the containers
    in the backend, such as **containerd** and **CRI-O**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubelet** – Takes care of the running containers, as per specifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-proxy** – Helps to implement Kubernetes Services by maintaining network
    rules on the nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like any other open source project, Kubernetes is also free to use and supported
    by the Kubernetes user and developer community ([https://kubernetes.io/community](https://kubernetes.io/community)).
    If an organization is looking for enterprise Kubernetes distributions and support,
    there are different Kubernetes distributions available on the market as turnkey
    solutions, such as Red Hat OpenShift, Rancher, and VMware Tanzu.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Kubernetes platform, concepts, and architecture is beyond the
    scope of this book. You can find more details in the *Further reading* section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For using Ansible with Kubernetes, we can use **minikube**, which is a local
    Kubernetes cluster for learning about and developing Kubernetes Deployments. Refer
    to the documentation at [https://minikube.sigs.k8s.io/docs/start](https://minikube.sigs.k8s.io/docs/start),
    where you will find installation instructions for Linux, Windows, and macOS platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes Documentation
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the Kubernetes documentation at [https://kubernetes.io/docs/home](https://kubernetes.io/docs/home)
    to learn more about Kubernetes. Also refer to *Top 15 Free Kubernetes Courses*
    ([https://www.techbeatly.com/kubernetes-free-courses](https://www.techbeatly.com/kubernetes-free-courses))
    to learn the basics about Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about the Ansible method for managing Kubernetes
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Kubernetes clusters using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a Kubernetes cluster involves many steps, including preparing nodes,
    installing container runtime packages, and configuring networking. There are multiple
    methods we can use for deploying Kubernetes clusters within testing or production
    environments. The installation method for a Kubernetes cluster also depends on
    your requirements, whether you are using single-node clusters or multi-node clusters
    with HA or you require the option to scale the cluster whenever needed, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubespray** is a production-grade Kubernetes cluster deployment method that
    uses Ansible as its foundation for provisioning and orchestration. Using Kubespray,
    it is possible deploy a Kubernetes cluster on top of bare-metal servers, virtual
    machines, and private cloud or public cloud platforms (for example, AWS, GCE,
    Azure, and OpenStack).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubespray is highly customizable and you can configure the cluster with different
    Kubernetes components of your choice, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A supported **Container Network Interface** (**CNI**) – Calico, Flannel, Kube-router,
    Kube-OVN, Weave, or Multus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A supported **Container Runtime Interface** (**CRI**) – containerd, Docker,
    CRI-O, Kata Containers, or gVisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported cloud providers – AWS, Azure, OpenStack, or vSphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A supported **Ingress** – Kube-vip, ALB Ingress, MetalLB, or Nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported operating systems – Debian, Fedora CoreOS, Flatcar Container Linux,
    openSUSE, Red Hat Enterprise Linux, CentOS, or Amazon Linux 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes deployment using Kubespray is explained in the documentation ([https://kubespray.io](https://kubespray.io))
    and other online guides.
  prefs: []
  type: TYPE_NORMAL
- en: Once provisioned, the Kubernetes cluster can be scaled as needed (by adding
    or removing nodes) using Kubespray without worrying about the manual configurations
    of the new nodes and cluster-joining steps. Refer to the following information
    box and the *Further reading* section at the end of this chapter for links to
    further information on Kubespray.
  prefs: []
  type: TYPE_NORMAL
- en: Kubespray
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation ([https://kubespray.io](https://kubespray.io)) and
    project repository ([https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray))
    to learn more about the different options available with Kubespray. Also, check
    out [https://www.techbeatly.com/deploying-kubernetes-with-kubespray](https://www.techbeatly.com/deploying-kubernetes-with-kubespray)
    for a detailed guide on how to deploy a multi-node Kubernetes cluster using Kubespray.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the demonstration of Ansible use cases, we have used a minikube Kubernetes
    environment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – minikube Kubernetes cluster details ](img/B18383_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – minikube Kubernetes cluster details
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation ([https://minikube.sigs.k8s.io/docs/start](https://minikube.sigs.k8s.io/docs/start))
    for more details on how to create a minikube environment.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to configure Ansible for Kubernetes cluster access and check
    cluster resources in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ansible for Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible can communicate with Kubernetes clusters using the Kubernetes Python
    libraries or directly via the Kubernetes API, as shown in *Figure 11.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Communication between Ansible and Kubernetes  ](img/B18383_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Communication between Ansible and Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: Ansible modules and plugins for managing Kubernetes are available in the `kubernetes.core`
    Ansible collection. (The Ansible Kubernetes collection was released as `community.kubernetes`
    prior to the release of `kubernetes.core` 1.1.) We will install, configure, and
    use the `kubernetes.core` collection in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Python requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To communicate with the Kubernetes or OpenShift API, use the **Python client
    for the OpenShift API** ([https://github.com/openshift/openshift-restclient-python](https://github.com/openshift/openshift-restclient-python))
    Python library. Before using any of the Kubernetes modules, you need to install
    the required Python libraries, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Ansible inside a Python virtual environment, then remember
    to activate it and install the libraries within it.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Library for Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: The OpenShift REST client depends on the Kubernetes Python client ([https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python))
    and this Kubernetes Python client will be installed as part of the dependencies.
    Also check the Ansible Content Collection for Red Hat OpenShift (Ansible blog)
    – [https://www.ansible.com/blog/introducing-the-ansible-content-collection-for-red-hat-openshift](https://www.ansible.com/blog/introducing-the-ansible-content-collection-for-red-hat-openshift)
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Ansible Kubernetes collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the Ansible Kubernetes collection from Ansible Galaxy ([https://galaxy.ansible.com/kubernetes/core](https://galaxy.ansible.com/kubernetes/core)),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the `ansible.cfg` object type with the collection path if you want
    to install the collection inside the project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 - Configure collection path in ansible.cfg ](img/B18383_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 - Configure collection path in ansible.cfg
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `kubernetes.core` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 - Install kubernetes.core collection ](img/B18383_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 - Install kubernetes.core collection
  prefs: []
  type: TYPE_NORMAL
- en: The `kubernetes.core` collection will be installed inside the collection directory
    (`COLLECTIONS_PATHS = ./collections`) as you mentioned in the `ansible.cfg` file.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Ansible to Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible will try to use the `$HOME/.kube/config` file, which is the default
    Kubernetes configuration file (`kubeconfig`) containing Kubernetes cluster details,
    credential details, and connection contexts. If your `kubeconfig` file is residing
    in a different path or has a different filename, then specify this in the Kubernetes
    `module` parameter inside the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, we have a Kubernetes cluster running on minikube.
    The `kubeconfig` file and certificate credentials are copied to the Ansible control
    node, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – The kubeconfig file and certificates ](img/B18383_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – The kubeconfig file and certificates
  prefs: []
  type: TYPE_NORMAL
- en: If you are using basic authentication (a username and password) for accessing
    the cluster, then specify these details inside the Kubernetes module itself.
  prefs: []
  type: TYPE_NORMAL
- en: For production environments, remember to follow best practices for storing the
    credentials, certificates, and access keys, using Ansible Vault or any other secret
    management system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the kubectl CLI tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are working from the control node, install the `kubectl` CLI tool on
    the machine and execute the `kubectl` command to verify the resources that we
    will be creating using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a machine installed with `kubectl` and access to the Kubernetes
    cluster, then skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the `kubectl` installation document ([https://kubernetes.io/docs/tasks/tools/install-kubectl-linux](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux))
    and use the appropriate method suitable for your environment (since we are running
    the Ansible control node on a Red Hat Enterprise Linux machine, the following
    commands are based on Red Hat Enterprise Linux/Fedora distributions):'
  prefs: []
  type: TYPE_NORMAL
- en: Add the repository for the `kubectl` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Add the repository for the kubectl package ](img/B18383_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Add the repository for the kubectl package
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `kubectl` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Installing the kubectl utility ](img/B18383_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Installing the kubectl utility
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the `KUBECONFIG` environment variable, as our `kubeconfig` filename
    is different (`/home/ansible/.kube/minikube-config`) from the default filename
    (`/home/ansible/.kube/config`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Configure the KUBECONFIG environment variable ](img/B18383_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Configure the KUBECONFIG environment variable
  prefs: []
  type: TYPE_NORMAL
- en: Verify the `kubectl` CLI version and cluster details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.10 – kubectl version information ](img/B18383_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – kubectl version information
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl` CLI is able to access the cluster and we will go on to use it
    in the following sections to verify the resources in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the Kubernetes cluster details using Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collecting the cluster details and resource information is an important step.
    The Kubernetes cluster details can be collected using the `kubectl` CLI, as shown
    in *Figure 11.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Kubernetes cluster details, collected using the kubectl CLI
    ](img/B18383_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Kubernetes cluster details, collected using the kubectl CLI
  prefs: []
  type: TYPE_NORMAL
- en: Use the `kubernetes.core.k8s_info` module to collect similar details about the
    Kubernetes cluster using Ansible (prior to Ansible 2.9, the module was called
    `k8s_facts`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create our first Ansible playbook to interact with a
    Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `Chapter-11/k8s-details.yaml`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.12 – The task for fetching Pod details from the kube-system namespace
    ](img/B18383_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – The task for fetching Pod details from the kube-system namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'We are fetching the Pod details from the `kube-system` namespace in the Kubernetes
    cluster. Note the `hosts: localhost` line as the execution needs to happen on
    `localhost`. The Python libraries will take care of the Kubernetes operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and verify the output. You will see a lot of details about
    the Pods running inside the `kube-system` namespace, as shown in *Figure 11.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Pod details from a Kubernetes namespace ](img/B18383_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Pod details from a Kubernetes namespace
  prefs: []
  type: TYPE_NORMAL
- en: Add one more task in the same playbook to collect the Kubernetes cluster node
    details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The task to get the Kubernetes node details ](img/B18383_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – The task to get the Kubernetes node details
  prefs: []
  type: TYPE_NORMAL
- en: Execute the playbook again and verify the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the node name (in this case, `minikube`), as in the output in *Figure 11.15*.
    If you have multiple nodes, you will see multiple entries here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Fetching the Kubernetes cluster node details ](img/B18383_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Fetching the Kubernetes cluster node details
  prefs: []
  type: TYPE_NORMAL
- en: Customize the playbook for different clusters by using different `kubeconfig`
    files or providing the credential details in the module itself, such as `api_key`,
    `client_cert`, and `client_key`. Refer to the `kubernetes.core.k8s_info` module
    ([https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_info_module.xhtml](https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_info_module.xhtml))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have learned how to communicate with Kubernetes clusters using Ansible
    modules and how to fetch cluster details. In the next section, we will learn more
    about Ansible for Kubernetes automation by creating resources and objects in Kubernetes
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying applications to Kubernetes using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerized applications can be deployed inside Kubernetes via the Kubernetes
    dashboard (web UI) or using the `kubectl` CLI ([https://kubernetes.io/docs/reference/kubectl](https://kubernetes.io/docs/reference/kubectl)).
    By using Ansible, we can automate most of the deployment operations that take
    place inside our Kubernetes clusters. Since Ansible can easily integrate within
    CI/CD pipelines, it is possible to achieve more control over your application
    deployments in a containerized environment such as Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications are deployed inside logical isolated groups called Kubernetes
    **namespaces**. There can be default namespaces and Kubernetes cluster-related
    namespaces, and we can also create additional namespaces as required to deploy
    applications. *Figure 11.16* demonstrates the relation between Deployments, Pods,
    Services, and namespaces in a Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Kubernetes Deployments and namespaces ](img/B18383_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Kubernetes Deployments and namespaces
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following exercise, we will deploy an application in Kubernetes by creating
    a dedicated namespace, Deployment configuration, and Service:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the `Chapter-11/todo-app-deploy.yaml` Deployment definition file, which
    will be used to create a Kubernetes Deployment resource in the next steps. We
    can create `ginigangadharan/todo-app:latest` image that we created in [*Chapter
    10*](B18383_10.xhtml#_idTextAnchor178), *Managing Containers Using Ansible*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.17 – The Kubernetes definition file for the to-do app Deployment
    ](img/B18383_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – The Kubernetes definition file for the to-do app Deployment
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a `Chapter-11/todo-app-service.yaml` Kubernetes Service definition file
    to expose the application using `NodePort 300080`. Use different `NodePort`, `ClusterIP`,
    or `LoadBalancer` type Services depending on the Kubernetes cluster that you are
    using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.18 – The Kubernetes definition file for the to-do app Service ](img/B18383_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – The Kubernetes definition file for the to-do app Service
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Chapter-11/k8s-app-deploy.yaml` playbook and add contents, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.19 – A playbook to deploy the application in Kubernetes ](img/B18383_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – A playbook to deploy the application in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Execute the playbook to deploy todo-app ](img/B18383_11_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – Execute the playbook to deploy todo-app
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the namespace was created using the `kubectl` CLI, as shown in
    *Figure 11.21*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.21 – A Kubernetes namespace created using Ansible ](img/B18383_11_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – A Kubernetes namespace created using Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a task in the same playbook to create the Deployment using the `todo-app-deploy.yaml`
    Deployment definition file and to create the Kubernetes Service resource using
    the `todo-app-service.yaml` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Tasks to create Deployment and Service resources in Kubernetes
    ](img/B18383_11_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – Tasks to create Deployment and Service resources in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: Execute the playbook again to create the Deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the Deployment, Pods, ReplicaSet, and Service resources were created,
    as shown in *Figure 11.23*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Deployment, Pod, and Service created by Ansible ](img/B18383_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.23 – Deployment, Pod, and Service created by Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are using a minikube cluster, we can get the exposed Service details
    using the `minikube service list` command from the machine running the minikube
    cluster (not from the Ansible control node), as shown in *Figure 11.24*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Exposed Service details in a minikube cluster ](img/B18383_11_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.24 – Exposed Service details in a minikube cluster
  prefs: []
  type: TYPE_NORMAL
- en: Find the URL for the `todo-app` application (`http://192.168.64.10:30080`, in
    this case) based on the name and use it in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the application from a web browser using the URL `http://192.168.64.10:30080`,
    as shown in *Figure 11.25*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.25 – Accessing the to-do app deployed in a Kubernetes cluster ](img/B18383_11_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.25 – Accessing the to-do app deployed in a Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the playbook with more resources and configurations as part of your
    application deployment. For example, we can create an Ingress resource with the
    Ingress definition, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.26 – Ingress resource definition for the to-do app ](img/B18383_11_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.26 – Ingress resource definition for the to-do app
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Ingress definition in the Ansible task to create an Ingress resource,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.27 – Create an Ingress resource using Ansible ](img/B18383_11_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.27 – Create an Ingress resource using Ansible
  prefs: []
  type: TYPE_NORMAL
- en: We can also pass the Deployment information in the form of variables and integrate
    them into our CD workflow.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to deploy applications and Service resources in Kubernetes
    using Ansible. Most of the resources in Kubernetes can be created using the `kubernetes.core.k8s`
    module with the resource definition files. However, there are other useful modules
    in the `kubernetes.core` collection and we will go on to learn how to use a few
    of them, such as scaling applications and running commands inside a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Kubernetes applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **ReplicaSet** resource in Kubernetes ensures that a specified number of
    application Pod replicas are running as part of the Deployment. This mechanism
    will help to scale the application horizontally whenever needed and without additional
    resource configurations. A ReplicaSet resource will be created when you create
    a deployment resource in Kubernetes, as shown in *Figure 11.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.28 – A ReplicaSet resource created as part of Deployment ](img/B18383_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.28 – A ReplicaSet resource created as part of Deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify the initial number of replicas inside the Deployment definition file
    as `replicas: 1` . ReplicaSet will scale the number of Pods based on the replica
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is extra traffic on the application Pods, scale the application
    using the `kubectl scale` command, as follows (modify the Deployment, not the
    ReplicaSet):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.29 – Scaling an application using kubectl ](img/B18383_11_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.29 – Scaling an application using kubectl
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for the replication changes to take effect and check the resource details
    again. You will find multiple Pods (three) now running, as shown in *Figure 11.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.30 – An application scaled up using a ReplicaSet resource ](img/B18383_11_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.30 – An application scaled up using a ReplicaSet resource
  prefs: []
  type: TYPE_NORMAL
- en: 'The traffic will be distributed to all Pods using the `service/todoapp-svc`
    module as a load balancer. Refer to *Figure 11.31*, which highlights the multiple
    *endpoints*, which are Pod IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.31 – A Kubernetes Service with multiple Pod replicas as endpoints
    ](img/B18383_11_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.31 – A Kubernetes Service with multiple Pod replicas as endpoints
  prefs: []
  type: TYPE_NORMAL
- en: We can manage the scaling of the Kubernetes application based on traffic and
    conditions automatically using Ansible. We will learn more about the `kubernetes.core.k8s_scale`
    module and practice using it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Kubernetes Deployments using Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `k8s_scale` module is part of the `kubernetes.core` collection and we can
    use it for scaling up or scaling down Kubernetes Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding with the exercise, remember to scale down the application
    to one replica (`--replicas=1`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.32 – Scale down todo-app replica ](img/B18383_11_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.32 – Scale down todo-app replica
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create Ansible artifacts for scaling a Kubernetes application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Chapter-11/k8s-app-scale.yaml` playbook and add content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.33 – An Ansible playbook to scale a Kubernetes Deployment ](img/B18383_11_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.33 – An Ansible playbook to scale a Kubernetes Deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjust `wait_timeout: 30` depending on your next task in the workflow. For
    example, increase the value to ensure the Pod replicas are created and running
    successfully before proceeding with the next task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.34 – Execute Kubernetes Deployment scaling playbook ](img/B18383_11_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.34 – Execute Kubernetes Deployment scaling playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the Pod replicas using the `kubectl` command, as shown in *Figure 11.35*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.35 – Pod replicas after scaling ](img/B18383_11_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.35 – Pod replicas after scaling
  prefs: []
  type: TYPE_NORMAL
- en: 'Customize the scaling based on several conditions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current_replicas: x`: This will change the replicas only if the current number
    of replicas matches the `current_replicas` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src: deployment.ym`l: This will read the Deployment and the replicas definition
    from a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait: no`: This will not wait for the scaling to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the `k8s_scale` module documentation for more details ([https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_scale_module.xhtml](https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_scale_module.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about the `k8s_exec` module and how to use
    it to troubleshoot Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Executing commands inside a Kubernetes Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a normal situation, we do not need to log in to a Pod or container, as the
    application is exposed on some ports and Services are talking over these exposed
    ports. However, when there are issues, we need to access the containers and check
    what is happening inside, by checking logs, accessing other Pods, or running any
    necessary troubleshooting commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `kubectl exec` command if you are doing this troubleshooting or information
    gathering manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.36 – Execute commands inside a Pod using the kubectl utility ](img/B18383_11_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.36 – Execute commands inside a Pod using the kubectl utility
  prefs: []
  type: TYPE_NORMAL
- en: However, when we automate Kubernetes operations using Ansible, use the `k8s_exec`
    module and automate the verification tasks or validation tasks as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such scenarios, we can deploy debug Pods using suitable images (for example,
    images with required utilities, such as `ping`, `curl`, or `netstat`) and execute
    validation commands from these Pods. A typical deployment scenario with test Pods
    (`curl-pod`) is shown in *Figure 11.37*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.37– A debug Pod to validate and verify applications ](img/B18383_11_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.37– A debug Pod to validate and verify applications
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following scenario, we will create a playbook to deploy a `curl-pod`
    Pod using a `busyboxplus` image ([https://hub.docker.com/r/radial/busyboxplus](https://hub.docker.com/r/radial/busyboxplus))
    and verify the `todoapp-svc` Service from the `curl-pod` Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `curl-app-pod.yaml` definition file for the `curl-pod` Pod, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.38 – Kubernetes Deployment definition for a curl-pod Pod ](img/B18383_11_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.38 – Kubernetes Deployment definition for a curl-pod Pod
  prefs: []
  type: TYPE_NORMAL
- en: We have added a `sleep 50000` command; otherwise, the Pod will exit without
    running any processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Chapter-11/curl-app-deploy.yaml` playbook and add content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.39 – Ansible playbook for deploying curl-pod ](img/B18383_11_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.39 – Ansible playbook for deploying curl-pod
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a task to execute the `curl` command inside the `curl-pod` Pod to verify
    whether the `todoapp-svc` Service is accessible or not. Then, add tasks for displaying
    the output of the `curl` command, and validate the success and fail status (`curl_output.failed
    == true`), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.40– Tasks to execute the curl command inside the curl-pod Pod and
    to display its status ](img/B18383_11_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.40– Tasks to execute the curl command inside the curl-pod Pod and
    to display its status
  prefs: []
  type: TYPE_NORMAL
- en: The last task is optional but adding more validations and messages will help
    you to implement a better workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Once the verification is complete, delete the `curl-pod` Pod, as we do not require
    it anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.41 – Remove the curl-pod Pod after testing ](img/B18383_11_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.41 – Remove the curl-pod Pod after testing
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and verify the output. We can see the `curl` output as
    shown in *Figure 11.42* if the `todoapp-svc` Service is reachable from the `curl-pod`
    Pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.42 – The curl command output for todoapp-svc ](img/B18383_11_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.42 – The curl command output for todoapp-svc
  prefs: []
  type: TYPE_NORMAL
- en: The `kubernetes.core.k8s_exec` module is very useful for the validation and
    verification of Kubernetes applications and cluster management using Ansible.
    The command can be executed inside a debug Pod, as we learned in the preceding
    exercise, or even inside the application Pod for verifying facts.
  prefs: []
  type: TYPE_NORMAL
- en: Explore the `kubernetes.core` collection and find other useful modules and plugins
    to automate your Kubernetes Deployments and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the Ansible collection for Kubernetes
    cluster and resource management. We started by covering the basics of Kubernetes
    components and discussed how to use Kubespray to deploy and manage Kubernetes
    clusters and their supported features.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned the method of connecting a Kubernetes cluster to Ansible
    to automate cluster operations. We have used the Kubernetes Ansible collection
    to deploy applications and scale Deployments. We have also learned how to execute
    commands inside a running Kubernetes Pod using Ansible, which can be utilized
    for validation and troubleshooting purposes. This chapter has provided a brief
    introduction to Kubernetes automation using Ansible and other important information,
    such as Kubernetes content collection and methods of connecting Ansible to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the different available methods of
    integrating your CI/CD and communication tools using Ansible. We will learn more
    about the enterprise version of Ansible, which is called Ansible Automation Platform,
    and its flexible integration features.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, please refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Introduction to Ansible for Kubernetes guide* – [https://docs.ansible.com/ansible/latest/collections/kubernetes/core/docsite/scenario_guide.xhtml](https://docs.ansible.com/ansible/latest/collections/kubernetes/core/docsite/scenario_guide.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Play with Kubernetes – free hands-on labs* – [https://labs.play-with-k8s.com/](https://labs.play-with-k8s.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CRI-O* – [https://cri-o.io](https://cri-o.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*containerd* – [https://containerd.io/](https://containerd.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Top 15 Free Kubernetes Courses* – [https://www.techbeatly.com/kubernetes-free-courses/](https://www.techbeatly.com/kubernetes-free-courses/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is Kubernetes?* – [https://www.redhat.com/en/topics/containers/what-is-kubernetes](https://www.redhat.com/en/topics/containers/what-is-kubernetes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Free OpenShift labs* – [learn.openshift.com](http://learn.openshift.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Ansible kubernetes.core collection* – [https://galaxy.ansible.com/kubernetes/core](https://galaxy.ansible.com/kubernetes/core)
    or [https://console.redhat.com/ansible/automation-hub/repo/published/kubernetes/core](https://console.redhat.com/ansible/automation-hub/repo/published/kubernetes/core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Ansible community.kubernetes collection* – [https://galaxy.ansible.com/community/kubernetes](https://galaxy.ansible.com/community/kubernetes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Templating (Jinja2)* – [https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.xhtml](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is PaaS?* – [https://www.redhat.com/en/topics/cloud-computing/what-is-paas](https://www.redhat.com/en/topics/cloud-computing/what-is-paas)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microk8s* – [https://microk8s.io](https://microk8s.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Red Hat OpenShift* – [https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubespray* – [https://kubespray.io](https://kubespray.io), [https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
