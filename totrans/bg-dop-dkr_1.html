<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Images and Containers</h1></div></div></div><p>This lesson will cover fundamental concepts about containerization as a foundation for the images and containers we will later build. We will also get to understand how and why Docker gets involved in the DevOps ecosystem. Before we begin, we will see how virtualization differs from containerization in Docker. </p><div><div><div><div><h1 class="title"><a id="ch02lvl4sec03"/>Lesson Objectives</h1></div></div></div><p>By the end of this lesson, you will be able to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Describe how Docker improves a DevOps workflow</li><li class="listitem" style="list-style-type: disc">Interpret Dockerfile syntax</li><li class="listitem" style="list-style-type: disc">Build images</li><li class="listitem" style="list-style-type: disc">Set up containers and images </li><li class="listitem" style="list-style-type: disc">Set up a local dynamic environment </li><li class="listitem" style="list-style-type: disc">Run applications in Docker containers</li><li class="listitem" style="list-style-type: disc">Obtain a basic overview of how Docker manages images via Docker Hub</li><li class="listitem" style="list-style-type: disc">Deploy a Docker image to Docker Hub</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl4sec04"/>Virtualization versus Containerization</h1></div></div></div><p> This <a class="indexterm" id="id0"/>block diagram gives an overview of a typical virtual machine setup:</p><div><img alt="Virtualization versus Containerization" src="img/image01_01a.jpg"/></div><p>In virtual machines, the physical hardware is abstracted, therefore we have many servers running on one server. A hypervisor helps do this.</p><p>Virtual machines do sometimes take time to start up and are expensive in capacity (they can be GBs in size), although the greatest advantage they have over containers is the ability to run different Linux distributions such as CentOS instead of just Ubuntu:</p><div><img alt="Virtualization versus Containerization" src="img/image01_02a.jpg"/></div><p>In<a class="indexterm" id="id1"/> containerization, it is only the app layer (where code and dependencies are packaged) that is abstracted, making<a class="indexterm" id="id2"/> it possible for many containers to run on the same OS kernel but on separate user space.</p><p>Containers use less space and boot fast. This makes development easier, since you can delete and start up containers on the fly without considering how much server or developer working space you have.</p><p>Let's begin the lesson with a quick overview on how Docker comes into play in a DevOps workflow and the Docker environment.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec08"/>How Docker Improves a DevOps Workflow</h1></div></div></div><p>DevOps is a <a class="indexterm" id="id3"/>mindset, a culture, and a way of thinking. The ultimate goal is to always improve and automate processes as much as possible. In layman language, DevOps requires one to think in the laziest point of view, which puts most, if not all, processes as automatic as possible.</p><p>Docker is an <a class="indexterm" id="id4"/>open source containerization platform that improves the shipping process of a development life cycle. Note it is neither a replacement for the already existing platforms nor does the organization want it to be.</p><p>Docker abstracts the complexity of configuration management like Puppet. With this kind of setup, shell scripts become unnecessary. Docker can also be used on small or large deployments, from a hello world application to a full-fledged production server. </p><p>As a developer on different levels, whether beginner or expert, you may have used Docker and you didn't even realize it. If you have set up a continuous integration pipeline to run your tests online, most servers use Docker to build and run your tests.</p><p>Docker has gained a lot of support in the tech community because of its agility and, as such, a lot of organizations are running containers for their services. Such<a class="indexterm" id="id5"/> organizations include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Continuous integration and continuous delivery platforms such as Circle CI, Travis CI, and Codeship</li><li class="listitem" style="list-style-type: disc">Cloud platforms such as <strong>Amazon Web Services</strong> <strong>(AWS)</strong> and <strong>Google Cloud Platform</strong> <strong>(GCP)</strong> allow developers to run applications out of containers</li><li class="listitem" style="list-style-type: disc">Cisco and the Alibaba group also run some of their services in containers</li></ul></div><p>Docker's place in the DevOps workflow involves, but is not limited to, the following:</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Examples of Docker's use cases in a development workflow. </p><p>Unifying requirements refers to using a single configuration file. Docker abstracts and limits requirements to a single Dockerfile file.</p><p>Abstraction of OS means one doesn't need to worry about building the OS because there exist prebuilt images.</p><p>Velocity has to define a Dockerfile and build containers to test in, or use an already built image without writing a Dockerfile.Docker allows <a class="indexterm" id="id6"/>development teams to avoid investment on steep learning curves through shell scripts because "automation tool X" is too complicated. </p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl3sec03"/>Recap of the Docker Environment </h2></div></div></div><p>We<a class="indexterm" id="id7"/> walked through the fundamentals of containerization earlier. Allow me to emphasize the alternative workflow that Docker brings to us.</p><p>Normally, we have two pieces to a working application: the project code base and the provisioning script. The code base is the application code. It is managed by version control and hosted in GitHub, among other platforms. </p><p>The provisioning script could be a simple shell script to be run in a host machine, which could be anywhere from a Windows workstation to a fully dedicated server in the cloud.</p><p>Using Docker does not interfere with the project code base, but innovates on the provisioning aspect, improving the workflow and delivery velocity. This is a sample setup of how Docker implements this:</p><div><img alt="Recap of the Docker Environment" src="img/image01_03a.jpg"/></div><p>The <strong>Dockerfile</strong> takes <a class="indexterm" id="id8"/>the place of the provisioning script. The two combined (project code and Dockerfile) make a <strong>Docker image.</strong> A Docker image<a class="indexterm" id="id9"/> can be run as an application. This running application sourced from a Docker image is called a <strong>Docker container.</strong>
</p><p>The Docker container <a class="indexterm" id="id10"/>allows us to run the application in a completely new environment on our computers, which is completely disposable. What does this mean?</p><p>It means that we are able to declare and run Linux or any other operating system on our computers and then, run our application in it. This also emphasizes that we can build and run the container as many times as we want without interfering with our computer's configuration.</p><p>With this, I have brought to your attention four key words: <strong>image</strong>,<strong> container</strong>,<strong> build</strong>, and <strong>run</strong>. We will get to the nitty-gritty of the Docker CLI next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Basic Docker Terminal Commands</h1></div></div></div><p>Open Command <a class="indexterm" id="id11"/>Prompt to check that Docker is installed<a class="indexterm" id="id12"/> in your workstation. Entering the command <code class="literal">docker</code> on your terminal should show the following:</p><div><img alt="Basic Docker Terminal Commands" src="img/image01_04a.jpg"/></div><p>This is the list of available subcommands for Docker. To understand what each subcommand does, enter <code class="literal">docker-subcommand –help</code> on the terminal: </p><div><img alt="Basic Docker Terminal Commands" src="img/image01_05a.jpg"/></div><p>Run <code class="literal">docker info</code> and note the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Containers</li><li class="listitem" style="list-style-type: disc">Images</li><li class="listitem" style="list-style-type: disc">Server Version</li></ul></div><div><img alt="Basic Docker Terminal Commands" src="img/image01_06a.jpg"/></div><p>This command displays system-wide information. The server version number is important at times, especially when new releases introduce <a class="indexterm" id="id13"/>something that is not backward-compatible. Docker has stable and edge releases for their Community Edition.</p><p>We will now look at a few commonly used commands.</p><p>This command searches <a class="indexterm" id="id14"/>
<strong>Docker Hub</strong> for images:</p><div><pre class="programlisting">
<code class="literal">docker search &lt;term&gt;</code> (for example, <code class="literal">docker search ubuntu</code>)</pre></div><p>Docker Hub is the default Docker registry. A Docker registry holds named Docker images. Docker Hub is basically the "GitHub for Docker images". Earlier, we looked at running an Ubuntu container without building one; this is where the Ubuntu image is stored and versioned:</p><div><img alt="Basic Docker Terminal Commands" src="img/image01_07a.jpg"/></div><p>"There are private Docker registries, and it is important that you are aware of this now."? Docker Hub is at <a class="ulink" href="http://hub.docker.com">hub.docker.com</a>. Some images are hosted at <a class="ulink" href="http://store.docker.com">store.docker.com</a> but Docker Store contains official images. However, it mainly focuses on the commercial aspect of an app store of sorts for Docker images and provides workflows for use.</p><p>The register page is as shown here:</p><div><img alt="Basic Docker Terminal Commands" src="img/image01_08a.jpg"/></div><p>The log in page is as shown here:</p><div><img alt="Basic Docker Terminal Commands" src="img/image01_09a.jpg"/></div><p>From<a class="indexterm" id="id15"/> the results, you can tell how users have rated the image by the number of stars. You can also tell whether the image is official. This means that the image is promoted by the registry, in this case, Docker Hub. New Docker users are advised to use official images since they have great documentation, are secure, promote best practices, and are designed for most use cases.  As soon as you have settled on one image, you'll need to have it locally.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Ensure you are able to search for at least one image from Docker Hub. Image variety ranges from operating systems to libraries, such as Ubuntu, Node.js, and Apache.</p></div></div><p>This command allows you to search from Docker Hub:</p><div><pre class="programlisting">
<code class="literal">docker search &lt;term&gt;</code>
</pre></div><p>For example, <code class="literal">docker search ubuntu</code>.</p><p>This command pulls an image from the registry to your local machine:</p><div><pre class="programlisting">
<code class="literal">docker pull</code>
</pre></div><p>For example, <code class="literal">docker pull ubuntu</code>.</p><p>As soon as this command is running, you'll notice that it is using the default tag: <code class="literal">latest</code>. In Docker Hub, you can see the list of tags. For <strong>Ubuntu</strong>, they are listed here: <a class="ulink" href="https://hub.docker.com/r/library/ubuntu/">https://hub.docker.com/r/library/ubuntu/</a> plus their respective Dockerfiles:</p><div><img alt="Basic Docker Terminal Commands" src="img/image01_010a.jpg"/></div><p>Download the Ubuntu image profile on Docker Hub from: <a class="ulink" href="https://hub.docker.com/r/library/ubuntu/">https://hub.docker.com/r/library/ubuntu/</a>.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Activity 1 — Utilizing the docker pull Command</h2></div></div></div><p>To get you conversant with the <code class="literal">docke</code>r <code class="literal">pull</code> command.</p><p> The goal of this activity is to gain a firm understanding of the <code class="literal">docker-pull</code> CLI, not only by running the listed commands, but also by seeking help on other commands while exploring, through manipulating the built containers. </p><div><ol class="orderedlist arabic"><li class="listitem">Is Docker up <a class="indexterm" id="id16"/>and running? Type <code class="literal">docker</code> on the terminal or command-line application.</li><li class="listitem">This command is used to pull the image from the Docker Hub<code class="literal">.</code> <div><pre class="programlisting">
<code class="literal">docker pull</code>
</pre></div></li></ol></div><p>Image variety ranges from operating systems to libraries, such as Ubuntu, Node.js, and Apache. This command allows you to pull images from Docker Hub:</p><p>For example, <code class="literal">docker pull ubuntu</code>.</p><p>This command lists the Docker images we have locally:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">docker images</code></li></ul></div><p>When we run the command, if we have pulled images from Docker Hub, we will be able to see a list of images: </p><div><img alt="Activity 1 — Utilizing the docker pull Command" src="img/image01_11a.jpg"/></div><p>They are <a class="indexterm" id="id17"/>listed according to the repository, tag, image ID, date created, and size. The repository is simply the image name unless it is <a class="indexterm" id="id18"/>sourced from a different registry. In this case, you'll have a URL without the <code class="literal">http://</code> and the <strong>top level domain (TLD)</strong> such as <code class="literal">&gt;registry.heroku.com/&lt;image-name&gt;</code> from the Heroku registry.</p><p>This command will check whether the image by the name <code class="literal">hello-world</code> exists locally:</p><div><pre class="programlisting">
<code class="literal">docker run &lt;image&gt;</code>
</pre></div><p>For example, <code class="literal">docker run hello-world</code>:</p><div><img alt="Activity 1 — Utilizing the docker pull Command" src="img/image01_12a.jpg"/></div><p>If the image is not local, it will be pulled from the default registry, Docker Hub, and run as a container, by default.</p><p>This command lists the running containers:</p><div><pre class="programlisting">docker ps</pre></div><p>If there aren't any <a class="indexterm" id="id19"/>running containers, you should have a blank screen with the headers:</p><div><img alt="Activity 1 — Utilizing the docker pull Command" src="img/image01_13a.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Activity 2 — Analyzing the Docker CLI</h2></div></div></div><p>Ensure you have the Docker CLI running by typing <code class="literal">docker</code> on your terminal. </p><p>You have been asked to demonstrate the commands covered so far.</p><p>To get you conversant with the Docker CLI. The goal of this activity is to gain a firm understanding of the <code class="literal">docker-compose</code> CLI, not only by running the listed commands, but also by seeking help on other commands while exploring, through manipulating the built containers. The goal is to be flexible enough with the CLI to be able to use it in a real-world scenario such as running an automated script.</p><div><ol class="orderedlist arabic"><li class="listitem"> Is Docker up <a class="indexterm" id="id20"/>and running? Type <code class="literal">docker</code> on the terminal or command-line application.</li><li class="listitem">Search for the official Apache image using the CLI, using <code class="literal">docker search apache:</code> <div><img alt="Activity 2 — Analyzing the Docker CLI" src="img/image01_14a.jpg"/></div></li><li class="listitem">Attempt to pull the image using <code class="literal">docker pull apache.</code></li><li class="listitem">Confirm the availability of the image locally using <code class="literal">docker images.</code></li><li class="listitem">Bonus: Run the image as a container using <code class="literal">docker run apache.</code></li><li class="listitem">Bonus: Stop the container using <code class="literal">docker stop &lt;container ID&gt;.</code></li><li class="listitem">Bonus: Delete the container and the image using <code class="literal">docker rm &lt;contai</code><code class="literal">ner ID&gt;.</code></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Dockerfile Syntax</h1></div></div></div><p>Every Docker image<a class="indexterm" id="id21"/> starts from a <strong>Dockerfile</strong>. To create an image of an application or script, simply create a file called <strong>Dockerfile</strong>. </p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>It does not have an extension and begins with a capital letter D.</p><p>A Dockerfile is a simple text document where all the commands that template a container are written. The Dockerfile always starts with a base image. It contains steps to create the application or to run the script in mind.</p><p>Before we build, let's take <a class="indexterm" id="id22"/>a quick look at a few best practices on writing Dockerfiles.</p></div></div><p>Some best practices include, but are not limited to, the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Separation of concern</strong>: Ensure each Dockerfile is, as much as possible, focused on one goal. This will make it so much easier to reuse in multiple applications.</li><li class="listitem" style="list-style-type: disc"><strong>Avoid unnecessary installations</strong>: This will reduce complexity and make the image and container compact enough.</li><li class="listitem" style="list-style-type: disc"><strong>Reuse already built images</strong>: There are several built and versioned images on Docker Hub; thus, instead of implementing an already existing image, it's highly advisable to reuse by importing.</li><li class="listitem" style="list-style-type: disc"><strong>Have a limited number of layers</strong>: A minimal number of layers will allow one to have a compact or smaller build. Memory is a key factor to consider when building images and containers, because this also affects the consumers of the image, or the clients.</li></ul></div><p>We'll start <a class="indexterm" id="id23"/>simply with a Python and JavaScript script. The choice of these languages is based on their popularity and ease of demonstration. </p><div><div><div><div><h2 class="title"><a id="ch02lvl4sec05"/>Writing Dockerfiles for Python and JavaScript examples</h2></div></div></div><div><div><h3 class="title"><a id="note05"/>Note</h3><p>No prior experience is required on the selected languages as theyare meant to give a dynamic view of how any language can adopt containerization.</p></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Python</h3></div></div></div><p>Before <a class="indexterm" id="id24"/>we begin, create a new directory or folder; let's use this as our workspace.</p><p>Open the directory and run <code class="literal">docker search python</code>. We'll pick the official image: <code class="literal">python</code>.  The official image has the value <strong>[OK]</strong>
<code class="literal"> </code>in the <strong>OFFICIAL</strong> column:</p><div><img alt="Python" src="img/image01_15a.jpg"/></div><p>Go to <a class="ulink" href="http://hub.docker.com">hub.docker.com</a> or <a class="ulink" href="http://store.docker.com">store.docker.com</a> and search for python to get the correct tag or at least know what version the Python image with the latest tag is. We will talk more about tags in <em>Topic D</em>. </p><p>The image tag should be the number with this syntax that looks like <code class="literal">3.x.x</code> or <code class="literal">3.x.x-rc.</code>
</p><p>Create a <a class="indexterm" id="id25"/>file by the name <code class="literal">run.py</code> and enter the first line as follows:</p><div><pre class="programlisting">print("Hello Docker - PY")</pre></div><p>Create a new file on the same folder level and name it <strong>Dockerfile.</strong> </p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>We do not have an extension for the Dockerfile.</p><p>Add the following in the <strong>Dockerfile</strong>:</p><div><pre class="programlisting">FROM python
ADD . .
RUN ls
CMD python run.py</pre></div><p>The <strong>FROM</strong> command, as alluded to earlier, specifies the base image.</p></div></div><p>The command can also be used on an <strong>inheritance</strong> point of view. This means you do not have to include extra package installations in the Dockerfile if there already exists an image with the packages.</p><p>The <strong>ADD</strong> command copies the specified files at source to the destination within the image's filesystem. This means the contents of the script will be copied to the directory specified.</p><p>In this case<a class="indexterm" id="id26"/> because <code class="literal">run.py</code> and Dockerfile are on the same level then <code class="literal">run.py</code> is copied to the working directory of the base image's file system that we are building upon.</p><p>The <strong>RUN</strong> command is executed while the image is being built. <code class="literal">ls</code> being run here is simply for us to see the contents of the image's filesystem.</p><p>The <strong>CMD </strong>command is used when a container is run based on the image we'll create using this Dockerfile. That means at the end of the Dockerfile execution, we are intending to run a container.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>JavaScript</h3></div></div></div><p>Exit the <a class="indexterm" id="id27"/>previous directory and create a new one. This one will be demonstrating a node application. </p><p>Add the following line in the script and save:</p><div><pre class="programlisting">console.log("Hello Docker - JS")</pre></div><p>Run <code class="literal">docker search node</code> - we'll pick the official image: <code class="literal">node</code>
</p><p>Remember<a class="indexterm" id="id28"/> that the official image has the value<strong> [OK]</strong> in the <strong>OFFICIAL</strong> column:</p><div><img alt="JavaScript" src="img/image01_16a.jpg"/></div><p>Note that node is the JavaScript runtime based on Google's high performance, open source JavaScript engine, V8.</p><p>Go to <a class="ulink" href="http://hub.docker.com">hub.docker.com</a> and search for node to get the correct tag or at least know what version the node image with the latest tag is.</p><p>Create a new <strong>Dockerfile</strong> and add the following:</p><p>This should be on the same file level as the script.</p><div><pre class="programlisting">
<code class="literal">FROM node</code>
<code class="literal">ADD . .</code>
<code class="literal">RUN ls</code>
<code class="literal">CMD node run.js</code>
</pre></div><p>We'll cover these for now.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Activity 3 — Building the Dockerfile</h2></div></div></div><p>Ensure you have the Docker CLI running by typing <code class="literal">docker</code> on your terminal. </p><p>To get you conversant with Dockerfile syntax. The goal of this activity is to help understand and practice working with third-party images and containers. This helps get a bigger picture on how collaboration can still be affected through containerization. This increases product delivery pace by building features or resources that already exist.</p><p>You have been asked to write a simple Dockerfile that prints <code class="literal">hello-world</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">Is Docker up and running? Type <code class="literal">docker</code> on the terminal or command-line application.</li><li class="listitem">Create a new directory and create a new Dockerfile.</li><li class="listitem">Write a Dockerfile that includes the following steps:<div><pre class="programlisting">FROM <code class="literal">ubuntu:xenial </code>
RUN <code class="literal">apt-get install -y apt-transport-https curl software-properties-common python-software-properties</code>
RUN <code class="literal">curl -fsSL https://apt.dockerproject.org/gpg | apt-key add</code> 
RUN <code class="literal">echo 'deb https://apt.dockerproject.org/repo ubuntu-xenial main' &gt; /etc/apt/sources.list.d/docker.list</code>
RUN <code class="literal">apt-get update</code>
RUN <code class="literal">apt-get install -y python3-pip</code>
RUN <code class="literal">apt-get install -y build-essential libssl-dev libffi-dev python-dev</code>
</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec11"/>Building Images</h1></div></div></div><p>Before we <a class="indexterm" id="id29"/>begin building images, let's understand the context first. An image is a standalone package that can run an application or allocated service. Images are built through Dockerfiles, which are templates that define how images are to be built.</p><p>A container is defined as a runtime instance or version of an image. Note this will run on your computer or the host as a completely isolated environment, which makes it disposable and viable for tasks such as testing.</p><p>With the Dockerfiles ready, let's get to the Python Dockerfile directory and build the image.</p><div><div><div><div><h2 class="title"><a id="ch02lvl3sec07"/>docker build</h2></div></div></div><p>The<a class="indexterm" id="id30"/> command to build images is as follows:</p><div><pre class="programlisting">docker build -t &lt;image-name&gt; &lt;relative location of the Dockerfile&gt;</pre></div><p>
<code class="literal">-t</code> stands for the tag. The <code class="literal">&lt;image-name&gt;</code> can include the specific tag, say, latest. It is advised that you do it this way: always tagging the image.</p><p>
<strong>The relative location of the Dockerfile</strong> here would be a <code class="literal">dot (.)</code> to mean that the Dockerfile is on the same level as the rest of the code; that is, it is at the root level of the project. Otherwise, you would enter the directory the Dockerfile is in. </p><p>If, for example, it is in the Docker folder, you would have <code class="literal">docker build -t &lt;image-name&gt; docker</code>, or if it is in a folder higher than the root directory, you <a class="indexterm" id="id31"/>would have two dots. Two levels higher would be three dots in place of the one dot.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>The<a class="indexterm" id="id32"/> output on the terminal and compare to the steps written on the Dockerfiles. You may want to have two or more Dockerfiles to configure different situations, say, a Dockerfile to build a production-ready app and another one for testing. Whatever reason you may have, Docker has the solution.</p></div></div><p>The default Dockerfile is, yes, Dockerfile. Any additional one by best practices is named <code class="literal">Dockerfile.&lt;name&gt;</code>,say, <code class="literal">Dockerfile.dev</code>. </p><p>To build an image using a Dockerfile aside from the default one, run the following: <code class="literal">docker build -f Dockerfile.&lt;name&gt; -t &lt;image-name&gt; &lt;relative location of the Dockerfile&gt;</code>
</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>If you rebuild the image with a change to the Dockerfile, without specifying a different tag, a new image will be built and the previous image is named <code class="literal">&lt;none&gt;.</code>
</p></div></div><p>The<code class="literal"> docker</code> build command has several options that you can see for yourself by running <code class="literal">docker build --help</code>. Tagging images with names such as latest is also used for versioning. We will talk more on this in the <em>Topic F</em>.</p><p>To build the image, run the following command in the Python workspace:</p><div><pre class="programlisting">
<code class="literal">&gt;$ docker build -t python-docker .</code>
</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>The trailing dot is an important part of the syntax here:</p><div><img alt="docker build" src="img/image01_17a.jpg"/></div></div></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>The trailing dot is an important part of the syntax here:</p><div><img alt="docker build" src="img/image01_18a.jpg"/></div></div></div><p>Open the<a class="indexterm" id="id33"/> JavaScript directory and build the JavaScript image as follows:</p><div><pre class="programlisting">
<code class="literal">&gt;$ docker build -t js-docker .</code>
</pre></div><p>Running the<a class="indexterm" id="id34"/> commands will outline the four steps based on the four lines of commands in the <strong>Dockerfile</strong>.</p><p>Running <code class="literal">docker images</code> lists the two images you have created and any other image you had pulled before.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl3sec08"/>Removing Docker Images</h2></div></div></div><p>The <code class="literal">docker rmi &lt;image-id&gt;</code> command is used to delete an image. Let me remind<a class="indexterm" id="id35"/> you that the image ID can be found by running the <code class="literal">docker images</code> command. </p><p>To delete the images that are non-tagged (assumed not to be relevant), knowledge of bash scripting comes in handy. Use the following command: </p><div><pre class="programlisting">docker rmi $(docker images | grep "^&lt;none&gt;" | awk "{print $3}")</pre></div><p>This simply searches for images with &lt;none&gt; within their row of the <code class="literal">docker images</code> command and returns the image IDs that are in the third column:</p><div><img alt="Removing Docker Images" src="img/image01_19a.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Activity 4 — Utilizing the Docker Image</h2></div></div></div><p>Ensure you have the Docker CLI running by typing <code class="literal">docker</code> on your terminal. </p><p>To get you conversant with running containers out of images.</p><p>You have been<a class="indexterm" id="id36"/> asked to build an image from the Dockerfile written in <em>Activity C</em>. Stop the running container, delete the image, and rebuild it using a different name.</p><div><ol class="orderedlist arabic"><li class="listitem">Is Docker up and running? Type <code class="literal">docker </code>on the terminal or command-line application.</li><li class="listitem">Open the JavaScript example directory.</li><li class="listitem">Run <code class="literal">docker build -t &lt;choose a name&gt;</code> (observe the steps and take note of the result).</li><li class="listitem">Run <code class="literal">docker run &lt;the-name-you-chose&gt;.</code></li><li class="listitem">Run <code class="literal">docker stop &lt;container ID&gt;.</code></li><li class="listitem">Run <code class="literal">docker rmi &lt;add the image ID here&gt;.</code></li><li class="listitem">Run <code class="literal">docker build -t &lt;choose new name&gt;.</code></li><li class="listitem">Run <code class="literal">docker ps</code> (note the result; the old image should not exist).</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Running Containers From Images</h1></div></div></div><p>Remember when<a class="indexterm" id="id37"/> we mentioned containers are built from images? The command <code class="literal">docker run &lt;image&gt;</code> creates a container based on that image. One can say that a container is a running instance of an image. Another reminder is that this image could either be local or in the registry.</p><p>Go ahead and run the already created images <code class="literal">docker run python-docker</code> and <code class="literal">docker run js-docker:</code>
</p><div><img alt="Running Containers From Images" src="img/image01_20a.jpg"/></div><p>What do you notice? The containers run outputs to the terminal's respective lines. Notice that the command preceded by CMD in the Dockerfile is the one that runs:</p><div><pre class="programlisting">docker build -t python-docker:test .  and docker build -t js-docker:test .</pre></div><p>Then, run the following:</p><div><pre class="programlisting">python-docker:test and docker run js-docker:test</pre></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>You will not see any output on the terminal.</p></div></div><p>This is not because we don't have a command <code class="literal">CMD</code> to run as soon as the container is up. For both images built from <strong>Python</strong> and <strong>Node</strong>, there is a <code class="literal">CMD</code> inherited from the base images.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Images created always inherit from the base image.</p></div></div><p>The two containers we have run contain scripts that run once and exit. Examining the results of <code class="literal">docker ps</code>, you'll have nothing listed from the two containers run earlier. However, running <code class="literal">docker ps -a</code> reveals the containers and their state as exited. </p><p>There is a command column that shows the CMD of the image from which the container is built from.</p><p>When running a container, you can specify the name as follows:</p><p>
<code class="literal">docker run --name &lt;container-name&gt; &lt;image-name&gt;</code> (for example, <code class="literal">docker run --name py-docker-container python-docker</code>):</p><div><img alt="Running Containers From Images" src="img/image01_21a.jpg"/></div><p>We outlined earlier that you only want to have relevant Docker images and not the <code class="literal">&lt;none&gt;</code> tagged Docker images.</p><p>As<a class="indexterm" id="id38"/> for containers, you need to be aware that you can have several containers from one image. <code class="literal">docker rm &lt;container-id&gt;</code> is the command for removing containers. This works for exited containers (those that are not running). </p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>For the containers that are still running, you would have to either:</p><p>Stop the containers before removing them (<code class="literal">docker stop &lt;container-id&gt;)</code>
</p><p>Remove the containers forcefully (<code class="literal">docker rm &lt;container-id&gt; -f</code>)</p></div></div><p>No container will be listed if you run <code class="literal">docker ps</code>,<code class="literal"> </code>but sure enough if we run <code class="literal">docker ps -a</code>, you will notice that the containers are listed and their command columns will show the inherited CMD commands: <code class="literal">python3</code> and <code class="literal">node</code>:</p><div><img alt="Running Containers From Images" src="img/image01_22a.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl3sec09"/>Python</h2></div></div></div><p>The CMD in Dockerfile for Python's image is <code class="literal">python3</code>. This means that the <code class="literal">python3</code> command is run in the container and the container exits.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>With this in mind, one gets to run Python without installing Python in one's machine.</p></div></div><p>Try running this: <code class="literal">docker run -it python-docker:test</code> (with the image we created last).</p><p>We <a class="indexterm" id="id39"/>get into an interactive bash shell in the container. <code class="literal">-it</code> instructs the Docker container to create this shell. The shell runs <code class="literal">python3</code>, which is the CMD in the Python base image:</p><div><img alt="Python" src="img/image01_23a.jpg"/></div><p>In the command <code class="literal">docker run -it python-docker:test python3 run.py, python3 run.py</code> is run as you would in the terminal within the container. Note that <code class="literal">run.py</code> is within the container and so runs. Running <code class="literal">docker run -it python python3 run.py</code> would indicate the absence of the <code class="literal">run.py</code> script:</p><div><img alt="Python" src="img/image01_24a.jpg"/></div><div><img alt="Python" src="img/image01_25a.jpg"/></div><p>The same <a class="indexterm" id="id40"/>applies to JavaScript, showing that the concept applies across the board.</p><p>
<code class="literal">docker run -it js-docker:test</code> (the image we created last) will have a shell running node (the CMD in the node base image):</p><div><img alt="Python" src="img/image01_26a.jpg"/></div><p>
<code class="literal">docker run -it js-docker:test node run.js</code> will output <code class="literal">Hello Docker - JS:</code>
</p><div><img alt="Python" src="img/image01_27a.jpg"/></div><p>That proves the inheritance factor in Docker images. </p><p>Now, return the Dockerfiles to their original state with the <strong>CMD commands</strong> on the last line.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Versioning Images and Docker Hub</h1></div></div></div><p>Remember<a class="indexterm" id="id41"/> talking about versioning images in <em>Topic D</em>? We did that by adding latest and using some numbers against our images, such as <code class="literal">3.x.x</code> or <code class="literal">3.x.x-rc.</code>
</p><p>In this topic, we'll <a class="indexterm" id="id42"/>go through using tags for versioning and look at how official images have been versioned in the past, thereby learning best practices. </p><p>The command in use here is the following:</p><div><pre class="programlisting">docker build -t &lt;image-name&gt;:&lt;tag&gt; &lt;relative location of the Dockerfile&gt;</pre></div><p>Say, for example, we know that Python has several versions: Python 3.6, 3.5, and so on. Node.js has several more. If you take a look at the official Node.js page on Docker Hub, you see the following at the top of the list: </p><p>9.1.0, 9.1, 9, latest (9.1/Dockerfile) (as of November 2017):</p><div><img alt="Versioning Images and Docker Hub" src="img/image01_28a.jpg"/></div><p>This <a class="indexterm" id="id43"/>versioning system is called semver: semantic versioning. This version number has the format MAJOR, MINOR, PATCH in an incremental manner:</p><p>
<strong>MAJOR</strong>: For a change that is backward-incompatible</p><p>
<strong>MINOR</strong>: For when you have a backward-compatible change</p><p>
<strong>PATCH</strong>: For when you make bug fixes that are backward-compatible</p><p>You'll notice labels such as <code class="literal">rc</code> and other prerelease and build metadata attached to the image.</p><p>When <a class="indexterm" id="id44"/>building your images, especially for release to the public or your team, using semver is the best practice. </p><p>That said, I advocate that you do this always and have this as a personal mantra: semver is key. It will remove ambiguity and confusion when working with your images.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Deploying a Docker Image to Docker Hub</h1></div></div></div><p>Every time <a class="indexterm" id="id45"/>we run <code class="literal">docker build</code>, the image created is locally available. Normally, the Dockerfile is hosted together with the code base; therefore, on a new machine, one would need to use <code class="literal">docker build</code> to create the Docker image.</p><p>With Docker Hub, any developer has the opportunity to have a Docker image hosted to be pulled into any machine running Docker. This does two things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Eliminates the repetitive task of running <code class="literal">docker build</code></li><li class="listitem" style="list-style-type: disc">Adds an additional way of sharing your application which is simple to set up compared to sharing a link of your app's code base and <strong>README</strong> detailing the setup process</li></ul></div><p>
<code class="literal">docker login</code> is the command to run to connect to <strong>Docker Hub</strong> via the CLI. You need to have an account in hub.docker.com and enter the username and password through the terminal. </p><p>
<code class="literal">docker push &lt;docker-hub-username/image-name[:tag]&gt;</code> is the command to send the image to the registry, Docker Hub:</p><div><img alt="Deploying a Docker Image to Docker Hub" src="img/image01_30a.jpg"/></div><p>A simple <a class="indexterm" id="id46"/>search of your image on <a class="ulink" href="http://hub.docker.com">hub.docker.com</a> will give the output to your Docker image.</p><p>In a new machine, a simple <code class="literal">docker pull &lt;docker-hub-username/your-image-name&gt; </code>command will produce a copy of your image locally. </p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>In this lesson, we have done the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reviewed the DevOps workflow and a few use cases for Docker</li><li class="listitem" style="list-style-type: disc">Walked through Dockerfile syntax</li><li class="listitem" style="list-style-type: disc">Gained a high-level understanding of the build images for applications and running containers</li><li class="listitem" style="list-style-type: disc">Constructed a number of images, versioned them, and pushed them to Docker Hub</li></ul></div></div></body></html>