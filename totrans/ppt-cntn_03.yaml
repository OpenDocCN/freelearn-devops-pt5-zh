- en: Chapter 3. Building a Single Container Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to write our first module to deploy our first
    containerized application. The application that we are going to deploy is Consul
    from HashiCorp ([https://www.consul.io/](https://www.consul.io/)). We will talk
    about Consul a little later in the chapter. The first thing we will look at is
    how to construct a Puppet module with the correct file structure, unit tests,
    and gems. Once we have our module skeleton, we will look at the two ways to deploy
    Consul with Puppet in a container. The first will be to use resource declarations
    in a manifest and the second will be to use Docker Compose as a template `.erb`
    file. These are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Puppet module skeleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding using resource declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding using `.erb` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Puppet module skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things in development is having a solid foundation.
    Writing a Puppet module is no different. This topic is extremely important for
    the rest of the book, as we will be reusing the code over and over again to build
    all our modules from now on. We will first look at how to build a module with
    the Puppet module generator. Once we have our module skeleton, we will look at
    its construct. We will look at the plumbing Puppet uses with Ruby, and lastly,
    at basic unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The Puppet module generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the best things about working with Puppet is the number of tools out
    there, both from the community and from puppetlabs itself. The Puppet module generator
    is a tool that is developed by puppetlabs and follows the best practices to create
    a module skeleton. The best thing about this tool is that it is bundled with every
    Puppet agent install. So, we don''t need to install any extra software. Let''s
    log in to our Vagrant box that we built in the last chapter. Let''s change directory
    to the root of our Vagrant repo and then use the `vagrant up && vagrant ssh` command.
    Now that we are logged in to the box, let''s sudo to root (`sudo -i`) and change
    the directory to `/vagrant`. The reason for this is that this folder will be mapped
    to our local box. Then, we can use our favorite text editor later in the chapter.
    Once we''re in `/vagrant`, we can run the command to build our Puppet module skeleton.
    The `puppet module generate <AUTHOR>-consul` command for me will look like this:
    `puppet module generate scottyc-consul`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script will then ask a few questions such as the version, author name,
    description, where the source lives, and so on. These are very important questions
    that are to be considered when you want to publish a module to the Puppet Forge
    ([https://forge.puppetlabs.com/](https://forge.puppetlabs.com/)), but for now,
    let''s just answer the questions as per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Puppet module generator](img/B05201_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our Puppet module skeleton, we should look at what the structure
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Puppet module generator](img/B05201_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are going to add a few files to help us with unit tests. The first
    file is `.fixtures.yml`. This file is used by `spec-puppet` to pull down any module
    dependencies into the `spec/fixtures` directory when we run our unit tests. For
    this module, the `.fixtures.yml` file should look like the one shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Puppet module generator](img/B05201_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next file that we are going to add is a `.rspec` file. This is the file
    that `rspec-puppet` uses when it requires `spec_helper`, and it sets the pattern
    for our unit test folder structure. The file contents should look as shown in
    this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Puppet module generator](img/B05201_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our folder structure, let''s install the gems that we need
    to run our unit tests. My personal preference is to install the gems on the vagrant
    box; if you want to use your local machine, that''s fine as well. So, let''s log
    in to our vagrant box (cd into the root of our Vagrant repo, use the `vagrant
    ssh` command, and then change the directory to root using `sudo -i`). First, we
    will install Ruby with `yum install -y ruby`. Once that is complete, let''s cd
    into `/vagrant/<your modules folder>` and then run `gem install bundler && bundle
    install`. You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Puppet module generator](img/B05201_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding screenshot, we got some warnings. This is
    because we ran `gem install` as the root. We would not do that on a production
    system, but as this is our development box, it won''t pose an issue. Now that
    we have all the gems that we need for our unit tests, let''s add some basic facts
    to `/spec/classes/init_spec.rb`. The facts we are going to add are `osfamily`
    and `operatingsystemrelease`. So, the file will look as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Puppet module generator](img/B05201_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last file that we will edit is the `metadata.json` file in the root of
    the repo. This file defines our module dependencies. For this module, we have
    one dependency, `docker`, so we need to add that at the bottom of the `metadata.json`
    file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Puppet module generator](img/B05201_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last thing we need to do is put everything in its place inside our Vagrant
    repo. We do that by creating a folder called `modules` in the root of our Vagrant
    repo. Then, we issue the `mv <AUTHOR>-consul/ modules/consul` command. Note that
    we removed the author name because we need the module to replicate what it would
    look like on a Puppet master. Now that we have our basic module skeleton ready,
    we can start with some coding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding using resource declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to use our module skeleton to build our first
    Docker application. We are going to write it using standard Puppet manifests.
  prefs: []
  type: TYPE_NORMAL
- en: But first, why is the first module that we are writing Consul? I chose this
    application for a few reasons. First, Consul has a lot of awesome features such
    as service discovery and health checks, and can be used as a key/value store.
    The second reason is that we will use all the features I just mentioned later
    in the book. So, it will come in handy when we look at Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: File structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create two new files, `install.pp` and `params.pp`, in the `manifests`
    folder. The structure should look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File structures](img/B05201_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing our module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start writing our module. We will start with `init.pp`; this module
    is not going to be very complex as we are only going to add a few lines of code
    and some parameters. As you can see in the preceding screenshot, we created three
    files in the `manifests` directory. When I write a module, I always like to start
    at `params.pp`, as it gives me a good starting structure to work for the code
    that provides the module logic. So, let''s look at `params.pp` for this module,
    which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module](img/B05201_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at the parameters that we have set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$docker_version`: This is the version of Docker that we will install.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$docker_tcp_bind`: This is the IP address and port that the Docker API will
    bind to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$docker_image`: This is the Docker image we will be using from Docker Hub.
    We will be using my Consul image. To read more about the image or get the Dockerfile,
    go to [https://hub.docker.com/r/scottyc/consul/](https://hub.docker.com/r/scottyc/consul/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$container_hostname`: This is going to set the hostname inside the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$consul_advertise`: This is the IP address that Consul is going to advertise.
    We are going to use a built-in Puppet fact, `$::ipaddress_enp0s8`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$consul_bootstrap_expect`: This sets the number of nodes in the Consul cluster.
    We are using just the one. If it was a production cluster, you would use at least
    three.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have set up our parameters, let''s get started on `install.pp`.
    As the name implies, this class will contain the logic that installs Docker, pulls
    the image, and runs the container. So, let''s take a look at the code shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module](img/B05201_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To look at the code in more depth, we will break the class into two, the Docker
    installation and the container configuration. In the Docker installation, the
    first piece of code is a simple package type for `device-mapper-libs`. The reason
    we make sure that this package and its dependencies are installed is that it will
    be the storage drive that Docker will use to mount the container's filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we move on to the Docker install. We start by declaring the `docker` class.
    For this class, we will set the Docker version, calling the parameters we set
    in `params.pp`, and the version of Docker that we are using is 1.9.1 (which is
    the latest at the time of writing this book). The next piece of configurations
    we will declare are the Docker API's TCP bind. Again, we will call our `params.pp`
    class and set the value to `tcp://127.0.0.1:4242`. This binds the API to listen
    to the localhost address on the TCP port `4242`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last value we will set to our Docker install is the Unix socket, which
    Docker will use. We will declare this without calling a parameter. The last piece
    of code makes sure that `device-mapper-libs` is installed before Docker, as it
    is a prerequisite to the Docker install:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module](img/B05201_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have Docker installed, let's look at the code to build our Consul
    container. The first class that we call is `docker::image`. This will pull the
    image from Docker Hub before we call the `docker::run` class. In the `docker::run`
    class, we set `navmar` as the same value as the container's hostname. We will
    get that value from `params.pp` and it will be set to `consul`.
  prefs: []
  type: TYPE_NORMAL
- en: The next configuration we will set is the image. Now, this is different from
    calling `docker::image`. When you call `docker::image`, it pulls the image from
    Docker Hub to the local filesystem. When we set the image value in the `docker::run`
    class, it sets the value for the base image where the container will be deployed
    from. The value is set to `scottyc/consul`, and again we will get that value from
    `params.pp`. The `hostname` parameter is going to set the hostname inside the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we get to the the `resource` attribute that passes running configurations''
    parameters to the container. The `command` attribute is an arbitrary attribute
    that allows you to pass configurations to the container at boot. In this case,
    we are going to pass the boot configuration for the Consul setting as the server
    role, the IP address that the Consul application will bind to, and the number
    of servers that are there in the Consul''s cluster. In the first case, all the
    values in the arguments that we are passing to the `command` attribute come from
    `params.pp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module](img/B05201_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, last but definitely not least, let''s look at what our `init.pp` file
    contains. The first thing that you will note at the top after the main class declaration
    is the mapping of all our parameters to `params.pp`. The reason we do this is
    to set any sensible configurations or defaults in `params.pp` and any sensitive
    data we can overwrite the defaults with Hiera lookups. We will look at Hiera lookups
    in the next chapter. The last line of code includes our `consul::install` class,
    which we covered in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module](img/B05201_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's run our module.
  prefs: []
  type: TYPE_NORMAL
- en: Running our module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have written our module, I am sure we are all keen to run it; however,
    before we can do that, there is one more piece of configuration that we need to
    add to `servers.yml` and `default.pp`. First, we need to make sure that our module
    `consul` is located in `modules/consul`. The next step is to open our `servers.yml`
    file and add the following line at the bottom of the shell commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will copy our module into the correct module path in the vagrant box.
    We also need to forward the Consul port so that we can hit the GUI. This is done
    by adding `- { guest: 8500, host: 8500 }` to the forwarded port''s attribute.
    It should look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our module](img/B05201_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s open our `manifests` directory and edit `default.pp`. We just need
    to add our module to the node definition. You can do this by adding the `include
    consul` configuration, as shown in the following screenshot, and saving both files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our module](img/B05201_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s head to our terminal, change the directory to the root of our Vagrant
    repo, and type the `vagrant up` command. Now, if this box is already running,
    issue a `vagrant destroy -f && vagrant up` command. The output should look as
    shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our module](img/B05201_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even though we a have successful run Puppet, it can take a couple of minutes
    for the container to come up the first time, as it downloads the image from Docker
    Hub, so just be patient. You can easily check when the container is up by going
    to your browser and navigating to `127.0.0.1:8500`. You should get the consul
    GUI, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our module](img/B05201_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have one node that is running, named `consul`, which is the
    hostname that we gave to our container.
  prefs: []
  type: TYPE_NORMAL
- en: Coding using .erb files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this topic, we are going to deploy the same container using `docker-compose`
    with a twist. The twist is with Puppet, where we can turn the `docker-compose.yml`
    file into `docker-compose.yml.erb`. This allows us to take advantage of all the
    tools Puppet gives us to manipulate template files. This is definitely the way
    I like to deploy containers with Puppet; however, I will let you decide for yourself
    the method you like best as we continue through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our module with Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the chapter, we are going to look at how to use `docker-compose` as an `.erb`
    template file. In this example, we are only deploying a single container, but
    when an application contains five or six containers with links, this way is much
    more efficient than using the standard manifest declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will take our `consul` module from the last topic and modify it now
    to use `docker-compose`. If you want to keep that module, just make a copy. First,
    we are not going to touch `init.pp` and `params.pp`—they will remain the same.
    Now, let''s look at `install.pp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module with Docker Compose](img/B05201_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, the top half of the class is exactly
    the same. However, we still install `device-mapper-libs` and declare the `docker`
    class in exactly the same way. The next attribute is different though; here, we
    call the file resource type. The reason is that this is the configuration that
    is used to place our `docker-compose` file on the local filesystem. You can see
    that we are declaring the contents with a template file located in the `templates`
    directory of the module. We will come back to this in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the last resource type in `install.pp`. We are calling the
    `docker_compose` type because this is the resource type that will run the `docker-compose`
    command to bring up our container. Let's look at the attributes that we have configured.
    The first is `navmar`; this will set the name tag in Docker for the container.
    We are calling this value from `params.pp`, and it will be set to `consul`. `ensure`
    is a puppet meta parameter container which ensures that the container is always
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to delete the container, we would have to set this value to `absent`.
    The next attribute is `source`; this sets the folder where the `docker-compose`
    command can find the `docker-compose` file. We have set this to `root`. You could
    change the value to any folder on your system. The last attribute is `scale`.
    This tells `docker-compose` how many containers we want. The value is set to `1`
    in this instance. If we were deploying an nginx web farm, we might set the value
    to a figure such as 5\. Now, let''s get back to that template file. The first
    thing we need to do is create a folder called `templates` in the root of our `consul`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module with Docker Compose](img/B05201_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step after that is to create our `.erb` template file. In `install.pp`,
    we declared the filename as `docker-compose.yml.erb`, so in our `templates` directory,
    let''s create a file with that name. The contents of the file should look as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing our module with Docker Compose](img/B05201_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, the first thing that you should note in the preceding screenshot are the
    variables that are set, such as `<%= @container_hostname %>`. This maps back to
    `init.pp` as `$container_hostname`. As you can see, attributes such as `image`,
    `hostname`, `ports`, and `command` look very familiar. This is because they are
    the same attributes that we declared in the preceding section. In this example,
    we only configured our `docker-compose` file for a single container; in the next
    topic, we will look at a much more complex configuration. Before we get to that,
    let's make sure that this module runs.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose up with Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run our module, let''s make sure that our module is located in the `modules/consul`
    directory in the root of your Vagrant repo. We have the configuration to forward
    port `8500` (`forwarded_ports: - { guest: 8500, host: 8500 }`) and copy our module
    to our module''s path directory using `- { shell: cp /home/vagrant/node-01/modules/*
    -R /tmp/modules }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is in place, let''s run `vagrant up` in our terminal in the root
    of our Vagrant repo. Again, if you have a box that is running, issue the `vagrant
    destroy -f && vagrant up` command. The terminal should give you the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Compose up with Puppet](img/B05201_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we can go to `127.0.0.1:8500` and get the Consul GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Compose up with Puppet](img/B05201_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s log in to our vagrant box; we will do that by issuing the `vagrant
    ssh` command in our terminal from the root of our Vagrant repo. Once we have logged
    in, we can `su` to root (`sudo -i`). Then, we can issue the `docker ps` command
    to look at all the running containers. The terminal should give you the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Compose up with Puppet](img/B05201_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the container is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we deployed our first container with Puppet. In doing so, we
    actually covered a lot of ground. We now have our script to create Puppet modules,
    and we know how to map our Puppet module's dependencies with `metadata.json` and
    `.fixtures.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: In our tool belt, we now have two ways to deploy a container with Puppet, which
    will come in very handy in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
