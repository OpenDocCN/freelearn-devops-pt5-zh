- en: '*Chapter 6*: Deploying Applications with Docker Compose'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第六章*：使用 Docker Compose 部署应用'
- en: The simplest possible practical deployment scenario of an application packaged
    with Docker involves running Docker Compose on a single host. Many of the commands
    that you use as a developer, such as `docker-compose up -d`, also apply to deploying
    Docker applications on a single host.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 部署应用的最简单实用场景是通过在单主机上运行 Docker Compose。你作为开发人员使用的许多命令，例如 `docker-compose
    up -d`，同样适用于在单主机上部署 Docker 应用。
- en: Running Docker applications on a single host is easier to understand than running
    them using one of the more complex container orchestration systems because many
    of the same techniques you might use to run a non-Docker application apply; however,
    it has some significant drawbacks in terms of performance and availability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在单主机上运行 Docker 应用比使用更复杂的容器编排系统运行它们更容易理解，因为你可以使用许多与运行非 Docker 应用相同的技术；然而，在性能和可用性方面，它存在一些显著的缺点。
- en: In this chapter, you will discover why this is the simplest practical option,
    learn how to configure Docker for production on a single host, and master some
    techniques for managing and monitoring a simple setup efficiently. Furthermore,
    you will better understand the drawbacks of running Docker on a single host, including
    the problems you may face.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将发现为何这是最简单的实用选项，学习如何为单主机生产环境配置 Docker，并掌握一些高效管理和监控简单部署的技巧。此外，你还将更好地理解在单主机上运行
    Docker 的缺点，包括可能面临的问题。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Selecting a host and operating system for single-host deployment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为单主机部署选择主机和操作系统
- en: Preparing the host for Docker and Docker Compose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Docker 和 Docker Compose 准备主机
- en: Deploying using configuration files and support scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置文件和支持脚本进行部署
- en: Monitoring small deployments—logging and alerting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控小型部署——日志记录和警报
- en: Limitations of single-host deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单主机部署的限制
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the exercises in this chapter, you'll need Git and Docker on your
    local workstation, and you will need a single host capable of running Linux and
    Docker for your production server, connected to a network that you can SSH into
    and that your users can reach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，你需要在本地工作站上安装 Git 和 Docker，并且需要一台能够运行 Linux 和 Docker 的单主机作为生产服务器，该主机需连接到一个可以通过
    SSH 访问且用户能够访问的网络。
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)—please
    refer to the `chapter6` folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 GitHub 仓库可以在 [https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)
    找到——请参阅 `chapter6` 文件夹。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，查看代码实际应用：
- en: '[https://bit.ly/31OSi1H](https://bit.ly/31OSi1H)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/31OSi1H](https://bit.ly/31OSi1H)'
- en: Example application – ShipIt Clicker v2
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例应用 – ShipIt Clicker v2
- en: 'The version of ShipIt Clicker in this chapter is more polished than the one
    we used in [*Chapter 5*](B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080), *Alternatives
    for Deploying and Running Containers in Production*. It has the following features:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的 ShipIt Clicker 版本比我们在[*第五章*](B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080)中使用的版本更加完善，*部署和运行生产环境中的容器的替代方案*。它具有以下功能：
- en: An improved Dockerfile and `docker-compose.yml` file suitable for basic production
    use
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的 Dockerfile 和适合基本生产环境使用的 `docker-compose.yml` 文件
- en: Storage of game state in Redis tied to a server session, leading to distinct
    game states for different client devices
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Redis 中存储游戏状态并与服务器会话绑定，导致不同客户端设备的游戏状态各异
- en: Improved visual and audio assets
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的视觉和音频资源
- en: We will use this enhanced version of ShipIt Clicker as the application to deploy
    on a single host using Docker Compose.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个增强版本的 ShipIt Clicker 作为应用，通过 Docker Compose 在单主机上进行部署。
- en: Selecting a host and operating system for single-host deployment
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单主机部署选择主机和操作系统
- en: Deploying your application on a single host is the simplest possible way to
    run an application in production. In many ways, it resembles the user experience
    of performing local development using Docker and Docker Compose. If you can package
    the parts of your application using a `docker-compose.yml` file, you are already
    70 percent of the way there. If you already have basic UNIX or Linux system administration
    skills, this will be very easy—this strategy requires the least effort and you
    can master the essentials in an hour or two.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一主机上部署应用是生产环境中最简单的运行方式。从许多方面来看，它类似于使用 Docker 和 Docker Compose 进行本地开发的用户体验。如果你能够通过
    `docker-compose.yml` 文件打包应用的各个部分，那么你已经完成了 70% 的工作。如果你已经具备基本的 UNIX 或 Linux 系统管理技能，那么这将非常简单——这个策略所需的努力最少，你可以在一到两个小时内掌握要点。
- en: Requirements for single-host deployment
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单主机部署的要求
- en: In order to proceed with deployment, you will need a computer running a modern
    Linux operating system of the same architecture as your development system, with
    enough memory and processor and storage capacity to run your application. If you
    are developing on a Windows 10 64-bit desktop using Docker Community Edition,
    you need a Linux system that also uses the x86_64 architecture. If you're using
    Docker on a Raspberry Pi 4 running Raspbian, you need an ARM architecture server.
    Really, you could use any bare metal or virtual machine server, either on-premises
    or in the cloud, as long as it supports Docker.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续进行部署，你需要一台运行现代 Linux 操作系统且架构与开发系统相同的计算机，且该计算机应具备足够的内存、处理器和存储容量来运行你的应用。如果你是在使用
    Docker Community Edition 的 Windows 10 64 位桌面上进行开发，你需要一台使用 x86_64 架构的 Linux 系统。如果你是在运行
    Raspbian 的 Raspberry Pi 4 上使用 Docker，你需要一台 ARM 架构的服务器。实际上，你可以使用任何裸金属服务器或虚拟机服务器，无论是在本地还是云端，只要它支持
    Docker。
- en: Some cloud providers, such as **Amazon Web Services** (**AWS**), offer a free
    tier for their smallest virtual machine deployments, at least for the first year.
    The example in this chapter will work on a host like this, but if you have a larger
    application, you may need to use a larger and more expensive system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些云服务提供商，如 **Amazon Web Services** (**AWS**)，为其最小虚拟机部署提供免费层，至少是第一年。在本章中的示例可以在类似的主机上运行，但如果你的应用较大，你可能需要使用更大、更昂贵的系统。
- en: Production applications often must run *24*7*, and the users of these applications
    may have reliability concerns. While running Docker applications on a single host
    is possibly the least reliable way to proceed, it might be good enough for your
    application. All the single-host reliability measures that vendors such as HP,
    Dell, and IBM have built can be enough in many cases to ensure adequate reliability
    if your application requires that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境中的应用通常需要 *24*7* 不间断运行，且这些应用的用户可能有可靠性方面的担忧。虽然在单一主机上运行 Docker 应用可能是最不可靠的方式，但对于某些应用来说，这可能已经足够。像
    HP、Dell 和 IBM 这样的厂商提供的单主机可靠性措施在很多情况下已经足够确保应用的可靠性，前提是你的应用需要这种级别的可靠性。
- en: 'You will need one of the following Linux operating system distributions that
    support Docker:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下支持 Docker 的 Linux 操作系统发行版之一：
- en: Red Hat Enterprise Linux (or CentOS) 7 or 8
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat Enterprise Linux（或 CentOS）7 或 8
- en: Ubuntu 16.04 or 18.04 or newer
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 16.04 或 18.04 或更新版本
- en: Amazon Linux 2
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Linux 2
- en: Debian Stretch 9
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debian Stretch 9
- en: Buster 10
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buster 10
- en: To minimize time to production and to maximize ease, pick one that you know
    already, or use CentOS 7, which is used in the following examples.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化生产时间并最大化便捷性，选择你已经熟悉的操作系统，或者使用 CentOS 7，后续示例中将使用此版本。
- en: Only select a Docker-focused distribution, such as Container Linux or CoreOS,
    if you want to take a slower, more advanced path to production, as your system
    administration skills may be less effective in those environments. User management
    in CoreOS, for example, works quite differently than it does in more mainstream
    distributions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当你希望采用更慢且更高级的生产路径时，才选择专注于 Docker 的发行版，如 Container Linux 或 CoreOS，因为在这些环境下，你的系统管理技能可能效果不佳。例如，CoreOS
    中的用户管理与主流发行版的方式大不相同。
- en: Because this strategy depends only on having a host that the users of your application
    can reach, you have tremendous flexibility.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个策略仅依赖于用户能够访问的主机，你将拥有极大的灵活性。
- en: Preparing the host for Docker and Docker Compose
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Docker 和 Docker Compose 准备主机
- en: Before you configure the software on the host, you should ensure that it has
    a stable IP address. Sometimes these are referred to as static IP addresses, or
    Elastic IP addresses, in an AWS context. You may need to specially allocate these
    IP address through your provider, which can often be done through the provider's
    console, such as with the **Network** tab in AWS Lightsail, or the **Elastic IPs**
    settings in the AWS EC2 console.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你配置主机上的软件之前，你应确保它具有一个稳定的IP地址。有时这些被称为静态IP地址，或者在AWS中称为弹性IP地址。你可能需要通过提供商特别分配这些IP地址，通常可以通过提供商的控制台进行操作，例如AWS
    Lightsail中的**网络**选项卡，或者AWS EC2控制台中的**弹性IP**设置。
- en: Also, you should map an address (type `shipitclicker.example.com` instead of
    a raw IP address, such as `192.2.0.10`. All public cloud systems have the ability
    to manage DNS entries—for example, [AWS Route 53 (https://docs.aws.amazon.com/rout](https://docs.aws.amazon.com/route53/index.html)e53/index.html),
    and most virtual hosting systems have this capacity as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该映射一个地址（例如使用`shipitclicker.example.com`而不是原始IP地址，如`192.2.0.10`）。所有公共云系统都能够管理DNS条目——例如，[AWS
    Route 53](https://docs.aws.amazon.com/route53/index.html)，大多数虚拟主机系统也具备此功能。
- en: Using operating system packages to install Docker and Git
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用操作系统软件包安装Docker和Git
- en: You will need to install Docker on the host. For production use, avoid the outdated
    Docker versions that ships with operating system distributions, and try to use
    the operating system  packages that Docker publishes for Docker Community Edition.
    You can find instructions on installing Docker Community Edition on the Docker
    website for various operating systems, a[s follows:](https://docs.docker.com/install/linux/docker-ce/centos/)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在主机上安装Docker。对于生产环境，避免使用操作系统发行版中附带的过时Docker版本，尽量使用Docker为Docker社区版发布的操作系统软件包。你可以在Docker官网上找到针对各种操作系统的Docker社区版安装说明，具体如下：[链接](https://docs.docker.com/install/linux/docker-ce/centos/)
- en: '[**CentOS**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/centos/)x/docker-[ce/centos/](https://docs.docker.com/install/linux/docker-ce/debian/)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**CentOS**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/centos/)x/docker-[ce/centos/](https://docs.docker.com/install/linux/docker-ce/debian/)'
- en: '[**Debian**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/debian/)x/docker-[ce/debian/](https://docs.docker.com/install/linux/docker-ce/fedora/)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**Debian**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/debian/)x/docker-[ce/debian/](https://docs.docker.com/install/linux/docker-ce/fedora/)'
- en: '[**Fedora**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/fedora/)x/docker-[ce/fedora/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**Fedora**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/fedora/)x/docker-[ce/fedora/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)'
- en: '[**Ubuntu**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/ubuntu/)x/docker-ce[/ubuntu/](https://docs.docker.com/install/linux/docker-ce/binaries/)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**Ubuntu**: https://docs.docker.com/install/linu](https://docs.docker.com/install/linux/docker-ce/ubuntu/)x/docker-ce[/ubuntu/](https://docs.docker.com/install/linux/docker-ce/binaries/)'
- en: '[**Binaries**: https://docs.docker.com/install/linux/](https://docs.docker.com/install/linux/docker-ce/binaries/)docker-ce/binaries/'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**二进制文件**: https://docs.docker.com/install/linux/](https://docs.docker.com/install/linux/docker-ce/binaries/)docker-ce/binaries/'
- en: 'Use the following commands for a fresh installation of CentOS 7:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CentOS 7的全新安装，使用以下命令：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add your normal, non-root user to the Docker user group, and become a member
    of that group for this Terminal session:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将你常用的非root用户添加到Docker用户组，并在当前终端会话中成为该组的成员：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make sure the Docker service is enabled so that it will start on boot, and
    that the Docker service is started:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Docker服务已启用，这样它会在启动时自动启动，并且Docker服务已经启动：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install `docker-compose` by foll[owing the directions at https://docs.do](https://docs.docker.com/compose/install/)cker.com/compose/install/.
    `1.25.3` is the latest version as of January 2020, but please check the version
    number on that page for the latest to put in the following command, which should
    all be one line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[https://docs.do](https://docs.docker.com/compose/install/)cker.com/compose/install/上的说明安装`docker-compose`。截至2020年1月，`1.25.3`是最新版本，但请检查该页面上的版本号，使用最新版本填入以下命令，这应该是单行命令：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that you have the Docker daemon running and enabled, and you also have `docker-compose`
    installed, you can deploy your application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经启动并启用了Docker守护进程，并且安装了`docker-compose`，你可以部署你的应用程序了。
- en: 'Next, install `git` through your operating system''s package manager. For Red
    Hat family distributions (such as RHEL, CentOS, Fedora, and Amazon Linux), use
    the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过操作系统的包管理器安装 `git`。对于 Red Hat 系列的发行版（如 RHEL、CentOS、Fedora 和 Amazon Linux），请使用以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For Debian family distributions (including Ubuntu), run the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Debian 系列的发行版（包括 Ubuntu），请运行以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, the host is ready to deploy Docker applications. In order to
    complete deployment, we will use a strategy that relies on shell scripts and Docker
    environment configuration files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，主机已准备好部署 Docker 应用程序。为了完成部署，我们将使用一种依赖于 shell 脚本和 Docker 环境配置文件的策略。
- en: Deploying using configuration files and support scripts
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置文件和支持脚本进行部署
- en: 'To deploy our application to a production server, we will use a combination
    of simple commands and support scripts that start or update the running set of
    containers. Let''s start by taking a close look at the two most important files
    required for deployment: `Dockerfile` and `docker-compose.yml`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的应用程序部署到生产服务器，我们将使用简单命令和支持脚本的组合来启动或更新正在运行的容器集。让我们首先仔细看看部署所需的两个最重要的文件：`Dockerfile`
    和 `docker-compose.yml`。
- en: Re-examining the initial Dockerfile
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视初始 Dockerfile
- en: 'The Dockerfile from [*Chapter 5*](B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080),
    *Alternatives for Deploying and Running Containers in Production*, has good layering
    and has `package.json` and `package.json.lock` copied into the image before `RUN
    npm -s install` executes and before the main parts of the app are copied into
    the image. However, it has some rough edges, which we are going to smooth out
    in this chapter to prepare a solid production deployment. First, let''s take a
    look at the initial Dockerfile:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [*第5章*](B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080)的 Dockerfile，*在生产环境中部署和运行容器的替代方案*，具有良好的分层，并且在
    `RUN npm -s install` 执行之前和将应用程序的主要部分复制到镜像之前，已经将 `package.json` 和 `package.json.lock`
    复制到镜像中。然而，它也有一些不足之处，我们将在本章中进行改进，以便为生产部署做好充分准备。首先，让我们看看初始的 Dockerfile：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding Dockerfile for the ShipIt Clicker game prototype gets many things
    right from a local development perspective, but has some limitations, which we
    will address in the Dockerfile for this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 ShipIt Clicker 游戏原型的 Dockerfile 从本地开发的角度来看有很多地方是正确的，但也有一些限制，我们将在本章的 Dockerfile
    中解决这些问题。
- en: 'Very often, developers start with a base image (such as `FROM ubuntu:bionic`)
    that mirrors what they know best: traditional Linux distributions that you might
    run on your workstation. This may help with debugging the Dockerfile initially,
    but it comes at a steep cost because both the base and generated images are large,
    consisting of hundreds of megabytes. Also, the package installation for Ubuntu
    is quite verbose, so the `apt-get install` command has to redirect `stdout` to
    `/dev/null` to prevent verbose output [from taking over our Terminal (](https://askubuntu.com/a/1134785)see
    [https://askubuntu.com/a/1134785](https://askubuntu.com/a/1134785)).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，开发人员会从一个基础镜像开始（例如 `FROM ubuntu:bionic`），这个镜像通常是他们最熟悉的：传统的 Linux 发行版，通常在工作站上运行。这可能有助于最初调试
    Dockerfile，但代价很高，因为基础镜像和生成的镜像都非常大，包含数百兆字节。此外，Ubuntu 的软件包安装过程相当冗长，因此 `apt-get install`
    命令必须将 `stdout` 重定向到 `/dev/null` 以防止冗长的输出 [占用终端](https://askubuntu.com/a/1134785)（参见
    [https://askubuntu.com/a/1134785](https://askubuntu.com/a/1134785)）。
- en: The rest of the initial Dockerfile has some common quirks that you should avoid
    for production, such as copying configuration files for all of the development
    tooling (see the `COPY` command, which copies dotfiles). The initial Dockerfile
    has an entry point (`ENTRYPOINT`) that refers to a server that is best suited
    for development, not production, because it was quick and easy to define that
    way. A real production setup requires a build step that will create a set of assets
    suitable for distribution, as well as a different `npm` command that launches
    the app using those assets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 初始 Dockerfile 的其余部分有一些常见的缺陷，您应该避免在生产环境中使用，比如复制所有开发工具的配置文件（参见 `COPY` 命令，它复制点文件）。初始
    Dockerfile 有一个入口点（`ENTRYPOINT`），它指向一个更适合开发的服务器，而非生产环境，因为这种方式定义起来快速而简便。真正的生产设置需要一个构建步骤来创建适合分发的资源集，还需要一个不同的
    `npm` 命令来使用这些资源启动应用程序。
- en: 'The Dockerfile for this chapter has corrections for all of these issues:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 Dockerfile 修正了所有这些问题：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this revised Dockerfile, we use Alpine Linux instead of Ubuntu for smaller
    images, and we pin the version of Alpine for consistent builds. The container
    image based on Alpine Linux is 71% smaller:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的Dockerfile中，我们使用了Alpine Linux而不是Ubuntu，目的是生成更小的镜像，同时我们固定了Alpine的版本，以确保构建的一致性。基于Alpine
    Linux的容器镜像体积比Ubuntu小71%：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the revised Dockerfile, we also create an `app` user so that Docker runs
    the application as a normal UNIX user, not the `root` user, as that can exacerbate
    security problems.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后的Dockerfile中，我们还创建了一个`app`用户，这样Docker就可以以普通的UNIX用户身份运行应用程序，而不是`root`用户，因为后者可能会加剧安全问题。
- en: After installing the operating system packages and `npm` packages as silently
    as possible, we can copy the application files and the `.babelrc` configuration
    file into `/app`, and then run `RUN npm run compile` in order to prepare the production
    version of the node application, which we run as the `app` user with `ENTRYPOINT
    npm start`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在尽可能无声地安装操作系统包和`npm`包后，我们可以将应用程序文件和`.babelrc`配置文件复制到`/app`目录，然后运行`RUN npm run
    compile`来准备生产版本的节点应用程序，我们以`app`用户身份运行它，并使用`ENTRYPOINT npm start`。
- en: Re-examining the initial docker-compose.yml file
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视初始的docker-compose.yml文件
- en: 'The initial `docker-compose.yml` file from the previous chapter gets the job
    done of starting both a web and a Redis container, but it has some deficiencies.
    The initial `docker-compose.yml` file was adapted from the barebones e[xample
    in the Docker documentati](https://docs.docker.com/compose/)on at [https://docs.docker.com/compose/](https://docs.docker.com/compose/),
    so it has some gaps in how ready it is for production use. Many developers adapt
    these examples without considering certain nuances that matter when you have to
    deploy an application to production. You can think of it as a starting point,
    rather than the final destination. The initial `docker-compose.yml` file is as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章中的初始`docker-compose.yml`文件完成了启动Web和Redis容器的任务，但存在一些不足。初始的`docker-compose.yml`文件是从Docker文档中的简单示例[e[xample](https://docs.docker.com/compose/)改编而来，位于[https://docs.docker.com/compose/](https://docs.docker.com/compose/)，因此它在生产使用时还有一些缺陷。许多开发者在没有考虑到某些生产部署时需要注意的细微差异的情况下，直接适应这些示例。你可以将它视为起点，而非终点。初始的`docker-compose.yml`文件如下：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The revised `docker-compose.yml` file for this chapter is much more robust.
    This file [is inspired in part by the samples at https://gith](https://github.com/docker-library/redis/issues/111)ub.com/docker-library/redis/issues/111
    and especially by an example by GitHub user `@lagden`, which has a nice example
    of a `docker-compose.yml` file that supports Redis:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章修改后的`docker-compose.yml`文件更加健壮。这个文件[部分灵感来自于 https://gith](https://github.com/docker-library/redis/issues/111)ub.com/docker-library/redis/issues/111，尤其是GitHub用户`@lagden`提供的示例，其中展示了一个支持Redis的`docker-compose.yml`文件的优秀示例：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that we define all the environment variables explicitly for the application,
    and that several of them are defined with a `${VARIABLE_NAME:-default_value}`
    syntax that uses the value of an environment variable. These can be specified
    on the command line, in the usual configuration file: `$HOME/.profile`, `$HOME/.bashrc`,
    or the `.env` file in the same directory as the `docker-compose.yml` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们显式地为应用程序定义了所有环境变量，其中有几个变量使用`${VARIABLE_NAME:-default_value}`语法，该语法利用环境变量的值。可以在命令行、常见的配置文件（如：`$HOME/.profile`、`$HOME/.bashrc`）或者与`docker-compose.yml`文件在同一目录中的`.env`文件中指定这些变量：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding `ports` section defines the networking configuration for the
    main container; it defines a private network called `private-redis-shipit-clicker-v2`,
    which links the two containers. Note the use of `depends_on` in this section.
    This means that the ShipIt Clicker container will wait until the Redis container
    is started before starting. Next, let''s examine the Redis container definition:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`ports`部分定义了主容器的网络配置；它定义了一个名为`private-redis-shipit-clicker-v2`的私有网络，该网络将两个容器连接起来。请注意，这部分使用了`depends_on`。这意味着ShipIt
    Clicker容器将在Redis容器启动后才会启动。接下来，让我们看看Redis容器的定义：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This has many environment variable entries—for example, `LOG_LEVEL`, `REDIS_HOST`,
    and `REDIS_PORT`—that allow easy overrides. It allows the override of Redis host
    settings, both for easier debugging and to pave the way for easy connection to
    cloud Redis services. It starts Redis with command-line parameters that enable
    persistence and allocates a Docker persistent volume to store Redis append-only
    log files. Otherwise, the data would vanish every time the Redis container is
    restarted. It makes the network where Redis and the web server communicates private.
    This is especially important with Redis because, with the default configuration,
    the Redis server operates without any authentication or authorization—it is wide
    open to whoever can connect!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含许多环境变量条目——例如 `LOG_LEVEL`、`REDIS_HOST` 和 `REDIS_PORT`——允许轻松覆盖。这使得重写 Redis
    主机设置变得容易，无论是为了更方便的调试，还是为了便于连接到云端 Redis 服务。它通过命令行参数启动 Redis，并启用持久化，同时分配一个 Docker
    持久卷来存储 Redis 的仅附加日志文件。否则，每次 Redis 容器重启时，数据都会丢失。它使得 Redis 和 Web 服务器之间的网络通信变为私密。这一点尤其重要，因为
    Redis 的默认配置下，Redis 服务器在没有任何身份验证或授权的情况下运行——这意味着任何能够连接的人都可以访问！
- en: In this minimalistic, production-ready `docker-compose.yml` file, we expose
    the web server directly on port `80` to the world. This works, but modern browsers
    will show a security warning for plain HTTP content. It will work to get you to
    production, but many production applications require more security safeguards
    than running over plain HTTP. You can get around this by using either a proxy
    or external load balancer that terminates HTTPS on port `443`, or by configuring
    SSL certificates. We will cover this in more detail in later chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简约的、适用于生产环境的 `docker-compose.yml` 文件中，我们将 Web 服务器直接暴露在 `80` 端口上供全世界访问。这是可行的，但现代浏览器会对纯
    HTTP 内容显示安全警告。虽然这能让你顺利进入生产环境，但许多生产应用程序需要比纯 HTTP 更强的安全保护。你可以通过使用代理或外部负载均衡器，在 `443`
    端口终止 HTTPS，或者通过配置 SSL 证书来绕过这个问题。我们将在后续章节中详细介绍这一点。
- en: One of the features of the `docker-compose` v3 configuration is that it sets
    the default behavior for when a container fails to *always restart*. This should
    happen even if the host is rebooted, and will definitely happen if a process exits
    due to an unhandled exception. If you need to configure the restart behavior of
    your application more directly, you can do so with the settings listed in the
    documentation at [https://docs.docker.com/compose/compose-file/#restart_policy](https://docs.docker.com/compose/compose-file/#restart_policy).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` v3 配置的一个特点是它设置了容器失败时的默认行为为*始终重启*。即使主机重新启动，这也应该发生，如果进程由于未处理的异常退出，这种行为也一定会发生。如果你需要更直接地配置应用程序的重启行为，可以参考文档中列出的设置，链接为
    [https://docs.docker.com/compose/compose-file/#restart_policy](https://docs.docker.com/compose/compose-file/#restart_policy)。'
- en: Preparing the production .env file
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备生产环境的 .env 文件
- en: 'Clone the repository and prepare to configure `docker-compose`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆仓库并准备配置 `docker-compose`：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to configure your application for production, you should create a file
    called `.env` in the directory where your `docker-compose.yml` file lives. If
    you want to change any of the defaults—for example, to change the level of debugging
    shown in production from `info` to `debug`—you should do so through creating and
    editing the `.env` file associated with the production deployment. Copy the file,
    `env.sample`, to `.env` and edit it to suit your preferences for production.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置生产环境中的应用程序，你应该在 `docker-compose.yml` 文件所在的目录中创建一个名为 `.env` 的文件。如果你想更改任何默认设置——例如，将生产环境中的调试级别从
    `info` 改为 `debug`——你应该通过创建和编辑与生产部署相关的 `.env` 文件来进行修改。将 `env.sample` 文件复制为 `.env`
    并根据你的生产需求进行编辑。
- en: Handling secrets
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理密钥
- en: This demo application uses environment variables and an `.env` file to store
    secrets. This is in accordance wit[h the 12-factor application](https://12factor.net/config)
    principles (see https://12factor.net/config), but it is certainly not the only
    way, or the most secure way, to deal with secrets. You could use a secret management
    system, such as HashiCorp Vault or Amazon Secrets Manager, to store and retrieve
    secrets. We will cover this in detail in both [*Chapter 8*](B11641_08_Final_AM_ePub.xhtml#_idTextAnchor157),
    *Deploying Docker Apps to Kubernetes*, and [*Chapter 14*](B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316),
    *Advanced Docker Security – Secrets, Secret Commands, Tagging, and Labels*; but
    for now, let's just use environment variables for the secrets.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用程序使用环境变量和 `.env` 文件来存储密钥。这符合[12因子应用](https://12factor.net/config)原则（详见
    https://12factor.net/config），但这并不是处理密钥的唯一方法，也不是最安全的方法。你可以使用密钥管理系统，例如 HashiCorp
    Vault 或 Amazon Secrets Manager，来存储和检索密钥。我们将在[*第8章*](B11641_08_Final_AM_ePub.xhtml#_idTextAnchor157)《将
    Docker 应用部署到 Kubernetes》和[*第14章*](B11641_14_Final_NM_ePub.xhtml#_idTextAnchor316)《高级
    Docker 安全性 - 密钥、密钥命令、标签和标签》详细介绍这一点；但目前，我们先使用环境变量来处理密钥。
- en: 'You should replace the secret in the environment variable, `SESSION_SECRET`,
    with a random secret and confirm whether you want to expose port `80` to the world.
    Use whatever editor you are comfortable with, whether that is `vi`, `emacs`, or
    `nano`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该用随机的密钥替换环境变量中的 `SESSION_SECRET` 密钥，并确认是否要将端口 `80` 暴露给外界。使用你熟悉的编辑器，不论是 `vi`、`emacs`
    还是 `nano`：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once you have set the environment variable overrides, you can deploy the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好环境变量覆盖后，你可以部署应用程序。
- en: Deploying for the first time
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首次部署
- en: 'Once you have copied your `.env` file in place, start the services in the background
    to deploy the application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你把 `.env` 文件放置好，后台启动服务以部署应用程序：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Verify that the services are running, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤验证服务是否正在运行：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Check whether the system logs show any errors:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 检查系统日志是否显示任何错误：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As long as you don't see a stream of error messages in the logs, you should
    then be able to reach the website at [the IP address o](http://192.0.2.10)f the
    server—for example, at `http://192.0.2.10`—substituting your IP address. If you
    assigned a hostname using DNS, you should be able to [reach it using that hostname—f](http://shiptclicker.example.com)or
    example, at [http://shiptclicker.example.com](http://shiptclicker.example.com)—substituting
    the full canonical domain name for this one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只要在日志中没有看到一连串的错误信息，你应该能够通过服务器的 [IP 地址](http://192.0.2.10)访问该网站，例如 `http://192.0.2.10`，用你的
    IP 地址替代。如果你使用 DNS 分配了主机名，你应该可以[通过主机名访问它—例如](http://shiptclicker.example.com)，例如，[http://shiptclicker.example.com](http://shiptclicker.example.com)，用这个域名替代原始域名。
- en: Troubleshooting common errors
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排查常见错误
- en: 'If you get an error like this, you need to ensure that the host is not running
    another web server, such as Apache HTTPD or NGINX:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到类似的错误，你需要确保主机上没有运行其他的 Web 服务器，例如 Apache HTTPD 或 NGINX：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you get this issue, you should either uninstall the web server that is running
    on the host or change what port it uses to listen for requests. You could also
    change the port that ShipIt Clicker runs on by changing the `PORT` variable in
    the `.env` file. For Red Hat family systems, a server listening on port `80` is
    likely to be Apache HTTPd, and you can remove it with the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到这个问题，你应该卸载主机上运行的 Web 服务器，或者更改它监听请求的端口。你也可以通过更改 `.env` 文件中的 `PORT` 变量，改变
    ShipIt Clicker 运行的端口。对于 Red Hat 系列系统，监听端口 `80` 的服务器很可能是 Apache HTTPd，你可以使用以下命令来移除它：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For Debian family systems, it is also likely to be Apache, and you will need
    to use the following command to remove it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Debian 系列的系统，通常也可能是 Apache，你需要使用以下命令来移除它：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is possible that you might have some other web server running. You can find
    out what the process name of your web server is with `netstat`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的系统上运行着其他 Web 服务器。你可以使用 `netstat` 查找你 Web 服务器的进程名称：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may not need to do any troubleshooting to get your application running in
    Docker, but in a single-host deployment scenario, you can use your system administration
    troubleshooting skills to figure out what might be going wrong.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不需要进行故障排除就能让应用程序在 Docker 中运行，但在单主机部署场景下，你可以使用系统管理员的故障排除技能来找出可能出错的地方。
- en: Once you have the application running, you may find that you run some of the
    same operations repeatedly, such as rebuilding the application when you have made
    changes. This is where support scripts come in handy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序运行起来，您可能会发现您经常运行一些相同的操作，例如在进行更改后重建应用程序。这就是支持脚本派上用场的地方。
- en: Supporting scripts
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持脚本
- en: When running a site in production, you might have to do some operations frequently.
    It becomes tiresome to remember the exact sequence of the Docker commands required
    to restart and update the running system or to connect to the database.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行站点时，您可能经常需要执行一些操作。记住重新启动和更新运行系统或连接到数据库所需的确切Docker命令序列变得很烦人。
- en: You should continue to develop your application on your local workstation and
    use the production system to deploy changes to your users, once you have tested
    things locally.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该继续在本地工作站上开发您的应用程序，并使用生产系统将更改部署给您的用户。
- en: With the improved networking setup in this chapter, it is no longer possible
    to connect directly to the Redis container via a direct TCP port, so we will use
    `docker exec` within a script to do that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中改进的网络设置中，不再可能通过直接TCP端口直接连接到Redis容器，因此我们将使用脚本内的`docker exec`来执行此操作。
- en: 'If you are in the `Docker-for-Developers``/chapter6` directory, you can permanently
    add this directory to `PATH` with the following commands to make running these
    scripts more convenient:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`Docker-for-Developers``/chapter6`目录中，可以通过以下命令将该目录永久添加到`PATH`中，以便更方便地运行这些脚本：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The most common operations for this application are probably restarting the
    application, deploying changes, and connecting to Redis to troubleshoot. For these
    operations, we will use the `restart.sh` script, the `deploy.sh` script, and the
    `redis-cli.sh` script.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此应用程序来说，最常见的操作可能是重新启动应用程序，部署更改和连接到Redis进行故障排除。对于这些操作，我们将使用`restart.sh`脚本，`deploy.sh`脚本和`redis-cli.sh`脚本。
- en: Restarting
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新启动
- en: 'The `restart.sh` script will restart all the containers. You should run this
    after you make a change to the configuration file, `.env`. You could just run
    `docker-compose up -d`, but that alone will not tell you whether the changes took
    hold. This will also run `docker-compose ps` for you, which will show you whether
    your containers are running correctly after the change, including what the port
    mappings are. In the following example session, we remove the `.env` file entirely
    and then recreate it with just a single setting for `PORT=80`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart.sh`脚本将重新启动所有容器。在修改配置文件`.env`后，您应该运行此命令。您可以简单地运行`docker-compose up
    -d`，但仅此不足以告诉您更改是否生效。此命令还将为您运行`docker-compose ps`，以显示更改后您的容器是否正确运行，包括端口映射。在以下示例会话中，我们完全删除`.env`文件，然后仅使用`PORT=80`设置重新创建它：'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see that the `chapter6_shipit-clicker-web-v2_1` application was recreated
    the second time that `restart.sh` was run, and that the server is now connected
    to the wildcard IPv4 `0.0.0.0` address on port `80`. This will allow the server
    to respond to an HTTP request without a special port number in the URL.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到第二次运行`restart.sh`时重新创建了`chapter6_shipit-clicker-web-v2_1`应用程序，并且服务器现在通过通配符IPv4地址`0.0.0.0`连接到端口`80`。这将允许服务器在URL中没有特殊端口号的情况下响应HTTP请求。
- en: Deploying
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: The `deploy.sh` script pulls changes from the `git` upstream repository, builds
    the container, and restarts any containers requiring an update. You should use
    this after you have made changes to the code and tested them locally.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`deploy.sh`脚本从`git`上游仓库拉取更改，构建容器，并重新启动需要更新的所有容器。在本地测试完代码并对其进行了测试后，请使用此选项。'
- en: Redis
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis
- en: The `redis-cli.sh` script will allow you to connect to the running Redis server
    in the command line. It uses a `docker exec` command, which attaches to the running
    container and starts a new `redis-cli` command within it This is needed in part
    because now, Redis is running in an isolated network, and you should not be able
    to reach it via TCP sockets, even from the production host. This will let you
    troubleshoot any issues with the backend server.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis-cli.sh`脚本将允许您在命令行中连接到运行的Redis服务器。它使用`docker exec`命令，在运行的容器中附加并启动新的`redis-cli`命令。由于现在Redis在一个隔离的网络中运行，甚至从生产主机也不应该能够通过TCP套接字访问它。这将帮助您排除后端服务器的任何问题。'
- en: 'Here is a sample session showing `redis-cli.sh` in action:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是展示`redis-cli.sh`运行的示例会话：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that you can use this `redis-cli.sh` script to connect to the Redis server,
    even though it is on a private virtual network that would be inaccessible if you
    had installed the standard `redis-cli` program on the host. Being able to rely
    on tools in a container can allow you to reach deep into the configuration of
    an application, even though it is protected from being directly exposed to the
    internet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使`redis-cli.sh`脚本位于一个私有虚拟网络中（如果您在宿主机上安装了标准的`redis-cli`程序，您将无法访问该网络），您仍然可以使用它连接到
    Redis 服务器。依赖容器中的工具可以让您深入到应用程序的配置中，即便该应用程序被保护，不直接暴露在互联网上。
- en: Exercise – keeping builds off the production server
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 避免在生产服务器上进行构建
- en: 'The deployment script for this chapter does the simplest thing possible for
    updates: it rebuilds the container on the production server. This might, however,
    lead to resource exhaustion and bringing the production server down.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的部署脚本执行最简单的更新方式：它在生产服务器上重建容器。然而，这可能导致资源耗尽并使生产服务器宕机。
- en: Given what you learned about Docker Hub in [*Chapter 4*](B11641_04_Final_NM_ePub.xhtml#_idTextAnchor059),
    *Composing Systems Using Containers*, how might you change the workflow of application
    development to revise the `docker-compose.yml` file and the `deploy.sh` script
    to avoid building the Docker container on the production server?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B11641_04_Final_NM_ePub.xhtml#_idTextAnchor059)《使用容器构建系统》中学到的关于 Docker
    Hub 的知识基础上，您如何修改应用程序开发的工作流程，以便修改`docker-compose.yml`文件和`deploy.sh`脚本，避免在生产服务器上构建
    Docker 容器？
- en: Write down one or two sentences describing the workflow that you would use and
    what alterations to the `docker-compose.yml` configuration file would be needed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 写下您将使用的工作流程的一两句话，并描述`docker-compose.yml`配置文件需要做出哪些更改。
- en: 'Note:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: There are multiple ways to achieve these goals, and there is no single answer
    to how to achieve them. You can compare your answer with the `docker-compose.yml`
    file in the next chapter to see how your ideas compare to the solution for building
    the containers highlighted in that chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现这些目标，并且没有单一的答案来实现它们。您可以将您的答案与下一章中的`docker-compose.yml`文件进行对比，看看您的想法与该章中构建容器的解决方案有何不同。
- en: Exercise – planning to secure the production site
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 规划如何保护生产站点
- en: 'Imagine that you hear from your boss that the ShipIt Squirrel code and production
    systems are going to get some attention from your company''s chief information
    security officer, who is going to go through everything looking for weaknesses.
    He is concerned that in the rush to get this live, too many shortcuts have been
    taken, and he wants you to provide some more information to him. Please write
    down the answers to these three questions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您从老板那里听到消息，ShipIt Squirrel 代码和生产系统将受到公司首席信息安全官的关注，他将全面审查并寻找潜在的安全漏洞。他担心在急于上线的过程中，采取了太多的快捷方式，他希望您提供更多信息。请回答以下三个问题：
- en: What could be done to secure communication between the clients and the server
    with SSL? Which of the following should you do?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何通过 SSL 加密来保护客户端与服务器之间的通信？以下哪些是您应该做的？
- en: a. Terminate SSL within the program itself.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 在程序内部终止 SSL。
- en: b. Use an external load balancer to terminate SSL.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 使用外部负载均衡器终止 SSL。
- en: c. Use a web server on the host, but outside Docker, to terminate SSL.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 在宿主机上使用 Web 服务器，但不在 Docker 中，来终止 SSL。
- en: d. Use Docker and a web server container to terminate SSL.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 使用 Docker 和 Web 服务器容器终止 SSL。
- en: How do you plan on renewing the SSL certificate periodically?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您计划如何定期更新 SSL 证书？
- en: Are there other weaknesses in the security of the current system that you can
    find, either at the Docker layer or the API layer?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否找到当前系统中其他的安全弱点，可能存在于 Docker 层或 API 层？
- en: Once you have deployed the application and considered some enhancements to its
    security, you should learn how to monitor the deployment so that you can find
    out when something goes wrong before the users of your application notice.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序并考虑一些安全增强措施后，您应该学习如何监控部署，以便在用户发现问题之前，先发现故障。
- en: 'Answers for how to secure the production site:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何保护生产站点的答案：
- en: Any of the four options for *Question 1* could work, but options *b* and *d*
    are the most robust and stable in practice. Option *a* is tricky to get right,
    and option *c* requires separate updates to the application environment.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*问题1*的四个选项中任何一个都可以使用，但实践中选项*b*和*d*最为稳健和稳定。选项*a*难以正确实现，选项*c*需要对应用环境进行单独更新。'
- en: Regarding *Question 2*, you can either purchase an SSL certificate from a vendor,
    which you must renew and reinstall every year, you can rely on the vendor of your
    load balancer to automatically renew your certificate (if they offer that as an
    option), or you can use Let's Encrypt to automatically renew the certificate.
    See the *Further reading* section of the next chapter for more about using Let's
    Encrypt to renew the certificate, as well as using a set of Docker containers
    to terminate SSL.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*问题2*，您可以从供应商购买SSL证书，每年必须更新和重新安装，或者依赖负载均衡器的供应商自动更新您的证书（如果他们提供此选项），或者使用Let's
    Encrypt自动更新证书。有关使用Let's Encrypt更新证书以及使用一组Docker容器终止SSL的更多信息，请参阅下一章的*进一步阅读*部分。
- en: '*Question 3* is open-ended, but the first thing that you should notice is that
    there is no authentication or authorization built into the web services in the
    `chapter6` code base.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*问题3*是开放式的，但您应该注意的第一件事是`chapter6`代码库中的Web服务没有内置认证或授权。'
- en: Monitoring small deployments – logging and alerting
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控小型部署 - 日志记录和警报
- en: One of the nice things about starting small is that you may be able to rely
    on very simple mechanisms for both logging and alerting. For any deployment using
    Docker and `Docker Compose` on a single host—for example, a deployment of ShipIt
    Clicker—you can use some basic tools and commands to deal with logging, and a
    variety of simple alerting services provided by third parties to deal with alerting.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好处是，从小开始，您可能可以依赖于非常简单的机制来处理日志记录和警报。对于在单个主机上使用Docker和`Docker Compose`部署的任何部署（例如，ShipIt
    Clicker的部署），您可以使用一些基本的工具和命令来处理日志记录，并使用第三方提供的各种简单的警报服务来处理警报。
- en: Logging
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录
- en: 'For logging, in many cases, all that is required is to use the logs built into
    Docker. Docker captures the standard output and standard error file handles of
    every process it starts and makes them available as logs for each container. You
    can review the consolidated logs for all the services started since the last container
    restart with the following command, assuming you are in the directory where your
    `docker-compose.yml` file is present (`less -R` will interpret the ANSI color
    escapes that the `logs` command produces):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日志记录，在许多情况下，只需使用Docker内置的日志即可。Docker捕获其启动的每个进程的标准输出和标准错误文件句柄，并将它们作为每个容器的日志提供。您可以使用以下命令查看自上次容器重启以来启动的所有服务的汇总日志，假设您在包含您的`docker-compose.yml`文件的目录中（`less
    -R`将解释`logs`命令生成的ANSI颜色转义）：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also do `docker ps` in order to find the name of the running containers
    so that you can retrieve their log streams:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以执行`docker ps`以查找正在运行的容器的名称，以便检索其日志流：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once you have the names of the containers, you can retrieve the individual
    log files for each running container separately. You can pipe them to `less`,
    or redirect the output of the logs to a file, for example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了容器的名称，您可以分别检索每个运行容器的单独日志文件。您可以将它们管道传输到`less`，或者将日志输出重定向到文件，例如：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This procedure does require you to log into the production server and run some
    commands there, but in practice, this is a good way to examine the logs of an
    application running on a single host.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程确实要求您登录到生产服务器并在那里运行一些命令，但实际操作中，这是检查运行在单个主机上的应用程序日志的好方法。
- en: Alerting
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警报
- en: To begin, it would be enough to monitor the HTTP server on port `80` of the
    production server to ensure it stays alive. If you have access to a network monitoring
    system for your company—for example, a Nagios or Icinga server—you could use that.
    If the system is accessible via the internet, you can use a free monitoring service,
    such as [https://uptimerobot.com](https://uptimerobot.com), to monitor the server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始监视生产服务器上端口`80`上的HTTP服务器以确保其保持运行，这就足够了。如果您可以访问公司的网络监控系统，例如Nagios或Icinga服务器，可以使用该系统。如果系统可以通过互联网访问，您可以使用免费的监控服务，例如[https://uptimerobot.com](https://uptimerobot.com)，监控服务器。
- en: In order to extend monitoring deeper, you might want to also monitor the internal
    services, such as Redis. This is more challenging in a simple setup like this
    one, though. We will go into more depth about advanced monitoring systems in [*Chapter
    10*](B11641_10_Final_AM_ePub.xhtml#_idTextAnchor226), *Monitoring Docker Using
    Prometheus, Grafana, and Jaeger*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步扩展监控，您可能还需要监控内部服务，如Redis。然而，在像这样简单的设置中，这更加具有挑战性。我们将在[*第10章*](B11641_10_Final_AM_ePub.xhtml#_idTextAnchor226)中深入讨论高级监控系统，*使用Prometheus、Grafana和Jaeger监控Docker*。
- en: The basic idea here is that you want to get either an email, an SMS message,
    or both if the system goes down.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思路是，如果系统出现故障，您希望收到电子邮件、短信或两者兼有的通知。
- en: Limitations of single-host deployment
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单主机部署的局限性
- en: What could go wrong with deploying a Docker application to a single host? Plenty!
    While single-host deployment offers operational simplicity, it has some major
    limitations. Let's look at some of the limitations in the following sections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将Docker应用程序部署到单一主机时可能出现什么问题？很多！虽然单主机部署提供了操作上的简便性，但也存在一些重大局限性。接下来我们将详细讨论这些局限性。
- en: No automatic failover
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有自动故障转移
- en: If either the database server container or the web service container fails and
    cannot be restarted automatically, the site will be down and will require manual
    intervention. This might be as simple as noticing that your monitoring system
    says that the site is down, and so you need to SSH in and reboot the server. But
    sometimes, a single server will be so low on memory that it must be manually rebooted
    from a higher-level console or even power-cycled manually. This tends to lead
    to significant periods of time where an application is down and not available
    to serve requests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库服务器容器或Web服务容器发生故障且无法自动重启，站点将无法访问，并需要人工干预。这可能只是简单地发现您的监控系统显示站点已停机，然后您需要SSH进入并重启服务器。但有时，单个服务器的内存会非常低，以至于必须从更高层次的控制台手动重启，甚至手动断电再重启。这通常会导致应用程序长时间停机，无法响应请求。
- en: Inability to scale horizontally to accept more load
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无法横向扩展以接受更多负载
- en: What happens if the traffic for the system exceeds the current capacity? In
    single-host deployment, you may be able to switch the host to a larger computer
    with more memory and processors, which is called *vertical scaling*. That is much
    easier in a cloud environment than it is in an environment, where you have to
    deal with physical hardware, such as an on-premises or data center environment.
    It would be much harder to adapt these simple deployment techniques to a whole
    fleet of server instances—which is called *horizontal scaling*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统的流量超出了当前的容量，会发生什么？在单主机部署中，您可能能够将主机切换到更大的计算机，增加更多内存和处理器，这称为*纵向扩展*。在云环境中，这要比在需要处理物理硬件（如本地环境或数据中心环境）中要容易得多。而将这些简单的部署技术应用到整个服务器实例群组中——这被称为*横向扩展*——则要困难得多。
- en: Tracking down unstable behavior based on incorrect host tuning
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于错误的主机调优跟踪不稳定行为
- en: Depending on your hosting provider, the base operating system you start with,
    and how the Docker containers are configured, you might experience instability
    that is hard to track down. Maybe your host gets rebooted frequently due to the
    provider's network detecting unstable hardware or network conditions. Maybe you
    have configured your operating system to install automatic updates and applying
    them causes periods of outages. Maybe the application grows in memory until it
    triggers a failure of some kind.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的托管提供商、您所使用的基础操作系统以及Docker容器的配置，您可能会遇到很难追踪的不稳定性。也许由于提供商的网络检测到不稳定的硬件或网络条件，您的主机会频繁重启。也许您已将操作系统配置为安装自动更新，应用这些更新会导致一段时间的中断。也许应用程序的内存增长到触发某种故障。
- en: For simplicity's sake, the examples in this chapter do not specify memory limits
    at an application or container level. This means that the Redis container could
    consume all available memory on the host since it lacks a `max_memory` setting
    in its application-level main configuration file. It also means that the node
    container running the Express web application could leak memory until the operating
    system **Out-Of-Memory** (**OOM**) killer terminates it or the Docker daemon.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，本章中的示例没有在应用程序或容器级别指定内存限制。这意味着，由于缺少在应用程序级主配置文件中的`max_memory`设置，Redis容器可能会消耗主机上所有可用内存。这也意味着，运行Express
    Web应用程序的节点容器可能会泄漏内存，直到操作系统的**内存溢出** (**OOM**)杀手终止它，或者Docker守护进程终止。
- en: One way of mitigating this problem is by configuring virtual memory on the host
    using a swap file or swap partition, which makes the system look as if it has
    more physical memory than it actually does. If you do not configure a swap file
    on the host, you may find that running the `deploy.sh` script will fail. You might
    not see any messages in the console when this happens, but if you check `/var/log/messages`,
    you will find traces of the Linux kernel's OOM killer terminating the `npm` install
    program or another part of the Docker container build process.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解此问题的一种方法是通过使用交换文件或交换分区来配置主机的虚拟内存，这样系统看起来就像拥有比实际更多的物理内存。如果未在主机上配置交换文件，则可能会发现运行
    `deploy.sh` 脚本时失败。发生这种情况时，控制台可能没有任何信息，但如果检查 `/var/log/messages`，你会发现 Linux 内核的
    OOM 杀手终止了 `npm` 安装程序或 Docker 容器构建过程的其他部分。
- en: 'See the Docker documentation for more on the dangers of not configuring the
    memory for your containers and operating system appropriately:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Docker 文档，了解未为容器和操作系统适当配置内存的风险：
- en: '[https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/)'
- en: Loss of single host could be disastrous – backups are essential
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单台主机的丢失可能会造成灾难性后果 – 定期备份至关重要
- en: If you have hosted your application on a single physical or virtual server,
    you should ensure that the system is backed up regularly. Many providers have
    an image backup service that you can configure to take daily backups and preserve
    them for some period of time for an extra cost. You could also script backups
    of the critical volumes using old-school methods, such as using [TAR and SSH or
    using a modern backup sy](https://restic.readthedocs.io/en/latest/)stem, such
    as `restic` (see [https://restic.readthedocs.io/en/latest/](https://restic.readthedocs.io/en/latest/)),
    to back up the files and volumes to a cloud storage system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用托管在单台物理服务器或虚拟服务器上，应该确保定期备份系统。许多提供商提供镜像备份服务，你可以配置该服务进行每日备份，并将备份保留一段时间，通常需要额外付费。你也可以使用传统方法脚本化备份关键卷，例如使用
    [TAR 和 SSH 或使用现代备份系统](https://restic.readthedocs.io/en/latest/)，比如 `restic`（参见
    [https://restic.readthedocs.io/en/latest/](https://restic.readthedocs.io/en/latest/)），将文件和卷备份到云存储系统。
- en: Case study – migrating from CoreOS and Digital Ocean to CentOS 7 and AWS
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 从 CoreOS 和 Digital Ocean 迁移到 CentOS 7 和 AWS
- en: One of the authors, Richard Bul[lington-McGuire, maintained](https://freezingsaddles.org/)
    a winter cycling competition website, [https://freezingsaddles.org/](https://freezingsaddles.org/),
    on a Digital Ocean droplet using CoreOS for more than a year. This system would
    frequently be knocked offline after a reboot, and it was difficult to track down
    exactly what the problems were that caused the periodic outages. Lack of console
    access to the Digital Ocean control panel and a lack of familiarity with CoreOS
    made troubleshooting the system even more difficult. To ensure that the system
    was backed up, `restic` was installed and configured to send backups to Amazon
    S3\. After many frustrating system administration experiences, the system was
    moved over to AWS using Lightsail, running CentOS 7 as a host operating system.
    To guard against OOM conditions, the new system ran with a swap file equal in
    size to RAM. After this, the system stopped randomly failing every few days and
    operations became much more smooth. Additionally, the new system had daily automatic
    snapshot backups enabled, lessening the need to back up the system with an application-level
    tool such as `restic`. Even so, if the system reboots, the web server does not
    always come up smoothly, with manual intervention required to restore the service.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作者之一 Richard Bul[lington-McGuire，维护了](https://freezingsaddles.org/)一个冬季骑行比赛网站，[https://freezingsaddles.org/](https://freezingsaddles.org/)，该网站托管在
    Digital Ocean 的一个虚拟机上，使用 CoreOS 运行超过一年。这个系统经常在重启后掉线，很难追踪导致周期性宕机的具体问题。由于无法访问 Digital
    Ocean 控制面板的控制台，且对 CoreOS 不熟悉，系统故障排查变得更加困难。为了确保系统有备份，安装并配置了 `restic`，将备份发送到 Amazon
    S3。经过多次令人沮丧的系统管理经历后，系统迁移到了 AWS，使用 Lightsail，并运行 CentOS 7 作为主机操作系统。为了防止 OOM（内存不足）情况发生，新系统配置了一个与内存大小相等的交换文件。此后，系统停止了每隔几天随机宕机的问题，操作也变得更加顺畅。此外，新系统启用了每日自动快照备份，减少了使用像
    `restic` 这样的应用级工具进行备份的需求。尽管如此，如果系统重启，Web 服务器有时仍无法平稳启动，需要手动干预才能恢复服务。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The simplest way to get your Docker-based application to production is to deploy
    it onto a single host with Docker Compose. If you have properly prepared the host
    with the right software, including Docker Compose, you can deploy your application
    there in a production-ready configuration. This can be completed in a matter of
    hours and can serve applications with low to moderate performance and availability
    demands efficiently. If you make the right adjustments to your configuration files,
    your application will be ready to deploy to production. By using shell scripts
    that encapsulate long, verbose commands, you can more easily handle regular maintenance
    and updates for your applications. In the simplest case, you can use external
    monitoring and alerting for this class of application and handle this concern
    with low effort.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于 Docker 的应用程序推向生产环境的最简单方式是通过 Docker Compose 将其部署到单个主机上。如果你已正确准备好主机，安装了合适的软件，包括
    Docker Compose，那么你可以在生产环境配置下将应用程序部署到该主机。这可以在几小时内完成，并且能高效地服务于低到中等性能和可用性需求的应用。如果你对配置文件做出正确调整，应用程序就可以准备好进行生产部署。通过使用封装长而繁琐命令的
    shell 脚本，你可以更轻松地处理应用程序的常规维护和更新。在最简单的情况下，你可以使用外部监控和警报来处理此类应用，并以低成本解决此类问题。
- en: You can apply what you have learned in this chapter to increase the sophistication
    of the Dockerfile and the `docker-compose.yml` file that support your application.
    You can craft simple shell scripts to automate the most common applications. You
    will have learned [that you can rely on e](https://uptimerobot.com)xternal monitoring
    through services such as [https://uptimerobot.com](https://uptimerobot.com) to
    provide simple availability monitoring, and that you can use the built-in Docker
    logging facilities to provide insights into the operations of your application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将本章所学的内容应用于提升支持你应用程序的 Dockerfile 和 `docker-compose.yml` 文件的复杂度。你可以编写简单的 shell
    脚本来自动化最常见的应用。你将了解到，你可以依赖外部监控服务（例如 [https://uptimerobot.com](https://uptimerobot.com)）来提供简单的可用性监控，并且可以使用内建的
    Docker 日志功能来深入了解你应用的运行情况。
- en: Once you have an application deployed, it would be a good idea to increase the
    level of automation surrounding it, particularly related to how you can build
    and deploy the application. In the next chapter, we will see how you can use Jenkins,
    a common continuous integration system, to [automate deployment and testing.](https://www.packtpub.com/free-ebooks/virtualization-and-cloud/docker-cookbook-second-edition/9781788626866)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你部署了应用程序，最好能提高与之相关的自动化水平，特别是在如何构建和部署应用程序方面。在下一章中，我们将看到如何使用 Jenkins —— 一个常见的持续集成系统
    —— 来[自动化部署和测试](https://www.packtpub.com/free-ebooks/virtualization-and-cloud/docker-cookbook-second-edition/9781788626866)。
- en: '[Further reading](https://www.packtpub.com/free-ebooks/virtualization-and-cloud/docker-cookbook-second-edition/9781788626866)'
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[进一步阅读](https://www.packtpub.com/free-ebooks/virtualization-and-cloud/docker-cookbook-second-edition/9781788626866)'
- en: '[*Docker Cookbook*: https://www.packtpub.com/free-ebooks/vi](https://www.packtpub.com/free-ebooks/virtualization-and-cloud/docker-cookbook-second-edition/9781788626866)rtualization-and-cloud/docke[r-cookbook-second-edition/9781788626866](https://docs.docker.com/compose/production/)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*Docker 食谱*](https://www.packtpub.com/free-ebooks/vi)(https://www.packtpub.com/free-ebooks/virtualization-and-cloud/docker-cookbook-second-edition/9781788626866)虚拟化与云端/Docker
    食谱第二版'
- en: '[*Use*](https://docs.docker.com/compose/production/) *Compose in production*:
    https:/[/docs.docker.com/compose/production/](https://geekflare.com/best-open-source-monitoring-software/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*在生产环境中使用*](https://docs.docker.com/compose/production/) *Compose*： https:/[/docs.docker.com/compose/production/](https://geekflare.com/best-open-source-monitoring-software/)'
- en: '[Open source monitoring](https://geekflare.com/best-open-source-monitoring-software/)
    tools: https://geekflar[e.com/best-open-source-monitoring-software/](https://www.dnsstuff.com/free-network-monitoring-software)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[开源监控](https://geekflare.com/best-open-source-monitoring-software/)工具: https://geekflar[e.com/best-open-source-monitoring-software/](https://www.dnsstuff.com/free-network-monitoring-software)'
- en: '[Free monitori](https://www.dnsstuff.com/free-network-monitoring-software)ng
    tools: https://www.dnsstuff.com/free-ne[twork-monitoring-software](https://vsupalov.com/docker-compose-production/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[免费的监控工具](https://www.dnsstuff.com/free-network-monitoring-software): https://www.dnsstuff.com/free-ne[twork-monitoring-software](https://vsupalov.com/docker-compose-production/)'
- en: '[Is `docker-compose` sui](https://vsupalov.com/docker-compose-production/)ted
    for production? [https://vsupalov.com/docker-compose-production/](https://vsupalov.com/docker-compose-production/)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`docker-compose` 是否适用于生产环境？](https://vsupalov.com/docker-compose-production/)
    [https://vsupalov.com/docker-compose-production/](https://vsupalov.com/docker-compose-production/)'
- en: 'Docker tip 2: the difference between `COPY` and `ADD` in a Dockerfile: [https://nickjanetakis.com/blog/docker-tip-2-the-difference-between-copy-and-add-in-a-dockerile](https://nickjanetakis.com/blog/docker-tip-2-the-difference-between-copy-and-add-in-a-dockerile)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 提示 2：`COPY` 和 `ADD` 在 Dockerfile 中的区别：[https://nickjanetakis.com/blog/docker-tip-2-the-difference-between-copy-and-add-in-a-dockerile](https://nickjanetakis.com/blog/docker-tip-2-the-difference-between-copy-and-add-in-a-dockerile)
- en: 'If you are running a real production application on a single host with docker-compose,
    you should strongly consider securing your site with SSL. You can use Let''s Encrypt
    and a host of Docker sidecar containers to achieve this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在单台主机上运行真实的生产应用并使用 docker-compose，您应当强烈考虑使用 SSL 来保护您的网站。您可以使用 Let's Encrypt
    和一组 Docker sidecar 容器来实现这一点：
- en: 'How to use Let''s Encrypt, NGINX, and Docker to secure your site with SSL:
    [https://github.com/nginx-proxy/docker-letsencrypt-nginxproxy-companion](https://github.com/nginx-proxy/docker-letsencrypt-nginxproxy-companion)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Let's Encrypt、NGINX 和 Docker 为您的网站启用 SSL：[https://github.com/nginx-proxy/docker-letsencrypt-nginxproxy-companion](https://github.com/nginx-proxy/docker-letsencrypt-nginxproxy-companion)
- en: 'Using `docker-compose.yml` to configure Let''s Encrypt with NGINX and Docker:
    [https://github.com/nginx-proxy/docker-letsencryptnginx-proxy-companion/blob/master/docs/Docker-Compose.md](https://github.com/nginx-proxy/docker-letsencryptnginx-proxy-companion/blob/master/docs/Docker-Compose.md)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker-compose.yml` 配置 Let's Encrypt 与 NGINX 和 Docker：[https://github.com/nginx-proxy/docker-letsencryptnginx-proxy-companion/blob/master/docs/Docker-Compose.md](https://github.com/nginx-proxy/docker-letsencryptnginx-proxy-companion/blob/master/docs/Docker-Compose.md)
