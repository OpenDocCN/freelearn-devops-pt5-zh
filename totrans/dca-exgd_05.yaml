- en: Container Persistency and Networking
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的持久性和网络
- en: Containers are processes that run on a host. This seems very simple, but how
    will this work on a pool of nodes? If we are looking for high availability, being
    able to run our containers on any host from a pool will ensure execution everywhere.
    But this approach requires some special logic in our applications. Our applications
    must be completely portable and avoid friction and dependencies on any host. Applications
    with many dependencies are always less portable. We need to find a way to manage
    status data for containers. We will review different persistence strategies in
    this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是运行在主机上的进程。这看起来很简单，但在一组节点上如何实现呢？如果我们追求高可用性，能够在池中的任何主机上运行容器将确保在任何地方都能执行。但这种方法需要在我们的应用程序中一些特殊的逻辑。我们的应用必须完全可移植，并避免与任何主机之间的摩擦和依赖关系。具有大量依赖的应用总是更难移植。我们需要找到一种方法来管理容器的状态数据。本章将回顾不同的持久化策略。
- en: On the other hand, the aforementioned pool of hosts must be able to communicate
    with all containers. In this chapter, we will learn about basic standalone host
    networking and introduce advanced cluster-orchestrated networking concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，前述的主机池必须能够与所有容器进行通信。在本章中，我们将学习基本的独立主机网络，并介绍高级集群编排网络概念。
- en: In this chapter, we will cover the differences between stateless and stateful
    applications, how volumes work and how can we use them, and how the Docker daemon
    provides networking on standalone environments. We'll also consider interactions
    between containers and how to publish services provided by processes running within
    containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论无状态和有状态应用程序之间的差异，卷如何工作以及我们如何使用它们，以及Docker守护进程如何在独立环境中提供网络功能。我们还将考虑容器之间的交互以及如何发布容器内运行的进程提供的服务。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding stateless and stateful containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解无状态容器和有状态容器
- en: Learning about different persistence strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不同的持久化策略
- en: Networking in containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器中的网络
- en: Learning about container interactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解容器交互
- en: Publishing applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布应用程序
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will learn about Docker volumes and networking concepts.
    We''ll provide some labs at the end of this chapter that will help you understand
    and learn about the concepts shown. These labs can be run on your laptop or PC
    using the provided Vagrant standalone environment or any already deployed Docker
    host of your own. You can find additional information in this book''s GitHub repository:
    [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Docker卷和网络概念。在本章的最后，我们将提供一些实验，帮助你理解并学习所展示的概念。这些实验可以在你的笔记本电脑或PC上运行，使用提供的Vagrant独立环境或你自己已部署的任何Docker主机。你可以在本书的GitHub仓库中找到更多信息：[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码如何运行：
- en: '"[https://bit.ly/34DJ3V4](https://bit.ly/34DJ3V4)"'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/34DJ3V4](https://bit.ly/34DJ3V4)"'
- en: Understanding stateless and stateful containers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解无状态容器和有状态容器
- en: Portability is key in modern applications because they should run in every environment
    (on-premises or the cloud). Containers are prepared for these situations. We will
    also seek the high availability of applications in production, and containers
    will help us here too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植性是现代应用程序的关键，因为它们应该能够在每个环境中运行（无论是本地还是云端）。容器为这些情况做好了准备。我们还将追求生产环境中应用的高可用性，而容器也将在这里帮助我们。
- en: Not all applications are ready for containers by default. Processes' states
    and their data are difficult to manage inside containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的应用程序默认都可以使用容器。进程的状态和数据在容器内管理起来很困难。
- en: In [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*, we learned that containers are not ephemeral. They
    live in our hosts. Containers are created, executed, and stopped or killed, but
    they will remain in our host until they are deleted. We can restart a previously
    stopped container. But this is only true in standalone environments because all
    information resides under the host data path-defined directory (`/var/lib/docker`
    and `C:\ProgramData\docker` by default on Linux and Windows, respectively). If
    we move our workloads (that is, our application components running as containers)
    to another host, we will not have their data and state there. What happens if
    we need to upgrade their image versions? In that case, we could run a new container
    and everything will be recreated again. We can launch a new container, but we
    need to maintain all application data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml)，*现代基础设施和基于 Docker 的应用程序*中，我们了解到容器并不是短暂的。它们存在于我们的主机中。容器被创建、执行并停止或杀死，但它们会一直存在于主机中，直到被删除。我们可以重新启动之前停止的容器。但这仅适用于独立环境，因为所有信息都存储在主机数据路径定义的目录下（在
    Linux 和 Windows 中，默认路径分别是`/var/lib/docker`和`C:\ProgramData\docker`）。如果我们将工作负载（即作为容器运行的应用组件）迁移到另一台主机上，我们将无法在那儿获取它们的数据和状态。如果我们需要升级它们的镜像版本，会发生什么呢？在这种情况下，我们可以运行一个新的容器，所有内容将重新创建。我们可以启动一个新的容器，但我们需要保持所有的应用数据。
- en: Previously, we introduced volumes as a method used to bypass the internal filesystem
    of containers and their life cycles. Everything inside a volume is, in fact, outside
    of the container's filesystem. This will help us with application performance
    using direct access to a host's devices' but it will also keep data. Volumes will
    persist even when containers are removed (unless we use `--volumes` or `-v` on
    removal). Therefore, volumes will help us maintain application data locally, but
    how about execution on other Docker hosts? We can share images, but a container's
    associated data will not be there unless we can also share volumes between them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们介绍了卷作为绕过容器内部文件系统及其生命周期的一种方法。卷中的一切，实际上都在容器的文件系统之外。这将帮助我们通过直接访问主机的设备来提升应用性能，同时它也能保存数据。即使容器被移除，卷也会保持存在（除非在移除时使用`--volumes`或`-v`选项）。因此，卷有助于我们本地维护应用数据，但如果需要在其他
    Docker 主机上执行怎么办？我们可以共享镜像，但除非我们也能在它们之间共享卷，否则容器相关的数据将无法存在。
- en: Under these circumstances, stateless processes – those that do not require any
    kind of persistent data to work – are easier to manage. These processes are always
    candidates to run within containers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，无状态进程——那些不需要任何持久数据来工作的进程——更容易管理。这些进程总是容器运行的候选者。
- en: And what about stateful processes – those using persistent data between executions?
    We have to take care in this case. We should provide external volumes or databases
    to store the process's state and its required data. These concepts are very important
    when we design microservice-based application architectures.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对于有状态的进程——那些在执行之间使用持久数据的进程，怎么办呢？在这种情况下，我们必须小心。我们应该提供外部卷或数据库来存储进程的状态及其所需数据。当我们设计基于微服务的应用架构时，这些概念是非常重要的。
- en: Let's deep dive into how volumes work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解卷是如何工作的。
- en: Learning how volumes work
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习卷是如何工作的
- en: 'Previously, we learned how to define volumes in images to simply bypass a container''s
    filesystem. Here is a simple Dockerfile definition showing a defined volume (this
    is an excerpt from the PostgreSQL database official image):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何在镜像中定义卷，以简单地绕过容器的文件系统。以下是一个简单的 Dockerfile 定义，展示了定义的卷（这是 PostgreSQL
    数据库官方镜像的摘录）：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have omitted many lines because we just want to review the `VOLUME` definition.
    In this case, all data stored under the `/var/lib/postgresql/data` directory will
    be outside of the container's filesystem. This is an **unnamed volume** definition
    and it will be identified in our system by a random ID when we run a container
    using this image. It was defined for bypassing copy-on-write filesystems. Every
    time we create or run a new container, a new random identifier volume will be
    created. These volumes should be removed manually or by using the `--volume` or
    `-v` options when we remove their associated containers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了许多行，因为我们只想回顾 `VOLUME` 的定义。在这种情况下，存储在`/var/lib/postgresql/data` 目录下的所有数据将位于容器文件系统之外。这是一个**未命名卷**的定义，它将在我们运行使用此镜像的容器时，通过随机
    ID 在系统中进行标识。此卷的定义是为了绕过写时复制文件系统。每次创建或运行新的容器时，都将创建一个新的随机标识符卷。这些卷应当手动删除，或者在删除关联容器时使用
    `--volume` 或 `-v` 选项来删除。
- en: 'Now, it is time to define the different volumes types we can have on Docker:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候定义我们可以在 Docker 中使用的不同类型的卷了：
- en: '**Unnamed volumes**: These are the volumes that are defined on images and therefore
    created using random identifiers. It is hard to track them on local filesystems
    because they are unnamed. As volumes can grow very fast, depending on your application,
    it is very important to check for volume definitions before running any image
    on your local system. Remember that unnamed volumes will grow under your Docker
    data root path, wherever it is.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未命名卷**：这些是在镜像上定义的卷，因此使用随机标识符创建它们。由于它们没有名称，因此很难在本地文件系统上跟踪它们。由于卷可能会随着应用程序的增长而快速增大，因此在本地系统上运行任何镜像之前，检查卷定义非常重要。记住，未命名的卷将会在
    Docker 数据根路径下增长，无论该路径位于何处。'
- en: '**Named volumes**: These are the volumes we create manually. As we learned
    in [*Chapter 1*](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*, volumes are Docker objects and we have some actions
    to control them. In this chapter, we will learn about their associated actions
    and how to use them. These volumes will be located under the data root path also,
    but we can use different plugins or drivers to create them. Drivers will allow
    local or remote volumes, via NFS for example. In these cases, what we will have
    under the data root path is a link to the real mounted remote filesystem. Consequently,
    these volumes will not consume local storage if they are remote.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名卷**：这些是我们手动创建的卷。正如我们在[*第 1 章*](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml)《现代基础设施与
    Docker 应用》中学到的那样，*卷是 Docker 对象，我们可以对其进行一些操作来控制它们*。在这一章中，我们将学习与它们相关的操作以及如何使用它们。这些卷也会位于数据根路径下，但我们可以使用不同的插件或驱动程序来创建它们。驱动程序将允许本地或远程卷，例如通过
    NFS。在这些情况下，我们在数据根路径下看到的将是指向实际挂载的远程文件系统的链接。因此，如果这些卷是远程的，它们将不会消耗本地存储。'
- en: '**Localhost directories or files**: In this case, we will use host directories
    and files inside containers. We usually refer to these volumes as **bind mounts**.
    We must take care of file and directory permissions because we can also use any
    special file inside containers (including devices). Adding permissions that are
    too open will give users access to your host''s devices. They will require appropriate
    process capabilities and permissions. It is important to understand that Docker
    does not care about how block devices, directories, and filesystems are mounted
    on the Docker host. They will be used always as if they were locally available.
    Bind mounts will not be listed as volumes.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地主机目录或文件**：在这种情况下，我们将在容器内使用主机的目录和文件。我们通常将这些卷称为**绑定挂载**。我们必须小心文件和目录的权限，因为我们也可以在容器内使用任何特殊文件（包括设备）。如果权限设置得过于开放，将使用户能够访问主机设备。它们将需要适当的进程能力和权限。重要的是要理解，Docker
    不关心块设备、目录和文件系统在 Docker 主机上的挂载方式。它们总是像本地可用一样被使用。绑定挂载不会作为卷列出。'
- en: '**tmpfs volumes**: This kind of volume is temporal. They will only persist
    in the host memory. When the container stops, the volume will be removed. Files
    inside them will not persist.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tmpfs 卷**：这种类型的卷是临时的。它们只会在主机内存中保持。当容器停止时，卷将被移除。它们内部的文件不会持久化。'
- en: All kinds of volumes can be mounted in read-only mode inside containers. This
    is very important and useful when volume data shouldn't be modified by running
    processes, for example, when serving static web content. We can have containers
    that should be able to modify data and others that will only read and serve this
    modified data using read-only mode.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 各种类型的卷可以以只读模式挂载到容器内。当卷数据不应该被运行中的进程修改时，这非常重要且有用，例如在提供静态网页内容时。我们可以有一些容器应该能够修改数据，另一些容器则只会读取并以只读模式提供这些已修改的数据。
- en: Named volumes or bind mounts will retain data. Unnamed volumes will be created
    with new containers. Keep this in mind. If we need to provide some data to an
    unnamed volume, it should be done when the container starts. We can also define
    a procedure in the image definition. This concept is very important as the position
    of the `VOLUME` definition in Dockerfiles matters. As we learned in [Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    *Building Docker Images*, image creation is based on a sequence of container executions.
    If we add a volume for a specific path, all subsequent executions will not retain
    data in that directory. The building process will create a new unnamed volume
    on each new container and content will not be used between executions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 命名卷或绑定挂载将保留数据。未命名卷将在新容器中创建。请记住这一点。如果我们需要为未命名卷提供一些数据，应该在容器启动时进行。我们还可以在镜像定义中定义一个过程。这个概念非常重要，因为`VOLUME`定义在Dockerfile中的位置非常关键。正如我们在[第2章](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml)《构建Docker镜像》中学到的那样，镜像的创建是基于容器执行的顺序。如果我们为特定路径添加一个卷，所有后续的执行将不会在该目录中保留数据。构建过程将在每个新容器上创建一个新的未命名卷，执行之间的内容不会被复用。
- en: Learning about volume object actions
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习卷对象操作
- en: 'Volumes can be created, used, and removed. We will also be able to inspect
    all their properties. The following table shows the actions that are allowed for
    volume objects:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以被创建、使用和移除。我们还可以检查它们的所有属性。下表展示了卷对象的可执行操作：
- en: '| **Objects** | **Actions** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **操作** |'
- en: '| `create` | We are able to create named volumes. We can add labels for filtering
    the listing output, as we learned in previous chapters. We can specify the driver
    to be used for creating a new volume. By default, volumes will use a local driver.
    This driver will create directories under the `volumes` directory. Each new volume
    will have its own directory containing the required meta-information and a **`_data`**subdirectory.
    This directory contains all files added to the volume. As we mentioned previously,
    some drivers will provide host external storage resources. Linked directories
    will provide connection information instead of their data.We will use `--driver`
    to specify a driver other than `local`. The `--opt` or `-o` arguments allow us
    to add required options for the specified driver. Each driver will have its own
    special options. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 我们能够创建命名卷。我们可以添加标签以过滤列出的输出，正如我们在之前的章节中学到的那样。我们可以指定用于创建新卷的驱动程序。默认情况下，卷将使用本地驱动程序。该驱动程序将在`volumes`目录下创建目录。每个新卷将拥有自己的目录，包含所需的元信息和一个**`_data`**子目录。该目录包含所有添加到卷中的文件。如前所述，一些驱动程序将提供主机外部存储资源。链接目录将提供连接信息而不是其数据。我们将使用`--driver`来指定除`local`之外的其他驱动程序。`--opt`或`-o`参数允许我们为指定的驱动程序添加所需的选项。每个驱动程序都有自己的特殊选项。
    |'
- en: '| `inspect` | All objects can be inspected. In this case, the `inspect` action
    will provide information about the object''s location, the driver used, and the
    labels provided. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `inspect` | 所有对象都可以被检查。在这种情况下，`inspect`操作将提供有关对象位置、使用的驱动程序和提供的标签的信息。 |'
- en: '| `ls` | We can list all volumes using the `ls` action. Almost all filtering
    and formatting options learned throughout this book can be applied. Formatting
    will also depend on a given volume''s properties. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `ls` | 我们可以使用`ls`操作列出所有卷。本书中学到的几乎所有过滤和格式化选项都可以应用。格式化也将取决于给定卷的属性。 |'
- en: '| `prune` | The `prune` option will help us with volume housekeeping. It will
    remove all created volumes not used by any container. It will not delete any bind
    mount because they are not really treated as volumes. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `prune` | `prune`选项将帮助我们进行卷的清理。它将移除所有未被任何容器使用的创建卷。它不会删除任何绑定挂载，因为这些并不被真正视为卷。
    |'
- en: '| `rm` | We can remove volumes using the `rm` action. It is important to note
    that volumes attached to existing containers cannot be removed. Containers should
    be removed before volumes. Alternatively, you can use the `--volumes` option on
    container removal. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | 我们可以使用`rm`操作来删除卷。需要注意的是，附加到现有容器的卷无法被删除。必须先删除容器，然后才能删除卷。或者，您可以在容器删除时使用`--volumes`选项。
    |'
- en: Now, let's introduce how containers use volumes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍容器如何使用卷。
- en: Using volumes in containers
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器中使用卷
- en: 'First, we will start with unnamed volumes. These are volumes defined in a container''s
    images. As we mentioned previously, always review images before execution. If
    we run an application that stores a huge amount of data on a predefined unnamed
    volume, our Docker host can run out of disk space. It is very important to review
    what image will run and what resources will be required. If we take a quick view
    of the `postgres:alpine` image (the PostgreSQL database image based on Alpine
    Linux), for example, we will find a volume definition (we first pull the `postgres:alpine`
    image from Docker Hub):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从未命名的卷开始。这些卷是容器镜像中定义的卷。如前所述，在执行前一定要检查镜像。如果我们运行一个将大量数据存储在预定义的未命名卷上的应用程序，我们的Docker主机可能会耗尽磁盘空间。因此，检查运行的镜像和所需的资源非常重要。例如，如果我们快速查看`postgres:alpine`镜像（基于Alpine
    Linux的PostgreSQL数据库镜像），我们会发现有卷定义（我们首先从Docker Hub拉取`postgres:alpine`镜像）：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, `postgres:alpine` will define an unnamed volume to bypass the
    copy-on-write container filesystem to allow a process to write or modify any content
    under the `/var/lib/postgresql/data` directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`postgres:alpine`将定义一个未命名的卷，以绕过写时复制容器文件系统，允许进程在`/var/lib/postgresql/data`目录下写入或修改任何内容。
- en: 'Let''s create a container named `mydb` using the `postgres:alpine` image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`mydb`的容器，使用`postgres:alpine`镜像：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can inspect the `mydb` container, looking for its mount points (identifiers
    will be different in your system):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查`mydb`容器，查找它的挂载点（在您的系统中标识符会有所不同）：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the obtained volume identifier, we can review its properties:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用获取的卷标识符，我们可以查看它的属性：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output shows where this volume is mounted on our host (`/var/lib/docker/volumes/c888a831d6819aea6c6b4474f53b7d6c60e085efaa30d17db60334522281d76f/_data`)
    and what container is using it that it's mounted on (`/var/lib/postgresql/data`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了该卷在主机上挂载的位置（`/var/lib/docker/volumes/c888a831d6819aea6c6b4474f53b7d6c60e085efaa30d17db60334522281d76f/_data`）以及哪个容器在使用它并将其挂载在（`/var/lib/postgresql/data`）的位置。
- en: 'If we take a look at the `/var/lib/docker/volumes/c888a831d6819aea6c6b4474f53b7d6c60e085efaa30d17db60334522281d76f/_data`
    directory, we can list all PostgreSQL database data files (notice in the following
    log that the directory is owned by root, so root access will be required):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`/var/lib/docker/volumes/c888a831d6819aea6c6b4474f53b7d6c60e085efaa30d17db60334522281d76f/_data`目录，我们可以列出所有PostgreSQL数据库数据文件（请注意，以下日志中的目录归root所有，因此需要root权限访问）：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that files and directories are owned by `userid` (`70`) and `groupid`
    (`70`). This is because the container's main process is not running under the
    root user and, as a result, all files created by the PostgreSQL process will be
    owned by an internal `postgres:postgres` user, whose ID may be different or even
    may not exist on our host. This is the ID used within the container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文件和目录的所有者是`userid`（`70`）和`groupid`（`70`）。这是因为容器的主进程不是以root用户身份运行，因此所有由PostgreSQL进程创建的文件都将归一个内部的`postgres:postgres`用户所有，该用户的ID可能与我们的主机不同，甚至可能在我们的主机上不存在。这是在容器内使用的ID。
- en: 'Let''s stop the `mydb` container and check our volume. You will see that the
    volume is still in our system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止`mydb`容器并检查我们的卷。您将看到该卷仍然存在于系统中：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, we can start our `mydb` container and it will reuse its volume data.
    If we had added data to this database, we would still be able to access it, because
    the volume persists our data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动`mydb`容器，它将重用其卷数据。如果我们向数据库中添加了数据，我们仍然可以访问它，因为卷会持久化我们的数据。
- en: 'Now, let''s remove the `mydb` container:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除`mydb`容器：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can verify that the volume is still under `/var/lib/docker/volumes`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证该卷是否仍在`/var/lib/docker/volumes`下：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Volumes survive containers unless we use `--volume` to remove them with its
    associated container. We can also reuse volume content with other containers.
    But unnamed containers are not easy to manage because they are identified only
    by a digest. We will remove this volume:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容量会保留在容器外，除非我们使用`--volume`将它们与关联的容器一起删除。我们还可以将卷的内容与其他容器共享。但未命名的容器难以管理，因为它们仅通过摘要来识别。我们将删除这个卷：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s create a volume named `mydata`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`mydata`的卷：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, we can create a new container using this volume and its content
    will be available for our new process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用这个卷创建一个新容器，并且它的内容将对我们的新进程可用。
- en: It is important to understand that the `VOLUME` definition in an image is not
    required to use volumes on containers. But they will help us understand what directories
    should be managed out of the container filesystem. Good container images will
    define the directories where persistent data should be stored.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，镜像中的`VOLUME`定义并不是使用容器卷的必要条件。但它们有助于我们了解哪些目录应该管理容器外部的文件系统。好的容器镜像会定义持久数据应该存储的目录。
- en: 'Docker containers can mount volumes using two different options in terms of
    container creation or execution:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器可以在容器创建或执行时使用两种不同的选项挂载卷：
- en: '| `--volume` or `-v` | We will use this option with three arguments, separated
    by `:`. We will use the last argument to declare what type of access will be provided
    (read-only or read-write). The second argument will indicate the container''s
    directory or file where the volume will be mounted within the container. The first
    argument will be different, depending on what type of resource we are using. If
    we are using bind mounts, we will use them as a file or directory in the host.
    If we are using named volumes, this argument will declare which volume will be
    mounted inside the container. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `--volume` 或 `-v` | 我们将使用三个参数与这个选项，参数之间用`:`分隔。我们将使用最后一个参数来声明将提供的访问类型（只读或读写）。第二个参数将指示容器中将挂载卷的目录或文件。第一个参数将根据我们使用的资源类型而有所不同。如果我们使用绑定挂载，它将作为主机中的文件或目录。如果我们使用命名卷，该参数将声明将在容器中挂载的卷。
    |'
- en: There are other options for the third argument when using the `--volume` option.
    In addition to read or write access, we can specify `z` or `Z` when we use SELinux.
    If the volume is going to be shared between multiple containers, we will use these
    options to declare the volume content as private and unshareable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--volume`选项时，第三个参数还有其他选项。除了读取或写入访问权限，我们在使用 SELinux 时可以指定`z`或`Z`。如果卷将在多个容器之间共享，我们将使用这些选项将卷内容声明为私有且不可共享。
- en: '| `--mount` | This notation allows more arguments than `--volume`. We will
    use the key/value format to declare multiple options. The available keys are as
    follows:**- type**: Values available are `bind`, `volume`, or `tmpfs`.**- source
    (or src)**: This will describe the volume or host path.**- destination (or dst
    or target)**: This describes the path where the volume content will be mounted.**-
    readonly**: This identifies the access type for the volume content. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `--mount` | 这个符号表示比`--volume`接受更多的参数。我们将使用键/值格式来声明多个选项。可用的键如下：**- type**：可用的值有`bind`、`volume`或`tmpfs`。**-
    source (或src)**：这将描述卷或主机路径。**- destination (或dst或target)**：这描述了将挂载卷内容的路径。**- readonly**：这表示卷内容的访问类型。
    |'
- en: There is only one difference between using the `--volume` and `--mount` options.
    Using `--volume` will create the endpoint if we specify a path that does not exist
    in the Docker host when using bind mounts, while `--mount` will raise an error
    in this instance and it will not be created.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--volume`和`--mount`选项之间只有一个区别。使用`--volume`时，如果我们在使用绑定挂载时指定的路径在 Docker 主机中不存在，它将创建该端点，而`--mount`在这种情况下会报错并且不会创建该路径。
- en: 'Now, we''ll start an `alpine` container using the defined volume mounted in
    `/data`. We named it `c1` here. We will just touch a file under its `/data` directory:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将启动一个`alpine`容器，使用挂载在`/data`中的定义卷。我们在这里将其命名为`c1`。我们将在其`/data`目录下创建一个文件：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After exiting the container, we can list the files under the `mydata` volume
    filesystem:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 退出容器后，我们可以列出`mydata`卷文件系统下的文件：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can create a new container and reuse our previously created named volume,
    `mydata`. In this example, we will mount it under `/tmp`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新容器，并重新使用我们之前创建的命名卷`mydata`。在这个示例中，我们将其挂载到`/tmp`下：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, both containers, `c1` and `c2`, have mounted the `mydata` volume. Consequently,
    we can''t remove the `mydata` volume unless both are removed from the local system
    (even if we use `--force` for removal):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`c1`和`c2`两个容器都已经挂载了`mydata`卷。因此，除非两个容器都从本地系统中删除，否则我们无法删除`mydata`卷（即使我们使用`--force`进行删除）：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will only be able to remove the `mydata` volume when both containers have
    been removed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当两个容器都被删除时，我们才能删除`mydata`卷：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's learn about some strategies and use cases for storing persistent
    data in containerized environments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解在容器化环境中存储持久化数据的一些策略和用例。
- en: Learning about different persistence strategies
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习不同的持久化策略
- en: As we've already learned, there are different approaches to persistence in containers.
    Choosing the right solution will depend on the use case or requirements of the
    environment and our applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经了解到的，容器中的持久化有不同的方法。选择正确的解决方案将取决于环境和我们应用程序的用例或需求。
- en: Local persistence
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地持久化
- en: We will use local directories or files whenever we are deploying applications
    on isolated and standalone Docker daemons. In this approach, you should take care
    of filesystem permissions and secure module configurations. This strategy is quite
    interesting for developers as they can run multi-container applications on their
    laptops using local source code files inside containers. Therefore, all changes
    made on their local files will be synced within the containers (in fact, they
    will not quite be synced; rather, they are the same files that are mounted inside
    the container filesystem as a bind mount volume). We will review some examples
    of this in the *Chapter labs* section. This solution will not provide high availability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在隔离的独立 Docker 守护进程上部署应用程序时，我们将使用本地目录或文件。在这种方法中，你应该注意文件系统权限和安全模块配置。对于开发人员来说，这种策略非常有趣，因为他们可以在笔记本电脑上使用容器内的本地源代码文件运行多容器应用程序。因此，所有在本地文件上做出的更改将在容器内同步（实际上，它们并不会完全同步；而是作为绑定挂载卷挂载到容器文件系统中的相同文件）。我们将在*章节实验*部分回顾一些例子。这个解决方案不会提供高可用性。
- en: Distributed or remote volumes
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式或远程卷
- en: These are the preferred solutions for orchestrated environments. We should provide
    a pool of distributed or remote storage endpoints to allow applications to run
    everywhere within the cluster. Depending on your applications, volume speed could
    be key for deciding which driver to use. We will also have different choices regarding
    cloud providers. But for common use cases with static content, **Network File
    System** (**NFS**) will be fine. While it would not be enough for databases or
    high I/O application requirements, locking filesystem files is needed when we
    scale instances using shared resources. The Docker daemon will not manage these
    situations as they are out of Docker's scope. Volume I/O and file locking will
    really depend on the application logic and its architecture. Neither distributed
    nor remote volume solutions will provide high availability. In fact, Docker doesn't
    really know anything about storage. It just cares about volumes, no matter how
    storage was implemented on your host.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编排环境中首选的解决方案。我们应该提供一个分布式或远程存储端点池，以便应用程序可以在集群内的任何地方运行。根据你的应用程序，卷的速度可能是决定使用哪个驱动程序的关键。我们也会有不同的云服务提供商选择。但是，对于具有静态内容的常见用例，**网络文件系统**（**NFS**）就足够了。虽然它对于数据库或高
    I/O 应用要求来说可能不够，但在我们使用共享资源扩展实例时，需要对文件系统文件进行锁定。Docker 守护进程不会管理这些情况，因为它们超出了 Docker
    的范围。卷的 I/O 和文件锁定实际上取决于应用程序的逻辑及其架构。分布式或远程卷解决方案都不会提供高可用性。事实上，Docker 并不真正了解存储。它只关心卷，无论你的主机上存储是如何实现的。
- en: Volume drivers provide extensions to extend Docker's out-of-the-box features.
    The Docker plugin system changed in version 1.12 of Docker. Therefore, we refer
    to old plugins as *legacy plugins*, which are not managed using `docker plugin`
    actions. We can find a list of legacy volume plugins at [https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins](https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins).
    New plugins are always managed using `docker plugin` command-line actions. These
    plugins may require special capabilities because they should be able to execute
    privileged actions at the host system level. We will review a quick lab at the
    end of this chapter, where we'll use the `sshfs` plugin.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 卷驱动程序提供扩展功能，以扩展 Docker 的开箱即用功能。Docker 插件系统在 Docker 1.12 版本中发生了变化。因此，我们将旧的插件称为*传统插件*，这些插件不使用
    `docker plugin` 命令进行管理。我们可以在[https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins](https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins)找到传统卷插件的列表。新的插件总是通过
    `docker plugin` 命令行操作进行管理。这些插件可能需要特殊的权限，因为它们应该能够在主机系统级别执行特权操作。在本章的最后，我们将回顾一个快速实验，我们将使用
    `sshfs` 插件。
- en: These described use cases are closer to data management. But what about the
    application state? This is usually managed using volumes, but it really depends
    on your application architecture. One recommendation for new application development
    projects is to track the application state out of containers or even volumes.
    This makes it easier to manage instance replication when we need to scale up or
    down some components. But remember, it should be managed at the application level.
    Docker will just manage how your containerized application components run; it
    will not manage their application states or dependencies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些描述的用例更偏向于数据管理。但应用程序状态呢？通常通过卷来管理，但这确实取决于你的应用架构。对于新的应用开发项目，有一个建议是将应用程序状态追踪放在容器外部，甚至是卷外部。这使得在我们需要扩展或缩减某些组件时，更容易管理实例复制。但请记住，这应该在应用程序级别管理。Docker
    只会管理容器化应用程序组件的运行方式；它不会管理它们的应用状态或依赖关系。
- en: Now that we know how to manage container data and their states using persistent
    volumes, let's get into networking features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了如何使用持久卷来管理容器数据及其状态，接下来我们来探讨网络功能。
- en: Networking in containers
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器中的网络
- en: We have already learned that containers are processes that run isolated on top
    of host operating systems. This isolation is provided using different namespaces
    for users, processes trees, inter-process communications, and a set of complete
    network resources for each containerized process. Therefore, each container will
    have its own network interfaces. To be able to communicate with the world, by
    default, the Docker daemon will create a bridged interface called `docker0`. The
    Docker network plane has not changed too much in the latest releases. It can be
    extended using external tools and plugins and is based on bridged and virtual
    network interfaces that connect hosts and container resources.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解容器是运行在宿主操作系统上的独立进程。这种隔离通过为用户、进程树、进程间通信以及每个容器化进程的一整套网络资源使用不同的命名空间来提供。因此，每个容器将拥有自己的网络接口。为了能够与外界通信，默认情况下，Docker
    守护进程将创建一个名为`docker0`的桥接接口。Docker 网络平面在最新版本中变化不大。它可以通过外部工具和插件扩展，基于桥接和虚拟网络接口，连接宿主机和容器资源。
- en: 'By default, a fresh Docker installation will show three network objects:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新的 Docker 安装将显示三个网络对象：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we have already learned, all objects are identified by their unique ID. The
    Docker network listing shows the network `NAME` (we can set our own network name),
    `DRIVER` (the network type), and `SCOPE` columns (indicating where this network
    will be available). There are different types of networks, according to which
    network driver containers will be used to attach to that network.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学习的，所有对象都通过其唯一的 ID 来识别。Docker 网络列表显示了网络的`NAME`（我们可以设置自己的网络名称）、`DRIVER`（网络类型）和`SCOPE`列（指示此网络将在哪些地方可用）。根据网络驱动程序的不同，容器将被附加到不同类型的网络上。
- en: Besides all common object actions such as `create`, `list` (using `ls`), `inspect`,
    and `remove` (using `rm` or `prune`), networks also have `connect` and `disconnect`
    actions in order to attach or detach containers to/from them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有常见的对象操作，如`create`、`list`（使用`ls`）、`inspect`和`remove`（使用`rm`或`prune`）外，网络还具有`connect`和`disconnect`操作，用于将容器附加或从网络中分离。
- en: 'Let''s review some of the creation options before deep diving on each network
    type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入每种网络类型之前，让我们先回顾一下创建选项：
- en: '| **Option** | **Description** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `--attachable` | This option enables manual container attachment. It is not
    required for locally scoped networks. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `--attachable` | 此选项启用手动容器附加。对于本地作用域网络，它不是必需的。 |'
- en: '| `--aux-address` | Using `--aux-address`, we can add a host and its addresses
    to this network. For example, we can use `--aux-address="mygateway=192.168.1.10"`
    to set a specific host-to-IP mapping on the declared network. It is usually used
    on `macvlan` networks. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `--aux-address` | 使用`--aux-address`，我们可以将一个主机及其地址添加到此网络。例如，我们可以使用`--aux-address="mygateway=192.168.1.10"`在声明的网络上设置特定的主机到
    IP 的映射。通常用于`macvlan`网络。 |'
- en: '| `--config-from`and`--config-only` | We can create (or reuse previously created)
    network configurations. This is very useful for building configurations using
    automation tools, for example, on different hosts and being able to use them when
    needed. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `--config-from` 和 `--config-only` | 我们可以创建（或重用之前创建的）网络配置。这对于使用自动化工具构建配置非常有用，例如在不同的宿主机上，并能够在需要时使用它们。
    |'
- en: '| `--driver` or `-d`and`--opt` | This option allows us to specify which driver
    to use. By default, we can only use `macvlan`, `none`, `host`, and `bridge`. But
    we can extend Docker''s networking capabilities using other external plugins.
    We will use `--opt` to customize the applied driver. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `--driver` 或 `-d` 和 `--opt` | 这个选项允许我们指定要使用的驱动程序。默认情况下，我们只能使用 `macvlan`、`none`、`host`
    和 `bridge`。但我们可以使用其他外部插件来扩展 Docker 的网络功能。我们将使用 `--opt` 来定制所应用的驱动程序。 |'
- en: '| `--gateway` | We can overwrite the default gateway (the lower IP address
    of the defined subnet, by default) and specify another IP address for this purpose.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `--gateway` | 我们可以覆盖默认网关（默认是定义子网的最低 IP 地址），并为此指定另一个 IP 地址。 |'
- en: '| `--ingress` | This option will be used in cases where we want to create a
    special Swarm vxLan network for internal service management. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `--ingress` | 这个选项将在我们需要为内部服务管理创建一个特殊的 Swarm vxLan 网络时使用。 |'
- en: '| `--internal` | This option is only available on overlay networks. We will
    only use it to define internal networks because, by default, all overlay networks
    will be attached to the `docker_gwbridge` bridge network (created automatically
    when operating on a Swarm) to provide external connectivity. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `--internal` | 这个选项仅适用于覆盖网络。我们将只使用它来定义内部网络，因为默认情况下，所有覆盖网络都会连接到 `docker_gwbridge`
    桥接网络（在操作 Swarm 时自动创建）以提供外部连接。 |'
- en: '| `--ip-range` | Once we have configured a subnet, we can specify a range of
    IP addresses to be used for containers. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `--ip-range` | 配置完子网后，我们可以指定一段 IP 地址范围供容器使用。 |'
- en: '| `--ipam-driver`and`--ipam-opt` | With these options, we can use an external
    IP address management driver. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `--ipam-driver` 和 `--ipam-opt` | 使用这些选项，我们可以使用外部 IP 地址管理驱动程序。 |'
- en: '| `--ipv6` | We will use this option to enable IPv6 on this network. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `--ipv6` | 我们将使用这个选项来启用该网络的 IPv6。 |'
- en: '| `--label` | With this, we can add metadata information to networks for better
    filtering. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `--label` | 通过这个选项，我们可以向网络添加元数据，以便更好地进行过滤。 |'
- en: '| `--scope` | With this option, we declare the scope where the network will
    be created for local or Swarm usage. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `--scope` | 通过这个选项，我们声明网络将为本地或 Swarm 使用而创建的范围。 |'
- en: '| `--subnet` | This specifies a subnet in CIDR format that represents a network
    segment. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `--subnet` | 该选项指定一个 CIDR 格式的子网，用来表示一个网络段。 |'
- en: Once created, network objects will exist until they are removed. But removal
    is only possible when no containers are attached to them. It is important to understand
    that dead containers will still have endpoints configured for existing networks
    and must, as a result, be deleted before network removal. On the other hand, the
    `prune` action will remove all unused networks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，网络对象将一直存在，直到被删除。但是，只有当没有容器连接到它们时，才能进行删除。需要理解的是，已删除的容器仍然会在现有网络上配置端点，因此必须先删除容器才能删除网络。另一方面，`prune`
    操作将删除所有未使用的网络。 |
- en: Docker manipulates the `iptables` rules for you every time a network is created
    or some connection or container process publication must be implemented. You can
    avoid this feature, but we strongly recommend allowing the Docker daemon to manage
    these rules for you. It is not easy to track unexpected behaviors and there will
    be many rules to manage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 每次创建网络或需要实现某些连接或容器进程发布时，都会为你操作 `iptables` 规则。你可以避免这一特性，但我们强烈建议允许 Docker
    守护进程为你管理这些规则。追踪意外行为并不容易，而且会有很多规则需要管理。 |
- en: Now that we have the basic `create` command options under our belts, let's look
    at the different standard networks we can create.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基本的 `create` 命令选项，让我们来看一下可以创建的不同标准网络。 |
- en: Using the default bridge network
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用默认的桥接网络 |
- en: Bridge is the default network type for all containers. Any other network types
    must be declared on container creation or execution using the `--network` optional
    parameter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Bridge 是所有容器的默认网络类型。任何其他网络类型必须在容器创建或执行时使用 `--network` 可选参数声明。 |
- en: In operating system terms, we use bridged interfaces to allow forwarded traffic
    from other virtual interfaces. All those virtual interfaces will use a physical
    interface, associated with the bridge, to talk to other network devices or connected
    hosts. In the world of containers, all container interfaces are virtual and they
    will be attached to these bridge interfaces at the host level. Therefore, all
    containers attached to the same bridge interface will see each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统术语中，我们使用桥接接口来允许从其他虚拟接口转发流量。所有这些虚拟接口将使用与桥接关联的物理接口，以与其他网络设备或连接的主机进行通信。在容器的世界中，所有容器接口都是虚拟的，它们将被附加到主机级别的这些桥接接口上。因此，附加到同一桥接接口的所有容器将彼此可见。
- en: 'Let''s look at a quick example of using a bridge network:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用桥接网络的快速示例：
- en: 'We just run two containers, `c1` and `c2`, attached to the default network
    (notice that we have not defined any network at all):'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只运行了两个容器，`c1`和`c2`，附加到默认网络（注意我们根本没有定义任何网络）：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We find their IP addresses:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到它们的IP地址：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Consequently, we can ping each of them:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以对它们中的每一个进行ping测试：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s quickly review some of the `c1` container properties:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速查看一些`c1`容器的属性：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each container will have its own IP address and `EndpointID`. Let''s inspect
    the bridge network''s configuration (created by Docker by default):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个容器都将有自己的IP地址和`EndpointID`。让我们检查由Docker默认创建的桥接网络的配置：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s talk about some of the most important sections in this output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈此输出中一些最重要的部分：
- en: This network is not using IPv6\. It's called `bridge`, was created using the
    `bridge` driver, and will only be available locally on this host.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此网络未使用IPv6。它被称为`bridge`，使用了`bridge`驱动程序创建，并且只能在此主机上本地使用。
- en: It was created using the `172.17.0.0/16` subnet and consequently, all containers
    on this network will get an IP address on this segment range.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是使用了`172.17.0.0/16`子网创建的，因此，此网络上的所有容器将在该段范围内获得一个IP地址。
- en: The bridge interface has the IP address `172.17.0.1` and will be the default
    gateway for all containers.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接口的IP地址是`172.17.0.1`，将成为所有容器的默认网关。
- en: We have two running containers on this network. They are both listed under the
    `Containers` section with their virtual MAC addresses, IP addresses, and associated
    endpoints.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在此网络上有两个正在运行的容器。它们都在`Containers`部分下列出，带有它们的虚拟MAC地址、IP地址和关联的端点。
- en: 'There are a number of options that can be used during network creation that
    are of interest:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络创建期间，有许多有趣的选项可以使用：
- en: '`com.docker.network.bridge.default_bridge: true`: This means that this is the
    default bridge when no network is defined.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.bridge.default_bridge: true`: 这意味着当未定义任何网络时，这是默认的桥接。'
- en: '`com.docker.network.bridge.enable_icc: true`: This parameter indicates that
    containers connected to this network can talk to each other. We can disable this
    feature on custom bridges, allowing just North-South traffic.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.bridge.enable_icc: true`: 此参数表示连接到此网络的容器可以彼此通信。我们可以在自定义桥上禁用此功能，只允许南北流量。'
- en: '`com.docker.network.bridge.name: docker0`: This is the name of the associated
    host interface.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.bridge.name: docker0`: 这是关联主机接口的名称。'
- en: When we refer to *North-South traffic*, we mean the type of communication that
    goes out of the Docker host to the containers and vice versa. On the other hand,
    *East-West traffic* is the traffic between different containers. These are references
    to well-known network terms that are applied to describe network traffic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到*南北流量*时，我们指的是从 Docker 主机到容器及其反向的通信类型。另一方面，*东西流量*是不同容器之间的流量。这些是用来描述网络流量的广为人知的网络术语参考。
- en: Understanding null networks
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解空网络
- en: 'Null or none networks are used when we need to deploy a container that should
    run without any network interface. Although it might sound useless, there are
    many situations where we may need to launch a task for executing a mathematical
    operation, compression, or many other examples that don''t require networking
    capabilities. In these cases, we just need to use volumes and we really do not
    need any network operation. Using a null network ensures that the task will only
    have access to its required resources. If it does not require network access,
    do not provide it. By default, the container will use a `bridge` network unless
    we specify `none`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要部署一个没有任何网络接口的容器时，使用空网络（Null 或 none 网络）。虽然这听起来似乎没有用，但实际上有很多情况我们可能需要启动一个任务来执行数学运算、压缩或许多其他不需要网络功能的操作。在这些情况下，我们只需要使用数据卷，而不需要任何网络操作。使用空网络可以确保任务只会访问所需的资源。如果不需要网络访问，就不提供网络。默认情况下，容器将使用
    `bridge` 网络，除非我们指定 `none`：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we understand that containers can have a null interface to avoid networking,
    we can look at the host's network namespace.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解容器可以使用空接口来避免网络连接，接下来我们可以看看主机的网络命名空间。
- en: Understanding the host network
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解主机网络
- en: Host networking is only available on Linux hosts. This is important because
    it is an important difference in Windows containers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 主机网络仅在 Linux 主机上可用。这一点非常重要，因为它是 Windows 容器的一个重要区别。
- en: 'Using host networking, the container shares the `host` networking namespace.
    Therefore, the container will get all host IP addresses, and every port that''s
    used at the container level will be set on the host. Consequently, no more than
    one container using a specific given port will be allowed to run at a time. But,
    on the other hand, network performance is better because container services are
    directly attached to host ports. There isn''t any NAT or firewall rule adaptation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主机网络时，容器共享 `host` 网络命名空间。因此，容器将获取所有主机的 IP 地址，容器级别使用的每个端口都将在主机上设置。因此，不允许多个容器同时使用特定端口运行。另一方面，网络性能更好，因为容器服务直接连接到主机端口，不需要进行
    NAT 或防火墙规则适配：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you can see that all host interfaces are listed because the container
    is using its network namespace.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到所有主机接口被列出，因为容器正在使用其网络命名空间。
- en: This networking mode is risky because we are allowing any kind of communication
    on the containers. This should be used with care in **privileged mode**. It is
    very common in monitoring tools or when we run applications that require high
    levels of network interface performance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种网络模式有一定风险，因为它允许容器之间进行任何类型的通信。应当在**特权模式**下谨慎使用。它在监控工具中非常常见，或者当我们运行需要高性能网络接口的应用程序时。
- en: We can define our own network interfaces. We'll create custom bridge networks
    in the next section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义自己的网络接口。我们将在下一部分创建自定义桥接网络。
- en: Creating custom bridge networks
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义桥接网络
- en: As we discussed in the default bridge network example, this networking type
    will be associated with host `bridge` interfaces. By default, it is attached to
    `docker0`, but every time we create a new bridge network, a new `bridge` interface
    will be created for us and all attached containers will have a virtual interface
    linked to this one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在默认桥接网络示例中讨论的那样，这种网络类型将与主机的 `bridge` 接口关联。默认情况下，它会附加到 `docker0`，但每次我们创建一个新的桥接网络时，都会为我们创建一个新的
    `bridge` 接口，所有附加的容器都将拥有与该接口相连接的虚拟接口。
- en: 'There are a few very important differences between a default bridge network
    and custom created ones:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认桥接网络与自定义创建的桥接网络之间有一些非常重要的区别：
- en: '**Custom bridge isolation**: Each new custom bridge network created will have
    its own associated bridge with its own subnet and host `iptables`. This feature
    provides a higher level of isolation as only attached containers can talk to each
    other. All other containers running on the same host will not *see* these containers
    running on custom bridge networks.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义桥接隔离**：每个创建的自定义桥接网络都会有自己关联的桥接接口，并且有自己的子网和主机 `iptables`。此功能提供了更高的隔离级别，因为只有附加的容器才能相互通信。所有在同一主机上运行的其他容器将无法*看到*运行在自定义桥接网络上的这些容器。'
- en: '**Internal DNS**: The Docker daemon provides a custom DNS for each custom bridge
    network. This means that all containers running on the same network will know
    each other by name. This is a very important feature because your service discovery
    will not need any external source of knowledge. But remember that this is valid
    only for internal usage within the network.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部 DNS**：Docker 守护进程为每个自定义桥接网络提供自定义的 DNS。这意味着在同一网络上运行的所有容器将通过名称彼此识别。这是一个非常重要的特性，因为服务发现不需要任何外部的知识来源。但请记住，这仅适用于网络内的内部使用。'
- en: We can provide this kind of DNS resolution on default bridge networks using
    the legacy `--link` functionality. This was the way of interconnecting containers
    on old Docker releases. Nowadays, using custom bridge networks is considered as
    providing better isolation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用传统的 `--link` 功能，在默认桥接网络上提供这种类型的 DNS 解析。这是旧版 Docker 中连接容器的方式。如今，使用自定义桥接网络被认为提供了更好的隔离性。
- en: '**On-the-fly container attachment**: In default bridge networks, we must provide
    connectivity in terms of container creation or execution. Imagine that we used
    a null or none network for a container and we want to attach it to a default bridge
    network later – this is not possible. Once a container is created, it can''t be
    attached to a default bridge network later. It must be recreated from the beginning
    with that network attachment. On the other hand, custom bridge networks are attachable,
    which means that we can consider a situation where our container was created without
    a specific attachment and can add it later. We can also run a container with multiple
    interfaces on different custom networks, with its name resolution.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态容器附加**：在默认桥接网络中，我们必须在容器创建或执行时提供连接。假设我们为容器使用了一个 null 或 none 网络，并且之后想将其连接到默认桥接网络——这是不可能的。一旦容器创建，就不能再将其附加到默认桥接网络。必须从头开始重新创建该容器，并附加该网络。另一方面，自定义桥接网络是可以附加的，这意味着我们可以考虑这样一种情况：容器在创建时没有特定的网络连接，后来可以添加该连接。我们还可以在不同的自定义网络上运行一个容器，并为其提供名称解析。'
- en: 'Let''s review a quick example. We will provide more detailed examples in the
    *Chapter labs* section of this chapter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个简单的示例。我们将在本章的 *章节实验* 部分提供更详细的示例：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We review the created network properties (notice the defined subnet) and internal
    settings:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾一下创建的网络属性（请注意定义的子网）和内部设置：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we create a container and test internet access:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个容器并测试互联网访问：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember to use the *Ctrl* + *P* + *Q* shortcut to leave the `intc1` container
    running in the background.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得使用 *Ctrl* + *P* + *Q* 快捷键将 `intc1` 容器运行在后台。
- en: 'You may have noticed that we do not have any egress connectivity. Let''s review
    the internal connectivity with another container:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们没有任何外部连接。让我们通过另一个容器来查看内部连接情况：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As shown in the preceding output, we have internal communication and DNS resolution,
    but we are unable to talk to any other external IP address.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我们有内部通信和 DNS 解析，但无法与任何其他外部 IP 地址进行通信。
- en: 'If we take a look at `iptables`, we can see that the creation of the internal
    network added some very interesting rules to our local firewall. Executing `iptables
    -L` and avoiding all non-Docker related rules, we can observe these rules:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `iptables`，我们可以看到内部网络的创建为本地防火墙添加了一些非常有趣的规则。执行 `iptables -L` 并忽略所有与 Docker
    无关的规则，我们可以观察到这些规则：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These are the rules that manage the internal network isolation we created previously.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是管理我们先前创建的内部网络隔离的规则。
- en: We will examine some multi-interface examples toward the end of this chapter
    in the *Chapter labs* section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的 *章节实验* 部分检查一些多接口示例。
- en: The MacVLAN network – macvlan
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MacVLAN 网络 – macvlan
- en: The MacVLAN driver assigns a virtual MAC address to each container interface.
    Consequently, a container will be able to manage its own IP address on the real
    network. To manage this type of network interface, we need to declare a host physical
    interface. As containers will get their own MACs, we can use VLANs on these interfaces
    to provide containers with access only to the defined VLAN. But note that in these
    cases, we will need to assign all required VLANs to the `macvlan` assigned host
    interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: MacVLAN 驱动程序为每个容器接口分配一个虚拟 MAC 地址。因此，容器将能够管理其在真实网络上的 IP 地址。为了管理这种类型的网络接口，我们需要声明一个主机物理接口。由于容器将拥有自己的
    MAC 地址，我们可以在这些接口上使用 VLAN，为容器提供仅访问定义 VLAN 的权限。但请注意，在这种情况下，我们需要将所有所需的 VLAN 分配给 `macvlan`
    所分配的主机接口。
- en: The `macvlan` driver will only work on Linux hosts (with a kernel version above
    3.9; 4.0 is recommended). This kind of interface is usually blocked on cloud providers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`macvlan`驱动程序仅在Linux主机上有效（内核版本需高于3.9，推荐使用4.0）。这种接口通常会在云服务提供商处被阻止。'
- en: 'As a result, we have described two different modes for `macvlan`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们描述了`macvlan`的两种不同模式：
- en: '**Bridge mode**: In this case (the default one), traffic will go through the
    defined host physical interface.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接模式**：在这种情况下（默认模式），流量将通过定义的主机物理接口。'
- en: '**802.1q trunk bridge mode**: Traffic will go through an 802.1q VLAN interface,
    created by the Docker daemon on network creation.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**802.1q 中继桥接模式**：流量将通过由Docker守护进程在网络创建时创建的802.1q VLAN接口。'
- en: In these networks, we usually use `--aux-address` to add existing nodes or network
    devices to this newly created Docker network.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些网络中，我们通常使用`--aux-address`将现有的节点或网络设备添加到这个新创建的Docker网络中。
- en: We have been reviewing different interfaces that are provided by Docker out
    of the box. Now, let's continue our journey and understand how these communications
    happen at the host level.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经回顾了Docker默认提供的不同接口。现在，让我们继续了解这些通信在主机级别是如何发生的。
- en: Learning about container interactions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习容器交互
- en: 'There are two different types of communication in container environments:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 容器环境中有两种不同的通信类型：
- en: Communication with the external world
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部世界的通信
- en: Inter-container communications
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器间通信
- en: We'll take a look at both of these in this section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中查看这两者。
- en: Communication with the external world
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与外部世界的通信
- en: 'There are two features at the host level that are required to allow containers
    to talk to the external world:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许容器与外部世界通信，主机级别需要两个特性：
- en: IP forwarding is required to allow packets from container IP addresses to go
    outside the containerized environment. This is done at the kernel level and the
    Docker daemon will manage the required parameters (the `ip_forward` kernel parameter
    will be set to `1`) to allow this strategy. We can change this default behavior
    setting with `--ip-forward=false` in the daemon configuration. This forwarding
    is required for all kinds of communications between containers in general.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP转发是允许来自容器IP地址的数据包走出容器化环境所必需的。这是在内核级别完成的，Docker守护进程会管理所需的参数（`ip_forward`内核参数将设置为`1`）以允许此策略。我们可以在守护进程配置中使用`--ip-forward=false`更改此默认行为设置。通常，容器间所有种类的通信都需要这种转发。
- en: '`iptables` will manage the required rules to strictly allow only required communications
    once forwarding is enabled. We can manually set `iptables` rules, instead of allowing
    the Docker daemon to take care of these settings, using the `--iptables=false`
    option in the daemon configuration. It is recommended to allow the Docker daemon
    to manage these rules unless you are sure of what changes to implement. Docker
    will only manage `DOCKER` and `DOCKER-ISOLATION` filter chains and we are able
    to manage custom rules in the `DOCKER-USER` chain.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦启用转发，`iptables`将管理所需的规则，仅严格允许所需的通信。我们可以手动设置`iptables`规则，而不是允许Docker守护进程处理这些设置，方法是在守护进程配置中使用`--iptables=false`选项。除非你非常清楚需要做哪些更改，否则建议允许Docker守护进程管理这些规则。Docker只会管理`DOCKER`和`DOCKER-ISOLATION`过滤链，而我们可以在`DOCKER-USER`链中管理自定义规则。
- en: By default, Docker forwards all packets and permits all external source IP addresses.
    If we need to allow only required IP addresses, we can add custom rules to `DROP`
    all non-permitted communications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker会转发所有数据包，并允许所有外部源IP地址。如果我们只需允许必要的IP地址，可以添加自定义规则来`DROP`所有不被允许的通信。
- en: Inter-container communications
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器间通信
- en: We can also manage inter-container communications with IP forwarding and `iptables`.
    As we've already learned, we can use `--internal` on network creation to only
    allow internal communications. Any other communication out of this defined subnet
    will be dropped.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过IP转发和`iptables`来管理容器间的通信。正如我们已经学到的那样，我们可以在创建网络时使用`--internal`选项，仅允许内部通信。任何超出此定义子网的通信将被丢弃。
- en: On the other hand, we can disallow any inter-container communication by applying
    `--icc=false`. This option manages the internal interaction within containers
    linked to the same bridge. If we set this parameter to `false`, no inter-container
    communication will be allowed, even if they are running on the same subnet. This
    is the most secure network configuration because we can still allow specific communications
    using the `--link` option. Container links will create special `iptables` rules
    to allow these specific communications.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以通过应用`--icc=false`来禁止任何容器之间的通信。此选项管理与同一桥接网络相连的容器之间的内部交互。如果我们将该参数设置为`false`，即使它们运行在同一子网内，也不允许容器之间的通信。这是最安全的网络配置，因为我们仍然可以通过`--link`选项允许特定的通信。容器链接将创建特定的`iptables`规则，以允许这些特定的通信。
- en: DNS on custom bridge networks
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义桥接网络上的DNS
- en: We've already learned that custom bridge networks own an internal DNS. This
    means that any container interaction can be managed using container names. This
    internal DNS will always run on `127.0.0.11`. We can modify some of its features,
    such as adding new hosts, for example.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了自定义桥接网络拥有一个内部DNS。这意味着任何容器交互都可以通过容器名称进行管理。此内部DNS将始终运行在`127.0.0.11`上。我们可以修改其某些特性，例如添加新的主机等。
- en: 'Let''s review some of the common features that can easily be manipulated to
    improve application discovery and interactions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些常见的特性，这些特性可以轻松地被操作以改善应用程序的发现和交互：
- en: '| **Features** | **Description** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **描述** |'
- en: '| `--network-alias=ALIAS` | This option allows us to add another internal DNS
    name to a container. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `--network-alias=ALIAS` | 此选项允许我们为容器添加另一个内部DNS名称。 |'
- en: '| `--link=CONTAINER_NAME:ALIAS` | We have been talking about the link option
    for legacy environments. It is also a way to allow specific communications when
    no container interaction is allowed by default. This option will also add an entry
    to the internal DNS to allow the resolution of `CONTAINER_NAME` as a defined `ALIAS`.
    This use case is different to `--network-alias` because it is used on different
    containers. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `--link=CONTAINER_NAME:ALIAS` | 我们之前讨论了针对传统环境的链接选项。它也是一种在默认不允许容器交互的情况下，允许特定通信的方法。此选项还会向内部DNS添加一条条目，以允许将`CONTAINER_NAME`解析为定义的`ALIAS`。此用例与`--network-alias`不同，因为它用于不同的容器。
    |'
- en: '| `--dns`,`--dns-search`,and `--dns-option` | These options will manage forwarded
    DNS resolution in cases where an internal DNS cannot resolve a defined name. We
    can add a forwarder DNS, with its specific options to allow or disallow external
    searches for some containers. This will help us use different name resolutions
    to access internal or external applications. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `--dns`,`--dns-search` 和 `--dns-option` | 这些选项将在内部DNS无法解析已定义名称的情况下管理转发的DNS解析。我们可以添加转发DNS及其特定选项，以允许或禁止某些容器的外部搜索。这将帮助我们使用不同的名称解析来访问内部或外部应用程序。
    |'
- en: Now that we have learned about the different interfaces that are available and
    how communications work at the host system level, let's go ahead and learn how
    applications will be accessed from the client side. We have just introduced `iptables`
    as a mechanism to gain that access automatically when deploying containers on
    different networks. In the next section, we will deep dive into publishing application
    methods for standalone Docker hosts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可用的不同接口以及通信是如何在主机系统层面工作的，接下来让我们学习如何从客户端访问应用程序。我们刚刚介绍了`iptables`作为一种机制，可以在不同网络上部署容器时自动获得访问权限。在下一节中，我们将深入探讨如何在独立的Docker主机上发布应用程序的方法。
- en: Publishing applications
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布应用程序
- en: By default, all container processes are isolated from outside access. This means
    that although we had defined a port for the process service (using `EXPOSE` on
    images), it will not be accessible unless we declare it publicly available. This
    is a great security measure. No external communication will be allowed until it
    is specifically declared. Only containers attached to the same bridged network
    or host, using its host internal IP (attached to the bridge), will be able to
    use the process service.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有容器进程都与外部访问隔离。这意味着尽管我们为进程服务定义了一个端口（在镜像上使用`EXPOSE`），但除非我们明确声明它为公开可用，否则它是无法访问的。这是一项很好的安全措施。在没有明确声明之前，不会允许任何外部通信。只有连接到同一桥接网络或主机上的容器，使用其主机内部IP（连接到桥接网络），才能使用该进程服务。
- en: 'Let''s review a quick example using the `nginx:alpine` base image. We know
    that `nginx:alpine` exposes port `80`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来回顾一下使用`nginx:alpine`基础镜像的情况。我们知道`nginx:alpine`暴露了`80`端口：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our host IP on the default bridge network is `172.17.0.1` in this case, and
    we can reach container port `80`, but no other host will be able to reach this
    port. It is exposed internally by a `webserver` container.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的主机 IP 地址是在默认桥接网络上的 `172.17.0.1`，我们可以访问容器的 `80` 端口，但其他主机无法访问此端口。它是由
    `webserver` 容器内部暴露的。
- en: To publish a port exposed internally, we need to declare it during container
    creation or execution using the `--publish` or `-p` parameters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布一个内部暴露的端口，我们需要在容器创建或执行时使用 `--publish` 或 `-p` 参数进行声明。
- en: We will use `--publish [HOST_IP:][HOST_PORT:]CONTAINER_PORT[/PROTOCOL]` for
    this. This means that the only required argument is the container port. By default,
    the TCP protocol and a random port between `32768` and `65000` will be used, and
    the port will be publicly published on all host IP addresses (`0.0.0.0`). We can
    also use `-P` to publish all ports exposed in a given container's image definition.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `--publish [HOST_IP:][HOST_PORT:]CONTAINER_PORT[/PROTOCOL]` 来实现这一点。这意味着唯一需要的参数是容器端口。默认情况下，将使用
    TCP 协议和 `32768` 到 `65000` 之间的随机端口，并且该端口将在所有主机 IP 地址（`0.0.0.0`）上公开发布。我们还可以使用 `-P`
    来发布给定容器镜像定义中暴露的所有端口。
- en: If we need to declare a UDP application publication, we need to specify this
    protocol.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要声明 UDP 应用程序的发布，我们需要指定该协议。
- en: Host mode networking does not require any publication of ports because any exposed
    container process will be accessible from outside.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 主机模式网络不需要任何端口发布，因为任何暴露的容器进程都会对外部可访问。
- en: We can declare a range of ports in the form `--publish StartPort-EndPort[/PROTOCOL]`
    to publish more than one port.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以 `--publish StartPort-EndPort[/PROTOCOL]` 的形式声明一个端口范围，以发布多个端口。
- en: 'For security reasons, it is important to use a specific IP address on multi-homed
    hosts in order to only allow access to specified IP addresses:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，在多网卡主机上使用特定的 IP 地址非常重要，这样可以只允许访问指定的 IP 地址：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will see more examples of this in the next section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分看到更多关于此的例子。
- en: Chapter labs
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章实验
- en: This chapter was dedicated to learning how to manage stateful environments and
    the magic behind container networking. Now, let's complete some labs to review
    what we've learned. For these labs, we will use a CentOS Linux host with a Docker
    engine installed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于学习如何管理有状态环境以及容器网络背后的原理。现在，让我们完成一些实验，以复习我们所学到的内容。对于这些实验，我们将使用安装了 Docker
    引擎的 CentOS Linux 主机。
- en: Deploy `environments/standalone-environment` from this book's GitHub repository
    ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment` folder to start your virtual
    environment.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请从本书的 GitHub 仓库（[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)）部署
    `environments/standalone-environment`。你也可以使用自己的 CentOS 7 服务器。从 `environments/standalone-environment`
    文件夹中使用 `vagrant up` 启动你的虚拟环境。
- en: 'If you are using a standalone environment, wait until it is running. We can
    check the statuses of our nodes using `vagrant status`. Connect to your lab node
    using `vagrant ssh standalone`. `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should have
    the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是独立环境，请等待它运行起来。我们可以使用 `vagrant status` 检查节点的状态。使用 `vagrant ssh standalone`
    连接到你的实验节点。`standalone` 是你的节点名称。你将使用具有 root 权限的 `vagrant` 用户，并使用 `sudo`。你应该看到以下输出：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now connect to the standalone node using `vagrant ssh standalone`. This
    process may vary if you deployed a standalone virtual node previously and you
    just started it using `vagrant up`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `vagrant ssh standalone` 连接到独立节点。如果你之前部署了独立虚拟节点，并且刚刚使用 `vagrant up`
    启动了它，那么这个过程可能会有所不同：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you are reusing your standalone environment, this means Docker Engine is
    installed. If you started a new instance, please execute the `/vagrant/install_requirements.sh`
    script so that you have all the required tools (Docker Engine and `docker-compose`):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在重用你的独立环境，这意味着 Docker 引擎已经安装。如果你启动了一个新实例，请执行 `/vagrant/install_requirements.sh`
    脚本，以确保安装所有必需的工具（Docker 引擎和 `docker-compose`）：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, you are ready to start the labs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好开始实验了。
- en: Using volumes to code on your laptop
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的笔记本电脑上使用卷来编写代码
- en: 'In this lab, we will run a container with our application code inside. As the
    application is created using an interpreted language, any change or code modification
    will be refreshed (we added debugging to reload the application on each change
    using `debug=True`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将在容器内运行包含应用程序代码的容器。由于该应用程序是使用解释型语言创建的，任何更改或代码修改都会被刷新（我们已添加调试功能，以便在每次更改时重新加载应用程序，使用`debug=True`）：
- en: 'We''ve created a simple Python Flask application for you. The following is
    the content of the `app.py` file:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为您创建了一个简单的Python Flask应用程序。以下是`app.py`文件的内容：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We only require the `Flask` Python module, so we will only have one line in
    our `requirements.txt` file:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要`Flask` Python模块，因此`requirements.txt`文件中只有一行内容：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will use a simple template HTML file under `templates/index.html` with this
    content:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的模板HTML文件`templates/index.html`，其内容如下：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will run this application inside a container. We will create a Dockerfile
    and build an image called `simpleapp`, with a tag of `v1.0`. This is the content
    of the Dockerfile:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在容器内运行这个应用程序。我们将创建一个Dockerfile，并构建一个名为`simpleapp`的镜像，标签为`v1.0`。以下是Dockerfile的内容：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s build our application image (`simpleapp:v1.0`):'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建我们的应用程序镜像（`simpleapp:v1.0`）：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can run this simple application by executing a detached container exposing
    port `5000`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过执行一个独立容器并暴露`5000`端口来运行这个简单的应用程序：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can review the container''s IP address. We are running this container
    in a host, which means we can access the process port and defined IP address:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以查看容器的IP地址。我们在主机中运行此容器，这意味着我们可以访问进程端口和定义的IP地址：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can access our application as expected using the container''s defined IP
    and port:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用容器定义的IP和端口按预期访问我们的应用程序：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is simple to change `index.html` if we get into the container. The problem
    is that when we run a new container, changes will not be stored and `index.html`
    will be lost. Every time, we will get `index.html` defined in the base image.
    As a result, if we want changes to persist, we need to use volumes. Let''s use
    a bind mount to change the `index.html` file while the container is running:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们进入容器，更改`index.html`是很简单的。但问题在于，当我们运行一个新容器时，所做的更改不会被存储，`index.html`会丢失。每次都会得到在基础镜像中定义的`index.html`。因此，如果我们希望更改能够持久化，我们需要使用卷。让我们使用绑定挂载，在容器运行时更改`index.html`文件：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can now change `templates/index.html` because we have used `-v $(pwd)/templates:/app/templates`,
    assuming the current directory. Using the vi editor, we can modify the content
    of the `templates/index.html` file:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以更改`templates/index.html`，因为我们已经使用了`-v $(pwd)/templates:/app/templates`，假设当前目录为工作目录。使用vi编辑器，我们可以修改`templates/index.html`文件的内容：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We change the line containing the `Version` key and we access it again using
    `curl`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更改包含`Version`键的行，并使用`curl`再次访问它：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The changes are reflected because we did them on our host filesystem and it
    is mounted inside our container. We can also change our application code by mounting
    `app.py`. Depending on what programming language we are using, we can change the
    application code on the fly. If changes must be persistent, we need to follow
    a versioning strategy. We will build a new image with the required changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化之所以能反映出来，是因为我们在主机的文件系统上进行了操作，并且该文件系统已挂载到我们的容器内。我们还可以通过挂载`app.py`来更改应用程序代码。根据所使用的编程语言，我们可以实时更改应用程序代码。如果更改需要持久化，我们需要遵循版本控制策略。我们将构建一个包含所需更改的新镜像。
- en: Mounting SSHFS
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载SSHFS
- en: 'In this lab, we will install and use the `sshfs` volume plugin:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将安装并使用`sshfs`卷插件：
- en: 'First, we need to install the `sshfs` plugin:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`sshfs`插件：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s review our host IP address and start the `sshd` or `ssh` daemons (depending
    on your system and whether it is already running):'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看主机的IP地址，并启动`sshd`或`ssh`守护进程（具体取决于您的系统及其是否已在运行）：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s review the installed plugin:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看已安装的插件：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since plugins are objects, we can inspect installed plugins. We can review
    important aspects such as version, debug mode, or the type of mount points that
    will be managed with this plugin:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插件是对象，我们可以检查已安装的插件。我们可以查看插件的关键方面，如版本、调试模式或该插件将管理的挂载点类型：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we will create a new volume named `sshvolume` (we assume that you have
    a valid SSH username and password here). Notice that we''re using `127.0.0.1`
    and the `/tmp` directory or filesystem for demo purposes:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`sshvolume`的新卷（假设您已拥有有效的SSH用户名和密码）。请注意，我们正在使用`127.0.0.1`和`/tmp`目录或文件系统进行演示：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can easily run an `alpine` container by mounting previously created
    `sshvolume`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地通过挂载之前创建的`sshvolume`来运行一个`alpine`容器：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let's continue with some network labs.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行一些网络实验。
- en: Multi-homed containers
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多网卡容器
- en: 'We will now look at a quick lab on attaching containers to multiple networks.
    Let''s get started:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下如何将容器连接到多个网络的快速实验。让我们开始吧：
- en: 'First, we''ll create two different zones, `zone-a` and `zone-b`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个不同的区域，`zone-a` 和 `zone-b`：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can start a container named `cont1` on `zone-a`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `zone-a` 上启动一个名为 `cont1` 的容器：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we connect the `cont1` container to `zone-b` and review its IP addresses:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 `cont1` 容器连接到 `zone-b`，并查看其 IP 地址：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can run two containers with just one interface. One of them will run
    attached to `zone-a`, while the other one will just be attached to `zone-b`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过仅一个接口运行两个容器。一个容器将连接到 `zone-a`，而另一个容器则仅连接到 `zone-b`：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s review the IP addresses and routes on both containers:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看两个容器的 IP 地址和路由：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we want the `cont3` container to contact the `cont2` container, we should
    add a route through the `cont1` container, which contains both networks. In the
    `cont2` container, enter the following command:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们希望 `cont3` 容器能够联系 `cont2` 容器，我们应该通过 `cont1` 容器添加一条路由，因为 `cont1` 容器包含两个网络。在
    `cont2` 容器中，输入以下命令：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the `cont3` container, enter the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cont3` 容器中，输入以下内容：
- en: '[PRE57]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Remember that we don''t have name resolution between different networks. Therefore,
    we cannot reach `cont2` using its name:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，我们不同网络之间没有名称解析功能。因此，我们无法通过名称访问 `cont2`：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we expected, name resolution within the `zone-a` network works fine. Any
    other container on another network will not be able to resolve containers by their
    names.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，`zone-a` 网络内的名称解析工作正常。任何其他网络中的容器将无法通过名称解析其他容器。
- en: 'We should be able to ping from `cont3` to `cont2` using its IP address:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该能够通过 `cont3` 使用 `cont2` 的 IP 地址进行 ping：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, although we do not have name resolution, we can reach containers on other
    networks using a container gateway that has interfaces on all networks. For this
    to work, we added a route to each network container to route all other network
    traffic to the gateway container. We could have added aliases to reach other network
    containers by name. Try it yourself – it's easy!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，尽管我们没有名称解析功能，但我们可以通过一个在所有网络上都有接口的容器网关访问其他网络上的容器。为了使其工作，我们为每个网络容器添加了一条路由，将所有其他网络流量路由到网关容器。我们本可以添加别名，通过名称访问其他网络容器。试试吧，挺简单的！
- en: Publishing applications
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布应用程序
- en: 'In this lab, we are going to deploy a simple three-layer application. In fact,
    it''s a two-layer application with the addition of a load balancer for our lab
    purposes:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将部署一个简单的三层应用程序。实际上，它是一个两层应用程序，额外添加了一个负载均衡器以便用于我们的实验：
- en: 'First, we''ll create a bridge network named `simplenet`, where we will attach
    all application components:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为 `simplenet` 的桥接网络，在其中附加所有应用程序组件：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will deploy a PostgreSQL database with `changeme` as the password for the
    root user. We created a simple database named `demo` with a `demo` user and a
    password of `d3m0` for this lab:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将部署一个 PostgreSQL 数据库，并使用 `changeme` 作为 root 用户的密码。我们为本实验创建了一个名为 `demo` 的简单数据库，包含一个名为
    `demo` 的用户，密码为 `d3m0`：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice that we have not published any port for the database.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们尚未为数据库发布任何端口。
- en: Never use environment variables for secure content. There are other mechanisms
    to manage this kind of data. Use the secrets functionality of Docker Swarm or
    Kubernetes to provide security for these keys.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用环境变量存储安全内容。管理此类数据有其他机制。请使用 Docker Swarm 或 Kubernetes 的密钥管理功能为这些密钥提供安全性。
- en: 'Now, we need to launch the backend application component, named `simpleapp`.
    Notice that in this case, we used many environment variables to configure the
    application side. We set the database host, database name, and the required credentials,
    as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要启动名为 `simpleapp` 的后端应用程序组件。请注意，在这种情况下，我们使用了许多环境变量来配置应用程序端。我们设置了数据库主机、数据库名称以及所需的凭据，如下所示：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We have not published the application. Therefore, it is only accessible locally.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未发布该应用程序。因此，它仅在本地可访问。
- en: 'Let''s review the application component IP addresses deployed. We will inspect
    the containers attached to `simplenet`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看已部署的应用程序组件的 IP 地址。我们将检查附加到 `simplenet` 的容器：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If we take a look at the exposed (not published) ports on each image definition,
    we will observe the following in the database component:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看每个镜像定义中暴露（未发布）的端口，我们将在数据库组件中看到以下内容：
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the application backend, we will observe the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序后端中，我们将观察到以下内容：
- en: '[PRE65]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we have all the required information to test the connections to both components.
    We can even use the `curl` command to test whether the server is a database server.
    Let''s try the database with an IP address of `172.22.0.3` on port `5432`. We
    will use `curl -I` because we don''t really care about the response content. We
    just want to be able to connect to the exposed port:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有所有必要的信息来测试与这两个组件的连接。我们甚至可以使用 `curl` 命令来测试服务器是否为数据库服务器。让我们尝试在 IP 地址为
    `172.22.0.3`、端口为 `5432` 的数据库。我们将使用 `curl -I`，因为我们不关心响应内容。我们只想确保能够连接到暴露的端口：
- en: '[PRE66]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this case, `Empty reply from server` is `OK` (it does not use the HTTP protocol).
    The database is listening on that IP-port combination. The same will happen on
    the application backend on IP address `172.22.0.4` and port `3000`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Empty reply from server` 是 `OK`（它不使用 HTTP 协议）。数据库正在监听该 IP-端口组合。在 IP
    地址 `172.22.0.4` 和端口 `3000` 的应用程序后台也会发生同样的情况：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this situation, we will be able to open `http://172.22.0.4:3000` in the browser.
    The application will be visible, but it can only be consumed locally. It hasn't
    been published yet.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以在浏览器中打开 `http://172.22.0.4:3000`。应用程序将可见，但只能在本地使用。它还没有被发布。
- en: 'Let''s deploy the load balancer component. This component will publish a port
    on our host. Notice that we added two environment variables to allow the load
    balancer to connect to the backend application (we configured the load balancer
    on the fly with these variables because this image is modified for this behavior):'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们部署负载均衡器组件。该组件将在我们的主机上发布一个端口。请注意，我们添加了两个环境变量，以允许负载均衡器连接到后台应用程序（我们通过这些变量动态配置了负载均衡器，因为这个镜像已被修改以支持这种行为）：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s take a look at our local `iptables`. The Docker daemon has added a NAT
    rule to guide traffic from port `8080` to port `80` on the load balancer component:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看本地的 `iptables`。Docker 守护进程已添加了一条 NAT 规则，将流量从端口 `8080` 引导到负载均衡器组件上的端口 `80`：
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice that the load balancer will be available on all host IP addresses because
    we have not set any specific IP in the publish option.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，负载均衡器将在所有主机的 IP 地址上可用，因为我们没有在发布选项中设置任何特定的 IP 地址。
- en: 'Now, open `http://localhost:8080` in your web browser. You will be able to
    consume the deployed application. You will see the following GUI in your browser:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的网页浏览器中打开 `http://localhost:8080`。你将能够使用已部署的应用程序。你将在浏览器中看到以下图形用户界面：
- en: '![](img/9f8bdd0c-3c63-488a-9b32-bad2d56a8754.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f8bdd0c-3c63-488a-9b32-bad2d56a8754.png)'
- en: This GUI is, in fact, the application backend's front page. As we mentioned
    previously, it is not a real three-layer application. We added a load balancer
    as a frontend just to be able to publish it and add some rules there.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图形用户界面实际上是应用程序后台的首页。正如我们之前提到的，它并不是真正的三层应用程序。我们添加了一个负载均衡器作为前端，目的是能够发布它并在其中添加一些规则。
- en: To ensure that the application only listens on the required interfaces, we can
    specify them to avoid unsecured ones. Always use a specific IP address with the
    `--publish` option (for example, `--listen MY_PUBLIC_IP_ONLY:8080:80`) to publish
    your application on a defined IP address.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用程序仅在所需的接口上监听，我们可以指定它们以避免不安全的接口。始终使用特定的 IP 地址与 `--publish` 选项一起发布应用程序（例如，`--listen
    MY_PUBLIC_IP_ONLY:8080:80`），以便在定义的 IP 地址上发布你的应用程序。
- en: In this lab, we published a simple application and ensured that only specific
    components are visible externally. Remember that it is possible to use container
    gateways and internal-only networks. These features will improve application security.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们发布了一个简单的应用程序，并确保只有特定组件在外部可见。记住，使用容器网关和仅内部网络是可行的。这些功能将提高应用程序的安全性。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have reviewed how to manage data associated with
    containers. We took a look at different strategies to manage the data of processes
    and their statuses. We used host filesystems and unnamed and named volumes, and
    we learned how to extend the available Docker daemon volume management functionality
    by using plugins. We noticed that the Docker daemon will not take care of any
    application lock or even determine how storage resources are defined at the host
    level.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了如何管理与容器相关的数据。我们查看了管理进程数据及其状态的不同策略。我们使用了主机文件系统、无名卷和有名卷，并学习了如何通过使用插件扩展可用的
    Docker 守护进程卷管理功能。我们注意到，Docker 守护进程不会处理任何应用程序锁，也不会确定主机级别的存储资源如何定义。
- en: There are two different options for mounting volumes or bind mounts on containers
    using `--volume` or `--mount`. We also reviewed all the parameters required and
    the differences between them.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方式可以使用 `--volume` 或 `--mount` 将卷或绑定挂载到容器中。我们还回顾了所有必要的参数及它们之间的区别。
- en: We talked about how to manage data and process states in high-availability environments.
    We haven't introduced any orchestration concepts yet, but it is important to understand
    that high availability or multiple instances of a process will require special
    application logic. Docker will not manage that logic and this is something you
    must be aware of.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何在高可用性环境中管理数据和进程状态。我们还没有介绍任何编排概念，但理解高可用性或多个进程实例将需要特别的应用程序逻辑是很重要的。Docker
    不会管理这些逻辑，而这是你必须意识到的。
- en: We also introduced some basic networking concepts. We explained the different
    types of networks we can use out of the box on the Docker daemon and the special
    features of each one. We then reviewed the interactions between containers and
    how they can talk to external networks. Lastly, we finished this chapter by learning
    how to publish application processes running inside containers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些基本的网络概念。我们解释了可以在 Docker 守护进程中直接使用的不同类型的网络以及每种网络的特殊功能。接着我们回顾了容器之间的交互，以及它们如何与外部网络通信。最后，我们通过学习如何发布在容器内部运行的应用程序进程来结束本章内容。
- en: The next chapter will introduce you to how to run applications on multiple containers.
    We will learn how an application's components run and interact.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何在多个容器上运行应用程序。我们将学习应用程序组件如何运行和交互。
- en: Questions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In this chapter, we reviewed container persistency and networking in non-cluster
    environments. Let''s verify our understanding of these topics with some questions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了非集群环境中的容器持久性和网络配置。接下来，我们通过一些问题来验证我们对这些主题的理解：
- en: Which of the following statements is not true?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项说法是错误的？
- en: a) Containers are not ephemeral – once created, they will stay in the host unless
    they are removed.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: a) 容器不是短暂的——一旦创建，它们会保留在主机中，除非被删除。
- en: b) We can run more than one container at a time using the same image.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: b) 我们可以使用相同的镜像同时运行多个容器。
- en: c) Containers created from the same image share their filesystems.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: c) 从同一镜像创建的容器共享它们的文件系统。
- en: d) All of these statements are false.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: d) 所有这些说法都是错误的。
- en: Which methods are allowed when creating a volume?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建卷时允许使用哪些方法？
- en: a) We can manually create a volume using the `docker volume create` command
    for volume objects.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: a) 我们可以使用 `docker volume create` 命令手动创建卷对象。
- en: b) We can declare a `VOLUME` sentence in a Dockerfile to use a volume on containers
    created from a built image.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: b) 我们可以在 Dockerfile 中声明一个 `VOLUME` 语句，以便在从构建的镜像创建的容器中使用卷。
- en: c) We can use Docker host filesystems inside containers as if they were Docker
    volumes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: c) 我们可以像使用 Docker 卷一样，在容器内部使用 Docker 主机的文件系统。
- en: d) Volume creation is only allowed in terms of container creation or execution.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: d) 仅在容器创建或执行时允许创建卷。
- en: When we remove a container, all associated volumes will be removed. Is this
    true?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们删除容器时，所有相关的卷都会被删除。这是真的吗？
- en: a) This is false. You need to use the `--force` or `-f` option on container
    removal.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: a) 这是错误的。你需要在删除容器时使用 `--force` 或 `-f` 选项。
- en: b) This is false. You need to use the `--volumes` or `-v` options on container
    removal.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: b) 这是错误的。你需要在删除容器时使用 `--volumes` 或 `-v` 选项。
- en: c) This is false. You need to use the `--volumes` or `-v` options on container
    removal, and only unnamed volumes are removed.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: c) 这是错误的。你需要在删除容器时使用 `--volumes` 或 `-v` 选项，且只会删除未命名的卷。
- en: d) This is false. Volumes can only be removed manually using `docker volume
    rm` or `docker volume purge`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: d) 这是错误的。卷只能通过 `docker volume rm` 或 `docker volume purge` 手动删除。
- en: Which of the following statements is not true regarding container networking?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项关于容器网络的说法是错误的？
- en: a) By default, all exposed container ports are accessible from the Docker host`
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: a) 默认情况下，所有暴露的容器端口都可以从 Docker 主机访问。
- en: b) `docker network prune` will remove all unused networks`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: b) `docker network prune` 将删除所有未使用的网络。
- en: c) By default, all bridge networks are attachable on the fly`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: c) 默认情况下，所有桥接网络都可以动态连接。
- en: d) Docker provides an internal DNS for each custom bridge network`
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: d) Docker 为每个自定义桥接网络提供了一个内部 DNS。
- en: Which of the following statements is true regarding a container publishing an
    Nginx web server with port `80` exposed?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项关于容器发布暴露端口 `80` 的 Nginx Web 服务器的说法是正确的？
- en: a) If we use the host driver, we need to run this container with `NET_ADMIN`
    capabilities.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: a) 如果我们使用主机驱动程序，我们需要以`NET_ADMIN`权限运行此容器。
- en: b) If we use the `--publish-all` or `-P` options, a random port between `32768`
    and `65535` will be associated at the host level with each container port exposed.
    You need to add a NAT rule in `iptables` to allow requests to reach the container's
    internal port `80`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: b) 如果我们使用`--publish-all`或`-P`选项，主机层将为每个暴露的容器端口关联一个介于`32768`和`65535`之间的随机端口。你需要在`iptables`中添加一条NAT规则，以允许请求访问容器的内部端口`80`。
- en: c) Using `--publish 192.168.2.100:1080:80`, we will ensure that only requests
    to the host IP address `192.168.2.100` on port `1080` will be redirected to the
    internal web server container port. (We are assuming that IP address `192.168.2.100`
    is a host interface.)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: c) 使用`--publish 192.168.2.100:1080:80`，我们将确保只有指向主机IP地址`192.168.2.100`端口`1080`的请求会被重定向到内部Web服务器容器端口。（我们假设IP地址`192.168.2.100`是一个主机接口。）
- en: d) If we use `--publish 80` or `-p 80`, a random port between `32768` and `65535`
    will be associated at the host level with port `80`, and a NAT rule will be added
    to `iptables`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: d) 如果我们使用`--publish 80`或`-p 80`，主机层将为端口`80`关联一个介于`32768`和`65535`之间的随机端口，并且会在`iptables`中添加一条NAT规则。
- en: Further reading
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links will help you learn more about volumes and networking concepts:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接将帮助你更深入地了解卷和网络概念：
- en: 'Using storage volumes: [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用存储卷: [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)'
- en: 'Volume plugins: [https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '卷插件: [https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/)'
- en: 'Networking overview: [https://docs.docker.com/network/](https://docs.docker.com/network/)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '网络概览: [https://docs.docker.com/network/](https://docs.docker.com/network/)'
