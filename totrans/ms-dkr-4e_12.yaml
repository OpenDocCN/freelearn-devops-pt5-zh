- en: '*Chapter 12*'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering other Kubernetes options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at alternatives to using Docker's in-built support
    for running your own local Kubernetes single-node and multi-node clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be discussing and looking at the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kind** (**Kubernetes in Docker**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroK8s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K3s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using one of the tools we discussed in [*Chapter 6*](B15659_06_Final_JM_ePub.xhtml#_idTextAnchor187),
    *Docker Machine, Vagrant, and Multipass*, along with some standalone tools that
    can be used to bootstrap your own local Kubernetes installation.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the screenshots in this chapter will be from my preferred operating system,
    macOS
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3byY104](https://bit.ly/3byY104).'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Kubernetes using Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First in our list of alternative Kubernetes cluster installers is Minikube.
    It was initially released in May 2016, making it the oldest of the tools we will
    be discussing in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at installing Minikube, we should probably discuss why it was
    needed in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of its original release, Kubernetes `1.2` had been out for a few
    months, and it was almost a year after the `1.0` release of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: While installing Kubernetes had become a lot simpler since the original release,
    it typically still boiled down to a bunch of installation scripts and step-by-step
    instructions that were designed to mostly bootstrap cloud-hosted clusters utilizing
    the cloud provider's APIs or command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to run an installation locally for development purposes, then
    you would have to either hack together your installer from existing scripts or
    download a Vagrant box where you would be trusting the author of the box to have
    built it using the best practices promoted by the **Cloud Native Computing Foundation**
    (**CNCF**), which was trying to ensure consistency between clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Although Minikube started life as a way of creating a local Kubernetes node
    on just Linux and macOS hosts, Windows was soon introduced, and the project has
    grown to be an important part of the Kubernetes project as it is many people's
    first taste of interacting with Kubernetes and it forms part of the official Kubernetes
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know a little about Minikube's background, let's look at getting
    it installed and then launching a single-node cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minikube is designed to run a single binary, and like Kubernetes itself, it
    is written in Go, which means that it can easily be compiled to run on the three
    platforms we have been looking at in this title. To start with, let's have a look
    at how to install Minikube on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we have discussed installing software and tools on macOS in previous chapters,
    we have mentioned and used Homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Minikube follows this path, meaning that it can be installed using
    a single command, which as you may have already guessed, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can verify everything is working as expected by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will output the version of Minikube that was installed along with the commit
    ID that version was compiled from.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube on Windows 10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: "Like Homebrew on macOS, when it comes to package managers on Windows, the \L\
    go-to is Chocolatey. If you have it installed, you can install Minikube using\
    \ the following command:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you are not using Chocolatey, then you can download a Windows installer from
    [https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have Minikube installed, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will confirm the installed version and commit.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the version of Linux you are running, there are a few different
    ways to install Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Before running the commands that follow, check the project's release page on
    GitHub to confirm what version of Minikube to install. The page can be found at
    [https://github.com/kubernetes/minikube/releases/](https://github.com/kubernetes/minikube/releases/).
    At the time of writing, the latest release is 1.9.2-0, so the instructions will
    use that version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running a Debian-based system that uses an APT such as Ubuntu or
    Debian itself, then you can download and install a `.deb` using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running an RPM-based system, such as CentOS or Fedora, then you
    can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you would prefer not to use a package manager, then you can download
    the latest static binary using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Whichever way you have chosen to install Minikube, you can run the following
    to confirm that everything is installed and working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, this will confirm the installed version and the commit it was compiled
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have already mentioned, Minikube is a standalone static binary that helps
    you launch a Kubernetes node on your local machine; it does this by interacting
    with several hypervisors. Before we start to use Minikube, let''s quickly look
    at the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker (macOS, Windows, and Linux)**: This driver uses Docker Machine to
    launch containers that host your Kubernetes node. On Linux, it will use just containers,
    and on macOS and Windows, it will launch a small virtual machine too and deploy
    the containers there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox (macOS, Windows, and Linux)**: This driver works across three
    operating systems and will launch a virtual machine and then configure your node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HyperKit (macOS)**: This uses the hypervisor built into macOS to host a virtual
    machine where your node will be configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyper-V (Windows 10 Pro)**: This uses the native hypervisor that is built
    into Windows 10 Professional to host a virtual machine where your node will be
    launched and configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KVM2 (Linux)**: This driver uses **(Kernel-based Virtual Machine KVM)** to
    launch a virtual machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Podman (Linux)**: This experimental driver uses a Docker replacement called
    Podman to launch containers that make up your cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallels (macOS)**: Uses the macOS-only Parallels to host a virtual machine
    where your node will be launched and configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware (macOS)**: Uses the macOS-only VMware Fusion to host a virtual machine
    where your node will be launched and configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None (Linux)**: This final option does away with containers and virtual machines
    launched in your local hypervisor; it simply installs your cluster node directly
    on the host you are running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have made it this far through the book, then you will have already installed
    the perquisites for at least one of the drivers mentioned above on your host machine.
    Minikube is intelligent enough to figure out the best driver to use on your host
    so we should be able to proceed without worrying that things won't work.
  prefs: []
  type: TYPE_NORMAL
- en: However, should you get an error because a support driver for your chosen host
    operating system is not found, then see the *Further reading* section for links
    to each of the preceding projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Should you find yourself without a supported driver install, I would recommend
    installing VirtualBox as it has the least requirements and complexity out of all
    of the drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Minikube installed, and we have looked at the drivers that
    it needs to launch and configure your cluster node, we can get to work and launch
    our cluster node.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a cluster node using Minikube
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t matter what your host operating system, launching a Kubernetes
    cluster node using Minikube is a single, simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When you first run the command, it may take several minutes after detecting
    your local configuration as it has to download and configure various supporting
    tools, virtual machine images, and containers (depending on the driver it is using).
  prefs: []
  type: TYPE_NORMAL
- en: You may also find that it asks for passwords for parts of the installation that
    require elevated privileges. These steps are a one-off and once you have launched
    your initial Kubernetes cluster node, subsequent cluster node launches should
    be a lot quicker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Terminal output shows my initial Minikube cluster node launching:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Launching a Kubernetes cluster node on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Launching a Kubernetes cluster node on macOS
  prefs: []
  type: TYPE_NORMAL
- en: Once your cluster node is up and running, you may notice a message at the bottom
    of the output highlighting that the version of `kubectl` is out of date and may
    not be compatible with the version of Kubernetes that is installed on the Minikube
    launched cluster node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, you can work around this by prefixing our `kubectl` commands with
    `minikube`, and adding `–` after. This will download and install a compatible
    version of `kubectl`, but it will be isolated in our Minikube workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Initializing a compatible version of kubectl using Minikube'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Initializing a compatible version of kubectl using Minikube
  prefs: []
  type: TYPE_NORMAL
- en: So, why did we get this message in the first place? Well, the Docker for Mac
    installation comes bundled with a version of `kubectl` that supports the version
    of Kubernetes natively supported within Docker, which at the time of writing is
    version `1.15.5`, whereas Minikube has pulled down the latest stable release of
    Kubernetes, which is `1.18.0`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using Minikube over the native Docker-supported Kubernetes
    is that you can run different versions of Kubernetes and easily isolate the versions
    of the supporting tools required to interact with various versions by prefixing
    your `kubectl` commands with `minikube` and adding `--` immediately after.
  prefs: []
  type: TYPE_NORMAL
- en: This is great when you have to test how your applications will react when it
    is time to update your production Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with your Kubernetes cluster node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our cluster node up and running, we can run through some common
    commands and launch a test application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s get a little information about our cluster node. In [*Chapter
    11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294)*, Docker and Kubernetes*,
    we ran the following commands to get information on the cluster node and namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run them again, remembering to prefix `minikube` before and `--` after
    each command so that they now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Getting information on the cluster node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0033.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Getting information on the cluster node
  prefs: []
  type: TYPE_NORMAL
- en: The output we get when running the commands is similar to that we got when we
    executed the equivalent commands in [*Chapter 11*](B15659_11_Final_JM_ePub.xhtml#_idTextAnchor294),
    *Docker and Kubernetes*, although the pods listed for the `kube-system` namespace
    are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we can launch a test application by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment has been created, you can view its status and the pod involved
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Launching an application deployment and checking the status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Launching an application deployment and checking the status
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our application deployment has been launched, we need a way of interacting
    with it. To do this, we can run the following command, which will launch a load
    balancer service on port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the service has been exposed, we can run the following command to get
    more information on running services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If our cluster node was hosted on a public cloud, the command will let us know
    what the external IP address of the service is, however, when we run the command,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Exposing the service on port 8080'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0053.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Exposing the service on port 8080
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `EXTERNAL-IP` is listed as `<pending>`, so how do we access
    the application we deployed?
  prefs: []
  type: TYPE_NORMAL
- en: 'To this, we need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will open the `hello-node` service in the default browser on your
    machine as well as printing the URL you can access the service on in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Opening the hello-node service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0063.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Opening the hello-node service
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hello-node` application simply echoes back the headers sent by your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Viewing the hello-node application in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Viewing the hello-node application in a browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish looking at Minikube, we should look at launching the cluster
    application we have been running in the previous chapters. To do this, run the
    following commands to create the deployment, expose the service, and get some
    information on the running pods and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once launched, we can list the URLs of all of the exposed services on our cluster
    node by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening the URL for the cluster service in a browser should show the application
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Viewing the cluster application in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0083.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Viewing the cluster application in a browser
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next tool, let's have a quick look at some of the other
    Minikube commands.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few other commands we can use to manage our cluster node. The first
    of which is a command that allows you to quickly access the Kubernetes dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube dashboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Accessing the Kubernetes dashboard is a little more straight forward using
    Minikube; in fact, it is just a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will enable the dashboard, launch the proxy, and then open the dashboard
    in your default browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Viewing the Kubernetes dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0093.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – Viewing the Kubernetes dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no additional work to configure authentication needed this time. Also,
    you can use the following command to just get the URL you need to access the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Getting the dashboard URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0103.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – Getting the dashboard URL
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at launching a different version of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube start with Kubernetes version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we first launched our cluster node, I mentioned it is possible to launch
    a cluster node with a different version of Kubernetes. Using the following command,
    we can launch a second cluster node running Kubernetes `v1.15.5`, which is the
    same version currently supported by Docker for Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should show you something similar to the output we originally
    saw when we first launched our cluster node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Installing Kubernetes v1.15.5 on a second cluster node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – Installing Kubernetes v1.15.5 on a second cluster node
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the process was pretty painless, and this time we did not get
    a complaint about potential compatibility issues with the locally installed `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the different cluster nodes by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list the available cluster nodes. To check which one you are currently
    using, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch to a different cluster node run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you use the cluster node name you want to switch to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Switching cluster nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0123.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.12 – Switching cluster nodes
  prefs: []
  type: TYPE_NORMAL
- en: Now we can switch cluster nodes, what about accessing them?
  prefs: []
  type: TYPE_NORMAL
- en: Minikube SSH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although you shouldn''t need to access the cluster node itself, you can run
    this to get shell access to the currently selected cluster node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is useful if you are curious to see what is going on under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube stop and delete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final commands we are going to look at are the ones to stop our cluster
    nodes or remove them altogether; you may have already guessed the command to stop
    a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will stop the currently selected cluster node, and it can easily be started
    up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add `-p <profile name>` to stop or start another cluster node. To remove
    the cluster node, you can run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will remove the currently selected cluster node. Again, you can add `-p
    <profile name>` to interact with any other cluster node. Running the following
    will delete all of the cluster nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There is no warning or "are you sure?" prompt when running the `minikube delete`
    command, so please be careful.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I am sure you will agree, Minikube has a wealth of options and is extremely
    straightforward to use. With it being part of the Kubernetes project itself, you
    will find that it is always a more up-to-date Kubernetes experience than you would
    get enabling Kubernetes in Docker for Mac or Docker for Windows, and it also has
    Linux support.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you also get an environment that is a lot closer to a CNCF-compliant
    Kubernetes cluster running on a public cloud, which we'll be looking at in more
    detail in [*Chapter 13*](B15659_13_Final_JM_ePub.xhtml#_idTextAnchor626), *Running
    Kubernetes in Public Clouds*.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube takes a similar approach to Docker in that it deploys a small managed
    virtual machine to run your environment. The next tool we are going to look at
    takes a more modern, and at the time of writing, experimental approach to running
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Kubernetes using kind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next tool we are going to look at is Kind, which is short for **Kubernetes
    in Docker**. This is exactly what you think it would be, based on the name – a
    Kubernetes cluster node condensed down into a container. Kind is a very recent
    project – so recent, in fact, that at the time of writing it is still undergoing
    a lot of active development. Because of this, we aren't going to spend too much
    time on it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Minikube, Kind is distributed as a single static binary – meaning its installation
    is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it on macOS, we need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on Linux, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The release page to confirm the version number can be found at [https://github.com/kubernetes-sigs/kind/releases/](https://github.com/kubernetes-sigs/kind/releases/).
  prefs: []
  type: TYPE_NORMAL
- en: As we already have Docker installed, we don't need to worry about drivers, hypervisors,
    or anything to run a supporting virtual machine as Kind will simply use our local
    Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a Kind cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the kind binary has been installed, launching a cluster node is a very
    simple process; just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, this will download the necessary
    images and take care of configuring both the cluster and creating a context on
    your local Docker host so that you can use `kubectl` to interact with the cluster
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Launching a cluster node with Kind'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13 – Launching a cluster node with Kind
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our cluster node up and running, let's do something with it.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with your Kubernetes cluster node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our cluster node up and running, we can rerun the commands
    and launch a test application as we did in the previous section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we will be using the `kubectl` command on our Docker host, rather
    than using a wrapper; however, we will be adding a context to make sure that our
    Kind Kubernetes node cluster is used. This means that the commands we need to
    run look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, we again see similar output
    to the last time we queried our nodes, namespaces, and system pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Viewing the nodes, namespaces, and system pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0142.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – Viewing the nodes, namespaces, and system pods
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s deploy the **hello-node** application again, using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So far so good, you may be thinking, but unfortunately that is about as far
    as we can take the installation with the current configuration – while we can
    deploy pods and services, Kind does not come with an Ingress controller by default
    at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable an Ingress controller, we first have to delete our cluster. To do
    that, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the cluster has been deleted, we can re-launch it with the Ingress configuration
    enabled. The configuration is too long to list here, but you can find a copy of
    it in the repository that accompanies this book in the `chapter12/kind` folder.
    To launch the cluster with the config, change to the `chapter12/kind` folder in
    your Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once launched, the next step is to enable the NGINX Ingress controller. You
    will need to execute the following command to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'That will configure the cluster to use the NGINX Ingress controller. The controller
    itself take a minute or two to launch – you can check the status by running the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the `Ingress-nginx-controller` pod ready and running, you can
    then relaunch the `hello-node` application using the `hello-node.yml` file in
    the `chapter12/kind` folder with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once launched, you should be able to access the `hello-node` application at
    [http://localhost/hello-node/](http://localhost/hello-node/) as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – The output of the hello-node application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0152.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.15 – The output of the hello-node application
  prefs: []
  type: TYPE_NORMAL
- en: Once finished, you can delete the cluster with the `kind delete cluster` command.
  prefs: []
  type: TYPE_NORMAL
- en: Kind summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, you may be thinking to yourself, what is the point of Kind – why on earth
    would you want to run a Kubernetes cluster in a single container? Well, its main
    use is to test Kubernetes itself; however, it could be used to test deployments
    as part of a continuous delivery or continuous deployment pipeline where you need
    to test your Kubernetes definition files are working as expected and your application
    launches without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands at the moment, Kind is probably too slow and too heavy in development
    to be used to develop on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move onto the next tool, which takes us back to running a virtual machine
    to deploy our local Kubernetes cluster on.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Kubernetes using MicroK8s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we have MicroK8s by Canonical who, as you may remember from [*Chapter
    6*](B15659_06_Final_JM_ePub.xhtml#_idTextAnchor187), *Docker Machine, Vagrant,
    and Multipass*, are the creators of Multipass and also the Linux distribution
    Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: The mantra of the MicroK8s project is to provide a lightweight Kubernetes node
    with only a minimal number of basic services enabled by default while providing
    additional services as needed via plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MicroK8s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike Minikube and Kind, the standalone binary for MicroK8s only works on Linux-based
    machines. Because of this, we are going to use Multipass to launch a virtual machine
    and use that as our installation target.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the virtual machine, we need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the virtual machine is up and running, we can then enable and install
    MicroK8s with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, it will take a little while for MicroK8s to start up and the
    cluster node to be ready to use. Run the following command to poll the status
    and check MicroK8s is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, as MicroK8s by default is a minimal Kubernetes cluster node, we need
    to enable the `dns` and `Ingress` plugins, which will allow us to access our applications
    when we launch them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once enabled, the final thing we need to do is get a copy of the configuration
    on our host machine. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will leave us with a file called `microk8s.yml` in the current directory
    on our host machine. We can now use this configuration when we run `kubectl` to
    access our newly launched and configured MicroK8s Kubernetes cluster node.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with your Kubernetes cluster node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our cluster node up and running, we can rerun the commands
    and launch a test application as we did in the previous section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, this time we will be using the `kubectl` command on our
    host machine and pass the flag to make sure it uses the `microk8s.yml` config
    file. This means that the commands we need to run look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, we again see similar output
    to the last time we queried our nodes and namespaces until we get to the system
    pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Viewing the nodes, namespaces, and system pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0162.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.16 – Viewing the nodes, namespaces, and system pods
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we can't see any of the Pods outside of the `coredns` one is
    that the user attached to the configuration we downloaded doesn't have the necessary
    permissions to do so. Although, that's not a problem for us as we don't need to
    touch those pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we can launch the `hello-node` application. This time, we will use
    the YAML file straight out of the GitHub repository by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we are using this file is that it has the definition for the Ingress
    controller, which means we just need to get the IP address of our MicroK8s cluster
    node and then enter that URL into our browser. To get the IP address, run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once you know the IP address, which should be listed as IPv4, open a browser
    and go to `https://<IP Address>/hello-node/`. In my case, the URL was `https://192.168.64.16/hello-node/`.
    You will note that, this time, we are using HTTPS rather than HTTP. That is because
    the Ingress controller we enabled installs a self-signed certificate and redirects
    all traffic to HTTPS. Depending on the browser settings, you may be asked to accept
    or install the certificate when going to the page.
  prefs: []
  type: TYPE_NORMAL
- en: Once finished, you can delete the cluster node using the `multipass delete --purge
    microk8s` command. Also, don't forget to remove the `microk8s.yml` file. Once
    you have deleted the cluster, the config file would not work if you were to relaunch
    it.
  prefs: []
  type: TYPE_NORMAL
- en: MicroK8s summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MicroK8s delivers on its promise of a small, lightweight, but still functional
    and extendable Kubernetes cluster controller. Coupled with Multipass, you are
    easily able to spin up a virtual machine and quickly bootstrap your Kubernetes
    cluster node on your local workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Canonical has made sure that MicroK8s isn't just for local use; the cluster
    node itself can be considered to be production-ready, meaning that it is perfect
    for running Kubernetes on both edge and IoT devices – both of which traditionally
    have lower specifications and would normally run a single node.
  prefs: []
  type: TYPE_NORMAL
- en: The final tool we are going to look at will allow us to run multiple Kubernetes
    nodes locally, taking us closer to what a production environment might look like.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Kubernetes using K3s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final tool we are going to take a look at is K3s from Rancher. Like MicroK8s,
    K3s is a lightweight Kubernetes distribution designed for edge and IoT devices.
    This again makes it perfect for local development too as K3s is also a certified
    Kubernetes distribution – as is Docker, Kind, and MicroK8s.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why on earth it is called K3s. There is some logic behind
    it. As Rancher's main design aim for K3s was to produce something with half of
    the memory footprint of a typical Kubernetes distribution, they decided that as
    Kubernetes is a 10-letter word but is stylized as K8s, then their distribution
    would be half the size – 5 letters – and would, therefore, be stylized as K3s.
    However, there is no long-form for K3s and nor is there an official pronunciation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, K3s supports multi-node clusters, so we are going to look at building
    a three-node cluster. The commands we'll be using in this section of the chapter
    will cover macOS and Linux systems as we will be creating environment variables
    and using non-Windows tools to streamline the installation process as much as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Installing K3s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like MicroK8s, we are going to be using Multipass to launch our host machines.
    To do this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our three VMs up and running, we can configure the master node
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the master node up and running, we need a little information to
    be able to bootstrap the two remaining nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first piece of information we need is the URL of the master node. To create
    an environment variable, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the URL of the master node, we need to grab the access token. To
    do that, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the two bits of information needed to bootstrap the nodes, we can
    run the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have our three nodes configured, and all that is left is to configure
    our local `kubectl` so that it can interact with the cluster nodes. The first
    thing we need to do is copy the configuration to our local machine. To do this,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to use the configuration file as it is, then it would fail as, by
    default, K3s is configured to communicate on the localhost, so to update that
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this replaces [https://127.0.0.1:6443](https://127.0.0.1:6443)
    with the value of `${K3SMASTER}` in our local `k3s.yml` configuration file. Once
    replaced, we can configure `kubectl` to use our `k3s.yml` configuration file for
    the remainder of the Terminal session by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that our cluster is accessible using our local kubectl binary, we can launch
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with your Kubernetes cluster nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our cluster node up and running, we can rerun the commands
    and launch a test application as we did in the previous section of the chapter.
    This time, as we have configured `kubectl` to use our `k3s.yml` configuration
    file, we can just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you something like the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Viewing the nodes, namespaces, and system pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0172.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.17 – Viewing the nodes, namespaces, and system pods
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s launch the `hello-node` application, this time using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following output, as you can see, we have any `EXTERNAL-IP`
    and `PORT(S)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Launching and exposing the hello-node application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0181.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.18 – Launching and exposing the hello-node application
  prefs: []
  type: TYPE_NORMAL
- en: Adding the IP address with the second port should give you the URL to access
    the application, for example, I went to [http://192.168.64.19:31846/](http://192.168.64.19:31846/)
    and was presented with the `hello-node` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let''s launch our `cluster` application with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You might notice that this time, for `EXTERNAL-IP`, it says `<pending>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – Launching and exposing the cluster application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.19 – Launching and exposing the cluster application
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn't have to worry about that; just use the second port and the external
    IP exposed for the other server. This gave me a URL of [http://192.168.64.19:32042/](http://192.168.64.19:32042/)
    to access the `cluster` application on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also scale the cluster application using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not following along, the Terminal output for this looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – Scaling the cluster application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0201.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.20 – Scaling the cluster application
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish up, as we have more nodes to explore, let''s install the Kubernetes
    dashboard. To do this, run the following commands from your host machine. The
    first thing that is needed is to get the current version of the dashboard. To
    do this, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the current version as an environment variable, we can run
    the following commands to launch the dashboard, add a user, and configure the
    user''s access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'With the dashboard installed and the user configured, we can grab the access
    token we will need to log in to the dashboard by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a note of the token as we will need it in a second. The last thing we
    need to do before accessing the dashboard is to start the Kubernetes proxy service
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'With the proxy server running, open [http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/)
    in your preferred browser, enter the token you made a note of, and sign in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21 – Opening the Kubernetes dashboard on our K3s node cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0211.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.21 – Opening the Kubernetes dashboard on our K3s node cluster
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished with your K3s cluster, you can remove it using `the multipass
    delete --purge k3smaster k3snode1 k3snode2` command.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing – K3d
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, Rancher also provides K3d. Like Kind, this is the entire Kubernetes
    distribution in a single container, which means that not only can you use K3s
    as your local development environment but it is also straightforward to introduce
    to your CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we summarize K3s, let''s take a very quick look at how you can get K3d
    up and running on a macOS and Linux host, starting with Linux. To install the
    `k3d` command, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you are using macOS, you can use Homebrew to install it using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Once K3d is installed (I installed version 1.7), there are four commands we
    are going to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`k3d cluster create k3s-default`: This command will create a K3d-powered Kubernetes
    cluster called **k3s-default**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k3d kubeconfig merge k3s-default --switch-context`: This will configure your
    local `kubectl` to talk to the **k3s-default** cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you have a cluster up and running, you can interact with it like any
    other Kubernetes cluster, for example, by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22 – Running commands against our K3d cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0221.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.22 – Running commands against our K3d cluster
  prefs: []
  type: TYPE_NORMAL
- en: '`k3dcluster delete k3s-default` is the final command of the four we are going
    to look at, and as you might have guessed, this deletes the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'K3d is very much in active development. In fact, a complete rewrite of the
    K3d wrapper has just been completed so if the preceding commands, which cover
    the new version 3, do not work, then try the following commands, which cover the
    old version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For more up-to-date news on the development of K3d, see the project's GitHub
    page, which is linked in the *Further reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: K3s summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like MicroK8s, K3s delivers on its promise of a lightweight Kubernetes distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I find K3s to be the better of the two as it feels more like a fully
    formed Kubernetes distribution than MicroK8s does.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing K3s has going for it is that deploying a local multi-node cluster
    is a relatively painless experience. This should give your local development environment
    a much more production-like feeling, and while Minikube does allow you to launch
    a multi-node cluster, the functionality is still in its infancy and is not really
    ready for public consumption yet.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at four different tools for launching both single-node
    and multi-node Kubernetes clusters. We discovered that while the method of launching
    each of the clusters is slightly different, once they are up and running, you
    get a mostly consistent experience once you start to interact with them using
    standard Kubernetes tools like `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I should probably confess something: two of the four tools we
    have covered in this chapter do not actually use Docker in the traditional sense
    – both MicroK8s and K3s actually use **containerd**.'
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, **containerd** is an easily embeddable container runtime. It
    started life at Docker Inc., but the project was donated to the **Cloud Native
    Computing Foundation** (**CNCF**) – it is the container runtime of the Moby project,
    which Docker uses as its upstream project.
  prefs: []
  type: TYPE_NORMAL
- en: It is not only small and lightweight, but it also offers full OCI Image and
    OCI Runtime specification support, meaning that it is 100% compatible with Docker
    images and also the way that Docker runs containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move away from running Kubernetes locally
    and take our clusters to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True or false: Kind is recommended for production use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least two tools we have looked at in this chapter that are able to run
    inside a Docker container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you had an ARM-powered IoT device, which two Kubernetes distributions that
    we have covered in this chapter could you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the Google tools, presentations, and white papers mentioned at the
    start of the chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube: [https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kind: [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MicroK8s: [https://microk8s.io/](https://microk8s.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'K3s: [https://k3s.io/](https://k3s.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'K3d: [https://github.com/rancher/k3d](https://github.com/rancher/k3d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'containerd: [https://containerd.io/](https://containerd.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OCI Image and Runtime Specification: [https://www.opencontainers.org/](https://www.opencontainers.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Certified Kubernetes offerings: [https://www.cncf.io/certification/software-conformance/](https://www.cncf.io/certification/software-conformance/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
