- en: Running Services in a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come thus far by carefully explaining the various aspects of the Docker
    technology. The previous chapters definitely have laid down a stellar foundation
    for the overwhelmingly accepted Docker platform and the forthcoming chapters will
    be like the meticulously crafted buildings on that grandiose foundation.
  prefs: []
  type: TYPE_NORMAL
- en: We described the important building blocks (the highly usable and reusable Docker
    images) to bring forth powerful Docker containers. There are briefs about the
    various easy-to-learn-and-employ techniques and tips on how to store and share
    Docker images through a well-designed storage framework. Typically, images have
    to go through a series of verifications, validations, and refinements constantly
    in order to be right and relevant for the aspiring development community.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take our learning to the next level by detailing
    the key steps in creating a small web server, run the same inside a container,
    and enable outsiders to connect to the containerized web server through the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Container networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container as a Service** (**CaaS**) – building, running, exposing, and connecting
    to container services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing and retrieving containers' port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding a container to a specific IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autogenerating the Docker host port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port binding using the `EXPOSE` and `-P` options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of container networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Networking is a critical infrastructure component of enterprise and cloud IT.
    Especially, as computing becomes extremely distributed, networking becomes indispensable.
    Typically, a Docker host comprises multiple Docker containers and hence the networking
    has become a crucial component for realizing composite containerized applications.
    Docker containers also need to interact and collaborate with local as well as
    remote ones to come out with distributed applications. Precisely speaking, different
    and distributed containers need to be publicly found, network-accessible, and
    composable to bring forth business-centric and process-aware applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the key strengths of the Docker containerization paradigm is the ability
    to network seamlessly without much effort from the user. The earlier version of
    Docker supported just the bridge network; later, Docker acquired the SDN startup
    SocketPlane to add additional networking capabilities. Since then, Docker''s networking
    capability has grown leaps and bounds and a separate set of subcommands, namely
    `docker network connect`, `docker network create`, `docker network disconnect`,
    `docker network inspect`, `docker network ls`, and `docker network rm`, were introduced
    to handle the nitty-gritty of the Docker networking. By default, during installation,
    the Docker Engine creates three networks for you, which you can list using the
    `docker network ls` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, during the Docker setup, the Docker
    Engine creates the `bridge`, `host`, and `none` (`null`) networks. When Docker
    spins up a new container, by default, it creates a network stack for the container
    and attaches to the default `bridge` network. However, optionally, you could attach
    the container to the `host` or `none` network or the user-defined network using
    the `--net` option of the `docker run` subcommand. If you choose the `host` network,
    the container gets attached to the `host` network stack and shares the host''s
    IP addresses and ports. The `none` network mode creates a network stack with just
    the Loopback (`lo`) interface. We can confirm this using the `docker run --rm
    --net=none busybox ip addr` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Evidently, as you can see in the preceding screenshot, the container has got
    just a Loopback interface. Since this container has got just a Loopback interface,
    the container cannot communicate with other containers or the external world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bridge` network is the default network interface that Docker Engine assigns
    to a container if the network is not configured using the `--net` option of the
    `docker run` subcommand. To have a better understanding of the `bridge` network,
    let''s begin by inspecting it using the `docker network inspect` subcommand, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, in the preceding screenshot, we have highlighted three paramount insights.
    You can find the relevant description of what happens during the Docker installation
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker0`: Docker creates an Ethernet bridge interface inside the Linux kernel
    with the `docker0` name on the Docker host. This interface is used as a bridge
    to pass the Ethernet frames between containers and also between containers and
    an external network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subnet`: Docker also selects a private IP subnet from the address range of
    `172.17.0.0` to `172.17.255.255` and keeps it revered for its containers. In the
    preceding screenshot, Docker has selected the `172.17.0.0/16` subnet for the containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gateway`: The `docker0` interface is the gateway for the `bridge` network
    and Docker, from the IP subnet range selected earlier, assigns an IP address to
    `docker0`. Here, in the preceding example, `172.17.0.1` is assigned to the gateway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can cross-check the gateway address by listing the `docker0` interface using
    the `ip addr show` Linux command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The third line of the output shows the assigned IP address and its network
    prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, from the preceding text, `172.17.0.1` is the IP address assigned
    to `docker0`, the Ethernet bridge interface, which is also listed as the gateway
    address in the output of the `docker network inspect bridge` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a clear understanding of the bridge creation and the subnet/gateway
    address selection process, let''s explore the container networking in the `bridge`
    mode a bit more in detail. In the `bridge` network mode, the Docker Engine creates
    a network stack with a Loopback (`lo`) interface and an Ethernet (`eth0`) interface
    during the launch of the container. We can quickly examine this by running the
    `docker run --rm busybox ip addr` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Evidently, the preceding output of the `ip addr` command shows that the Docker
    Engine has created a network stack for the container with two network interfaces,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first interface is the `lo` (Loopback) interface, for which the Docker Engine
    assigned the `127.0.0.1` Loopback address. The Loopback interface is used for
    local communication within a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second interface is an `eth0` (Ethernet) interface, for which the Docker
    Engine assigned the `172.17.0.3` IP address. Obviously, this address also falls
    within the same IP address range of the `docker0` Ethernet bridge interface. Besides,
    the address assigned to the `eth0` interface is used for intra-container communication
    and host-to-container communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ip addr` and/or `ifconfig` commands are not supported by all Docker images,
    including `ubuntu:14.04` and `ubuntu:16.04`. The `docker inspect` subcommand is
    the reliable way to find the IP address of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we mentioned that `docker0`, the Ethernet bridge interface, acts as
    a conduit to pass the Ethernet frames between containers and also between containers
    and the external world. However, we have not yet clarified how the containers
    connect with the `docker0` bridge. The following diagram unravels some of the
    mystery around this connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_06_005.png)'
  prefs: []
  type: TYPE_IMG
- en: As depicted here, the container's `eth0` interface is connected to the `docker0`
    bridge using `veth`. The `eth0` and `veth` interfaces belong to a special type
    of Linux network interface called a **Virtual Ethernet** (**veth**) Interface.
    The `veth` interface always comes in a pair, and they are like a water pipe wherein
    the data send from one `veth` interface will come out of the other interface and
    vice versa. The Docker Engine assigns one of the `veth` interfaces to the container
    with the `eth0` name and assigns the container IP address to that interface. The
    other `veth` interface of the pair is bound to the `docker0` bridge interface.
    This ensures the seamless flow of data between the Docker host and the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker assigns private IP addresses to the container, which is not reachable
    from outside of the Docker host. However, the container IP address comes in handy
    for debugging within the Docker host. As we noted earlier, many Docker images
    do not support the `ip addr` or `ifconfig` commands, besides we may not directly
    have access to the container prompt to run any of these commands. Fortunately,
    Docker provides a `docker inspect` subcommand, which is as handy as a Swiss Army
    knife, to dive deep into the low-level details of the Docker container or image.
    The `docker inspect` subcommand reports quite a lot of details including the IP
    address and the gateway address. For the practical purpose, here you can either
    select a running container or temporarily launch a container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, let''s assume the container ID is `4b0b567b6019` and run the `docker
    inspect` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates quite a lot of information about the container. Here,
    we show some excerpts of the container''s network configuration from the output
    of the `docker inspect` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the details of some of the important fields in the network configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Gateway`: This is the gateway address of the container, which is the address
    of the `bridge` interface as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPAddress`: This is the IP address assigned to the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPPrefixLen`: This is the IP prefix length, another way of representing the
    subnet mask'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without doubt, the `docker inspect` subcommand is quite convenient to find the
    minute details of a container or an image. However, it's a tiresome job to go
    through the intimidating details and to find the right information that we are
    keenly looking for. Perhaps, you can narrow it down to the right information,
    using the `grep` command. Alternatively, even better, the `docker inspect` subcommand
    helps you pick the right field from the JSON array using the `--format` option
    of the `docker inspect` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notably, in the following example, we use the `--format` option of the `docker
    inspect` subcommand to retrieve just the IP address of the container. The IP address
    is accessible through the `.NetworkSettings.IPAddress` field of the JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `none`, `host`, and `bridge` networking modes, Docker also
    supports the `overlay`, `macvlan`, and `ipvlan` network modes.
  prefs: []
  type: TYPE_NORMAL
- en: Envisaging container as a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We laid a good foundation of the fundamentals of the Docker technology. In this
    section, we are going to focus on crafting an image with the HTTP service, launch
    the HTTP service inside the container using the crafted image, and then, demonstrate
    the connectivity to the HTTP service running inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTP server image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to craft a Docker image in order to install Apache2
    on top of the Ubuntu 16.04 base image, and configure an Apache HTTP server to
    run as an executable, using the `ENTRYPOINT` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](../Text/Ch03.xhtml), *Building Images*, we illustrated the concept
    of `Dockerfile` to craft an Apache2 image on top of the Ubuntu 16.04 base image.
    Here, in this example, we are going to extend this `Dockerfile` by setting the
    Apache log path and setting Apache2 as the default execution application, using
    the `ENTRYPOINT` instruction. The following is a detailed explanation of the content
    of `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to build an image using `ubuntu:16.04` as the base image, using
    the `FROM` instruction, as shown in the `Dockerfile` snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the author''s detail using the `MAINTAINER` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using one `RUN` instruction, we will synchronize the APT repository source
    list, install the `apache2` package, and then clean the retrieved files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the Apache log directory path using the `ENV` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the final instruction is to launch the `apache2` server using the `ENTRYPOINT`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line, you might be surprised to see the `FOREGROUND` argument.
    This is one of the key differences between the traditional and the container paradigm.
    In the traditional paradigm, the server applications are usually launched in the
    background either as a service or a daemon because the host system is a general-purpose
    system. However, in the container paradigm, it is imperative to launch an application
    in the foreground because the images are crafted for a sole purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having prescribed the image building instruction in the `Dockerfile`, let''s
    now move to the next logical step of building the image using the `docker build`
    subcommand by naming the image as `apache2`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now do a quick verification of the images using the `docker images`
    subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen in the previous chapters, the `docker images` command displays
    the details of all the images in the Docker host. However, in order to illustrate
    precisely the images created using the `docker build` subcommand, we highlight
    the details of `apache2:latest` (the target image) and `ubuntu:16.04` (the base
    image) from the complete image list, as shown in the following output snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having built the HTTP server image, let's now move on to the next session to
    learn how to run the HTTP service.
  prefs: []
  type: TYPE_NORMAL
- en: Running the HTTP server image as a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we are going to launch a container using the Apache HTTP server
    image, we crafted in the previous section. Here, we launch the container in the
    detached mode (similar to the UNIX daemon process) using the `-d` option of the
    `docker run` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Having launched the container, let''s run the `docker logs` subcommand to see
    whether our Docker container generates any output on its stdin (standard input)
    or stderr (standard error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have not fully configured the Apache HTTP server, you will find the following
    warning, as the output of the `docker logs` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding warning message, it is quite evident that the IP address
    assigned to this container is `172.17.0.13`.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the HTTP service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the preceding section, indecently, from the warning message, we find out
    that the IP address of the container is `172.17.0.13`. On a fully configured HTTP
    server container, no such warning is available, so let''s still run the `docker
    inspect` subcommand to retrieve the IP address using the container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Having found the IP address of the container as `172.17.0.13`, let''s quickly
    run a web request on this IP address from the shell prompt of the Docker host,
    using the `wget` command. Here, we choose to run the `wget` command with `-qO
    -` in order to run in the quiet mode and also display the retrieved HTML file
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are showcasing just the first five lines of the retrieved HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Awesome, isn't it? We got our first service running in a container, and we are
    able to reach out to our service from our Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, on a plain vanilla Docker installation, the service offered by
    one container is accessible by any other container within the Docker host. You
    can go ahead, launch a new Ubuntu container in the interactive mode, install the
    `wget` package using `apt-get`, and run the same `wget -qO - 172.17.0.13` command,
    as we did in the Docker host. Of course, you will see the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing container services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we successfully launched an HTTP service and accessed the service from
    the Docker host as well as another container within the same Docker host. Furthermore,
    as demonstrated in the *Building images from containers* section of [Chapter 2](../Text/Ch02.xhtml),
    *Handling Docker Containers*, the container is able to successfully install the
    `wget` package by making a connection to the publicly available APT repository
    over the Internet. Nonetheless, the outside world cannot access the service offered
    by a container by default. At the outset, this might seem like a limitation in
    the Docker technology. However, the fact is, the containers are isolated from
    the outside world by design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker achieves network isolation for the containers by the IP address assignment
    criteria, as enumerated here:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a private IP address to the container, which is not reachable from
    an external network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning an IP address to the container outside the host's IP network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consequently, the Docker container is not reachable even from the systems that
    are connected to the same IP network as the Docker host. This assignment scheme
    also provides protection from an IP address conflict that might otherwise arise.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might wonder how to make the services run inside a container that is
    accessible to the outside world, in other words, exposing container services.
    Well, Docker bridges this connectivity gap in a classy manner by leveraging the
    Linux `iptables` functionality under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: At the frontend, Docker provides two different building blocks for bridging
    this connectivity gap for its users. One of the building blocks is to bind the
    container port using the `-p` (publish a container's port to the host interface)
    option of the `docker run` subcommand. Another alternative is to use the combination
    of the `EXPOSE` instruction of `Dockerfile` and the `-P` (publish all exposed
    ports to the host interfaces) option of the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a container's port - the -p option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Docker enables you to publish a service offered inside a container by binding
    the container''s port to the host interface. The `-p` option of the `docker run`
    subcommand enables you to bind a container port to a user-specified or autogenerated
    port of the Docker host. Thus, any communication destined for the IP address and
    the port of the Docker host will be forwarded to the port of the container. The
    `-p` option, actually, supports the following four formats of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<hostPort>:<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ip>:<hostPort>:<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ip>::<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `<ip>` is the IP address of the Docker host, `<hostPort>` is the Docker
    host port number, and `<containerPort>` is the port number of the container. Here,
    in this section, we present you with the `-p <hostPort>:<containerPort>` format
    and introduce other formats in the succeeding sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand the port binding process better, let''s reuse the `apache2`
    HTTP server image that we crafted previously and spin up a container using a `-p`
    option of the `docker run` subcommand. The `80` port is the published port of
    the HTTP service, and as the default behavior, our `apache2` HTTP server is also
    available on port `80`. Here, in order to demonstrate this capability, we are
    going to bind port `80` of the container to port `80` of the Docker host, using
    the `-p <hostPort>:<containerPort>` option of the `docker run` subcommand, as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have successfully launched the container, we can connect to our
    HTTP server using any web browser from any external system (provided it has a
    network connectivity) to reach our Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have not added any web pages to our `apache2` HTTP server image.
    Hence, when we connect from a web browser, we will get the following screen, which
    is nothing but the default page that comes along with the Ubuntu Apache2 package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_06_006.png)'
  prefs: []
  type: TYPE_IMG
- en: NAT for containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we saw how a `-p 80:80` option did the magic, didn't
    we? Well, in reality, under the hood, the Docker Engine achieves this seamless
    connectivity by automatically configuring the **Network Address Translation**
    (**NAT**) rule in the Linux `iptables` configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the automatic configuration of the NAT rule in Linux `iptables`,
    let''s query the Docker hosts `iptables` for its NAT entries, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The ensuing text is an excerpt from the `iptables` NAT entry, which is automatically
    added by the Docker Engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding excerpt, it is quite evident that the Docker Engine has
    effectively added a `DNAT` rule. The following are the details of the `DNAT` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: The `tcp` keyword signifies that this `DNAT` rule applies only to the TCP transport
    protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `0.0.0.0/0` address is a meta IP address of the source address. This
    address indicates that the connection can originate from any IP address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `0.0.0.0/0` address is a meta IP address of the destination address
    on the Docker host. This address indicates that the connection can be made to
    any valid IP address in the Docker host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `dpt:80 to:172.17.0.14:80` is the forwarding instruction used to forward
    any TCP activity on port `80` of the Docker host to be forwarded to the `172.17.0.17` IP
    address, the IP address of our container and port `80`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, any TCP packet that the Docker host receives on port `80` will be
    forwarded to port `80` of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the container port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Docker Engine provides at least three different options to retrieve the
    container''s port binding details. Here, let''s first explore the options, and
    then, move on to dissect the retrieved information. The options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker ps` subcommand always displays the port binding details of a container,
    as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker inspect` subcommand is another alternative; however, you have to
    skim through quite a lot of details. Run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker inspect` subcommand displays the port binding related information
    in three JSON objects, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ExposedPorts` object enumerates all ports that are exposed through the
    `EXPOSE` instruction in `Dockerfile`, as well as the container ports that are
    mapped using the `-p` option in the `docker run` subcommand. Since we didn''t
    add the `EXPOSE` instruction in our `Dockerfile`, what we have is just the container
    port that was mapped using `-p 80:80` as an argument to the `docker run` subcommand:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PortBindings` object is part of the `HostConfig` object, and this object
    lists out all the port binding done through the `-p` option in the `docker run`
    subcommand. This object will never list the ports exposed through the `EXPOSE`
    instruction in the `Dockerfile`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ports` object of the `NetworkSettings` object has the same level of details,
    as the preceding `PortBindings` object. However, this object encompasses all ports
    that are exposed through the `EXPOSE` instruction in `Dockerfile`, as well as
    the container ports that are mapped using the `-p` option in the `docker run`
    subcommand:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the specific port field can be filtered using the `--format` option
    of the `docker inspect` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker port` subcommand enables you to retrieve the port binding on the
    Docker host by specifying the container''s port number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, in all the preceding output excerpts, the information that stands
    out is the `0.0.0.0` IP address and the `80` port number. The `0.0.0.0` IP address
    is a meta address, which represents all the IP addresses configured on the Docker
    host. In effect, the `80` container's port is bound to all the valid IP addresses
    on the Docker host. Therefore, the HTTP service is accessible through any of the
    valid IP addresses configured on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a container to a specific IP address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, with the method that you learned, the containers always get bound
    to all the IP addresses configured on the Docker host. However, you may want to
    offer different services on different IP addresses. In other words, a specific
    IP address and port would be configured to offer a particular service. We can
    achieve this in Docker using the `-p <ip>:<hostPort>:<containerPort>` option of
    the `docker run` subcommand, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the IP address must be a valid IP address on the Docker host. If the
    specified IP address is not a valid IP address on the Docker host, the container
    launch will fail with an error message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s quickly review the port mapping as well the NAT entry for the preceding
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, you will realize how elegantly the Docker Engine has configured
    the service offered by the container on the `198.51.100.73` IP address and `80` port
    of the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Autogenerating the Docker host port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Docker containers are innately lightweight and due to their lightweight
    nature, you can run multiple containers with the same or different service on
    a single Docker host. Particularly, autoscaling of the same service across several
    containers based on the demand is the need of the IT infrastructure today. Here,
    in this section, you will be informed about the challenge in spinning up multiple
    containers with the same service and also the Docker's way of addressing this
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we launched a container using Apache2 HTTP server
    by binding it to port `80` of the Docker host. Now, if we attempt to launch one
    more container with the same port `80` binding, the container would fail to start
    with an error message, as you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, in the preceding example, the container failed to start because the
    previous container is already mapped to `0.0.0.0` (all the IP addresses of the
    Docker host) and port `80`. In the TCP/IP communication model, the combination
    of the IP address, port, and the transport protocols (TCP, UDP, and so on) has
    to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have overcome this issue by manually choosing the Docker host port
    number (for instance, `-p 81:80` or `-p 8081:80`). Though this is an excellent
    solution, it does not scale well for autoscaling scenarios. Instead, if we give
    the control to Docker, it would autogenerate the port number on the Docker host.
    This port number generation is achieved by underspecifying the Docker host port
    number, using the `-p <containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully started the new container with the autogenerated port,
    let''s review the port mapping as well the NAT entry for the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, what stands out is the `49158` port number. The `49158` port
    number is niftily autogenerated by the Docker Engine on the Docker host, with
    the help of the underlying operating system. Besides, the `0.0.0.0` meta IP address
    implies that the service offered by the container is accessible from outside,
    through any of the valid IP addresses configured on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have a use case where you want to autogenerate the port number. However,
    if you still want to restrict the service to a particular IP address of the Docker
    host, you can use the `-p <IP>::<containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding two scenarios, the Docker Engine autogenerated the port number
    on the Docker host and exposed it to the outside world. The general norm of network
    communication is to expose any service through a predefined port number so that
    anybody knows the IP address, and the port number can easily access the offered
    service. Whereas, here the port numbers are autogenerated and as a result, the
    outside world cannot directly reach the offered service. So, the primary purpose
    of this method of container creation is to achieve autoscaling, and the container
    created in this fashion would be interfaced with a proxy or load balance service
    on a predefined port.
  prefs: []
  type: TYPE_NORMAL
- en: Port binding using EXPOSE and -P option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have discussed the four distinct methods to publish a service running
    inside a container to the outside world. In all these four methods, the port binding
    decision is taken during the container launch, and the image has no information
    about the ports on which the service is being offered. It has worked well so far
    because the image is being built by us, and we are pretty much aware of the port
    in which the service is being offered.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of third-party images, the port usage inside a container
    has to be published unambiguously. Besides, if we build images for third-party
    consumption or even for our own use, it is a good practice to explicitly state
    the ports in which the container offers its service. Perhaps, the image builders
    could ship a README document along with the image. However, it is even better
    to embed the port details in the image itself so that you can easily find the
    port details from the image both manually as well as through automated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker technology allows us to embed the port information using the `EXPOSE`
    instruction in the `Dockerfile`, which we introduced in [Chapter 3](../Text/Ch03.xhtml),
    *Building Images*. Here, let''s edit the `Dockerfile` we used to build the `apache2`
    HTTP server image earlier in this chapter, and add an `EXPOSE` instruction, as
    shown in the following code. The default port for the HTTP service is port `80`,
    hence port `80` is exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the `EXPOSE` instruction to our `Dockerfile`, let''s
    move to the next step of building the image using the `docker build` command.
    Here, let''s reuse the `apache2` image name, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully built the image, let''s inspect the image to verify the
    effects of the `EXPOSE` instruction to the image. As we learned earlier, we can
    resort to the `docker inspect` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'On a close review of the output generated by the preceding command, you will
    realize that Docker stores the exposed port information in the `ExposedPorts`
    field of the `Config` object. The following is an excerpt to show how the exposed
    port information is being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can apply the `--format` option to the `docker inspect`
    subcommand in order to narrow down the output to a very specific information.
    In this case, the `ExposedPorts` field of the `Config` object is shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To resume our discussion on the `EXPOSE` instruction, we can now spin up containers
    using an `apache2` image, we just crafted. Yet, the `EXPOSE` instruction by itself
    cannot create a port binding on the Docker host. In order to create a port binding
    for the port declared using the `EXPOSE` instruction, the Docker Engine provides
    a `-P` option in the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a container is launched from the `apache2` image,
    which was rebuilt earlier. Here, the `-d` option is used to launch the container
    in the detached mode, and the `-P` option is used to create the port binding on
    the Docker host for all the ports declared, using the `EXPOSE` instruction in
    the `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have started the new container with the image that was created
    using the `EXPOSE` instruction, like the previous containers, let''s review the
    port mapping as well the NAT entry for the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following text is an excerpt from the output of the `iptables -t nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `-P` option of the `docker run` subcommand does not take any additional
    arguments, such as an IP address or a port number; consequently, fine-tuning of
    the port binding is not possible, such as the `-p` option of the `docker run`
    subcommand. You can always resort to the `-p` option of the `docker run` subcommand
    if fine-tuning of port binding is critical to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers do not deliver anything substantial in an isolated or solo way. They
    need to be systematically built and provided with a network interface along with
    a port number. These lead to the standardized exposition of containers to the
    outside world, facilitating other hosts or containers to find, bind, and leverage
    their unique capabilities on any network. Thus, the network accessibility is paramount
    for containers to get noticed across and be utilized in innumerable ways. This
    chapter was dedicated to showcase how containers are being designed and deployed
    as a service, and how the aspect of container networking comes in handy in precisely
    and profusely empowering the peculiar world of container services as the days
    unfold. In the forthcoming chapters, we will deal and dwell at length on the various
    capabilities of Docker containers in the software-intensive IT environments.
  prefs: []
  type: TYPE_NORMAL
