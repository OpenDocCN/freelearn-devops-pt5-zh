- en: Running Services in a Container
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行服务
- en: We have come thus far by carefully explaining the various aspects of the Docker
    technology. The previous chapters definitely have laid down a stellar foundation
    for the overwhelmingly accepted Docker platform and the forthcoming chapters will
    be like the meticulously crafted buildings on that grandiose foundation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过仔细讲解 Docker 技术的各个方面，打下了坚实的基础。前几章无疑为广泛接受的 Docker 平台奠定了基础，接下来的章节将像在这一宏大基础上精心打造的建筑一样。
- en: We described the important building blocks (the highly usable and reusable Docker
    images) to bring forth powerful Docker containers. There are briefs about the
    various easy-to-learn-and-employ techniques and tips on how to store and share
    Docker images through a well-designed storage framework. Typically, images have
    to go through a series of verifications, validations, and refinements constantly
    in order to be right and relevant for the aspiring development community.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了构建强大 Docker 容器的重要构件（高度可用和可重用的 Docker 镜像）。有关于如何通过精心设计的存储框架存储和共享 Docker
    镜像的简要说明，涵盖了各种易学易用的技巧和方法。通常，镜像必须经过一系列验证、确认和完善，以确保其对开发社区的需求具有正确性和相关性。
- en: In this chapter, we are going to take our learning to the next level by detailing
    the key steps in creating a small web server, run the same inside a container,
    and enable outsiders to connect to the containerized web server through the Internet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将通过详细介绍创建一个小型 Web 服务器的关键步骤，将我们的学习提升到一个新的层次，在容器内运行该服务器，并允许外部通过互联网连接到容器化的
    Web 服务器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Container networking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络
- en: '**Container as a Service** (**CaaS**) – building, running, exposing, and connecting
    to container services'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器即服务** (**CaaS**) – 构建、运行、暴露和连接容器服务'
- en: Publishing and retrieving containers' port
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布和检索容器的端口
- en: Binding a container to a specific IP address
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器绑定到特定的 IP 地址
- en: Autogenerating the Docker host port
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成 Docker 主机端口
- en: Port binding using the `EXPOSE` and `-P` options
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `EXPOSE` 和 `-P` 选项进行端口绑定
- en: A brief overview of container networking
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器网络概述
- en: Networking is a critical infrastructure component of enterprise and cloud IT.
    Especially, as computing becomes extremely distributed, networking becomes indispensable.
    Typically, a Docker host comprises multiple Docker containers and hence the networking
    has become a crucial component for realizing composite containerized applications.
    Docker containers also need to interact and collaborate with local as well as
    remote ones to come out with distributed applications. Precisely speaking, different
    and distributed containers need to be publicly found, network-accessible, and
    composable to bring forth business-centric and process-aware applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是企业和云 IT 的关键基础设施组成部分。特别是随着计算变得极为分布式，网络变得不可或缺。通常，一个 Docker 主机包含多个 Docker 容器，因此网络已经成为实现复合容器化应用程序的关键组成部分。Docker
    容器还需要与本地及远程容器进行交互与协作，以实现分布式应用。准确地说，不同的分布式容器需要公开可见、可网络访问和可组合，以推动面向业务和流程感知的应用程序。
- en: 'One of the key strengths of the Docker containerization paradigm is the ability
    to network seamlessly without much effort from the user. The earlier version of
    Docker supported just the bridge network; later, Docker acquired the SDN startup
    SocketPlane to add additional networking capabilities. Since then, Docker''s networking
    capability has grown leaps and bounds and a separate set of subcommands, namely
    `docker network connect`, `docker network create`, `docker network disconnect`,
    `docker network inspect`, `docker network ls`, and `docker network rm`, were introduced
    to handle the nitty-gritty of the Docker networking. By default, during installation,
    the Docker Engine creates three networks for you, which you can list using the
    `docker network ls` subcommand, as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器化模式的一个关键优势是能够实现无缝网络连接，用户无需花费太多精力。Docker 的早期版本仅支持桥接网络；后来，Docker 收购了
    SDN 初创公司 SocketPlane，增加了更多的网络功能。从那时起，Docker 的网络能力大幅提升，并引入了一组独立的子命令，即 `docker network
    connect`、`docker network create`、`docker network disconnect`、`docker network inspect`、`docker
    network ls` 和 `docker network rm`，用于处理 Docker 网络的细节。默认情况下，在安装时，Docker 引擎会为你创建三个网络，你可以通过
    `docker network ls` 子命令列出它们，如下所示：
- en: '![](img/image_06_001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_001.jpg)'
- en: 'As you can see in the preceding screenshot, during the Docker setup, the Docker
    Engine creates the `bridge`, `host`, and `none` (`null`) networks. When Docker
    spins up a new container, by default, it creates a network stack for the container
    and attaches to the default `bridge` network. However, optionally, you could attach
    the container to the `host` or `none` network or the user-defined network using
    the `--net` option of the `docker run` subcommand. If you choose the `host` network,
    the container gets attached to the `host` network stack and shares the host''s
    IP addresses and ports. The `none` network mode creates a network stack with just
    the Loopback (`lo`) interface. We can confirm this using the `docker run --rm
    --net=none busybox ip addr` command, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的截图中看到的，在 Docker 设置过程中，Docker 引擎创建了 `bridge`、`host` 和 `none`（`null`）网络。当
    Docker 启动一个新的容器时，默认情况下，它会为容器创建一个网络堆栈，并附加到默认的 `bridge` 网络。然而，你也可以选择通过 `docker run`
    子命令的 `--net` 选项将容器连接到 `host` 或 `none` 网络，或者用户自定义网络。如果选择 `host` 网络，容器将连接到 `host`
    网络堆栈，并共享主机的 IP 地址和端口。`none` 网络模式只会创建一个具有回环（`lo`）接口的网络堆栈。我们可以通过使用 `docker run --rm
    --net=none busybox ip addr` 命令来验证这一点，如下所示：
- en: '![](img/image_06_002.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_002.jpg)'
- en: Evidently, as you can see in the preceding screenshot, the container has got
    just a Loopback interface. Since this container has got just a Loopback interface,
    the container cannot communicate with other containers or the external world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，正如你在前面的截图中看到的，容器只有一个回环接口。由于这个容器只有回环接口，它无法与其他容器或外部世界通信。
- en: 'The `bridge` network is the default network interface that Docker Engine assigns
    to a container if the network is not configured using the `--net` option of the
    `docker run` subcommand. To have a better understanding of the `bridge` network,
    let''s begin by inspecting it using the `docker network inspect` subcommand, as
    shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`bridge` 网络是 Docker 引擎分配给容器的默认网络接口，除非通过 `docker run` 子命令的 `--net` 选项配置网络。为了更好地理解
    `bridge` 网络，我们可以使用 `docker network inspect` 子命令进行检查，如下所示：'
- en: '![](img/image_06_003.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_003.jpg)'
- en: 'Here, in the preceding screenshot, we have highlighted three paramount insights.
    You can find the relevant description of what happens during the Docker installation
    process:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们突出了三个重要的见解。你可以找到关于 Docker 安装过程中发生的相关描述：
- en: '`docker0`: Docker creates an Ethernet bridge interface inside the Linux kernel
    with the `docker0` name on the Docker host. This interface is used as a bridge
    to pass the Ethernet frames between containers and also between containers and
    an external network.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker0`：Docker 在 Linux 内核中创建了一个名为 `docker0` 的以太网桥接口。这个接口用作桥梁，将以太网帧传递在容器之间以及容器与外部网络之间。'
- en: '`Subnet`: Docker also selects a private IP subnet from the address range of
    `172.17.0.0` to `172.17.255.255` and keeps it revered for its containers. In the
    preceding screenshot, Docker has selected the `172.17.0.0/16` subnet for the containers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`子网`：Docker 还从 `172.17.0.0` 到 `172.17.255.255` 的地址范围中选择了一个私有 IP 子网，并为其容器保留。前面的截图中，Docker
    为容器选择了 `172.17.0.0/16` 子网。'
- en: '`Gateway`: The `docker0` interface is the gateway for the `bridge` network
    and Docker, from the IP subnet range selected earlier, assigns an IP address to
    `docker0`. Here, in the preceding example, `172.17.0.1` is assigned to the gateway.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网关`：`docker0` 接口是 `bridge` 网络和 Docker 的网关，Docker 会从之前选择的 IP 子网范围中分配一个 IP 地址给
    `docker0`。在前面的示例中，`172.17.0.1` 被分配为网关地址。'
- en: 'We can cross-check the gateway address by listing the `docker0` interface using
    the `ip addr show` Linux command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `ip addr show` Linux 命令列出 `docker0` 接口来交叉验证网关地址：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The third line of the output shows the assigned IP address and its network
    prefix:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第三行显示了分配的 IP 地址及其网络前缀：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apparently, from the preceding text, `172.17.0.1` is the IP address assigned
    to `docker0`, the Ethernet bridge interface, which is also listed as the gateway
    address in the output of the `docker network inspect bridge` command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从前面的文字中可以看出，`172.17.0.1` 是分配给 `docker0` 的 IP 地址，`docker0` 是以太网桥接口，它也被列为 `docker
    network inspect bridge` 命令输出中的网关地址。
- en: 'Now that we have a clear understanding of the bridge creation and the subnet/gateway
    address selection process, let''s explore the container networking in the `bridge`
    mode a bit more in detail. In the `bridge` network mode, the Docker Engine creates
    a network stack with a Loopback (`lo`) interface and an Ethernet (`eth0`) interface
    during the launch of the container. We can quickly examine this by running the
    `docker run --rm busybox ip addr` command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对桥接器的创建以及子网/网关地址选择过程有了清晰的理解，接下来让我们更详细地探讨一下 `bridge` 模式下的容器网络。在 `bridge`
    网络模式下，Docker 引擎在启动容器时会创建一个网络栈，其中包含一个环回 (`lo`) 接口和一个以太网 (`eth0`) 接口。我们可以通过运行 `docker
    run --rm busybox ip addr` 命令快速检查这一点：
- en: '![](img/image_06_004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_004.jpg)'
- en: 'Evidently, the preceding output of the `ip addr` command shows that the Docker
    Engine has created a network stack for the container with two network interfaces,
    which are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`ip addr` 命令的前述输出显示 Docker 引擎已经为容器创建了一个网络栈，并且该栈有两个网络接口，分别如下：
- en: The first interface is the `lo` (Loopback) interface, for which the Docker Engine
    assigned the `127.0.0.1` Loopback address. The Loopback interface is used for
    local communication within a container.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个接口是 `lo`（环回）接口，Docker 引擎为其分配了 `127.0.0.1` 的环回地址。环回接口用于容器内部的本地通信。
- en: The second interface is an `eth0` (Ethernet) interface, for which the Docker
    Engine assigned the `172.17.0.3` IP address. Obviously, this address also falls
    within the same IP address range of the `docker0` Ethernet bridge interface. Besides,
    the address assigned to the `eth0` interface is used for intra-container communication
    and host-to-container communication.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个接口是 `eth0`（以太网）接口，Docker 引擎为其分配了 `172.17.0.3` 的 IP 地址。显然，这个地址也位于 `docker0`
    以太网桥接接口的相同 IP 地址范围内。此外，分配给 `eth0` 接口的地址用于容器之间的通信以及主机与容器之间的通信。
- en: The `ip addr` and/or `ifconfig` commands are not supported by all Docker images,
    including `ubuntu:14.04` and `ubuntu:16.04`. The `docker inspect` subcommand is
    the reliable way to find the IP address of the container.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip addr` 和/或 `ifconfig` 命令并不是所有 Docker 镜像都支持的，包括 `ubuntu:14.04` 和 `ubuntu:16.04`。`docker
    inspect` 子命令是查找容器 IP 地址的可靠方式。'
- en: 'Earlier, we mentioned that `docker0`, the Ethernet bridge interface, acts as
    a conduit to pass the Ethernet frames between containers and also between containers
    and the external world. However, we have not yet clarified how the containers
    connect with the `docker0` bridge. The following diagram unravels some of the
    mystery around this connection:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到过，`docker0` 以太网桥接接口作为容器之间以及容器与外部世界之间传递以太网帧的通道。不过，我们还没有说明容器是如何连接到 `docker0`
    桥接器的。下图揭示了这一连接的一些奥秘：
- en: '![](img/image_06_005.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_005.png)'
- en: As depicted here, the container's `eth0` interface is connected to the `docker0`
    bridge using `veth`. The `eth0` and `veth` interfaces belong to a special type
    of Linux network interface called a **Virtual Ethernet** (**veth**) Interface.
    The `veth` interface always comes in a pair, and they are like a water pipe wherein
    the data send from one `veth` interface will come out of the other interface and
    vice versa. The Docker Engine assigns one of the `veth` interfaces to the container
    with the `eth0` name and assigns the container IP address to that interface. The
    other `veth` interface of the pair is bound to the `docker0` bridge interface.
    This ensures the seamless flow of data between the Docker host and the containers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图所示，容器的 `eth0` 接口通过 `veth` 连接到 `docker0` 桥接器。`eth0` 和 `veth` 接口属于一种特殊类型的 Linux
    网络接口，称为 **虚拟以太网** (**veth**) 接口。`veth` 接口总是成对出现，它们就像一根水管，数据从一个 `veth` 接口发送出去，最终会从另一个接口出来，反之亦然。Docker
    引擎将其中一个 `veth` 接口分配给容器并命名为 `eth0`，并将容器的 IP 地址分配给该接口。成对的另一个 `veth` 接口则绑定到 `docker0`
    桥接器接口。这样确保了 Docker 主机与容器之间的数据流畅通无阻。
- en: 'Docker assigns private IP addresses to the container, which is not reachable
    from outside of the Docker host. However, the container IP address comes in handy
    for debugging within the Docker host. As we noted earlier, many Docker images
    do not support the `ip addr` or `ifconfig` commands, besides we may not directly
    have access to the container prompt to run any of these commands. Fortunately,
    Docker provides a `docker inspect` subcommand, which is as handy as a Swiss Army
    knife, to dive deep into the low-level details of the Docker container or image.
    The `docker inspect` subcommand reports quite a lot of details including the IP
    address and the gateway address. For the practical purpose, here you can either
    select a running container or temporarily launch a container, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为容器分配私有IP地址，这些地址无法从Docker主机外部访问。然而，容器的IP地址对于在Docker主机内部进行调试非常有用。正如我们之前所提到的，许多Docker镜像不支持
    `ip addr` 或 `ifconfig` 命令，此外，我们可能没有直接访问容器提示符以运行这些命令的权限。幸运的是，Docker提供了一个 `docker
    inspect` 子命令，就像瑞士军刀一样方便，可以深入查看Docker容器或镜像的底层细节。`docker inspect` 子命令报告了很多细节，包括IP地址和网关地址。为了实际操作，这里你可以选择一个正在运行的容器或暂时启动一个容器，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, let''s assume the container ID is `4b0b567b6019` and run the `docker
    inspect` subcommand, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，假设容器ID是 `4b0b567b6019`，并运行 `docker inspect` 子命令，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command generates quite a lot of information about the container. Here,
    we show some excerpts of the container''s network configuration from the output
    of the `docker inspect` subcommand:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令生成了关于容器的很多信息。这里，我们展示了从 `docker inspect` 子命令输出中提取的一些容器网络配置片段：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are the details of some of the important fields in the network configuration:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是网络配置中一些重要字段的详细信息：
- en: '`Gateway`: This is the gateway address of the container, which is the address
    of the `bridge` interface as well'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gateway`：这是容器的网关地址，也是 `bridge` 接口的地址。'
- en: '`IPAddress`: This is the IP address assigned to the container'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPAddress`：这是分配给容器的IP地址。'
- en: '`IPPrefixLen`: This is the IP prefix length, another way of representing the
    subnet mask'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPPrefixLen`：这是IP前缀长度，另一种表示子网掩码的方式。'
- en: Without doubt, the `docker inspect` subcommand is quite convenient to find the
    minute details of a container or an image. However, it's a tiresome job to go
    through the intimidating details and to find the right information that we are
    keenly looking for. Perhaps, you can narrow it down to the right information,
    using the `grep` command. Alternatively, even better, the `docker inspect` subcommand
    helps you pick the right field from the JSON array using the `--format` option
    of the `docker inspect` subcommand.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，`docker inspect` 子命令非常方便，用来查找容器或镜像的细节。然而，逐一浏览那些复杂的细节并找到我们需要的信息是一项繁琐的工作。或许，你可以通过使用
    `grep` 命令缩小范围，找到所需的信息。更好的是，`docker inspect` 子命令通过 `--format` 选项帮助你从JSON数组中选择正确的字段。
- en: 'Notably, in the following example, we use the `--format` option of the `docker
    inspect` subcommand to retrieve just the IP address of the container. The IP address
    is accessible through the `.NetworkSettings.IPAddress` field of the JSON array:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在以下示例中，我们使用 `docker inspect` 子命令的 `--format` 选项，只获取容器的IP地址。IP地址可以通过JSON数组中的
    `.NetworkSettings.IPAddress` 字段访问：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In addition to the `none`, `host`, and `bridge` networking modes, Docker also
    supports the `overlay`, `macvlan`, and `ipvlan` network modes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `none`、`host` 和 `bridge` 网络模式外，Docker还支持 `overlay`、`macvlan` 和 `ipvlan` 网络模式。
- en: Envisaging container as a service
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器视为一种服务
- en: We laid a good foundation of the fundamentals of the Docker technology. In this
    section, we are going to focus on crafting an image with the HTTP service, launch
    the HTTP service inside the container using the crafted image, and then, demonstrate
    the connectivity to the HTTP service running inside the container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打下了Docker技术基础的良好基础。在这一部分，我们将专注于创建一个带有HTTP服务的镜像，在容器内启动HTTP服务，并演示容器内运行的HTTP服务的连接性。
- en: Building an HTTP server image
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建HTTP服务器镜像
- en: In this section, we are going to craft a Docker image in order to install Apache2
    on top of the Ubuntu 16.04 base image, and configure an Apache HTTP server to
    run as an executable, using the `ENTRYPOINT` instruction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将构建一个Docker镜像，用以在Ubuntu 16.04基础镜像上安装Apache2，并使用 `ENTRYPOINT` 指令配置一个可执行的Apache
    HTTP服务器。
- en: In [Chapter 3](../Text/Ch03.xhtml), *Building Images*, we illustrated the concept
    of `Dockerfile` to craft an Apache2 image on top of the Ubuntu 16.04 base image.
    Here, in this example, we are going to extend this `Dockerfile` by setting the
    Apache log path and setting Apache2 as the default execution application, using
    the `ENTRYPOINT` instruction. The following is a detailed explanation of the content
    of `Dockerfile`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](../Text/Ch03.xhtml)，《构建镜像》一节中，我们阐述了使用`Dockerfile`在Ubuntu 16.04基础镜像上构建Apache2镜像的概念。在此示例中，我们将通过设置Apache日志路径并使用`ENTRYPOINT`指令将Apache2设置为默认执行应用程序，来扩展该`Dockerfile`。以下是`Dockerfile`内容的详细说明：
- en: 'We are going to build an image using `ubuntu:16.04` as the base image, using
    the `FROM` instruction, as shown in the `Dockerfile` snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ubuntu:16.04`作为基础镜像，使用`FROM`指令构建一个镜像，正如在`Dockerfile`片段中所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set the author''s detail using the `MAINTAINER` instruction:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MAINTAINER`指令设置作者的详细信息：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using one `RUN` instruction, we will synchronize the APT repository source
    list, install the `apache2` package, and then clean the retrieved files:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个`RUN`指令，我们将同步APT仓库源列表，安装`apache2`包，然后清理已获取的文件：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set the Apache log directory path using the `ENV` instruction:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ENV`指令设置Apache日志目录路径：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, the final instruction is to launch the `apache2` server using the `ENTRYPOINT`
    instruction:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后的指令是使用`ENTRYPOINT`指令启动`apache2`服务器：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding line, you might be surprised to see the `FOREGROUND` argument.
    This is one of the key differences between the traditional and the container paradigm.
    In the traditional paradigm, the server applications are usually launched in the
    background either as a service or a daemon because the host system is a general-purpose
    system. However, in the container paradigm, it is imperative to launch an application
    in the foreground because the images are crafted for a sole purpose.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，你可能会惊讶地看到`FOREGROUND`参数。这是传统模式和容器模式之间的一个关键区别。在传统模式下，服务器应用程序通常会作为服务或守护进程在后台启动，因为主机系统是通用系统。然而，在容器模式下，必须将应用程序启动在前台，因为镜像是为单一目的而制作的。
- en: 'Having prescribed the image building instruction in the `Dockerfile`, let''s
    now move to the next logical step of building the image using the `docker build`
    subcommand by naming the image as `apache2`, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dockerfile`中指定了镜像构建指令后，让我们进入下一个逻辑步骤，使用`docker build`子命令构建镜像，并将镜像命名为`apache2`，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now do a quick verification of the images using the `docker images`
    subcommand:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`docker images`子命令对镜像进行快速验证：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we have seen in the previous chapters, the `docker images` command displays
    the details of all the images in the Docker host. However, in order to illustrate
    precisely the images created using the `docker build` subcommand, we highlight
    the details of `apache2:latest` (the target image) and `ubuntu:16.04` (the base
    image) from the complete image list, as shown in the following output snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所看到的，`docker images`命令显示了Docker主机中所有镜像的详细信息。然而，为了准确地展示使用`docker build`子命令创建的镜像，我们从完整的镜像列表中突出显示了`apache2:latest`（目标镜像）和`ubuntu:16.04`（基础镜像）的详细信息，如下所示的输出片段：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having built the HTTP server image, let's now move on to the next session to
    learn how to run the HTTP service.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完HTTP服务器镜像后，让我们继续下一节，学习如何运行HTTP服务。
- en: Running the HTTP server image as a service
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以服务的方式运行HTTP服务器镜像
- en: 'In this section, we are going to launch a container using the Apache HTTP server
    image, we crafted in the previous section. Here, we launch the container in the
    detached mode (similar to the UNIX daemon process) using the `-d` option of the
    `docker run` subcommand:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用前一节中制作的Apache HTTP服务器镜像启动一个容器。这里，我们使用`docker run`子命令的`-d`选项以分离模式（类似于UNIX守护进程）启动容器：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Having launched the container, let''s run the `docker logs` subcommand to see
    whether our Docker container generates any output on its stdin (standard input)
    or stderr (standard error):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器后，让我们运行`docker logs`子命令查看我们的Docker容器是否会在其标准输入（stdin）或标准错误（stderr）上生成任何输出：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we have not fully configured the Apache HTTP server, you will find the following
    warning, as the output of the `docker logs` subcommand:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未完全配置Apache HTTP服务器，你将看到以下警告，作为`docker logs`子命令的输出：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the preceding warning message, it is quite evident that the IP address
    assigned to this container is `172.17.0.13`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的警告信息中可以明显看出，分配给此容器的IP地址是`172.17.0.13`。
- en: Connecting to the HTTP service
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到HTTP服务
- en: 'In the preceding section, indecently, from the warning message, we find out
    that the IP address of the container is `172.17.0.13`. On a fully configured HTTP
    server container, no such warning is available, so let''s still run the `docker
    inspect` subcommand to retrieve the IP address using the container ID:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，从警告信息中我们发现容器的IP地址是`172.17.0.13`。在完全配置好的HTTP服务器容器上，不会有这样的警告，因此我们仍然运行`docker
    inspect`子命令，使用容器ID来获取IP地址：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having found the IP address of the container as `172.17.0.13`, let''s quickly
    run a web request on this IP address from the shell prompt of the Docker host,
    using the `wget` command. Here, we choose to run the `wget` command with `-qO
    -` in order to run in the quiet mode and also display the retrieved HTML file
    on the screen:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到了容器的IP地址`172.17.0.13`之后，让我们快速地在Docker主机的shell提示符中通过`wget`命令在这个IP地址上发起一个Web请求。在这里，我们选择使用`-qO
    -`选项运行`wget`命令，以便在安静模式下运行，并将获取的HTML文件显示在屏幕上：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we are showcasing just the first five lines of the retrieved HTML file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示的是获取到的HTML文件的前五行：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Awesome, isn't it? We got our first service running in a container, and we are
    able to reach out to our service from our Docker host.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，对吧？我们已经在容器中运行了第一个服务，并且能够从Docker主机访问我们的服务。
- en: Furthermore, on a plain vanilla Docker installation, the service offered by
    one container is accessible by any other container within the Docker host. You
    can go ahead, launch a new Ubuntu container in the interactive mode, install the
    `wget` package using `apt-get`, and run the same `wget -qO - 172.17.0.13` command,
    as we did in the Docker host. Of course, you will see the same output.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在一个普通的Docker安装中，一个容器提供的服务是可以被同一Docker主机上的任何其他容器访问的。你可以继续启动一个新的Ubuntu容器并以交互模式运行，使用`apt-get`安装`wget`包，然后运行与我们在Docker主机中相同的`wget
    -qO - 172.17.0.13`命令。当然，你会看到相同的输出。
- en: Exposing container services
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 曝露容器服务
- en: So far, we successfully launched an HTTP service and accessed the service from
    the Docker host as well as another container within the same Docker host. Furthermore,
    as demonstrated in the *Building images from containers* section of [Chapter 2](../Text/Ch02.xhtml),
    *Handling Docker Containers*, the container is able to successfully install the
    `wget` package by making a connection to the publicly available APT repository
    over the Internet. Nonetheless, the outside world cannot access the service offered
    by a container by default. At the outset, this might seem like a limitation in
    the Docker technology. However, the fact is, the containers are isolated from
    the outside world by design.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们成功启动了一个HTTP服务，并从Docker主机以及同一Docker主机内的其他容器访问了该服务。此外，正如在[第二章](../Text/Ch02.xhtml)《处理Docker容器》中的*从容器构建镜像*一节中所展示的那样，通过连接到公开可用的APT仓库并通过互联网访问，容器能够成功安装`wget`包。然而，默认情况下，外界无法访问容器提供的服务。乍一看，这似乎是Docker技术的一个限制，但实际上，容器在设计上就与外界隔离。
- en: 'Docker achieves network isolation for the containers by the IP address assignment
    criteria, as enumerated here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Docker通过IP地址分配标准来实现容器的网络隔离，具体列举如下：
- en: Assigning a private IP address to the container, which is not reachable from
    an external network
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器分配一个私有IP地址，该地址无法从外部网络访问
- en: Assigning an IP address to the container outside the host's IP network
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器分配一个在主机IP网络之外的IP地址
- en: Consequently, the Docker container is not reachable even from the systems that
    are connected to the same IP network as the Docker host. This assignment scheme
    also provides protection from an IP address conflict that might otherwise arise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使是连接到与Docker主机相同IP网络的系统，也无法访问Docker容器。这个分配方案还提供了保护，防止可能出现的IP地址冲突。
- en: Now, you might wonder how to make the services run inside a container that is
    accessible to the outside world, in other words, exposing container services.
    Well, Docker bridges this connectivity gap in a classy manner by leveraging the
    Linux `iptables` functionality under the hood.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想知道如何让容器内部运行的服务对外界可访问，换句话说，如何曝露容器服务。好吧，Docker通过在幕后利用Linux的`iptables`功能，巧妙地弥补了这个连接性差距。
- en: At the frontend, Docker provides two different building blocks for bridging
    this connectivity gap for its users. One of the building blocks is to bind the
    container port using the `-p` (publish a container's port to the host interface)
    option of the `docker run` subcommand. Another alternative is to use the combination
    of the `EXPOSE` instruction of `Dockerfile` and the `-P` (publish all exposed
    ports to the host interfaces) option of the `docker run` subcommand.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端，Docker为其用户提供了两种不同的构建块，用于弥合连接性差距。其中一个构建块是使用`-p`（将容器端口发布到主机接口）选项，通过`docker
    run`子命令绑定容器端口。另一个替代方法是结合使用`Dockerfile`中的`EXPOSE`指令和`docker run`子命令的`-P`（将所有暴露的端口发布到主机接口）选项。
- en: Publishing a container's port - the -p option
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布容器端口 - `-p`选项
- en: 'Docker enables you to publish a service offered inside a container by binding
    the container''s port to the host interface. The `-p` option of the `docker run`
    subcommand enables you to bind a container port to a user-specified or autogenerated
    port of the Docker host. Thus, any communication destined for the IP address and
    the port of the Docker host will be forwarded to the port of the container. The
    `-p` option, actually, supports the following four formats of arguments:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许您通过将容器的端口绑定到主机接口，发布容器内提供的服务。`docker run`子命令的`-p`选项使您能够将容器端口绑定到Docker主机的用户指定端口或自动生成端口。因此，任何发送到Docker主机的IP地址和端口的通信都会被转发到容器的端口。实际上，`-p`选项支持以下四种格式的参数：
- en: '`<hostPort>:<containerPort>`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<hostPort>:<containerPort>`'
- en: '`<containerPort>`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<containerPort>`'
- en: '`<ip>:<hostPort>:<containerPort>`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ip>:<hostPort>:<containerPort>`'
- en: '`<ip>::<containerPort>`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ip>::<containerPort>`'
- en: Here, `<ip>` is the IP address of the Docker host, `<hostPort>` is the Docker
    host port number, and `<containerPort>` is the port number of the container. Here,
    in this section, we present you with the `-p <hostPort>:<containerPort>` format
    and introduce other formats in the succeeding sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<ip>`是Docker主机的IP地址，`<hostPort>`是Docker主机的端口号，`<containerPort>`是容器的端口号。在本节中，我们向您展示`-p
    <hostPort>:<containerPort>`格式，并将在后续部分介绍其他格式。
- en: 'In order to understand the port binding process better, let''s reuse the `apache2`
    HTTP server image that we crafted previously and spin up a container using a `-p`
    option of the `docker run` subcommand. The `80` port is the published port of
    the HTTP service, and as the default behavior, our `apache2` HTTP server is also
    available on port `80`. Here, in order to demonstrate this capability, we are
    going to bind port `80` of the container to port `80` of the Docker host, using
    the `-p <hostPort>:<containerPort>` option of the `docker run` subcommand, as
    shown in the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解端口绑定过程，让我们重新使用之前制作的`apache2` HTTP服务器镜像，并使用`docker run`子命令的`-p`选项启动一个容器。`80`端口是HTTP服务的发布端口，作为默认行为，我们的`apache2`
    HTTP服务器也在端口`80`上可用。在这里，为了演示这个功能，我们将使用`docker run`子命令的`-p <hostPort>:<containerPort>`选项，将容器的`80`端口绑定到Docker主机的`80`端口，如下命令所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have successfully launched the container, we can connect to our
    HTTP server using any web browser from any external system (provided it has a
    network connectivity) to reach our Docker host.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功启动了容器，可以通过任何外部系统的Web浏览器（只要该系统具有网络连接）连接到我们的HTTP服务器，从而访问我们的Docker主机。
- en: 'So far, we have not added any web pages to our `apache2` HTTP server image.
    Hence, when we connect from a web browser, we will get the following screen, which
    is nothing but the default page that comes along with the Ubuntu Apache2 package:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有向我们的`apache2` HTTP服务器镜像添加任何网页。因此，当我们从Web浏览器连接时，将看到以下屏幕，这只是Ubuntu
    Apache2包随附的默认页面：
- en: '![](img/image_06_006.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_006.png)'
- en: NAT for containers
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的NAT
- en: In the previous section, we saw how a `-p 80:80` option did the magic, didn't
    we? Well, in reality, under the hood, the Docker Engine achieves this seamless
    connectivity by automatically configuring the **Network Address Translation**
    (**NAT**) rule in the Linux `iptables` configuration files.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到`-p 80:80`选项是如何起作用的，对吧？实际上，在幕后，Docker引擎通过自动配置Linux `iptables`配置文件中的**网络地址转换**（**NAT**）规则，实现了这种无缝连接。
- en: 'To illustrate the automatic configuration of the NAT rule in Linux `iptables`,
    let''s query the Docker hosts `iptables` for its NAT entries, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Linux `iptables`中NAT规则的自动配置，下面我们查询Docker主机的`iptables`以获取其NAT条目，如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The ensuing text is an excerpt from the `iptables` NAT entry, which is automatically
    added by the Docker Engine:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本摘自由 Docker 引擎自动添加的 `iptables` NAT 条目：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From the preceding excerpt, it is quite evident that the Docker Engine has
    effectively added a `DNAT` rule. The following are the details of the `DNAT` rule:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的摘录可以明显看出，Docker 引擎已经有效地添加了一个 `DNAT` 规则。以下是该 `DNAT` 规则的详细信息：
- en: The `tcp` keyword signifies that this `DNAT` rule applies only to the TCP transport
    protocol.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcp` 关键字表示此 `DNAT` 规则仅适用于 TCP 传输协议。'
- en: The first `0.0.0.0/0` address is a meta IP address of the source address. This
    address indicates that the connection can originate from any IP address.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个 `0.0.0.0/0` 地址是源地址的元 IP 地址。该地址表示连接可以来自任何 IP 地址。
- en: The second `0.0.0.0/0` address is a meta IP address of the destination address
    on the Docker host. This address indicates that the connection can be made to
    any valid IP address in the Docker host.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个 `0.0.0.0/0` 地址是 Docker 主机上目标地址的元 IP 地址。该地址表示可以连接到 Docker 主机中的任何有效 IP 地址。
- en: Finally, `dpt:80 to:172.17.0.14:80` is the forwarding instruction used to forward
    any TCP activity on port `80` of the Docker host to be forwarded to the `172.17.0.17` IP
    address, the IP address of our container and port `80`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`dpt:80 to:172.17.0.14:80` 是转发指令，用于将 Docker 主机上的 `80` 端口的任何 TCP 活动转发到 `172.17.0.17`
    IP 地址，这是我们容器的 IP 地址，并且是端口 `80`。
- en: Therefore, any TCP packet that the Docker host receives on port `80` will be
    forwarded to port `80` of the container.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker 主机收到的任何 TCP 数据包都会转发到容器的 `80` 端口。
- en: Retrieving the container port
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索容器端口
- en: 'The Docker Engine provides at least three different options to retrieve the
    container''s port binding details. Here, let''s first explore the options, and
    then, move on to dissect the retrieved information. The options are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎提供了至少三种不同的选项来检索容器的端口绑定信息。在这里，我们先探索这些选项，然后继续解析检索到的信息。选项如下：
- en: 'The `docker ps` subcommand always displays the port binding details of a container,
    as shown here:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker ps` 子命令总是显示容器的端口绑定信息，如下所示：'
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `docker inspect` subcommand is another alternative; however, you have to
    skim through quite a lot of details. Run the following command:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker inspect` 子命令是另一种选择；但是，你需要浏览相当多的详细信息。运行以下命令：'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `docker inspect` subcommand displays the port binding related information
    in three JSON objects, as shown here:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker inspect` 子命令显示与端口绑定相关的信息，分为三个 JSON 对象，如下所示：'
- en: 'The `ExposedPorts` object enumerates all ports that are exposed through the
    `EXPOSE` instruction in `Dockerfile`, as well as the container ports that are
    mapped using the `-p` option in the `docker run` subcommand. Since we didn''t
    add the `EXPOSE` instruction in our `Dockerfile`, what we have is just the container
    port that was mapped using `-p 80:80` as an argument to the `docker run` subcommand:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExposedPorts` 对象枚举了通过 `Dockerfile` 中的 `EXPOSE` 指令暴露的所有端口，以及使用 `docker run`
    子命令中的 `-p` 选项映射的容器端口。由于我们没有在 `Dockerfile` 中添加 `EXPOSE` 指令，因此我们只有通过 `-p 80:80`
    参数传递给 `docker run` 子命令映射的容器端口：'
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `PortBindings` object is part of the `HostConfig` object, and this object
    lists out all the port binding done through the `-p` option in the `docker run`
    subcommand. This object will never list the ports exposed through the `EXPOSE`
    instruction in the `Dockerfile`:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PortBindings` 对象是 `HostConfig` 对象的一部分，该对象列出了通过 `docker run` 子命令中的 `-p` 选项进行的所有端口绑定。此对象永远不会列出通过
    `Dockerfile` 中的 `EXPOSE` 指令暴露的端口：'
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Ports` object of the `NetworkSettings` object has the same level of details,
    as the preceding `PortBindings` object. However, this object encompasses all ports
    that are exposed through the `EXPOSE` instruction in `Dockerfile`, as well as
    the container ports that are mapped using the `-p` option in the `docker run`
    subcommand:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkSettings` 对象中的 `Ports` 对象具有与前述 `PortBindings` 对象相同的详细级别。然而，该对象包含了通过
    `Dockerfile` 中的 `EXPOSE` 指令暴露的所有端口，以及使用 `docker run` 子命令中的 `-p` 选项映射的容器端口：'
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, the specific port field can be filtered using the `--format` option
    of the `docker inspect` subcommand.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，特定的端口字段可以使用 `docker inspect` 子命令的 `--format` 选项进行过滤。
- en: 'The `docker port` subcommand enables you to retrieve the port binding on the
    Docker host by specifying the container''s port number:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker port` 子命令使你能够通过指定容器的端口号来获取 Docker 主机上的端口绑定信息：'
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Evidently, in all the preceding output excerpts, the information that stands
    out is the `0.0.0.0` IP address and the `80` port number. The `0.0.0.0` IP address
    is a meta address, which represents all the IP addresses configured on the Docker
    host. In effect, the `80` container's port is bound to all the valid IP addresses
    on the Docker host. Therefore, the HTTP service is accessible through any of the
    valid IP addresses configured on the Docker host.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在所有前面的输出摘录中，突出显示的信息是`0.0.0.0` IP地址和`80`端口号。`0.0.0.0` IP地址是一个元地址，代表了所有在 Docker
    主机上配置的 IP 地址。实际上，`80`容器端口绑定到了 Docker 主机上所有有效的 IP 地址。因此，HTTP 服务可以通过 Docker 主机上任何有效的
    IP 地址进行访问。
- en: Binding a container to a specific IP address
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将容器绑定到特定 IP 地址
- en: 'Until now, with the method that you learned, the containers always get bound
    to all the IP addresses configured on the Docker host. However, you may want to
    offer different services on different IP addresses. In other words, a specific
    IP address and port would be configured to offer a particular service. We can
    achieve this in Docker using the `-p <ip>:<hostPort>:<containerPort>` option of
    the `docker run` subcommand, as shown in the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用你学到的方法，容器总是绑定到 Docker 主机上所有配置的 IP 地址。然而，你可能希望在不同的 IP 地址上提供不同的服务。换句话说，某个特定的
    IP 地址和端口将被配置来提供特定的服务。我们可以通过 Docker 的 `docker run` 子命令的 `-p <ip>:<hostPort>:<containerPort>`
    选项来实现这一点，正如以下示例所示：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the IP address must be a valid IP address on the Docker host. If the
    specified IP address is not a valid IP address on the Docker host, the container
    launch will fail with an error message, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，IP 地址必须是 Docker 主机上的有效 IP 地址。如果指定的 IP 地址不是 Docker 主机上的有效 IP 地址，容器启动将失败，并出现如下错误信息：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s quickly review the port mapping as well the NAT entry for the preceding
    example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速回顾一下前面示例中的端口映射和 NAT 条目：
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本是 `docker ps` 子命令输出的摘录，显示了该容器的详细信息：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本是 `iptables -n nat -L -n` 命令输出的摘录，显示了为该容器创建的 `DNAT` 条目：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, you will realize how elegantly the Docker Engine has configured
    the service offered by the container on the `198.51.100.73` IP address and `80` port
    of the Docker host.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了 `docker run` 子命令的输出和 `iptables` 的 `DNAT` 条目后，你会发现 Docker 引擎如何优雅地配置了容器提供的服务，绑定到了
    Docker 主机上 `198.51.100.73` IP 地址和 `80` 端口。
- en: Autogenerating the Docker host port
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动生成 Docker 主机端口
- en: The Docker containers are innately lightweight and due to their lightweight
    nature, you can run multiple containers with the same or different service on
    a single Docker host. Particularly, autoscaling of the same service across several
    containers based on the demand is the need of the IT infrastructure today. Here,
    in this section, you will be informed about the challenge in spinning up multiple
    containers with the same service and also the Docker's way of addressing this
    challenge.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器天生轻量级，由于其轻量化的特点，你可以在单一 Docker 主机上运行多个容器，提供相同或不同的服务。特别是，根据需求，多个容器间的同一服务自动扩展是现代
    IT 基础设施的需求。在本节中，你将了解启动多个相同服务容器的挑战，以及 Docker 如何应对这一挑战。
- en: 'Earlier in this chapter, we launched a container using Apache2 HTTP server
    by binding it to port `80` of the Docker host. Now, if we attempt to launch one
    more container with the same port `80` binding, the container would fail to start
    with an error message, as you can see in the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们通过将容器绑定到 Docker 主机的 `80` 端口来启动了一个使用 Apache2 HTTP 服务器的容器。现在，如果我们尝试启动一个绑定到相同
    `80` 端口的容器，该容器将无法启动，并且会出现错误信息，正如以下示例所示：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Obviously, in the preceding example, the container failed to start because the
    previous container is already mapped to `0.0.0.0` (all the IP addresses of the
    Docker host) and port `80`. In the TCP/IP communication model, the combination
    of the IP address, port, and the transport protocols (TCP, UDP, and so on) has
    to be unique.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在前面的示例中，容器启动失败是因为之前的容器已经将 `0.0.0.0`（Docker 主机的所有 IP 地址）和 `80` 端口进行了映射。在 TCP/IP
    通信模型中，IP 地址、端口和传输协议（如 TCP、UDP 等）的组合必须是唯一的。
- en: 'We could have overcome this issue by manually choosing the Docker host port
    number (for instance, `-p 81:80` or `-p 8081:80`). Though this is an excellent
    solution, it does not scale well for autoscaling scenarios. Instead, if we give
    the control to Docker, it would autogenerate the port number on the Docker host.
    This port number generation is achieved by underspecifying the Docker host port
    number, using the `-p <containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过手动选择 Docker 主机的端口号来解决这个问题（例如，`-p 81:80` 或 `-p 8081:80`）。虽然这是一个很好的解决方案，但对于自动扩展场景来说，它的扩展性较差。相反，如果将控制权交给
    Docker，它将自动生成 Docker 主机上的端口号。通过在 `docker run` 子命令中使用 `-p <containerPort>` 选项来实现端口号的自动生成，如下例所示：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Having successfully started the new container with the autogenerated port,
    let''s review the port mapping as well the NAT entry for the preceding example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动具有自动生成端口的新容器后，我们来回顾一下端口映射以及前述示例的 NAT 条目：
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本是 `docker ps` 子命令输出的摘录，显示了此容器的详细信息：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本是 `iptables -n nat -L -n` 命令输出的摘录，显示为此容器创建的 `DNAT` 条目：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, what stands out is the `49158` port number. The `49158` port
    number is niftily autogenerated by the Docker Engine on the Docker host, with
    the help of the underlying operating system. Besides, the `0.0.0.0` meta IP address
    implies that the service offered by the container is accessible from outside,
    through any of the valid IP addresses configured on the Docker host.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了 `docker run` 子命令的输出和 `iptables` 的 `DNAT` 条目后，突出显示的是端口号 `49158`。该端口号是 Docker
    引擎在 Docker 主机上巧妙地自动生成的，借助底层操作系统的帮助。此外，`0.0.0.0` 元IP地址表示容器提供的服务可以通过 Docker 主机上配置的任何有效
    IP 地址从外部访问。
- en: 'You may have a use case where you want to autogenerate the port number. However,
    if you still want to restrict the service to a particular IP address of the Docker
    host, you can use the `-p <IP>::<containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能有一个用例，需要自动生成端口号。然而，如果您仍然希望将服务限制为 Docker 主机的特定 IP 地址，可以使用 `docker run` 子命令中的
    `-p <IP>::<containerPort>` 选项，如下例所示：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding two scenarios, the Docker Engine autogenerated the port number
    on the Docker host and exposed it to the outside world. The general norm of network
    communication is to expose any service through a predefined port number so that
    anybody knows the IP address, and the port number can easily access the offered
    service. Whereas, here the port numbers are autogenerated and as a result, the
    outside world cannot directly reach the offered service. So, the primary purpose
    of this method of container creation is to achieve autoscaling, and the container
    created in this fashion would be interfaced with a proxy or load balance service
    on a predefined port.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述的两种场景中，Docker 引擎自动生成了 Docker 主机上的端口号，并将其暴露给外部世界。网络通信的普遍规范是通过预定义的端口号暴露任何服务，以便任何知道
    IP 地址和端口号的人都可以轻松访问提供的服务。而在这里，端口号是自动生成的，因此外部世界无法直接访问该服务。因此，这种容器创建方法的主要目的是实现自动扩展，并且以这种方式创建的容器将与预定义端口上的代理或负载均衡服务进行交互。
- en: Port binding using EXPOSE and -P option
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 EXPOSE 和 -P 选项进行端口绑定
- en: So far, we have discussed the four distinct methods to publish a service running
    inside a container to the outside world. In all these four methods, the port binding
    decision is taken during the container launch, and the image has no information
    about the ports on which the service is being offered. It has worked well so far
    because the image is being built by us, and we are pretty much aware of the port
    in which the service is being offered.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了四种将容器内部运行的服务发布到外部世界的不同方法。在这四种方法中，端口绑定的决定是在容器启动时做出的，并且镜像对服务提供的端口没有任何信息。到目前为止，这种方法运作良好，因为镜像是我们构建的，我们非常清楚服务提供的端口号。
- en: However, in the case of third-party images, the port usage inside a container
    has to be published unambiguously. Besides, if we build images for third-party
    consumption or even for our own use, it is a good practice to explicitly state
    the ports in which the container offers its service. Perhaps, the image builders
    could ship a README document along with the image. However, it is even better
    to embed the port details in the image itself so that you can easily find the
    port details from the image both manually as well as through automated scripts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第三方镜像的情况下，容器内的端口使用必须明确发布。此外，如果我们为第三方使用或甚至是为了我们自己的使用构建镜像，明确声明容器提供服务的端口是一个良好的实践。也许，镜像构建者可以随镜像附带一个README文档。然而，将端口信息嵌入镜像本身会更好，这样你可以更轻松地通过手动方式或自动化脚本从镜像中找到端口详情。
- en: 'The Docker technology allows us to embed the port information using the `EXPOSE`
    instruction in the `Dockerfile`, which we introduced in [Chapter 3](../Text/Ch03.xhtml),
    *Building Images*. Here, let''s edit the `Dockerfile` we used to build the `apache2`
    HTTP server image earlier in this chapter, and add an `EXPOSE` instruction, as
    shown in the following code. The default port for the HTTP service is port `80`,
    hence port `80` is exposed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Docker技术允许我们使用`EXPOSE`指令在`Dockerfile`中嵌入端口信息，正如我们在[第3章](../Text/Ch03.xhtml)
    *构建镜像*中介绍的那样。在这里，让我们编辑在本章之前用于构建`apache2` HTTP服务器镜像的`Dockerfile`，并添加`EXPOSE`指令，如以下代码所示。HTTP服务的默认端口是端口`80`，因此端口`80`被暴露：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have added the `EXPOSE` instruction to our `Dockerfile`, let''s
    move to the next step of building the image using the `docker build` command.
    Here, let''s reuse the `apache2` image name, as shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`Dockerfile`中添加了`EXPOSE`指令，让我们进入下一步，使用`docker build`命令来构建镜像。这里我们将重新使用之前的`apache2`镜像名称，如下所示：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Having successfully built the image, let''s inspect the image to verify the
    effects of the `EXPOSE` instruction to the image. As we learned earlier, we can
    resort to the `docker inspect` subcommand, as shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 成功构建镜像后，让我们检查一下该镜像，以验证`EXPOSE`指令对镜像的影响。如我们之前所学，我们可以使用`docker inspect`子命令，如下所示：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On a close review of the output generated by the preceding command, you will
    realize that Docker stores the exposed port information in the `ExposedPorts`
    field of the `Config` object. The following is an excerpt to show how the exposed
    port information is being displayed:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细查看前面命令生成的输出，你会发现 Docker 将暴露的端口信息存储在`Config`对象的`ExposedPorts`字段中。以下是一个摘录，展示了暴露的端口信息如何显示：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, you can apply the `--format` option to the `docker inspect`
    subcommand in order to narrow down the output to a very specific information.
    In this case, the `ExposedPorts` field of the `Config` object is shown in the
    following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用`--format`选项应用于`docker inspect`子命令，以便将输出限制为非常具体的信息。在这种情况下，`Config`对象的`ExposedPorts`字段在以下示例中展示：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To resume our discussion on the `EXPOSE` instruction, we can now spin up containers
    using an `apache2` image, we just crafted. Yet, the `EXPOSE` instruction by itself
    cannot create a port binding on the Docker host. In order to create a port binding
    for the port declared using the `EXPOSE` instruction, the Docker Engine provides
    a `-P` option in the `docker run` subcommand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续讨论`EXPOSE`指令，我们现在可以使用我们刚刚制作的`apache2`镜像启动容器。然而，`EXPOSE`指令本身并不能在 Docker 主机上创建端口绑定。为了为通过`EXPOSE`指令声明的端口创建端口绑定，Docker引擎在`docker
    run`子命令中提供了`-P`选项。
- en: 'In the following example, a container is launched from the `apache2` image,
    which was rebuilt earlier. Here, the `-d` option is used to launch the container
    in the detached mode, and the `-P` option is used to create the port binding on
    the Docker host for all the ports declared, using the `EXPOSE` instruction in
    the `Dockerfile`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，容器是从之前重新构建的`apache2`镜像启动的。这里使用`-d`选项将容器以分离模式启动，`-P`选项用于在 Docker 主机上为所有通过`Dockerfile`中的`EXPOSE`指令声明的端口创建端口绑定：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now that we have started the new container with the image that was created
    using the `EXPOSE` instruction, like the previous containers, let''s review the
    port mapping as well the NAT entry for the preceding example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经使用通过`EXPOSE`指令创建的镜像启动了新的容器，就像之前的容器一样，让我们查看端口映射以及前面示例中的NAT条目：
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本摘自`docker ps`子命令的输出，展示了该容器的详细信息：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following text is an excerpt from the output of the `iptables -t nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本摘自`iptables -t nat -L -n`命令的输出，展示了为该容器创建的`DNAT`条目：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `-P` option of the `docker run` subcommand does not take any additional
    arguments, such as an IP address or a port number; consequently, fine-tuning of
    the port binding is not possible, such as the `-p` option of the `docker run`
    subcommand. You can always resort to the `-p` option of the `docker run` subcommand
    if fine-tuning of port binding is critical to you.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`子命令的`-P`选项不接受任何额外的参数，如IP地址或端口号；因此，无法对端口绑定进行精细调节，类似于`docker run`子命令的`-p`选项。如果端口绑定的精细调节对你至关重要，你始终可以使用`docker
    run`子命令的`-p`选项。'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Containers do not deliver anything substantial in an isolated or solo way. They
    need to be systematically built and provided with a network interface along with
    a port number. These lead to the standardized exposition of containers to the
    outside world, facilitating other hosts or containers to find, bind, and leverage
    their unique capabilities on any network. Thus, the network accessibility is paramount
    for containers to get noticed across and be utilized in innumerable ways. This
    chapter was dedicated to showcase how containers are being designed and deployed
    as a service, and how the aspect of container networking comes in handy in precisely
    and profusely empowering the peculiar world of container services as the days
    unfold. In the forthcoming chapters, we will deal and dwell at length on the various
    capabilities of Docker containers in the software-intensive IT environments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在隔离或独立的方式下无法提供任何实质性功能。它们需要系统地构建，并配备网络接口和端口号。这些因素促成了容器向外界的标准化展示，便于其他主机或容器在任何网络上发现、绑定并利用它们的独特功能。因此，网络可访问性对容器而言至关重要，使其能够被广泛察觉并以多种方式加以利用。本章旨在展示容器如何作为一种服务进行设计和部署，以及容器网络功能如何在日新月异的容器服务领域中，发挥精准而丰富的作用。在接下来的章节中，我们将详细探讨Docker容器在软件密集型IT环境中的各种能力。
