- en: Building Docker Images
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Building images is the first step in deploying your own container-based applications.
    It is a simple process and anyone can build images from scratch, but it is not
    easy to create images with sufficient quality and security for production. In
    this chapter, we will learn all the basics and tips and tricks for creating good,
    production-ready images. We will review the requirements for saving and distributing
    our work, as well as how to improve these processes to get better performance
    when the number of images and releases is substantial in enterprise environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像是部署你自己的基于容器的应用程序的第一步。这个过程很简单，任何人都可以从头开始构建镜像，但要创建足够质量和安全的生产级镜像并不容易。在本章中，我们将学习创建优秀、适用于生产的镜像的所有基础知识和技巧。我们将回顾保存和分发我们的工作所需的要求，以及如何改进这些过程，以在企业环境中当镜像和发布的数量较大时获得更好的性能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building Docker images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Understanding copy-on-write filesystems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解写时复制（Copy-on-write）文件系统
- en: Building images with a Dockerfile reference
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 参考构建镜像
- en: Image tagging and meta-information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像标签和元信息
- en: Docker registries and repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 注册表与仓库
- en: Securing images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像安全
- en: Managing images and other related objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理镜像及其他相关对象
- en: Multistage building and image caches
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多阶段构建与镜像缓存
- en: Templating images
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板化镜像
- en: Image releases and updates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像发布和更新
- en: Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will learn about Docker image building concepts. We'll provide
    some labs at the end of this chapter that will help you understand and learn about
    the concepts explained here. These labs can be run on your laptop or PC using
    the provided Vagrant standalone environment or any already deployed Docker host
    of your own. You can find additional information in this book's GitHub repository
    at [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Docker 镜像构建的概念。在本章末尾，我们将提供一些实验，帮助你理解并学习本章所解释的概念。这些实验可以在你的笔记本电脑或 PC
    上运行，使用提供的 Vagrant 独立环境，或任何你自己部署的 Docker 主机。你可以在本书的 GitHub 仓库中找到更多信息，链接是 [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：
- en: '"[https://bit.ly/31v3AJq](https://bit.ly/31v3AJq)"'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/31v3AJq](https://bit.ly/31v3AJq)"'
- en: Building Docker images
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Developers create their own images, along with their own code and runtime components,
    to run their application components. However, the building process usually starts
    with a previous image. All image build processes will start with a `FROM` statement.
    This indicates that the previous image (compound on layers) will be used to add
    new components, binaries, configurations, or actions for building our new image.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员创建自己的镜像，以及自己的代码和运行时组件，以运行他们的应用程序组件。然而，构建过程通常从一个之前的镜像开始。所有的镜像构建过程都会以`FROM`语句开始。这表示将使用之前的镜像（在多层基础上叠加）来添加新的组件、二进制文件、配置或操作，以构建我们的新镜像。
- en: You may be asking yourself, *who is responsible for image creation?* Developers
    will probably create application images if they are not automatically generated
    using Continuous Integration platforms, but there will be teams who create images
    to be used by other users as base images. For example, database administrators
    would create database base images because they know what components should be
    included and how to ensure their security. Developers will take those base images
    for their components. In a big organization, there will be many teams creating
    images, or at least defining what components must be included, which users to
    use, ports to expose, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，*谁负责镜像的创建？* 如果没有通过持续集成平台自动生成，开发人员可能会创建应用程序镜像，但也会有团队创建供其他用户使用的基础镜像。例如，数据库管理员会创建数据库基础镜像，因为他们知道应该包含哪些组件以及如何确保其安全。开发人员会根据这些基础镜像来创建他们的组件。在大公司中，可能有许多团队在创建镜像，或者至少定义必须包含哪些组件、哪些用户使用、暴露哪些端口等等。
- en: There is something else, however. Many applications these days come prepared
    for container environments, and software manufacturers will provide you with images
    to deploy their software. Enterprises will look for homogenization and architecture,
    while DevOps teams will provide their colleagues with standard base images. The
    container's infrastructure runtime would be common to all of them and monitoring
    applications, middleware, databases, and so on would be running on this environment
    alongside developed business application components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些其他的情况。如今，许多应用程序都已为容器环境做好了准备，软件制造商会提供镜像来部署他们的软件。企业将寻求统一和架构，而 DevOps 团队将为他们的同事提供标准的基础镜像。容器的基础设施运行时将对所有这些环境通用，监控应用程序、中间件、数据库等将与开发的业务应用组件一起在这个环境中运行。
- en: 'There are three methods for creating images:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建镜像有三种方法：
- en: Using a file with all the instructions to create this image (Dockerfile)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含所有指令的文件来创建此镜像（Dockerfile）
- en: Interacting with files in different container layers, executing one container,
    modifying its content, and then storing the changes made (commit)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与不同容器层中的文件交互，执行一个容器，修改其内容，然后存储所做的更改（提交）
- en: Using an empty layer and adding components by hand, file by file, also known
    as creating an image from scratch
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个空层并手动逐个文件地添加组件，这也被称为从零开始创建镜像
- en: Now, we will review each one, along with their pros and cons and use cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回顾每个构件，并讨论它们的优缺点和使用场景。
- en: Creating images with Dockerfiles
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 创建镜像
- en: A Dockerfile is a script file that describes all the steps required to create
    a new image. Each step will be interpreted and, in many cases, create a container
    to execute declared changes against previous layers. On this Dockerfile, we will
    have a guide to creating this image. This guide creates a reproducible process.
    We will ensure that every time we use this script, we will get the same results.
    Of course, this can depend on some variables, but with some key mechanisms, we
    can ensure the same results. In this chapter, we will cover the main primitives
    available for creating image Dockerfiles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个脚本文件，描述了创建新镜像所需的所有步骤。每个步骤都会被解释，并且在许多情况下，会创建一个容器来执行声明的更改，应用于之前的层。在这个
    Dockerfile 中，我们将有一个创建镜像的指南。这个指南创建了一个可重复的过程。我们将确保每次使用这个脚本时，我们都会得到相同的结果。当然，这可能依赖于一些变量，但通过一些关键机制，我们可以确保相同的结果。在本章中，我们将介绍创建
    Docker 镜像的主要基本构件。
- en: 'A Dockerfile looks similar to the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Dockerfile 看起来类似于以下内容：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this simple example, and as we mentioned previously, we have a `FROM` sentence
    at the beginning:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，正如我们之前提到的，我们在开始时有一个 `FROM` 语句：
- en: First, we used Ubuntu 18.04 as the base image. To use this image, we need it
    in our building environment. Therefore, if the image is not present in our environment,
    Docker daemon will download its layers for us to make it available locally for
    the next steps. This will happen automatically; Docker daemon will do this for
    us.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 Ubuntu 18.04 作为基础镜像。为了使用这个镜像，我们需要在我们的构建环境中获取它。因此，如果该镜像不在我们的环境中，Docker
    守护进程将下载它的层，并将其提供给我们，以便在后续步骤中使用。这个过程是自动发生的；Docker 守护进程会为我们完成这项工作。
- en: Using the downloaded Ubuntu 18.04 layers, Docker will automatically run a container
    using this image and execute the declared commands since we used the `RUN` primitive.
    In this simple case, the shell (because it is the default command on the Ubuntu
    18.04 image) will execute `apt-get update` to update the container package cache.
    If everything goes well with this command, it will execute the installation of
    `package1` and `package2` using `apt-get install`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下载的 Ubuntu 18.04 层，Docker 将自动运行一个容器，使用这个镜像并执行声明的命令，因为我们使用了 `RUN` 基本构件。在这个简单的例子中，Shell（因为它是
    Ubuntu 18.04 镜像的默认命令）将执行 `apt-get update` 来更新容器的包缓存。如果此命令执行成功，它将使用 `apt-get install`
    安装 `package1` 和 `package2`。
- en: After software installation, Docker will execute a `Docker container commit`
    command internally to persist these changes on a new layer in order to use them
    as a base for the next step. The third line will copy our current directory content
    into the application code directory on a new running container.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件安装完成后，Docker 将内部执行 `Docker container commit` 命令，将这些更改持久化到一个新的层中，以便将其用作下一步的基础。第三行将把我们当前目录的内容复制到新运行容器中的应用代码目录。
- en: The next line will execute `make` (this is just an example; we haven't said
    anything about the programming language used for my application and so on). This
    line will run this action in a new container. As a result, a new image will be
    created automatically when the action has finished.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行将执行`make`（这只是一个示例；我们没有说明我的应用程序使用的编程语言等）。这行命令将在新容器中运行该操作。结果，当操作完成时，一个新的镜像将自动创建。
- en: We learned that a container is always created using an image as a template.
    The last line of code defines the command line to be run each time we create a
    container using this image.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们了解到，容器总是使用镜像作为模板来创建的。代码的最后一行定义了每次我们使用此镜像创建容器时要运行的命令行。
- en: In summary, Dockerfiles provide a guide of all the steps required to create
    an image so that we can run our application. It is a reproducible process and
    therefore, every time we create a new image using this file, we should obtain
    the same results (for example, in this case, we have updated the package cache
    and installed the required software; perhaps these packages changed since last
    time we did a build, but if not, we will have the same image).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Dockerfile提供了创建镜像所需的所有步骤指南，以便我们能够运行应用程序。这是一个可复现的过程，因此，每次使用该文件创建新镜像时，我们应该获得相同的结果（例如，在这种情况下，我们已更新了包缓存并安装了所需的软件；也许这些包自上次构建以来发生了变化，但如果没有，我们将拥有相同的镜像）。
- en: The built image has a unique identification in the `algorithm:hexadecimal_code_using_algorithm`
    format. This means that every time we build this image, we will get the same image
    identification unless there is some kind of change that's made during the process.
    This image ID, or digest ID, is calculated using an algorithm in relation to a
    layer's content, so we will get a new one with any layer change. This identification
    allows Docker Engine to verify whether the image described is the correct one
    to use. A Docker image contains information about all of its layers and informs
    Docker Engine of the layers' content that is required for the new container.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的镜像具有一个独特的标识符，格式为`algorithm:hexadecimal_code_using_algorithm`。这意味着每次我们构建该镜像时，除非过程中进行了一些更改，否则我们将获得相同的镜像标识符。该镜像ID或摘要ID是通过与层的内容相关的算法计算得出的，因此任何层的更改都会获得新的ID。这个标识符允许Docker引擎验证描述的镜像是否是正确的使用镜像。Docker镜像包含关于所有层的信息，并通知Docker引擎所需的新容器的层内容。
- en: 'When we inspect the image information, we will get all the necessary layers
    to create this image, `RootFS`. Here is an example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查镜像信息时，我们将获得创建该镜像所需的所有必要层，`RootFS`。以下是一个示例：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This output shows different layers being created using defined code in the Dockerfile.
    These layers will be interchangeable between images wherever possible. If we create
    an image using Dockerfile's first two lines, the layers that are created by those
    commands will be shared with the previous image. This ensures minimum disk space
    usage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出显示了使用Dockerfile中定义的代码创建的不同层。这些层将在可能的情况下在镜像之间互换。如果我们使用Dockerfile的前两行创建镜像，那么那些命令创建的层将与之前的镜像共享。这确保了最小的磁盘空间使用。
- en: Creating images interactively
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式创建镜像
- en: 'Images can be created interactively by running a container and making changes
    on the fly to `rootfs`. This is very useful when an application''s installation
    cannot be automated but lacks reproducibility. Let''s look at this process in
    action using an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以通过运行容器并实时修改`rootfs`来交互式创建。当应用程序的安装无法自动化且缺乏可复现性时，这非常有用。让我们通过一个示例来看看这个过程的实际操作：
- en: 'Start an interactive container:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个交互式容器：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once started, we will receive a command prompt because we launched the container
    by allocating a pseudo-terminal and did so interactively. We need to update the
    package''s database and then install, for example, the `postfix` package, which
    needs some interactive configurations (please note that some of the output will
    be truncated and omitted):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动后，我们将收到命令提示符，因为我们通过分配伪终端并以交互模式启动容器。我们需要更新包的数据库，然后安装例如`postfix`包，它需要一些交互式配置（请注意，部分输出将被截断并省略）：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The software was installed, and you were asked to confirm the installation
    of the `postfix` package and some default configuration. Now, we can exit the
    current container:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件已安装，并且您被要求确认安装`postfix`包以及一些默认配置。现在，我们可以退出当前容器：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What we have done here is exit the current main process (which is a shell in
    a Debian image) and, as a result, returned to our host. We will look for the last
    container that was executed on our host and then save the container layer as a
    new image layer (which means that we have created a new image with a name or identification
    if we omit it):'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里所做的是退出当前的主进程（在 Debian 镜像中是一个 shell），结果返回到我们的主机。我们将查找在主机上执行的最后一个容器，然后将容器层保存为一个新的镜像层（这意味着我们创建了一个新的镜像，如果我们省略名称或标识的话）：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we review the newly created image on our host system (the IDs may
    change in your environment):'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在主机系统上回顾新创建的镜像（在您的环境中，ID 可能会发生变化）：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using this method, we have created a new image interactively using a previously
    running Debian Docker container. As we can see, the new image has a different
    digest. If we inspect its meta-information, we can identify its preceding image
    layers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们通过与先前运行的 Debian Docker 容器进行交互，创建了一个新的镜像。如我们所见，新的镜像具有不同的摘要。如果我们检查其元信息，我们可以识别其前一个镜像层：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One key concept of images that are created using a Docker container commit is
    that they are not reproducible; you really don't know how they were created, so
    the necessary steps should be documented in relation to updates and management.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 容器提交创建的镜像有一个关键概念，那就是它们是不可重复的；你实际上不知道它们是如何创建的，因此必要的步骤应当记录下来，以便于更新和管理。
- en: 'There is an image action that provides a detailed review of the steps to create
    an image. `docker image history` will provide a historic view of the steps that
    were taken to create that image. However, it will not work on images that are
    created using committed containers. We will just have a line with a bash, for
    example, indicating that all the actions that were taken were made on an active
    container and therefore, no additional information can be extracted. For example,
    using the previously created image, executing `docker image history debian-with-postfix`
    will provide the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个镜像操作，它提供了创建镜像的详细步骤回顾。`docker image history` 将提供一个历史视图，展示创建该镜像时所采取的步骤。然而，它无法作用于使用提交的容器创建的镜像。我们只会看到一行包含
    bash 的内容，例如，指示所有操作都发生在一个活动容器上，因此无法提取额外的信息。例如，使用之前创建的镜像，执行 `docker image history
    debian-with-postfix` 将提供以下输出：
- en: '![](img/e4207a0e-d19a-4867-98c6-eb8f8080ffdc.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4207a0e-d19a-4867-98c6-eb8f8080ffdc.jpg)'
- en: Creating images from scratch
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从零开始创建镜像
- en: 'Creating images from scratch is the most effective method. In this case, we
    will use a Dockerfile, as described in the first method, but the initial base
    image will be an empty reserved one known literally as `scratch`. A simple example
    definition will look as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始创建镜像是最有效的方法。在这种情况下，我们将使用一个 Dockerfile，如第一种方法所述，但初始的基础镜像将是一个空的保留镜像，字面上称为
    `scratch`。一个简单的示例定义如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The main difference in the Dockerfile definition is the `FROM` line because
    we use a defined empty image named `scratch`. `scratch` is not a real image; it
    only contains the root filesystem structure and its meta-information. Images built
    using this method must contain all binaries, libraries, and files required by
    our process (as should always be the case). However, we are not using a predefined
    image and its content; it will be empty and we have to add each required file.
    This procedure is not easy and requires much more practice, but images are way
    better because they will only contain the pieces required for our application.
    We will see a complete lab at the end of this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 定义中的主要区别是 `FROM` 行，因为我们使用了一个名为 `scratch` 的空白镜像。`scratch` 并不是真正的镜像；它仅包含根文件系统结构及其元信息。使用这种方法构建的镜像必须包含我们进程所需的所有二进制文件、库文件和其他文件（这应当是始终如此）。然而，我们并没有使用预定义的镜像及其内容；它将是空的，我们必须添加每个所需的文件。这个过程并不容易，且需要更多的实践，但镜像会更加精简，因为它们只包含我们应用所需的部分。我们将在本章末尾看到一个完整的实验。
- en: Understanding copy-on-write filesystems
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解写时复制文件系统
- en: In the previous chapter, we learned what a container is. The isolated process
    or processes running inside a container will have their own root filesystem among
    other namespaces. The container adds a thin layer on top of image layers and every
    change made during the execution of its processes will be stored only on this
    layer. In order to manage these changes, the Docker storage driver will use stackable
    layers and **copy-on-write** (sometimes referenced as **CoW**).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了什么是容器。容器内运行的隔离进程将拥有自己的根文件系统以及其他命名空间。容器在镜像层之上添加了一层薄层，每个进程执行期间所做的更改将仅存储在这一层。为了管理这些更改，Docker
    存储驱动程序将使用可堆叠的层和**写时复制**（有时简称为 **CoW**）。
- en: When a process inside a container needs to modify a file, the Docker daemon
    storage filesystem mechanism will make a copy of that file from the underlying
    layers to the top one. These are only available for container usage. The same
    happens when a new file is created; it will only be written to the top container
    storage layer. All the other processes running on other containers will manage
    their own version of the file. In fact, this will be the original file from the
    other layers if no changes were made. Each container uses its own top layer to
    write file changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器内部的进程需要修改文件时，Docker 守护进程的存储文件系统机制会将该文件从底层复制到最上层。这些文件仅对容器可用。当创建新文件时也会发生相同的情况；新文件将只写入容器的最上层存储。其他容器中运行的进程会管理它们各自版本的文件。如果没有做任何更改，这些文件实际上就是来自其他层的原始文件。每个容器使用自己的最上层来写入文件更改。
- en: We have seen how the image building process works using containers for each
    layer's creation. We learned that we can commit a container's layers to obtain
    a new image. The creation of images using Dockerfiles will run intermediate containers
    using previous images that will be committed in order to obtain an intermediate
    image with all file changes between their layers. This process will run sequentially,
    following the order defined in the Dockerfile's code. As a result, an image will
    be created that's a compendium of thin layers with the changes or differences
    between them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用容器构建镜像过程的工作原理，每一层的创建过程。我们了解到，我们可以提交容器的层来获得一个新的镜像。使用 Dockerfile 创建镜像时，会运行使用先前镜像的中间容器，并将其提交以获得一个包含其各层之间所有文件更改的中间镜像。这个过程将按顺序执行，遵循
    Dockerfile 代码中定义的顺序。最终，创建的镜像将是一个包含层间差异的薄层合集。
- en: 'Docker copy-on-write reduces the space needed to run containers and the time
    required to launch them because it is only required for the creation of this writable
    layer for each container:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的写时复制减少了运行容器所需的空间和启动所需的时间，因为它只需要为每个容器创建这个可写层：
- en: '![](img/bd2f1683-477f-4674-9674-c80b5074e3a2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd2f1683-477f-4674-9674-c80b5074e3a2.jpg)'
- en: This image represents an NGINX process running as a container. The base image
    was created from a fresh `alpine` 3.5 image. We added some packages, performed
    some configurations, and copied our own `nginx.conf` file. Finally, we added some
    meta-information to be able to create containers using this image, declared which
    port we will use to expose NGINX, and declared the command line that will be used
    to run a container by default, starting NGINX in the foreground.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像表示一个作为容器运行的 NGINX 进程。基础镜像是从一个全新的 `alpine` 3.5 镜像创建的。我们添加了一些软件包，进行了配置，并复制了我们自己的
    `nginx.conf` 文件。最后，我们添加了一些元信息，以便使用此镜像创建容器，声明了将用于暴露 NGINX 的端口，并声明了默认用于运行容器的命令行，从而在前台启动
    NGINX。
- en: 'There are three strategies for CoW logic:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CoW 逻辑有三种策略：
- en: On AUFS and overlay-based drivers, Docker uses union filesystems
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于 AUFS 和 overlay 的驱动程序中，Docker 使用联合文件系统（union filesystem）。
- en: On BTFS and ZFS drivers, Docker uses filesystem snapshots
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 BTFS 和 ZFS 驱动程序中，Docker 使用文件系统快照。
- en: On device-mapper (available on a Red Hat-like OS), Docker uses an LVM snapshot
    for blocks
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 device-mapper（适用于类似 Red Hat 的操作系统）中，Docker 使用 LVM 快照来管理块。
- en: Nowadays, almost all Docker host OSes use overlay-based drivers by default whenever
    possible. There are some old implementations that use block devices instead, but
    today, these are deprecated. Overhead added by the CoW process depends on the
    driver used.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎所有 Docker 主机操作系统都默认使用基于 overlay 的驱动程序（尽可能使用）。过去有些实现使用块设备，但这些现在已经被弃用。CoW
    过程增加的开销取决于所使用的驱动程序。
- en: We can review how much space a container is using. Docker provides the `docker
    container ls -s/--size` option for this. It will return the current thin layer's
    used space and the read-only data used from the original image, defined as **virtual**.
    To understand how much space containers are really consuming, we will need to
    combine both sizes for each container to obtain the total amount of data used
    by all containers in our environment. This will not include volumes or a container's
    log files, among other small pieces that contribute to real used space.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看一个容器使用了多少空间。Docker 提供了 `docker container ls -s/--size` 选项来实现这一点。它将返回当前薄层的使用空间以及从原始镜像中使用的只读数据，定义为**虚拟**。为了了解容器实际消耗了多少空间，我们需要将每个容器的两种大小结合起来，得到所有容器在我们环境中使用的总数据量。这不包括卷或容器的日志文件等小部分，这些都会贡献到实际的使用空间中。
- en: CoW was prepared for maximum disk space efficiency, but it depends on how many
    layers are shared in your local images and how many containers will run using
    the same images. As you can imagine, containers that write a lot of data to their
    writable layer consume much more space than other containers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CoW 是为最大化磁盘空间效率而设计的，但它取决于本地镜像中有多少层是共享的，以及有多少容器会使用相同的镜像。如你所料，向其可写层写入大量数据的容器会消耗比其他容器更多的空间。
- en: CoW is a very fast process, but for heavy-write operations on containers, it
    is not enough. If we have a process that requires the creation of many small files,
    a very deep directory structure, or just very big files, we need to bypass CoW
    operations because performance will be impacted. This will lead us to using volumes
    to mitigate such situations. We will learn about volumes, which are the objects
    used for container persistent storage, in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CoW（写时复制）是一个非常快速的过程，但对于容器上的重写操作，它并不够。如果我们有一个需要创建许多小文件、非常深的目录结构，或者只是非常大的文件的进程，我们需要绕过
    CoW 操作，因为性能会受到影响。这将导致我们使用卷（volumes）来缓解这种情况。我们将在[第 4 章](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml)《容器持久性与网络》中学习卷，它们是用于容器持久存储的对象。
- en: Building images with a Dockerfile reference
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 构建镜像参考
- en: As we mentioned previously, building images is easy, but building good images
    is not. This section will guide you through the basics and provide you with tips
    and tricks that you can use to improve the image building process using Dockerfiles.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，构建镜像很容易，但构建优秀的镜像并非如此。本节将带你了解基本知识，并提供一些技巧，帮助你在使用 Dockerfile 时改进镜像构建过程。
- en: Dockerfile quick reference
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile 快速参考
- en: 'We have already learned which methods are available for building images. For
    production, it is recommended to use Dockerfiles because this method provides
    reproducibility and we can use a code versioning methodology. We will introduce
    the main Dockerfile instructions in their standard order of usage:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了构建镜像时可用的方法。对于生产环境，建议使用 Dockerfile，因为这种方法提供了可重现性，并且我们可以使用代码版本控制方法。我们将在此介绍
    Dockerfile 的主要指令，并按照其标准使用顺序进行讲解：
- en: '| **Instruction** | **Description and usage** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述和使用方法** |'
- en: '| `FROM` | This instruction sets the base image and initializes a new build
    (we will review this concept in the *Multistage building and image caches* section,
    later in this chapter). It is the only mandatory instruction that all Dockerfiles
    should start with. We can use any valid image as the base image for building or
    the reserved `scratch` word to start with an empty root filesystem, as we learned
    in the previous section.We can define a name for the build stage initialized using
    `AS name` in the same `FROM` instruction. We will use it in the *Multistage building*
    section at the end of this chapter.The base image can be defined using either
    its image name (repository) and a specific tag (version of that image) or its
    digest; for example, `FROM <image>[:tag] or FROM <image>[@digest]`. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `FROM` | 该指令设置基础镜像并初始化一个新的构建（我们将在本章后面的*多阶段构建和镜像缓存*部分回顾这个概念）。它是所有 Dockerfile
    开头的唯一必选指令。我们可以使用任何有效的镜像作为基础镜像进行构建，或者使用保留的 `scratch` 词从一个空的根文件系统开始，正如我们在上一节中所学。我们可以在同一个
    `FROM` 指令中使用 `AS name` 定义构建阶段的名称。我们将在本章最后的*多阶段构建*部分中使用它。基础镜像可以通过其镜像名称（仓库）和特定标签（镜像版本）或其摘要（digest）来定义，例如，`FROM
    <image>[:tag] 或 FROM <image>[@digest]`。 |'
- en: '| `ARG` | The `ARG` instruction defines a variable that will be set to the
    value provided when building, passing its value as an argument using `--build-arg
    <variable>=<value>`. To avoid problems when building with missing values, we can
    use `ARG` to define a default value for a variable that will be overwritten if
    an argument is passed.`ARG` will take the value every time it is invoked. This
    is very important when creating Dockerfiles.`ARG` can be used, preceding the `FROM`
    instruction, to specify different base images using arguments. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `ARG` | `ARG`指令定义了一个变量，在构建时会将其设置为提供的值，通过`--build-arg <variable>=<value>`将其作为参数传递。为了避免在构建过程中缺少值导致的问题，我们可以使用`ARG`定义一个默认值，该值将在传递参数时被覆盖。每次调用时，`ARG`都会获取该值。这在创建Dockerfile时非常重要。`ARG`可以在`FROM`指令之前使用，通过参数指定不同的基础镜像。
    |'
- en: '| `LABEL` | With `LABEL`, we can add meta-information to the image. This information
    should be in the key-value format and we can include many keys and values in the
    same `LABEL` sentence. Here, you have a number of brief examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| `LABEL` | 使用`LABEL`，我们可以为镜像添加元信息。这些信息应以键值对的格式呈现，并且我们可以在同一个`LABEL`语句中包含多个键值对。下面是一些简短的示例：'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ENV` | With the `ENV` instruction, we can set an environment variable for
    the next step and all subsequent steps thereafter. We can add more than one environment
    variable in the same sentence and values will be overwritten if we specify new
    values during Docker container creation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ENV` | 使用`ENV`指令，我们可以为下一步以及之后的所有步骤设置一个环境变量。我们可以在同一个语句中添加多个环境变量，如果在创建Docker容器时指定了新值，原来的值将被覆盖：'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `WORKDIR` | `WORKDIR` sets the working directory for the next sentences and
    subsequent ones thereafter. We can specify full paths or relative ones:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '| `WORKDIR` | `WORKDIR`设置接下来及之后语句的工作目录。我们可以指定完整路径或相对路径：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `RUN` | `RUN` will probably be one of the most frequently used sentences
    in your Dockerfiles. It will execute all commands in the line in a new layer and
    will commit the results on a new one (as we described in the previous chapter).
    This new layer will be used in the next sentence as a base layer, with the changes
    made by the `RUN` sentence. This means that every `RUN` sentence will create a
    new layer. Therefore, `RUN` directly affects the resulting number of layers in
    our image. To avoid using more layers than needed, we usually add more than one
    command per `RUN` sentence:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '| `RUN` | `RUN`可能是你在Dockerfile中最常用的指令之一。它会在一个新的层中执行行中的所有命令，并将结果提交到一个新的层（如我们在前一章节中所描述的）。这个新层将在下一条语句中作为基础层使用，并包含`RUN`指令所做的更改。这意味着每条`RUN`指令都会创建一个新的层。因此，`RUN`直接影响镜像中层的数量。为了避免使用比需要更多的层，我们通常会在每个`RUN`语句中添加多个命令：'
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `COPY` | The `COPY` instruction copies new files and directories from the
    build context (set during build execution) into the specified directory of the
    container filesystem (remember that building images is based on execution on containers
    and committing results in images for subsequent stages). `COPY` admits the `--chown=<user>:<group>`
    argument for providing file ownership on Linux containers. The owner will be `root:root`
    if it is not used.`COPY` accepts `--from=<name or index>` in order to copy files
    or directories from other build stages (this is key when employing multistage
    building, as we will learn later in this chapter):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '| `COPY` | `COPY`指令将新的文件和目录从构建上下文（在构建执行过程中设置）复制到容器文件系统的指定目录中（记住，构建镜像是基于在容器上执行命令，并将结果提交为镜像，用于后续的阶段）。`COPY`支持`--chown=<user>:<group>`参数，用于为Linux容器提供文件所有权。如果不使用该参数，所有者将默认为`root:root`。`COPY`还支持`--from=<name
    or index>`，用于从其他构建阶段复制文件或目录（当使用多阶段构建时，这一点至关重要，我们将在本章后面学习）：'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ADD` | `ADD` is similar to `COPY`, but can be used with URLs and TAR package
    files as well. It accepts the same ownership arguments for changing destination
    files and directory permissions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ADD` | `ADD`类似于`COPY`，但也可以与URL和TAR包文件一起使用。它接受相同的所有权参数，以更改目标文件和目录的权限：'
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `USER` | The `USER` instruction is used to specify the user, along with the
    group to use in the following sentences. It is very important to understand the
    required permissions of our process and specify a user and its group with `USER`.
    If it is not present, the steps will use `root:root` and the process inside the
    container will run as root. It should be mandatory in production to use a specific
    non-root user for container processes and, if root is required, we should use
    user mappings (as described in the previous chapter):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '| `USER` | `USER` 指令用于指定在接下来的语句中使用的用户及其所属组。理解我们进程所需的权限并使用 `USER` 指定用户及其组是非常重要的。如果没有指定，步骤将使用
    `root:root`，并且容器内的进程将以 root 用户身份运行。在生产环境中，应强制使用特定的非 root 用户运行容器进程，如果需要 root 用户，则应使用用户映射（如前一章所述）：'
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `VOLUME` | The `VOLUME` definition will create a mount point to bypass the
    CoW system. This means that this set directory''s content will be out of the container''s
    life cycle. As it is outside the container, any change in subsequent sentences
    affecting that directory will be discarded, so if we want to provide certain files
    during volume initialization, the `VOLUME` sentence should be after we''ve provisioned
    files inside the directory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '| `VOLUME` | `VOLUME` 定义将创建一个挂载点，用以绕过 CoW 系统。这意味着该目录的内容将不属于容器生命周期的一部分。由于它在容器外部，因此对该目录的任何后续更改都会被丢弃。因此，如果我们希望在初始化卷时提供某些文件，`VOLUME`
    语句应位于我们已将文件放入目录之后：'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `EXPOSE` | `EXPOSE` is used to inform Docker daemon about listening ports
    for containers created using this image. This does not mean that the defined ports
    listen at the Docker host level. They will just listen internally, inside the
    container''s network. We can define which transport protocol to use – UDP or TCP
    (by default):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '| `EXPOSE` | `EXPOSE` 用于通知 Docker 守护进程有关通过此镜像创建的容器的监听端口。这并不意味着定义的端口在 Docker
    主机级别监听，它们只会在容器的网络内部监听。我们可以定义使用哪种传输协议——UDP 或 TCP（默认为 TCP）：'
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `CMD` | The `CMD` instruction defines the default process or argument when
    executing a container based on this image. This behavior will be applied irrespective
    of whether the `ENTRYPOINT` instruction is defined. By default, and depending
    on the format used, `CMD` will provide the default arguments for a shell, which
    is the default entry point (the main executor for processes inside a container):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| `CMD` | `CMD` 指令定义了执行基于该镜像的容器时的默认进程或参数。无论是否定义了 `ENTRYPOINT` 指令，这一行为都会被应用。默认情况下，根据使用的格式，`CMD`
    将为 shell 提供默认的参数，shell 是默认的入口点（容器内进程的主要执行器）：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ENTRYPOINT` | The `ENTRYPOINT` directive will set which command container
    will run as an executable. As we learned previously, `CMD` will be the argument
    for this command.The interaction between `CMD` and `ENTRYPOINT` defines the command
    that will be executed when running a container. They are not required, but it
    is a good practice to define at least `CMD` so as to have a default process to
    launch on execution. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT` | `ENTRYPOINT` 指令将设置容器运行的命令作为可执行文件。如前所述，`CMD` 将是该命令的参数。`CMD`
    和 `ENTRYPOINT` 之间的交互定义了在运行容器时执行的命令。它们不是必需的，但最好至少定义 `CMD`，以便在执行时具有默认的进程启动命令。|'
- en: '| `HEALTHCHECK` | `HEALTHCHECK` defines a command line that will run inside
    the container to verify the health of the process or processes. Without `HEALTHCHECK`,
    Docker daemon will only verify if the main process is alive, and if it isn''t,
    the container will be exited. The `HEALTHCHECK` instruction allows us to improve
    the health of the application by defining a better script or binary-based process
    status monitoring.We can adjust the interval between checks, timeout, and the
    number of retries in case of failure before declaring a non-healthy state. And,
    if we have a process that takes time to start, we can set when to start monitoring
    the container processes'' health:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '| `HEALTHCHECK` | `HEALTHCHECK` 定义了一个命令行，该命令将在容器内运行以验证进程或进程的健康状况。如果没有 `HEALTHCHECK`，Docker
    守护进程将只验证主进程是否存活，如果主进程不存在，容器将退出。`HEALTHCHECK` 指令通过定义更好的脚本或基于二进制的进程状态监控，帮助我们改善应用程序的健康状况。我们可以调整检查之间的间隔、超时设置以及在声明为不健康状态之前的重试次数。如果我们有一个启动需要时间的进程，我们可以设置开始监控容器进程健康状况的时间：'
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is very important to understand that, by default, the main process running
    inside a container that is not working as expected (the process is alive but the
    health check is failing) will not be set as unhealthy until there are three failed
    verifications, with 30 seconds between them by default. This means that, by default,
    a process could be failing for 90 seconds before the container is marked as unhealthy.
    This is too much in many cases, and you should take action to change this behavior.We
    can use our own scripts inside containers and we just have to manage two different
    exit statuses for the output (`0` – verification is OK; `1` – verification is
    wrong). |
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，默认情况下，如果容器内运行的主进程没有按预期工作（进程仍在运行，但健康检查失败），在进行三次失败验证之前，它不会被标记为不健康，默认情况下每次验证之间会有
    30 秒的间隔。这意味着，默认情况下，一个进程可能会失败 90 秒，容器才会被标记为不健康。这在许多情况下过长，你应该采取措施来改变这种行为。我们可以在容器内使用自己的脚本，只需要管理两种不同的退出状态（`0`
    – 验证通过；`1` – 验证失败）。
- en: Be careful if you defined a primitive key multiple times in a Dockerfile. These
    files are read top to bottom and definition precedence matters because instruction
    values will be overwritten in some cases (`ARG`, `ENV`, `CMD`, `ENTRYPOINT`, `LABEL`,
    `USER`, `WORKDIR`, `HEALTHCHECK`, and so on) or added in others (`VOLUME`, `EXPOSE`,
    and so on).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Dockerfile 中多次定义了原始键，请小心。这些文件是从上到下读取的，定义的优先级很重要，因为某些指令的值会被覆盖（`ARG`、`ENV`、`CMD`、`ENTRYPOINT`、`LABEL`、`USER`、`WORKDIR`、`HEALTHCHECK`
    等），而其他指令的值会被添加（`VOLUME`、`EXPOSE` 等）。
- en: 'There are some instructions that admit two different formats, `shell` and `exec`,
    that have different behaviors in each case:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有些指令支持两种不同的格式，`shell` 和 `exec`，它们在每种情况下有不同的行为：
- en: '`RUN`:When using the `shell` form, all commands will be launched in a shell,
    as if we were using `/bin/sh -c` (on Linux by default) or `cmd /S` or `cmd /C`
    (on Windows by default). We can change which shell to use in this format by means
    of the `SHELL` directive:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：当使用 `shell` 形式时，所有命令都将在 Shell 中启动，就像我们使用 `/bin/sh -c`（默认在 Linux 上）或 `cmd
    /S` 或 `cmd /C`（默认在 Windows 上）一样。我们可以通过 `SHELL` 指令来更改在该形式中使用的 Shell。'
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will need to use the `exec` format in Windows containers. This format is
    required in this case because the defined values for some keys, such as directory
    paths, will contain slashes (`\`) and must be avoided.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 Windows 容器中使用 `exec` 格式。此格式在这种情况下是必要的，因为某些键的定义值，如目录路径，将包含反斜杠（`\`），并且必须避免使用。
- en: '`CMD`: This key will be used to define the command or arguments to pass to
    the main container process:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：此键用于定义传递给主容器进程的命令或参数：'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we learned previously, the shell form uses a shell to execute commands (this
    can be changed by setting a different shell using the `SHELL` key).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所学，Shell 形式会使用 Shell 执行命令（可以通过设置 `SHELL` 键来更改使用的 Shell）。
- en: In order to execute CMD commands without a shell, we must use the `exec` form.
    If we want to use CMD values as arguments for a defined entrypoint, we will use
    the `exec` form too, but this must be used on both `ENTRYPOINT` and CMD definitions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在没有 Shell 的情况下执行 CMD 命令，我们必须使用 `exec` 形式。如果我们想将 CMD 值作为已定义入口点的参数使用，也将使用 `exec`
    形式，但必须在 `ENTRYPOINT` 和 CMD 定义中都使用该形式。
- en: '`ENTRYPOINT`: This key will be used to define the main process to be executed
    inside the created container:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`：此键用于定义在创建的容器内执行的主进程：'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The same behavior is expected here in shell form, but in this case, using this
    form will not allow the use of CMD values as arguments. Using the shell form for
    `ENTRYPOINT` is not recommended because it uses `/bin/sh -c` to launch the main
    process and, in this case, it will not have PID 1 and will not receive Unix signals
    directly (we will review how Unix signals interact with container processes in
    [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml), *Running Docker Containers*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Shell 形式中预期会有相同的行为，但在这种情况下，使用此形式将不允许使用 CMD 值作为参数。因为 `ENTRYPOINT` 使用 Shell
    形式时，会使用 `/bin/sh -c` 启动主进程，而在这种情况下，它将不会拥有 PID 1，并且无法直接接收 Unix 信号（我们将在[第 3 章](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml)《运行
    Docker 容器》中回顾 Unix 信号如何与容器进程交互）。
- en: Remember, in order to use CMD values as `ENTRYPOINT` arguments, `ENTRYPOINT`
    must be defined in `exec` form.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了将 CMD 值作为 `ENTRYPOINT` 的参数使用，`ENTRYPOINT` 必须以 `exec` 形式定义。
- en: When we use a base image to create new ones, the base image's defined values
    are inherited by new images. This means that CMD and `ENTRYPOINT` definitions
    will be used unless we overwrite them, thereby setting new values on our image.
    However, there is an exception; if we set a new `ENTRYPOINT` on our new image,
    CMD will be reset to an empty value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用基础镜像创建新的镜像时，基础镜像定义的值会被新镜像继承。这意味着，除非我们覆盖它们，否则 CMD 和 `ENTRYPOINT` 的定义将被使用，从而为我们的镜像设置新值。然而，有一个例外；如果我们在新镜像中设置了新的
    `ENTRYPOINT`，CMD 会被重置为空值。
- en: Building process actions
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建过程操作
- en: The Docker command line provides management actions for Docker objects, as we
    learned in the previous chapter. Images are Docker objects and the command line
    will provide tools for building and manipulating them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 命令行提供了用于管理 Docker 对象的操作，正如我们在上一章中学习的那样。镜像是 Docker 对象，命令行将提供构建和操作它们的工具。
- en: I encourage the use of `docker image build` instead of the frequently used `docker
    build`. As you may have noticed, `docker image build` follows the `object action`
    schema, which is easier to remember.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励使用 `docker image build` 而不是常用的 `docker build`。正如你可能已经注意到的，`docker image build`
    遵循 `对象动作` 模式，这种方式更容易记住。
- en: 'We can review Docker image actions in different categories:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不同类别中查看 Docker 镜像操作：
- en: '**For management**: `ls`, `prune`, `rm`, and `tag`. These actions allow us
    to list, remove, and set identifications for images.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于管理**：`ls`、`prune`、`rm` 和 `tag`。这些操作允许我们列出、移除和为镜像设置标识。'
- en: '**To get information**: `history` and `inspect`. These actions provide information
    about the steps that need to be followed to create that image and all its properties.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取信息**：`history` 和 `inspect`。这些操作提供了有关创建该镜像所需步骤的信息，以及其所有属性。'
- en: '**To share images between hosts:** `pull`, `push`, `load`, `import`, and `save`.
    These actions allow us to interact with the registry to download and upload image
    layers, and different ways to import and export images to and from different Docker
    hosts.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在主机之间共享镜像**：`pull`、`push`、`load`、`import` 和 `save`。这些操作允许我们与注册表交互，以下载和上传镜像层，并通过不同方式导入和导出镜像到不同的
    Docker 主机。'
- en: '**To create new images**: `build`. Using the `build` action, we will be able
    to create new images, using base images or starting from an empty root filesystem.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建新镜像**：`build`。通过 `build` 操作，我们将能够使用基础镜像或从空根文件系统开始创建新镜像。'
- en: Therefore, we will use the Docker image build to create new images. There are
    a few very important options that change the building behavior, and these must
    be reviewed for the Docker Certified Associate exam.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们将使用 Docker 镜像构建来创建新镜像。这里有一些非常重要的选项会改变构建行为，这些内容必须在 Docker Certified Associate
    考试中进行复习。
- en: 'We will use `docker image build [options] <context>` with some additional options:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `docker image build [options] <context>` 并带上一些额外的选项：
- en: '`--add-host`: This option allows us to include host-to-IP entries with an image.
    It is very useful for adding non-DNS entries or for masking external resources,
    for example.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--add-host`：此选项允许我们在镜像中包含主机到 IP 的条目。它在添加非 DNS 条目或遮蔽外部资源时非常有用，例如。'
- en: '`--build-arg`: Using arguments during the construction of new images is standard
    in Continuous Integration pipelines combined with templated Dockerfiles.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-arg`：在构建新镜像时使用参数是持续集成流水线中结合模板化 Dockerfile 的标准做法。'
- en: In cluster environments, we will need to specify which nodes should build the
    required image. To ensure that images are built on specific nodes, we will specify
    some of their labels as constraints by using them as arguments; for example, using
    `--build-arg constraint:ostype==linux` on a cluster with both Windows and Linux
    nodes will send the building process just to Linux ones.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群环境中，我们需要指定哪些节点应构建所需的镜像。为了确保镜像在特定节点上构建，我们将使用某些标签作为约束，将它们作为参数指定；例如，在一个同时拥有
    Windows 和 Linux 节点的集群中，使用 `--build-arg constraint:ostype==linux` 会将构建过程仅发送到 Linux
    节点。
- en: '`--file` or `-f`: We can define which Dockerfile to use. We can have different
    files for each environment, architecture, and so on, but nowadays, there are other
    features, such as "target definition," that allow us to use a unique Dockerfile
    for different purposes and build each one as required.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--file` 或 `-f`：我们可以定义使用哪个 Dockerfile。我们可以为每个环境、架构等定义不同的文件，但如今有其他功能，例如“目标定义”，允许我们为不同的目的使用一个唯一的
    Dockerfile，并根据需要构建每一个。'
- en: '`--force-rm`: This option will keep your environment clean as it will remove
    all intermediate containers. By default, intermediate containers are only removed
    after a successful build.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force-rm`：此选项将保持环境的清洁，因为它会删除所有中间容器。默认情况下，只有在构建成功后，中间容器才会被删除。'
- en: '`--isolation`: This option is mandatory when building Windows images as we
    will choose which isolation to use.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--isolation`：在构建 Windows 镜像时，此选项是必需的，因为我们需要选择使用的隔离模式。'
- en: '`--label`: This option allows us to add meta-information in key-value pairs
    format.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--label`：此选项允许我们以键值对的格式添加元信息。'
- en: '`--no-cache`: By default, Docker daemon will use host cached layers when building
    a new image. There are some circumstances when we need to create a new fresh image,
    including, for example, new package updates. In these cases, we will avoid using
    previously built layers with this option. Take care of time and overheads when
    using this option since disabling caching will increase build times and we need
    to execute all the steps to produce a new image.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-cache`：默认情况下，Docker 守护进程在构建新镜像时会使用主机缓存的层。有些情况下我们需要创建一个全新的镜像，例如当有新软件包更新时。在这些情况下，我们会使用此选项避免使用之前构建的层。使用此选项时需要注意时间和开销，因为禁用缓存会增加构建时间，并且我们需要执行所有步骤来生成新镜像。'
- en: '`--tag` or `-t`: Tagging an image should be mandatory. By default, Docker will
    not "name" your images and we will just be able to reference the image using its
    `IMAGE` ID (we learned about this earlier in this chapter). It is very important
    to specify a repository name (we will learn what a repository is in the forthcoming
    sections; for now, just understand this concept as a simple name) and its version
    to help us with image management. We can apply more than one tag at build time
    using multiple `--tag` or `-t` arguments with image names and tags. We will learn
    that image names are also known as repository names and that we have to add our
    own registry (with a non-standard port), username, and team or organization that
    we belong to as a prefix when not using Docker Hub.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tag` 或 `-t`：为镜像打标签是必须的。默认情况下，Docker 不会“命名”镜像，我们只能通过其 `IMAGE` ID 来引用镜像（我们在本章前面已经学习过这个内容）。指定一个仓库名称（我们将在后续章节中学习什么是仓库；目前，只需理解它是一个简单的名称）及其版本对镜像管理非常重要。我们可以在构建时使用多个
    `--tag` 或 `-t` 参数，带上镜像名称和标签。我们还会学习到，镜像名称也称为仓库名称，并且在不使用 Docker Hub 时，我们需要添加自己的注册表（包括非标准端口）、用户名和所属的团队或组织作为前缀。'
- en: '`IMAGE` IDs are unique. Each created image will have a unique ID that identifies
    this compound of layers on all systems. But we can add tags to this `IMAGE` ID
    for ease of management. An image will have just one unique identifier but can
    have many names and versions. This concept is very important and is key to ensuring
    the correct image is executed in production.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMAGE` ID 是唯一的。每个创建的镜像都有一个唯一的 ID 来标识这个由多层组成的镜像，且在所有系统中都是唯一的。但我们可以为该 `IMAGE`
    ID 添加标签以便于管理。一个镜像只有一个唯一的标识符，但可以有多个名称和版本。这个概念非常重要，它是确保在生产环境中执行正确镜像的关键。'
- en: '`--target`: We can have multiple build stage definitions on the same Dockerfile.
    These definitions allow us to execute multistage builds using compiled binaries
    between different resulting images, for example, but they also allow us to have
    multiple architectures or environment definitions and choose which one to build,
    instead of using different Dockerfile files.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--target`：我们可以在同一个 Dockerfile 中定义多个构建阶段。这些定义允许我们在不同的结果镜像之间执行多阶段构建，例如使用已编译的二进制文件，但它们也允许我们定义多个架构或环境并选择要构建的一个，而不必使用不同的
    Dockerfile 文件。'
- en: We can limit the resources used when building using options such as `--cpu-quota`,
    `--cpu-shares`, and `--memory`, which will limit the number of resources available
    on each container's execution during the build process.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用诸如 `--cpu-quota`、`--cpu-shares` 和 `--memory` 等选项限制构建过程中使用的资源，这将限制每个容器在构建过程中可用的资源数量。
- en: The build context is a set of files located in a directory or URL (a Git URL
    or a tarball file) and we use it to refer to its files when building. These files
    are sent to Docker daemon, to either use them or not during the image build. Therefore,
    it's very important to know which files in the context directory, Git repository,
    or tarball are actually needed during compilation. If we have many small files
    inside our build context or very big files, Docker daemon will retrieve those
    files and will either incorporate them or not in the image, depending on the Dockerfile
    instruction. Therefore, the context directory should only contain those files
    required for the image. Files that should not be managed by Docker during image
    building should not be in the context path.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 构建上下文是位于某个目录或 URL（如 Git URL 或 tarball 文件）中的一组文件，我们在构建时使用它来引用这些文件。这些文件会被发送到 Docker
    守护进程，供其在构建镜像时使用或不使用。因此，了解构建过程中实际需要哪些文件非常重要。如果我们在构建上下文中有很多小文件或非常大的文件，Docker 守护进程将会获取这些文件，并根据
    Dockerfile 指令决定是否将其纳入镜像中。因此，构建上下文目录应仅包含镜像所需的文件。那些在镜像构建过程中不应由 Docker 管理的文件，应该不放在构建上下文中。
- en: Irrespective of whether you use Git URLs or tarball files, the behavior will
    be similar. Docker daemon will retrieve the repository or `.tar` file and will
    unpackage or uncompress data to be able to treat the temporary directory as a
    build context.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是 Git URL 还是 tarball 文件，行为都是类似的。Docker 守护进程将获取该仓库或 `.tar` 文件，并解压或解压缩数据，以便将临时目录作为构建上下文。
- en: We usually store Dockerfiles with our application code and, as a result, the
    build context is the location where the Dockerfile is located. Due to this, we
    use `.` to indicate the current directory if we launch the build from the same
    directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将 Dockerfile 存储在应用代码中，因此构建上下文就是 Dockerfile 所在的目录。因此，如果我们从相同目录启动构建，我们会使用
    `.` 来表示当前目录。
- en: 'A simple command-line example of image building with a number of options is
    as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的命令行示例，展示了带有多个选项的镜像构建如下：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Docker daemon will try to find any file named Dockerfile to script the build.
    If you are not using this standard name, use `--file` or `-f`, along with the
    file location (we can use the full or relative path for Dockerfile, but take care
    of the build context location relative to it).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程将尝试查找名为 Dockerfile 的文件以编写构建脚本。如果你没有使用标准名称，可以使用 `--file` 或 `-f`，并指定文件位置（我们可以使用
    Dockerfile 的完整路径或相对路径，但需要注意构建上下文的位置与其相对关系）。
- en: 'And, having substituted some real values, we will have something along the
    lines of the following (this line has been taken from one of the labs at the end
    of this chapter):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，在替换了一些实际值后，我们将得到类似于以下内容的结果（这行内容来自本章末尾的一个实验）：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we are using a non-standard Dockerfile name, creating an image named `templated:production`
    using the `ENVIRONMENT` variable with a `production` value inside the building
    process, and using the current location as the build context. Notice the `.` at
    the end of the command. This means that we are using the current directory as
    the build context to create the image. If we run this command from the previous
    directory, we will use the directory containing the required Dockerfile as the
    build context.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个非标准的 Dockerfile 名称，使用 `ENVIRONMENT` 变量并在构建过程中设置 `production` 值，创建一个名为
    `templated:production` 的镜像，并使用当前目录作为构建上下文。注意命令末尾的 `.`。这意味着我们使用当前目录作为构建上下文来创建镜像。如果我们从上级目录运行此命令，则会使用包含所需
    Dockerfile 的目录作为构建上下文。
- en: Using the same Git repository philosophy, if there are some files that we want
    to be stored within our Docker build context (for example, files that come with
    our Git repository data), but that we do not want to be processed during the build,
    we can use the `.dockerignore` file to avoid them. Just write down unwanted filenames
    in `.gitignore` and Docker daemon will not treat them during the image build.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的 Git 仓库哲学，如果有一些文件我们希望存储在 Docker 构建上下文中（例如，随 Git 仓库数据一起提供的文件），但不希望它们在构建过程中被处理，我们可以使用
    `.dockerignore` 文件将其排除。只需在 `.gitignore` 中写下不需要的文件名，Docker 守护进程就不会在镜像构建过程中处理它们。
- en: Image tagging and meta-information
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像标签和元信息
- en: Usually, you won't manage just a few images but probably hundreds or thousands,
    so having as much information as possible about them is very important.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会只管理少量的镜像，而是可能管理数百个或数千个镜像，因此尽可能多地了解它们的信息非常重要。
- en: 'Using labels, we will be able to search for specific images by environment,
    as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签，我们将能够按环境搜索特定的镜像，如下所示：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remember that an image can have multiple names and tags, but its digest is unique.
    Using different tags and names is very useful for interacting with different CI/CD
    workflow stages, using the same image content. For example, developers will create
    many images during development and testing, but only a few will make it to the
    quality and assurance or certification stages. We can automate these processes
    based on image names and tags on Docker Enterprise, as we will learn in [Chapter
    13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml), *Implementing an Enterprise-Grade
    Registry with DTR*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一个镜像可以有多个名称和标签，但其摘要是唯一的。使用不同的标签和名称对于与不同的 CI/CD 工作流阶段交互非常有用，使用相同的镜像内容。例如，开发人员在开发和测试过程中会创建许多镜像，但只有少数会进入质量保障或认证阶段。我们可以基于
    Docker 企业版中的镜像名称和标签自动化这些过程，正如我们将在[第 13 章](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml)中学习的，*使用
    DTR 实现企业级注册中心*。
- en: We've already learned that we can have many names for the same image, so removing
    one image by its name will not really delete its content if it is still in use
    by other names. If we use its image ID to remove `docker image rm <imageid>`,
    Docker daemon will inform us about multiple images with different names using
    the same layers and will not delete the image unless we use `--force`, in which
    case it will remove that image, along with all its layers and referenced names.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学过，同一张图片可以有多个名称，因此通过名称删除某个镜像并不会真正删除其内容，如果它仍然被其他名称使用。如果我们使用镜像 ID 来删除 `docker
    image rm <imageid>`，Docker 守护进程会提示我们多个使用相同层的不同名称的镜像，并且除非我们使用 `--force`，否则它不会删除该镜像，在这种情况下，它将删除该镜像及其所有层和引用的名称。
- en: We can use `docker rmi` as a command alias for `docker image rm`. On the other
    hand, `docker image prune` will be used to remove dangling images.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker rmi` 作为 `docker image rm` 的命令别名。另一方面，`docker image prune` 将用于删除悬空镜像。
- en: There are special **untagged images** that will appear in our Docker build hosts
    as we create new images. These images are the result of making changes between
    different compilations. They are unreferenced and unused. In your host, when used
    as their layers, they are not used by any other image and therefore can be removed
    from our system (in fact, you should remove them because they are using precious
    disk space). These images are usually known as **dangling** images, and we will
    learn how to purge them later in this chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊的**未标记镜像**，它们会出现在我们创建新镜像时的 Docker 构建主机上。这些镜像是不同编译之间变更的结果。它们没有被引用且未被使用。在你的主机中，当它们作为层使用时，其他镜像不会使用它们，因此可以从系统中删除（事实上，你应该删除它们，因为它们占用了宝贵的磁盘空间）。这些镜像通常被称为**悬空镜像**，我们将在本章稍后学习如何清理它们。
- en: To add a new tag to an image, we will use the Docker image tag, `SOURCE_IMAGE[:TAG]
    TARGET_IMAGE[:TAG]`. By default, if we omit tags, we are using the `latest` tag.
    Avoid using the `latest` tag for your images as this doesn't really indicate that
    this was the latest image built. The only way to ensure when the image was built
    is by reviewing its date of creation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要给镜像添加新标签，我们将使用 Docker 镜像标签，`SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]`。默认情况下，如果我们省略标签，系统将使用
    `latest` 标签。避免使用 `latest` 标签，因为这并不真正表明这是最新构建的镜像。确保镜像构建时间的唯一方法是查看其创建日期。
- en: Docker registries and repositories
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 注册表和仓库
- en: Images must be stored somewhere. Locally, each Docker host stores its own data
    under `/var/lib/docker/image` in Linux and `c:\programdata\docker\image` in Windows,
    by default. But these directories will work locally only, and we usually need
    to use images to build new ones and share them across multiple nodes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像必须存储在某个地方。默认情况下，每个 Docker 主机会将其数据存储在 Linux 系统中的 `/var/lib/docker/image` 和
    Windows 系统中的 `c:\programdata\docker\image` 目录下。但这些目录仅在本地有效，我们通常需要使用镜像来构建新的镜像并在多个节点之间共享。
- en: We can use the Docker command line to export and import image layers on different
    hosts, but this is hard to maintain and this method does not scale. Docker Registry
    is a server application that will store and let us download and upload images
    as required. It provides an API for sharing information and image layers using
    a Docker client. As a result, we can define a registry as a store and content
    delivery system for container images. Images will be stored locally using the
    settings defined at the Docker daemon level. To use remote registries, we will
    set up different storage backends that can handle S3, Microsoft Azure, OpenStack
    Swift for cloud environments, and NFS for your local data center.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Docker 命令行在不同主机之间导出和导入镜像层，但这很难维护，而且这种方法无法扩展。Docker Registry 是一个服务器应用程序，用于存储并根据需要让我们下载和上传镜像。它提供一个
    API，用于通过 Docker 客户端共享信息和镜像层。因此，我们可以将注册表定义为容器镜像的存储和内容分发系统。镜像将使用在 Docker 守护进程级别定义的设置本地存储。要使用远程注册表，我们将设置不同的存储后端，可以处理云环境中的
    S3、Microsoft Azure、OpenStack Swift，以及本地数据中心中的 NFS。
- en: At the end of this chapter, we will have a lab in which we will create a local
    registry. Docker Registry is an open source solution and can be configured using
    the `/etc/docker/registry/config.yml` configuration file to change storage backends,
    ports, and other advanced settings.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将进行一个实验室实践，创建一个本地注册表。Docker Registry 是一个开源解决方案，可以通过 `/etc/docker/registry/config.yml`
    配置文件进行配置，以更改存储后端、端口和其他高级设置。
- en: Docker Hub is the cloud-based registry provided by Docker. We can use it to
    store public or private images and, as a software as a service solution, there
    are some features that require a paid subscription.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是 Docker 提供的基于云的注册表。我们可以使用它来存储公有或私有镜像，并且作为一种软件即服务的解决方案，有些功能需要付费订阅。
- en: Docker Registry will not provide any authentication method, nor TLS, to allow
    Docker clients to use encrypted connectivity. These security enhancements are
    only available in Docker Hub (Docker public/private image registry as a service)
    and Docker Trusted Registry (Registry deployed on the Docker Enterprise platform).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Registry 不提供任何身份验证方法，也不支持 TLS，以允许 Docker 客户端使用加密连接。这些安全增强功能仅在 Docker
    Hub（Docker 公有/私有镜像注册表作为服务）和 Docker Trusted Registry（部署在 Docker 企业平台上的注册表）中可用。
- en: 'We usually describe three different image namespaces or naming conventions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常描述三种不同的镜像命名空间或命名约定：
- en: '**Root (docker.io hosted images)**: We reference these images using their names
    and tags; for example, `nginx:alpine` and `postgres:12.0`. They are public.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根目录（docker.io 托管镜像）**：我们使用镜像的名称和标签来引用这些镜像，例如 `nginx:alpine` 和 `postgres:12.0`。它们是公开的。'
- en: '**User or organization images under root (docker.io hosted images)**: In this
    case, images could be private or public, depending on user licensing. Image names
    will contain the username or an organization, where users are allowed to pull
    or push their images, for example, `frjaraur/simplest-demo:simplestapp` or `codegazers/colors:1.13`**.**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根目录下的用户或组织镜像（docker.io 托管镜像）**：在这种情况下，镜像可以是私有的或公开的，具体取决于用户许可。镜像名称将包含用户名或组织名，用户可以在其中拉取或推送镜像，例如
    `frjaraur/simplest-demo:simplestapp` 或 `codegazers/colors:1.13`**。'
- en: '**Full registry format (used for private registries on the cloud or on your
    own data center)**: We will use usernames, teams, or organizations, but we will
    need to use the fully qualified name of the registry; for example, `dtr.myorganization.com[:my_registry_port][/myteam
    or /myoraganization][/myusername]/<repository>[:tag]`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整注册表格式（用于云端或自有数据中心的私有注册表）**：我们将使用用户名、团队或组织，但需要使用注册表的完全限定名称；例如，`dtr.myorganization.com[:my_registry_port][/myteam
    或 /myorganization][/myusername]/<repository>[:tag]`。'
- en: In fact, root registries and repository names can be completed using the full
    registry format; for example, we can pull the `docker.io/codegazers/colors:1.13`
    image using this full name convention.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，根注册表和仓库名称可以使用完整的注册表格式来填写；例如，我们可以使用完整的名称约定来拉取 `docker.io/codegazers/colors:1.13`
    镜像。
- en: You should have noticed that in this case, we added `my_registry_port` and `repository`.
    We added the first because, by default, Docker Hub and Docker Trusted Registry
    use HTTPS, and therefore the port is `443`, but we can deploy our own registries
    using custom ports. `repository` is a reference to a compound of same-named images,
    each one with a different `IMAGE` ID (unique) and tags (multiple). Consequently,
    when we talked about the `nginx:alpine` image, we were referring to the `docker.io`
    registry, the `nginx` repository, and the alpine tag, and the same rule should
    be applied to all other images used throughout the course of this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经注意到，在这个例子中，我们添加了 `my_registry_port` 和 `repository`。我们添加了 `my_registry_port`，因为默认情况下，Docker
    Hub 和 Docker Trusted Registry 使用 HTTPS，因此端口是 `443`，但我们可以使用自定义端口部署我们自己的注册中心。`repository`
    是对具有相同名称的镜像的引用，每个镜像都有不同的 `IMAGE` ID（唯一）和标签（多个）。因此，当我们谈论 `nginx:alpine` 镜像时，我们是指
    `docker.io` 注册中心、`nginx` 仓库和 alpine 标签，所有其他镜像在本章中使用时也应遵循相同的规则。
- en: Securing images
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像安全
- en: 'As seen in the previous chapter, Docker containers are secure by default, but
    this is because they run inside namespaces and cgroups isolation. Images are different
    objects and their security is related to their content. With this idea, it is
    easy to understand that having less content will be more secure. So, the main
    rules for securing images are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所见，Docker 容器默认是安全的，但这是因为它们在命名空间和 cgroups 隔离中运行。镜像是不同的对象，它们的安全性与其内容有关。基于这个概念，很容易理解，内容越少，安全性就越高。因此，确保镜像安全的主要规则如下：
- en: Images should only contain mandatory binaries, libraries, and configurations
    to run our containerized process. Don't add any non-required applications or debug
    tools to production images. Less attack surface is better, and having many binaries
    increases this surface.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像应仅包含运行我们容器化进程所需的必要二进制文件、库和配置。不要在生产镜像中添加任何不必要的应用程序或调试工具。减少攻击面更为重要，而过多的二进制文件会增加这个面。
- en: Always declare resources on your images. In this case, we use the term *resources*
    to describe users, exposed ports, and volumes. Always describe what is needed
    to run your image and avoid root usage inside a container.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终声明镜像上的资源。在这里，我们使用“资源”一词来描述用户、暴露的端口和卷。始终描述运行镜像所需的内容，并避免在容器内使用 root 权限。
- en: Update image content packages if there is some security bug fix, rebuild all
    derived images, and redeploy the containers. In fact, there are more steps to
    follow, but this statement is true. If you identify any exploit or bug that could
    result in any security issue, you must fix it as soon as possible using a Docker
    container's life cycle. To fix the base image with an updated build and rebuild
    all their derivatives, follow the CI/CD workflow and pass all the tests again
    before deploying these new image versions to production.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有安全漏洞修复，更新镜像内容包，重建所有衍生镜像，并重新部署容器。实际上，还有更多步骤需要遵循，但这一点是正确的。如果你发现任何可能导致安全问题的漏洞或错误，必须尽快使用
    Docker 容器的生命周期进行修复。要通过更新构建修复基础镜像并重建所有衍生镜像，请遵循 CI/CD 工作流，并在将这些新版本的镜像部署到生产环境之前，重新通过所有测试。
- en: In the Docker Enterprise sections, we will learn about Docker image security
    scanning, which is an automated tool that verifies all of an image's content against
    the CVE database. We can mark images as insecure if a bug or exploit is found.
    This tool can trigger new events to implement a secure pipeline, scan all images
    before they go into the production stage, and provide information regarding any
    security risks found.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 企业版部分，我们将学习 Docker 镜像安全扫描，这是一种自动化工具，用于验证镜像的所有内容与 CVE 数据库的匹配情况。如果发现漏洞或漏洞利用，我们可以将镜像标记为不安全。该工具可以触发新的事件来实现安全的管道，在镜像进入生产阶段前扫描所有镜像，并提供关于发现的安全风险的信息。
- en: We know that image layers are read-only for containers and that a new writable
    layer will be created for each container. In the next chapter, we will learn that
    we can improve this situation using the read-only root filesystem, allowing only
    write access to external volumes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道镜像层对于容器是只读的，每个容器都会创建一个新的可写层。在下一章，我们将学习如何通过使用只读根文件系统来改进这种情况，只允许对外部卷进行写访问。
- en: Managing images and other related objects
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理镜像及其他相关对象
- en: We have learned how to manage image containers throughout this chapter, so now,
    let's take a look at the most common image administration tasks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中学习了如何管理镜像容器，现在，让我们看看最常见的镜像管理任务。
- en: Dangling images can be a nightmare if you do not take care of them from the
    very beginning. As we mentioned in the previous sections, *dangling images* are
    images that aren't referenced and therefore, are not used by any other image.
    In fact, they are the result of continuous builds as Docker uses them for caching
    and improving build performance. They are just layers used during image builds
    that are no longer used because, in a particular step, we changed a package, we
    updated our code, we changed a configuration file, and so on, and, as a result,
    it is not necessary. We should delete these images since they can consume a significant
    amount of disk space.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从一开始没有处理好悬空镜像，它们可能会变成一场噩梦。正如我们在前面的章节中提到的，*悬空镜像*是指那些未被引用、因此不被任何其他镜像使用的镜像。实际上，它们是连续构建的结果，因为
    Docker 使用它们进行缓存和提高构建性能。它们只是构建镜像过程中使用的层，在特定步骤中由于我们更改了某个包、更新了代码、更改了配置文件等原因，这些镜像不再被使用，因此它们不再必要。我们应该删除这些镜像，因为它们可能占用大量磁盘空间。
- en: 'Since version 1.13, Docker provides the *Docker* image prune action, which,
    by default, will remove all dangling images. However, we can choose what images
    we want to remove, for example, by filtering by date or labels:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.13 版本以来，Docker 提供了 *Docker* 镜像清理操作，默认情况下会删除所有悬空镜像。然而，我们可以选择删除我们希望删除的镜像，例如，可以按日期或标签进行过滤：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command line has removed all dangling images with an environment label
    equal to `test`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令行已删除所有环境标签为 `test` 的悬空镜像。
- en: The Docker image prune not only removes the dangling images but also the old
    images. However, you should manage this situation because it depends on what containers
    you have been running in your environment. Before removing non-dangling images
    in production, verify that there are no containers running using that image; for
    example, `docker container ls --filter ancestor=<image_to_be_removed>`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像清理不仅会删除悬空镜像，还会删除旧镜像。然而，您应该管理这种情况，因为它取决于您在环境中运行了哪些容器。在生产环境中删除非悬空镜像之前，请确认没有容器在使用该镜像；例如，`docker
    container ls --filter ancestor=<image_to_be_removed>`。
- en: Many containers are used in building operations. By default, Docker daemon will
    delete all the containers used during builds that exited correctly, so all the
    containers that were used during correct builds will be removed. However, containers
    that have been used on faulty builds should be removed by hand. It is easy to
    identify faulty containers related to image builds. We will usually set container
    names in all containers launched by hand in other situations. In *Section 2*,
    *Containers Orchestration*, dedicated to orchestration, we will learn about the
    naming patterns used by Kubernetes and Swarm orchestrators to create containers,
    thereby helping us identify their origin.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 许多容器用于构建操作。默认情况下，Docker 守护进程会删除所有在构建过程中正确退出的容器，因此所有在正确构建过程中使用的容器将被移除。然而，曾在构建失败时使用的容器应手动删除。识别与镜像构建相关的故障容器非常简单。通常，我们会在其他情况下手动启动的所有容器中设置容器名称。在*第
    2 节*，*容器编排*，专门讲解编排时，我们将学习 Kubernetes 和 Swarm 编排器在创建容器时使用的命名模式，从而帮助我们识别它们的来源。
- en: It is always useful to take a look at Docker host filesystem usage, especially
    the space used by Docker daemon. We can use `docker system df --verbose` to obtain
    fine-grained information about the images, containers, and volume usage of each
    host.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Docker 主机文件系统使用情况总是很有用，特别是 Docker 守护进程使用的空间。我们可以使用 `docker system df --verbose`
    获取关于每个主机的镜像、容器和卷使用情况的详细信息。
- en: Other common tasks involve inspecting images to understand the resources required
    in each case and sharing them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见任务包括检查镜像，以了解每种情况下所需的资源并共享它们。
- en: Listing images
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出镜像
- en: 'Listing images is a common task for reviewing host system content. We can modify
    the default `docker image ls` command''s output using the `--format` modifier
    in the GoLang format structure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列出镜像是审查主机系统内容的常见任务。我们可以通过在 GoLang 格式结构中使用 `--format` 修饰符来修改默认的 `docker image
    ls` 命令输出：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we learned in the previous examples, we can filter this output using labels,
    for example, to only show specific images.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中学到的，我们可以使用标签过滤输出，例如，只显示特定的镜像。
- en: Sharing images using registries
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注册表共享镜像
- en: We learned that registries are servers where images can be stored using the
    HTTP REST API. The Docker client knows how to manage the required requests, thereby
    facilitating image management at these locations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，注册表是可以存储镜像的服务器，使用 HTTP REST API。Docker 客户端知道如何管理所需的请求，从而简化了在这些位置的镜像管理。
- en: Images are always required to execute a container. Therefore, each time we run
    a new container, the image will be downloaded from a registry if it is not present
    on the Docker host.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We can download images manually using `docker image pull <IMAGE:TAG>`. This
    will download all image layers and we will be ready to launch a new container
    based on this image. This is very useful for warming hosts before launching containers;
    think of a 2 GB image that should be downloaded from the internet, for example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We can download all the images from a repository using `--all-tags`; for example,
    `docker image pull --all-tags --quiet codegazers/colors`. Using this command line,
    we are downloading all the images (all tags) that are available in the `codegazers/colors`
    repository without any output.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, we will use Docker `push` to upload images to registries. But
    remember to use the full name, including the registry's fully qualified domain
    name and port (if we are not using `docker.io` and the default `443` port). We
    will use the full path with custom registries – `myregistry.com[:non-default-port]/myusername/myrepository[:tag]`;
    for example, `$ docker push docker.io/codegazers/colors:test`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Docker registries should require a login to access them, for both pulling and
    pushing. Usually, we will use TLS encryption to connect to registries and it is
    enabled by default on Docker Client. Docker Engine needs to trust registry certificates
    to permit login and image pulling or pushing. If you do not want to use this feature,
    you will need to add a registry as an insecure registry in `/etc/docker/daemon.json`
    and restart Docker Daemon.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other methods for sharing images. We can save an image, along with
    all its layers and meta-information, using `docker image save`. This command will
    stream content to standard output by default, so we usually use `--output` to
    store all the content in a file (or redirect its output to a file):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As a result, `docker image save` will create a `.tar` file containing all the
    layers, along with all their files, and the manifest file (among other meta-information)
    required to recreate that image in your host. Notice that we choose the filename
    and its extension (`.tar` will not be added by default, but it does not affect
    content upload).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Uploading this image `.tar` file is easy. We have two options.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The first option will be to use `docker image import`. With this action, we
    will just import image layers, without any meta-information, and so we will not
    have a defined entry point, command arguments, exposed ports, volume definitions,
    and so on. It will just import the layers provided by the image into our host.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we will not be able to run a container using this image as is
    (but we will be able to add Dockerfile-like instructions on import to avoid this
    situation):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use `docker image load` to upload a saved image, along with all its
    layers and information for launching containers. This is a direct step, without
    any modifications, and we can use this loaded image as is. This command uses standard
    input to read content by default, but we can use a `.tar` file by adding the `--input`
    argument or simply by using redirection:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker image load`上传保存的镜像，连同所有其层和启动容器所需的信息。这是一个直接步骤，没有任何修改，我们可以直接使用加载后的镜像。此命令默认使用标准输入读取内容，但我们也可以通过添加`--input`参数或直接使用重定向，来使用`.tar`文件：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you will have noticed, we haven't used any name because it takes it from
    the image `.tar` file's meta-information.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们没有使用任何名称，因为它是从镜像`.tar`文件的元信息中获取的。
- en: Using `docker image save` on the original host and Docker import/load on the
    destination host, we can avoid the use of external storage, but as the platform
    grows in terms of the number of images and hosts, this is not enough and you should
    use a registry to manage sharing images.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker image save`在原主机上保存镜像，并在目标主机上通过Docker的导入/加载功能，我们可以避免使用外部存储。但随着平台上镜像和主机数量的增加，这种方法已不再足够，我们应该使用注册表来管理镜像共享。
- en: Multistage building and image caches
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段构建与镜像缓存
- en: Multistage building is a feature that appeared with Docker 17.05\. Prior to
    this version, if we wanted to ensure minimum image size and void compilers on
    final production images, we usually had to install the packages required for compiling,
    execute the binary's build, and then remove all non-required software, including
    used compilers, which are a real security problem in production.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建是Docker 17.05版本引入的一项功能。在此版本之前，如果我们想要确保最小的镜像大小并避免在最终生产镜像中使用编译器，我们通常需要安装编译所需的包，执行二进制文件的构建，然后删除所有不需要的软件，包括使用过的编译器，而这些编译器在生产环境中是一个真实的安全隐患。
- en: Automating this kind of compilation was not easy, and sometimes, we needed to
    create our own scripts to reproduce those steps on every build, usually using
    third-party CI/CD orchestrations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化这种编译过程并不容易，有时我们需要创建自己的脚本，以便在每次构建时重新执行这些步骤，通常使用第三方的CI/CD协调工具。
- en: We can use many build definitions on a Dockerfile to create small and compiler-free
    images. These images will only include application libraries, executables, and
    configurations. All compilations steps will be done on another image and we will
    just include the resulting files in a new one. We could also use external images
    in this process. We will only copy the required files for our application to a
    new image. This is known as multistage building.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Dockerfile中使用多个构建定义来创建小巧且不包含编译器的镜像。这些镜像只会包括应用程序库、可执行文件和配置。所有的编译步骤将在另一个镜像上完成，我们只需将结果文件包含到新镜像中。在此过程中，我们还可以使用外部镜像。我们将仅把应用所需的文件复制到新的镜像中。这被称为多阶段构建。
- en: 'Let''s look at an example that will help us understand this new process:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，帮助我们理解这个新过程：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we start a building stage named `sdk`. We add the name to be
    able to use it as a reference in the next stage. In the `sdk` stage, we compile
    our C code after installing the `alpine-sdk` package with the required tools for
    that task. As a result, we obtain a hello binary with our application, located
    in the `/myapp/bin` directory (check the `WORKDIR` instruction). In the next stage,
    we start again with a fresh alpine image and we just copy the compiled hello binary
    from the `sdk` build stage (from the previously compiled image container) to `/myapp/hello`
    on our new stage build container. And, as always in a building process, this container
    is committed as our new image.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们开始一个名为`sdk`的构建阶段。我们添加名称以便在下一个阶段中使用它作为引用。在`sdk`阶段，我们在安装了`alpine-sdk`包并包含了所需工具后，编译我们的C代码。最终，我们得到一个包含我们应用程序的hello二进制文件，位于`/myapp/bin`目录下（查看`WORKDIR`指令）。在下一个阶段，我们再次从一个全新的alpine镜像开始，只需将从`sdk`构建阶段（来自之前编译的镜像容器）复制过来的已编译hello二进制文件到新阶段构建容器的`/myapp/hello`目录下。正如构建过程中的常规操作一样，这个容器被提交为我们的新镜像。
- en: Multistage building simplifies the creation of images and improves security.
    This way, the process will just add previously created binaries and libraries
    instead of compilers, which can cause a security breach.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建简化了镜像的创建并提高了安全性。这样，构建过程只会添加先前创建的二进制文件和库，而不是编译器，从而避免了潜在的安全漏洞。
- en: Templating images
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化镜像
- en: Using prepared Dockerfiles with a certain template format is common. It is certainly
    a very useful approach. Passing arguments and using environment variables during
    builds will create different images for different CI/CD stages, for example, using
    the same Dockerfile.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用准备好的Dockerfile并遵循特定的模板格式是很常见的。这无疑是一个非常有用的方法。在构建过程中传递参数并使用环境变量将为不同的CI/CD阶段创建不同的镜像，例如，使用相同的Dockerfile。
- en: 'Templating is key when building using CI/CD orchestration, but there are a
    few rules:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CI/CD编排构建时，模板化是关键，但有一些规则：
- en: Don't use debugging tools in production images, so take care of these images
    and use slimmer ones (with fewer components) by default in templates.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在生产镜像中使用调试工具，因此请注意这些镜像，并且默认情况下在模板中使用更精简的镜像（包含更少的组件）。
- en: Don't use credentials as arguments when building. There are other mechanisms
    for managing users and passwords and the Docker `history` command will reveal
    this information.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时不要将凭证作为参数。管理用户和密码有其他机制，并且Docker的`history`命令将会暴露这些信息。
- en: 'Proxy settings are prepared for use as arguments. Therefore, the `HTTP_PROXY`,
    `HTTPS_PROXY`, `FTP_PROXY`, and `NO_PROXY` environment variables can be used during
    build time. These variables will be excluded from the Docker history output and
    will not be cached, so we will need to use an ARG definition to allow changes
    in proxy settings between compilations using the same Dockerfile. In other words,
    before using the `HTTP_PROXY` variable, we should call the `ARG` instruction to
    retrieve its value from the Docker build arguments:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理设置已经准备好作为构建时的参数。因此，`HTTP_PROXY`、`HTTPS_PROXY`、`FTP_PROXY`和`NO_PROXY`环境变量可以在构建过程中使用。这些变量将从Docker历史输出中排除，并且不会被缓存，因此我们需要使用`ARG`定义，以便在使用相同Dockerfile的多个构建之间更改代理设置。换句话说，在使用`HTTP_PROXY`变量之前，我们应该调用`ARG`指令来从Docker构建参数中获取其值：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The previous code shows an example that illustrates the behavior described since
    the proxy settings will get updated on every build if its value has changed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了一个例子，说明了如代理设置在每次构建时都会更新，如果其值发生变化的话。
- en: Operating systems and other applications would use `http_proxy`, `https_proxy`,
    `ftp_proxy`, and `no_proxy` instead of the capital strings described in this section.
    Review the application's requirements and use the appropriate format.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统和其他应用程序会使用`http_proxy`、`https_proxy`、`ftp_proxy`和`no_proxy`，而不是本节中描述的大写字符串。请检查应用程序的要求并使用适当的格式。
- en: We will see a simple, but illustrative, lab at the end of this chapter that
    uses a templated Dockerfile that will build a different version for production
    and development, along with a different base image that includes some debugging
    tools for developers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将看到一个简单但具有说明性的实验，使用模板化的Dockerfile来构建生产和开发环境的不同版本，并使用包含一些调试工具的不同基础镜像，供开发人员使用。
- en: Image releases and updates
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像发布和更新
- en: Earlier, we mentioned how we should manage image updates. In that instance,
    we were focused on security updates to avoid bugs and exploits in production.
    Similarly, we can apply this concept to application fixes and releases.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到过如何管理镜像更新。在那个实例中，我们专注于安全更新，以避免生产环境中的漏洞和bug。同样，我们也可以将这个概念应用于应用程序修复和发布。
- en: Base images should be updated in critical image components and these changes
    do not happen very frequently. Usually, the application releases are weekly or
    even daily (or hourly, depending on numerous factors, such as business requirements
    and critical fixes).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像应该更新关键的镜像组件，这些更改并不经常发生。通常，应用程序的发布是每周甚至每天发布（或者根据许多因素，如业务需求和关键修复，可能是每小时发布）。
- en: Depending on how many containers are running based on a specific image, a new
    image release can be a big change. These changes can be done in a couple of minutes
    or they can take you an hour. However, the procedure using containers is very
    quick; *let the orchestrator do its job*. Kubernetes and Swarm will provide automated
    image updates and rollback and we will be able to manage how this deployment should
    be done, how many containers will update their images in parallel, how much time
    we will wait between these updates, and more.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基于特定镜像运行的容器数量，新的镜像发布可能是一次重大更改。这些更改可以在几分钟内完成，也可能需要一个小时。然而，使用容器的过程非常迅速；*让编排器来处理它*。Kubernetes和Swarm将提供自动化的镜像更新和回滚，我们将能够管理如何执行此部署，多少容器将并行更新其镜像，我们将在这些更新之间等待多长时间，等等。
- en: It is easy to understand that changes to base images (used for building the
    others) require special care. Those image updates must be managed in cascade to
    all derived images. We will usually automate this kind of cascade building. These
    changes will require all the derived images to be rebuilt and will involve much
    more effort. It is recommended to use a Continuous Integration orchestrator to
    automate these kinds of tasks.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when we create a code or binary update, the changes will
    be easier because we will only affect the containers that were created for a specific
    application. We can deploy these updates quickly after passing all the required
    tests in our organization.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Chapter labs
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review the most important concepts for the Docker Certified
    Associate exam. For these labs, we will be using a CentOS Linux host with a Docker
    engine installed, which we covered in the previous chapter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Deploy `environments/standalone-environment` from this book's GitHub repository
    ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment` folder to start your virtual
    environment.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using `standalone-environment`, wait until it is running. We can
    check the status of our nodes using `vagrant status`. Connect to your lab node
    using `vagrant ssh standalone`. `standalone` as the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now connect to the `standalone` node using `vagrant ssh standalone`.
    This process may vary if you''ve already deployed a `standalone` virtual node
    before and you''ve just started it using `vagrant up`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, you are ready to start the labs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Docker build caching
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This lab will show us how caching works when building images. We will be able
    to speed up the building process, but it will depend on how the image layers are
    sorted. Let''s get started:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a directory named `chapter2` in your home directory on your Docker
    host. We will use this directory for these labs:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a file named `Dockerfile.cache` with the following simple content:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, build an image named `test1` while using this directory as an image context:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since we have not used any specific tag, Docker adds `latest`. Now, rebuild
    the image without any changes:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we can list our images using the `lab` label we created during the build:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Although we have not changed anything, the image ID is different. This is because
    we have avoided layer caches and we have always compiled each layer. Because we
    launched image buildings one after the other, only a few seconds passed between
    them. However, the meta-information has changed between them and they have different
    IDs, even though they contain the same content.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use caching because it will improve the build time. In many situations,
    this can make a big difference. Let''s add just a line for installing Python on
    our Dockerfile. Updating the package cache and the Python installation with its
    dependencies will take some time. When we use cached layers that have been created
    from previous builds, the building process will be quicker:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we build again without caching, measuring how many seconds it took for
    the process to complete:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, add a new line for adding `httpie`, which needs Python (and the package
    cache) to be installed. Now, let''s run the build with and without caching:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Without caching, it will take more than a minute:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Before launching a new build with caching, we removed the `test4` image using
    `docker image rm test4` because we just wanted to use the previous layers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Using caching, it will just take a few seconds:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since this process used the previously cached layers, it only took 15 seconds
    (`test4`, without caching, took 1 minute and 28 seconds to build). We have just
    added one layer and, to install just one package, we got more than 1 minute of
    difference, even though the images are small (around 100 MB in size). It can take
    hours to compile 5 GB images (which is not recommended, even though it is a good
    approach for caching).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Where to use volumes in Dockerfiles
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lab, we will review how the `VOLUME` key definition will be managed
    by Docker Daemon to specify persistent storage or to avoid container space when
    building. Let''s get started:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a small Dockerfile that''s using a volume to persist data between
    layers when building. The volume definition will also inform Docker Daemon about
    bypassing the volume directory from the CoW mechanism. We will name this Dockerfile
    `Dockerfile.chapter2.lab2`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s build this image:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, run a container using the `ch2lab2` image to retrieve the container''s
    `/data` directory content:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we will change the `VOLUME` instruction order. We write the `VOLUME` definition
    before the execution of `echo`. We will use a new file named `Dockerfile.chapter2.lab2-2`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let''s build a new image and review what happened with the `/data` content:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s review the `/data` content again:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we expected, the `VOLUME` directive allows containers to bypass the CoW filesystem.
    During builds, containers will not maintain volume content because the commit
    action will just transform container content into images, and volumes are not
    found inside containers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Multistage building
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lab, we will create a simple hello world binary in C and use an intermediate
    image to compile this code in the first stage and then copy the binary to a cleaner
    image. As a result, we will obtain a small image containing just the required
    components to run our compiled application. Let''s get started:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named `multistage` inside the `chapter2` directory:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, create a `helloword.c` file with the following content:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Prepare a multistage Dockerfile based on `alpine` called `Dockerfile.multistage`.
    The first stage will be named `compiler` and in it, we will install `alpine-sdk`
    to compile C code. We compile the C code in the first stage and we just use a
    `COPY` sentence to copy the binary from the previous stage. It will look like
    this:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Using the previous code, we will build a new image:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can now verify that `helloworld:latest` works as expected and that it will
    just contain the `/myapp/helloworld` binary on top of a clean `alpine:latest`
    image:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we will list the images in order to review the image we created recently:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Deploying a local registry
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lab, we will run a local registry and push/pull an image. Let''s get
    started:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll deploy a registry using the official Docker Registry image. We
    will launch it on the standard registry port, `5000`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we need to download a simple `alpine:latest` image (if you don''t already
    have one):'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, we need to add a new tag to this image to be able to upload it to our
    local registry, which is running on port `5000`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We will use `docker image tag <ORIGINAL_TAG> <NEW_TAG>` to add names and tags
    to images. This will add new names and tags; the old ones will stay until they
    are removed. We will use `docker image rm` to remove image names and tags. This
    will remove only the names and tags passed as arguments. Other images associated
    with the same ID will remain until they are specifically removed. If we create
    a new build, some layers will be un-referenced and even pushed out of any image
    construction chain.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We can remove all the images associated with a specific ID using `docker image
    rm --force <IMAGE_ID>`. All image names and tags associated with it will be removed.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Unreferenced images, also known as **dangling** images, should be removed, especially
    on image-building hosts. These are common in CI/CD environments where we assign
    some nodes to this process. We will use `docker image prune` to execute this image's
    housekeeping.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we push the image to our local registry:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To ensure that no other alpine image is present, we remove it by its ID:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We remove this ID and all its children (the IDs may vary):'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we run a container using the `localhost:5000/my-alpine:latest` image:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we used the image we downloaded from our `localhost:5000` registry.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, Docker Registry is insecure by default. It is easy
    to deploy but we will need authentication and authorization in production. Authentication
    can be deployed using a frontend proxy with validation. NGINX can be deployed
    even with basic authentication and can also provide TLS certificate encryption.
    Authorization is not as easy, so Docker Trusted Registry is a better solution.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we published our registry on local port `5000`. The application
    container will restart if the main process dies and the image's data will be stored
    on the host under the `/var/lib/docker/volumes/REGISTRY_DATA/_data` directory.
    We have used the `REGISTRY_DATA` named volume, so the registry data will remain
    even if we remove the `registry` container.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry can be configured to use different storage backends. We will
    learn about this feature regarding DTR in [Chapter 13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml),
    *Implementing an Enterprise-Grade Registry with DTR*. Docker Registry can be configured
    using the `/etc/docker/registry/config.yml` file. To deploy a localhost configuration
    file under the current directory, we will use `$(pwd)/config.yml:/etc/docker/registry/config.yml`.
    This will integrate a custom file as a bind-mount volume.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we remove the registry we deployed:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Image templating using Dockerfiles
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab will show us how we can build images for different environments by
    adding some debugging tools, for example, to debug a container's processes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named `templating` inside the `chapter2` directory:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We will have a couple of images: one for production and one for development.
    We will build each one with its own Dockerfile; in this case, we will use a simple
    `nginx:alpine` image as the basis for both:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Development – `Dockerfile.nginx-dev`:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Production – `Dockerfile.nginx`:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s build both images:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'We build both images as `baseimage:development` and `baseimage:production`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we can review the image''s sizes. These are pretty different because the
    debugging image has `curl` and `httpie` for testing (this is an example lab).
    We will use these images to launch debugging tools in order to review a container''s
    processes or against other components:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can build our application image for development and production environments
    using the `ENVIRONMENT` variable and a templated `Dockerfile.application` file:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we simply prepare a simple text file named `index.html` with some content
    inside the `html` directory:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, we just compile both images for the `DEV` and `PROD` environments.
    For development, we use the `ENVIRONMENT` argument, as follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For the production environment, we will do the same:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With this lab, we built different images using just one Dockerfile. Arguments
    will change the building process.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter guided us in terms of building container images. We learned about
    all the building steps and tips and tricks that will help us to ensure we have
    security in images. Building good and secure images is key for production and,
    as we learned, having good base images will help us build better application images.
    We will reuse many layers, so it is safer to ensure security from the bottom to
    the top. To ensure security, we just need to add the requisite software, expose
    the required processes, and avoid the root processes if they are not required.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to store images and their meta-information using code versioning-like
    tags to ensure that the correct image is running in production.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to implement templates to create images for different
    environments or stages on CI/CD pipelines.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to run containers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we uniquely identify an image?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) All images with their tags are unique
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: b) The image ID is what really makes an image unique; we can have an image ID
    with many names and tags, but they will all reference the same layers and meta-information
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: c) Only base images on the root registry namespace are unique because all other
    images are based on these
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: d) All the preceding answers are correct
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Which methods can be used to create container images?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We can build images from containers, committing their read-write layers on
    top of read-only ones
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: b) We can use a Dockerfile, starting with a base image
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: c) We can start from an empty one, known as scratch
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Which image creation methods are reproducible?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Committing containers to images is reproducible because we know which steps
    we followed
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: b) Using Dockerfiles, we will ensure that the requisite steps are written and
    that the creation process is reproducible
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: c) There is no reproducible method for creating images
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above options are incorrect
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Which Dockerfile instructions admit Shell and Exec formats?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `RUN`
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: b) Only `CMD`
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: c) `ENTRYPOINT` and `CMD`
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: d) All Dockerfile instructions admit both Exec and Shell formats
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: How can we avoid using command arguments when launching a container based on
    an image?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We can avoid user modification of the main process arguments and parameters
    by using the shell format for `ENTRYPOINT`
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: b) It is never possible to modify the container main process
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: c) It is always possible to modify the main container process arguments, irrespective
    of the `ENTRYPOINT` format used
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: d) None of the above options are correct
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on topics covered
    in this chapter:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Multi-architecture images using new builds: [https://www.docker.com/blog/multi-arch-images/](https://www.docker.com/blog/multi-arch-images/)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dockerfile best practices: [https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/](https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dockerfile reference: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
