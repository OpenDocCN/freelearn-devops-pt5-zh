<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Managing Secrets in Docker Swarm Clusters</h1>
            </header>

            <article>
                
<p><em>Docker 1.13</em> introduced a set of features that allow us to centrally manage secrets and pass them only to services that need them. They provide a much-needed mechanism to provide information that should be hidden from anyone except designated services.</p>
<p>A secret (at least from Docker's point of view) is a blob of data. A typical use case would be a certificate, SSH private keys, passwords, and so on. Secrets should stay secret meaning that they should not be stored unencrypted or transmitted over a network.</p>
<p>With all that being said, let's see them in action and continue our discussion through practical examples.</p>
<p>All the commands from this chapter are available in the <kbd>14-secrets.sh</kbd> (<a href="https://gist.github.com/vfarcic/906d37d1964255b40af430bb03d2a72e">https://gist.github.com/vfarcic/906d37d1964255b40af430bb03d2a72e</a>) Gist.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating secrets</h1>
            </header>

            <article>
                
<p>Since a single node is more <span>than enough to demonstrate Docker secrets, we'll start by creating a one node Swarm cluster based on Docker Machines:</span></p>
<pre>
<strong>docker-machine create \</strong><br/><strong>    -d virtualbox \</strong><br/><strong>    swarm </strong><br/><strong>eval $(docker-machine env swarm) <br/></strong><br/><strong>docker swarm init \</strong><br/><strong>    --advertise-addr $(docker-machine ip swarm)</strong>
</pre>
<div class="packt_tip"><strong>A note to Windows users</strong><br/>
The recommendation is to run all the examples from <em>Git Bash</em> (installed through <em>Docker Toolbox</em> as well as <em>Git</em>). That way the commands you'll see throughout the book will be same as those that should be executed on <em>OS X</em> or any <em>Linux</em> distribution.</div>
<p>We created a Docker Machine node called swarm and used it to initialize the cluster.</p>
<p>Now we can create a secret.</p>
<div class="packt_tip"><strong>A note to Windows users</strong><br/>
For mounts (a secret is a mount as well) used in the next command to work, you have to stop Git Bash from altering file system paths. Set this environment variable.<br/>
<kbd>export MSYS_NO_PATHCONV=1</kbd></div>
<p>The format of the command that creates a secret is as follows (please do not run it):</p>
<pre>
<strong>docker secret create [OPTIONS] SECRET file|-</strong>
</pre>
<p>The <kbd>secret create</kbd> command expects a file that contains a secret. However, creating a file with unencrypted secret defies the purpose of having secrets in the first place. Everyone can read that file. We could, delete the file after pushing it to Docker but that would only create unnecessary steps. Instead, we'll use <kbd>-</kbd> that will allow us to pipe standard output:</p>
<pre>
<strong><span class="hljs-built_in">echo</span> <span class="hljs-string">"I like candy"</span> \<br/>    | docker secret create my_secret -</strong>
</pre>
<p>The command we just executed created a secret called <kbd>my_secret</kbd>. That information was sent to the remote Docker Engine using TLS connection. If we had a bigger cluster with multiple managers, the secret would be replicated among all.</p>
<p>We can inspect the newly created secret:</p>
<pre>
<strong>docker secret inspect my_secret</strong>
</pre>
<p>The output is as follows:</p>
<pre>
<strong>[<br/>    {<br/>        "<span class="hljs-attribute">ID</span>": <span class="hljs-value"><span class="hljs-string">"9iqwc8zb7xum7krgm183t4mym"</span></span>,<br/>        "<span class="hljs-attribute">Version</span>": <span class="hljs-value">{<br/>            "<span class="hljs-attribute">Index</span>": <span class="hljs-value"><span class="hljs-number">11</span><br/></span>}</span>,<br/>        "<span class="hljs-attribute">CreatedAt</span>": <span class="hljs-value"><span class="hljs-string">"2017-02-20T23:00:48.983267019Z"</span></span>,<br/>        "<span class="hljs-attribute">UpdatedAt</span>": <span class="hljs-value"><span class="hljs-string">"2017-02-20T23:00:48.983267019Z"</span></span>,<br/>        "<span class="hljs-attribute">Spec</span>": <span class="hljs-value">{<br/>            "<span class="hljs-attribute">Name</span>": <span class="hljs-value"><span class="hljs-string">"my_secret"</span><br/></span>}<br/></span>}<br/>]</strong>
</pre>
<p>The value of the secret is hidden. Even if a malicious person gains access to Docker Engine, the secret would still be unavailable. Truth be told, in such a case, our worries would be much greater that protection of a Docker secret but I'll leave that discussion for some other time.</p>
<p>Now that we have encrypted the secret and stored in Swarm managers, we should explore ways to utilize it within our services.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Consuming secrets</h1>
            </header>

            <article>
                
<p>A new argument <kbd>--secret</kbd> was added to the <kbd>docker service create</kbd> command. If a secret is attached, it will be available as a file in the <kbd>/run/secrets</kbd> directory inside all the containers that form a service.</p>
<p>Let's see it in action:</p>
<pre>
<strong>docker service create --name test \<br/>    --secret my_secret \<br/>    --restart-condition none \<br/>    alpine cat /run/secrets/my_secret</strong>
</pre>
<p>We created a service called test and attached the secret called <kbd>my_secret</kbd>. The service is based on <kbd>alpine</kbd> and will output the content of the secret. Since it is a one-shot command that will terminate quickly, we set <kbd>--restart-condition</kbd> to <kbd>none</kbd>. Otherwise, the service would terminate a moment after it's created, Swarm would reschedule it, only to see it terminate again, and so on. We would enter a never-ending loop.</p>
<p>Let's take a look at the logs:</p>
<pre>
<strong>docker logs $(docker container ps -qa)</strong>
</pre>
<p>The output is as follows:</p>
<pre>
<strong><span class="hljs-keyword">I</span> like candy</strong>
</pre>
<p>The secret is available as the <kbd>/run/secrets/my_secret</kbd> file inside the container.</p>
<p>Before we start discussing a more real-world example, let us remove the service and the secret we created:</p>
<pre>
<strong>docker service rm test<br/><br/>docker secret rm my_secret</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">A real-world example of using secrets</h1>
            </header>

            <article>
                
<p>The <em>Docker Flow Proxy </em>(<a href="http://proxy.dockerflow.com/">http://proxy.dockerflow.com/</a>) project exposes statistics that should be reserved for internal use only. Therefore, it needs to be protected with a <kbd>username</kbd> and <kbd>password</kbd>. Before <em>Docker v1.13</em>, situations like that one would be handled by allowing users to specify username and password through environment variables. <em>Docker Flow Proxy</em> is no exception and, indeed, has the <em>environment variables </em>(<a href="http://proxy.dockerflow.com/config/#environment-variables">http://proxy.dockerflow.com/config/#environment-variables</a>) <kbd>STATS_USER and STATS_PASS</kbd>.</p>
<p>The command that would create the service with custom <kbd>username</kbd> and <kbd>password</kbd> would be as follows:</p>
<pre>
<strong>docker network create --driver overlay proxy<br/><br/>docker service create --name proxy \<br/>    -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \<br/>    -p <span class="hljs-number">443</span>:<span class="hljs-number">443</span> \<br/>    -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> \<br/><span class="hljs-operator">-e</span> STATS_USER=my-user \<br/><span class="hljs-operator">-e</span> STATS_PASS=my-pass \<br/>    --network proxy \<br/><span class="hljs-operator">-e</span> MODE=swarm \<br/>    vfarcic/docker-flow-proxy</strong>
</pre>
<p>While that would protect the statistics page from ordinary users, it would still leave it exposed to anyone capable of inspecting the service. A simple example is as follows:</p>
<pre>
<strong>docker service inspect proxy --pretty</strong>
</pre>
<p>The relevant part of the output is as follows:</p>
<pre>
<strong><span class="hljs-keyword">...</span><br/>ContainerSpec:<br/> Image:     vfarcic/docker-flow-proxy:latest@sha256:b1014afa9706413818903671086e484d98db669576b83727801637d1a3323910<br/> Env:       STATS_USER=my-user STATS_PASS=my-pass MODE=swarm<br/><span class="hljs-keyword">...</span></strong>
</pre>
<p>The same result that does not reveal confidential information could be accomplished with the commands that follow:</p>
<pre>
<strong><span class="hljs-built_in">echo</span> <span class="hljs-string">"secret-user"</span> \<br/>    | docker secret create dfp_stats_user -<br/><br/><span class="hljs-built_in">echo</span> <span class="hljs-string">"secret-pass"</span> \<br/>    | docker secret create dfp_stats_pass -<br/><br/>docker service update \<br/>    --secret-add dfp_stats_user \<br/>    --secret-add dfp_stats_pass \<br/>    proxy</strong>
</pre>
<p>We created two secrets <kbd>dfp_stats_user and dfp_stats_pass</kbd> and updated our service. From now on, those secrets would be available inside service containers as files <kbd>/run/secrets/dfp_stats_user</kbd> and <kbd>/run/secrets/dfp_stats_pass</kbd>. If a secret is named the same as the environment variable, is in lower case, and has the <kbd>dpf_ prefix</kbd>, it will be used instead.</p>
<p>If you inspect the container one more time, you'll notice that there is no trace of the secrets.</p>
<p>We could stop here. After all, there's not much more to be said for Docker secrets. However, we got used to Docker stacks and it would be great if secrets would work in the new YAML Compose format.</p>
<p>Before we move on, let's remove the <kbd>proxy</kbd> service:</p>
<pre>
<strong>docker service rm proxy</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using secrets with Docker Compose</h1>
            </header>

            <article>
                
<p>True to the mission to have the same features available in all supported flavours, Docker introduced secrets in Compose YAML format <em>version 3.1</em>.</p>
<p>We'll continue using <em>Docker Flow Proxy</em> to demonstrate how secrets work inside Compose files:</p>
<pre>
<strong>curl -o dfp.yml \<br/>    https://raw.githubusercontent.com/vfarcic/\<br/>docker-flow-stacks/master/proxy/docker-flow-proxy-secrets.yml</strong>
</pre>
<p>We downloaded the <kbd>docker-flow-proxy-secrets.yml</kbd> (<a href="https://github.com/vfarcic/docker-flow-stacks/blob/master/proxy/docker-flow-proxy-secrets.yml">https://github.com/vfarcic/docker-flow-stacks/blob/master/proxy/docker-flow-proxy-secrets.yml</a>) stack from the <kbd>vfarcic/docker-flow-stacks</kbd> (<a href="https://github.com/vfarcic/docker-flow-stacks">https://github.com/vfarcic/docker-flow-stacks</a>) repository.</p>
<p>The relevant parts of the definition of the stack are as follows:</p>
<pre>
<strong><span class="hljs-attribute">version</span>: <span class="hljs-string">"3.1"</span><br/><br/><span class="r"><span class="hljs-keyword">...</span><br/><br/>services:<br/><br/>  proxy:<br/>    image: vfarcic/docker-flow-proxy:${TAG:-latest}<br/>    ports:<br/>      - <span class="hljs-number">80</span>:<span class="hljs-number">80</span><br/>      - <span class="hljs-number">443</span>:<span class="hljs-number">443</span><br/>    networks:<br/>      - proxy<br/>    environment:<br/>      - LISTENER_ADDRESS=swarm-listener<br/>      - MODE=swarm<br/>    secrets:<br/>      - dfp_stats_user<br/>      - dfp_stats_pass<br/>    deploy:<br/>      replicas: <span class="hljs-number">3</span><br/><br/><span class="hljs-keyword">...</span><br/><br/>secrets:<br/>  dfp_stats_user:<br/>    external: true<br/>  dfp_stats_pass:<br/>    external: true</span></strong>
</pre>
<p>The version of the format is <kbd>3.1</kbd>. The <kbd>proxy</kbd> service has the two secrets attached. Finally, there is a separate <kbd>secrets</kbd> section that defines the <kbd>secrets</kbd> as <kbd>external</kbd> entities. The alternative would be to specify secrets internally.<br/>
An example would be as follows:</p>
<pre>
<strong>secrets:<br/>    dfp_stats_user:<br/>        external: <span class="hljs-constant">true</span><br/>    dfp_stats_pass:<br/>        external: <span class="hljs-constant">true</span><br/>secrets:<br/> dfp_stats_user:<br/><span class="hljs-built_in">    file</span>: ./dfp_stats_user.txt<br/> dfp_stats_pass:<br/><span class="hljs-built_in">    file</span>: ./dfp_stats_pass.txt</strong>
</pre>
<p>I prefer the first option that specifies secrets externally since that does not leave any trail. In some other cases, secrets might be used for non-secretive information (we'll discuss it soon) and using internal secrets specified as files would probably be a better option.</p>
<p>Let's run the <kbd>stack</kbd> and check whether it works:</p>
<pre>
<strong>docker stack deploy -c dfp.yml proxy</strong>
</pre>
<p>Statistics themselves are useless if there is no data so we'll deploy another service that will be reconfigured in the <kbd>proxy</kbd> and <kbd>start</kbd> generating some stats:</p>
<pre>
<strong>curl -o go-demo.yml \<br/>    https://raw.githubusercontent.com/vfarcic/\<br/>go-demo/master/docker-compose-stack.yml<br/><br/>docker stack deploy -c go-demo.yml go-demo</strong>
</pre>
<p>Please wait a few moments until the services from the <kbd>go-demo</kbd> stack are running. You can check their status by executing <kbd>docker stack ps go-demo</kbd>. You might see <kbd>go-demo_main</kbd> replicas in the failed status. Do not panic. They will continue failing only until the <kbd>go-demo_db</kbd> is starts running.</p>
<p>Now we can, finally, confirm that the <kbd>proxy</kbd> is configured to use secrets for authentication:</p>
<pre>
<strong>curl -u secret-user:secret-pass \<br/><span class="hljs-string">"http://<span class="hljs-variable">$(docker-machine ip swarm)</span>/admin?stats;csv;norefresh"</span></strong>
</pre>
<p>It works! With only a single additional step <kbd>docker service create</kbd>, we made our system more secured</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Common ways to use secrets</h1>
            </header>

            <article>
                
<p>Until secrets were introduced, a common way to pass information to containers was through environment variables. While that will continue being the preferable way for non-confidential information, part of the setup should involve secrets as well. Both should be combined. The question is which method to choose and when.</p>
<p>The obvious use case for Docker secrets are secrets. That was obvious, wasn't it. If there is a piece of information that should remain invisible to anyone but specific containers, it should be provided through Docker secrets. A commonly used pattern is to allow the same information to be specified as either environment variable and a secret. In case that both a set, secrets should take precedence. You already saw this pattern through <em>Docker Flow Proxy</em>. Every piece of information that can be specified through environment variables can be specified as a secret as well.</p>
<p>In some cases, you might not be able to modify code of your service and adapt it to use secrets. Maybe it's not a question of ability but lack of desire to modify your code. If you fall into the latter case, I will, for now, restrain myself from explaining why code should be continuously refactored and imagine that you have a very good reason for it. In either case, the solution is usually to create a wrapper script that transforms secrets into whatever your service needs and then invoke the service. Put that script as CMD instruction in <em>Dockerfile</em> and you're done. Secrets stay secrets and you don't get fired from refactoring your code. To some this last sentence sounds silly but it's not uncommon for companies to consider refactoring a waste of time.</p>
<p>What should be a secret? No one can truly answer that question for you since it differs from one organization to another. Some of the examples would be usernames and passwords, SSH keys, SSL certificates, and so on. If you don't want others to know about it, make it a secret.<br/>
<br/>
We should strive for immutability and do our best to run containers that are exactly the same no matter where they run. True immutability means that even the configuration is always the same across all environments. However, that is not always easy and is sometimes even impossible to accomplish. Such a situation could be a good candidate for Docker secrets. They do not necessarily have to be used only as means of specifying confidential information. We can use secrets as a way to provide information that differs from one cluster to another. In such a case, pieces of configuration that should differ from one environment to another (example: staging and production clusters) can be stored as secrets.</p>
<p>I am certain that there are quite a few other use cases I didn't even think about. After all, secrets are a new feature (a few weeks old from the day of this writing).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">What now?</h1>
            </header>

            <article>
                
<p>Remove your Docker Machine VM and start applying secrets to your own Swarm cluster. There's not much more to be said (for now):</p>
<pre>
<strong>docker-machine rm <span class="hljs-operator">-f</span> swarm</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>