- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating Non-Standard Platforms and Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have learned about the different systems and platforms (managed
    nodes) such as Linux systems, Microsoft Windows systems, network devices, and
    cloud platforms, all of which can be automated using Ansible. You have used different
    methods and protocols to connect to the target system or platform to execute the
    automated operations. You do not need to understand how complex operations are
    running inside these systems because Ansible will understand and take appropriate
    actions on the target systems to reach the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: What if there are no standard Ansible modules or connection methods available
    for a specific operation on the managed node? Or what if the module is missing
    some feature you are looking for? For example, let’s say you want to automate
    a machine that doesn’t have the supported Python version installed, and you want
    to use Ansible to automate this Python installation or run raw commands on a firewall
    device that does not have an appropriate module available.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ansible is flexible and modular, you have multiple ways to overcome these
    challenges. In this chapter, you will learn how to automate such non-standard
    operations using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing low-down raw commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw commands for network operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using API calls for automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom modules for Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with the Ansible `raw` module and the lifesaving situations where
    the `raw` module helps automate non-standard use cases. Then, you will learn how
    to use API calls to automate operations when Ansible modules or SSH-based connections
    are not available. You will also explore custom Ansible modules and how to develop
    simple custom modules using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux machine for the Ansible control node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of commands for network devices (for example, FortiOS and Cisco
    ASA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of REST API endpoints and their usages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of bash scripting and the Python programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the Ansible artifacts, commands, and snippets for this chapter can be found
    in this book’s GitHub repository at [https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-15](https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-15).
  prefs: []
  type: TYPE_NORMAL
- en: Executing low-down raw commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you have learned about different Ansible modules and collections for
    developing automation content. Most of these modules expect a supported Python
    version on the target node (or PowerShell for Microsoft Windows) to execute the
    automation scripts in the backend (refer to Ansible’s managed node requirements
    documentation for more details: [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements)).
    When there is no required Python version or packages available, then you need
    to install it manually (or using some scripts) on every node before Ansible can
    automate the tasks on that nodes. When several managed nodes need to onboard to
    Ansible, then it will be a tedious task to log into each node and install these
    dependencies manually. In such situations, it is possible to execute the raw commands
    (such as the ones you use inside a bash script or PowerShell script) to install
    and configure the systems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before using the low-down raw commands, please note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Low-down raw commands are the same commands that you use inside the system to
    handle the operations manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These low-down raw commands will not go through the Ansible module system; instead,
    they will be executed through the configured remote shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to assume the output, success, and error conditions of the commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to automate such operations via Ansible by executing low-down
    raw commands using the `ansible.builtin.raw` module.
  prefs: []
  type: TYPE_NORMAL
- en: The Difference in Ansible Network Automation
  prefs: []
  type: TYPE_NORMAL
- en: We cannot install Python on network devices. Because of that, network automation
    is different in the backend. Refer to [*Chapter 6*](B18383_06.xhtml#_idTextAnchor105),
    *Automating Microsoft Windows and Network Devices*, to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: The `ansible.builtin.raw` module helps execute raw commands on the target nodes
    over an SSH connection. It is not a best practice to use raw commands on the target
    nodes as the command’s result will not be predictable; therefore, Ansible will
    not be able to handle the validations and errors like other standard modules.
    However, the `ansible.builtin.raw` module is useful for some special cases, as
    you’ll learn in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python using the raw module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned in the introduction of this chapter, what if your managed node
    doesn’t have Python installed and you want to use Ansible to automate the Python
    installation? Let’s learn how to create a playbook for installing Python using
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: We assume that the required package repositories have been configured on the
    target node as per standard system configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the sample playbook for installing and verifying
    the Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Playbook for installing and verifying Python using the raw
    module ](img/B18383_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Playbook for installing and verifying Python using the raw module
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `gather_facts: false` line in the preceding screenshot; this is a
    fact-gathering task that relies on Python. The playbook will not work otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook’s installation output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Output of the Python installation playbook ](img/B18383_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Output of the Python installation playbook
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Python installed on the target nodes, use any other Ansible modules
    as usual. The `ansible.builtin.raw` module also supports Windows, network, and
    firewall devices for executing low-down raw commands.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Raw Module
  prefs: []
  type: TYPE_NORMAL
- en: The raw module is part of `ansible-core` and is included in your installation
    by default. Refer to the documentation at [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/raw_module.xhtml](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/raw_module.xhtml)
    to learn more. As mentioned earlier, the `raw` modules are only used in special
    situations; otherwise, use the `ansible.builtin.shell` or `ansible.builtin.command`
    module to execute shell commands (check out the alternative `ansible.windows.win_command`
    and `ansible.windows.win_shell` modules for Windows machines).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use the `ansible.builtin.raw` module
    for network automation when there are no appropriate modules available to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using raw commands for network operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible has a large collection of modules and plugins to support most of the
    well-known network and firewall devices. The following figure shows some of the
    supported network devices and brands for network automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Supported brands for Ansible network automation (source: https://www.ansible.com/integrations/networks)
    ](img/B18383_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3 – Supported brands for Ansible network automation (source: https://www.ansible.com/integrations/networks)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there will be situations where you must overcome the following challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: No supported Ansible module is available to execute a specific network or firewall
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a module available for operation but the specific feature or parameter
    you are looking for doesn’t exist in the current module version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The supported module for the operation is using a slow method compared to the
    CLI command on the device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network Collections in the Ansible Collection Index
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation page at [https://docs.ansible.com/ansible/latest/collections/index.xhtml](https://docs.ansible.com/ansible/latest/collections/index.xhtml)
    to see the network collections in the Ansible collection index.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome such situations, use the same `ansible.builtin.raw` module and execute
    the raw commands on the target network devices over an SSH connection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use the `ansible.builtin.raw` module
    to execute the necessary operations in FortiOS and Cisco devices, such as taking
    a configuration backup, upgrading software, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Backup FortiOS configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fortinet.fortios` Ansible collection contains more than 600 modules for
    managing and operating devices or appliances with FortiOS. Let’s look at a simple
    operation, such as taking a configuration backup from a FortiOS device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the inventory variables for the FortiOS device
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Inventory variables for the FortiOS connection ](img/B18383_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Inventory variables for the FortiOS connection
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `fortinet.fortios.fortios_monitor_fact` to collect and save the
    backup to a system, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Backing up FortiOS using the fortios_monitor_fact module ](img/B18383_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Backing up FortiOS using the fortios_monitor_fact module
  prefs: []
  type: TYPE_NORMAL
- en: Ansible fortinet.fortios Collection
  prefs: []
  type: TYPE_NORMAL
- en: Find the modules and plugin containers in the `fortinet.fortios` Ansible collection
    at [https://galaxy.ansible.com/fortinet/fortios](https://galaxy.ansible.com/fortinet/fortios).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the configuration backup needs to be transferred to the file server
    (for example, a TFTP server) securely using another task in Ansible. Some organizations
    may want to follow the standard and legacy way of backing up, which involves backing
    up from the device itself without copying to the Ansible control node (or automation
    controller). In such cases, use the `raw` module to execute the raw commands,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – FortiOS backup using raw commands ](img/B18383_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – FortiOS backup using raw commands
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used raw CLI commands to copy the configurations
    directly to the TFTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to modify the inventory variables to use the default SSH connection
    instead of `ansible.netcommon.httpapi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Inventory variables for the FortiOS connection without httpapi
    ](img/B18383_15_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Inventory variables for the FortiOS connection without httpapi
  prefs: []
  type: TYPE_NORMAL
- en: Ansible will use the default SSH connection and execute the raw commands on
    the target FortiOS device.
  prefs: []
  type: TYPE_NORMAL
- en: FortiOS software upgrade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at another example of a FortiOS software upgrade or patching.
    We have a module called `fortios_system_federated_upgrade` to do this task in
    the standard Ansible way. However, this module needs the new software image to
    be uploaded from the localhost (which is the Ansible control node or the Ansible
    execution environment), so first, you need to copy this image from some location
    to the localhost. Also, if there is a restriction in the network stopping you
    from copying large images such as firmware files, then the only choice is to execute
    the legacy raw commands inside the FortiOS device, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Running the FortiOS software upgrade using the raw module ](img/B18383_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Running the FortiOS software upgrade using the raw module
  prefs: []
  type: TYPE_NORMAL
- en: The `execute restore image` command will ask you to confirm the image upgrade;
    `Y` on the second line is the input to that confirmation question.
  prefs: []
  type: TYPE_NORMAL
- en: The `fortios_system_federated_upgrade` module will take care of all such confirmations
    and programmatic upgrades. Keep in mind that the raw command method should only
    be followed in special cases.
  prefs: []
  type: TYPE_NORMAL
- en: Raw commands on Cisco devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similarly, it is possible to use raw commands on any device that supports an
    SSH connection. Let’s take a look at another example for Cisco ASA device backup.
  prefs: []
  type: TYPE_NORMAL
- en: The `cisco.asa.asa_config` module is part of the `cisco.asa` Ansible collection
    ([https://galaxy.ansible.com/cisco/asa](https://galaxy.ansible.com/cisco/asa)).
    Use this module to configure the Cisco ASA device and take a configuration backup
    in the standard Ansible way. However, the backup will be downloaded to your `localmachine`
    (Ansible control node or the Ansible execution environment), so it will need to
    be transferred to the destination file server (for example, a TFTP server). The
    backup may contain sensitive information, so the organization may prefer to copy
    the backup directly to the TFTP server (or other supported target file servers).
  prefs: []
  type: TYPE_NORMAL
- en: 'In such situations, utilize the same `ansible.builtin.raw` module to execute
    the Cisco ASA commands on the target Cisco devices. But before you use the `ansible.builtin.raw`
    module, you need to check the respective Ansible collection (for example, the
    `cisco.asa` collection here) for any modules to execute the raw network commands
    in the Ansible way. In this case, the `cisco.asa.asa_command` module can be used
    to execute the Cisco ASA raw commands, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Cisco ASA backup using raw commands ](img/B18383_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Cisco ASA backup using raw commands
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can utilize the `cisco.ios.ios_command` and `cisco.nxos.nxos_command`
    modules on Cisco IOS and Cisco Nexus OS devices, respectively. If there is no
    device-specific module available to execute raw commands, then utilize `ansible.builtin.raw`,
    as you learned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The raw module can be used on any device that supports SSH and command-line
    execution. But for devices or platforms that don’t support SSH connections, or
    no such commands are available, then it is possible to use API calls. In the next
    section, you will learn how to use API calls to automate operations from Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Using API calls for automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18383_06.xhtml#_idTextAnchor105), *Automating Microsoft Windows
    and Network Devices*, you learned about the different ways Ansible can talk to
    managed nodes, platforms, or applications. So as long as there is a supported
    method to access the target system, it is possible use Ansible to automate these
    tasks. In the previous chapters, you learned about the integration between Ansible
    and other tools such as Jira, ServiceNow, Kubernetes, public or private cloud
    platforms, and so on. For such platforms, most of those modules use HTTP/HTTPS
    API calls to execute operations. This means that if there are no modules available
    to automate your operations but there is an API method, you can use the same raw
    API calls from your Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Python SDK and API Calls
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that not all modules use direct or native API calls to execute
    the operations; some modules use Python libraries and `fortiosapi` Python library,
    but now, `httpapi` is the preferred way to execute the playbooks. Read more about
    **the httpapi** plugins at https://docs.ansible.com/ansible/latest/plugins/httpapi.xhtml.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `amazon.aws.ec2_instance_info` module (part of the Ansible
    `amazon.aws` collection) helps gather information about EC2 instances in AWS.
    Its usage is straightforward, as shown in the following screenshot, and you do
    not need to worry about the complex API calls to the AWS EC2 endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Gathering AWS EC2 information using amazon.aws.ec2_instance_info
    module ](img/B18383_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Gathering AWS EC2 information using amazon.aws.ec2_instance_info
    module
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume you have a requirement to collect some additional requirement that
    is not available as part of the module’s output. In this case, it is also possible
    to use the AWS EC2 API endpoints ([https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Welcome.xhtml](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Welcome.xhtml))
    to utilize the full features of API calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will learn how to use API calls from Ansible
    to automate the platform or applications.
  prefs: []
  type: TYPE_NORMAL
- en: Automating a ToDo app using Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will automate a simple ToDo application using the API provided.
    This demonstration will help you understand how to make API calls using Ansible
    and how to handle the API call output appropriately. This section will help you
    understand how to handle API calls for any other service (for example, the cloud,
    network devices, software applications, and so on) by following the product’s
    API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Ansible uri module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ansible.builtin.uri` module is used to interact with the HTTP and HTTPS
    endpoints and implement web-related operations using Ansible. The `ansible.builtin.uri`
    module supports multiple authentication mechanisms, such as Digest, Basic, and
    WSSE HTTP ([https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml)).
    The `ansible.builtin.uri` module can be used for several use cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling an AWS API service to fetch EC2 instance details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a Jira API to update a ticket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching details from a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying a web service health check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s learn how to use the `ansible.builtin.uri` module to interact with
    a ToDo application API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you have a ToDo application running, and the API is available at [http://todo-app.example.com:8081/api](http://todo-app.example.com:8081/api)
    without any authentication. Test the API using the default `curl` command, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Testing the ToDo API’s access ](img/B18383_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – Testing the ToDo API’s access
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use Ansible and the `ansible.builtin.uri` module ([https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml))
    to handle the ToDo application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you have `Chapter-15/todo-app.yaml` (refer to the GitHub repository)
    whose content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – ToDo app playbook details ](img/B18383_15_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – ToDo app playbook details
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hosts: localhost`: This is used because we are running this API call from
    a localhost machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gather_facts: false`: This is used because we do not require any facts from
    `localhost` (enable this if there is a requirement to use Ansible facts).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`become: false`: This is used because the API calls don’t require privileged
    access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `method` parameter uses `GET` as the default value in the `uri` module.
    Since we are fetching the data from a URL, the default GET HTTP method will be
    used in the following example. The first task is to fetch the health status of
    the API and then print the output with a debug module, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – API health check task ](img/B18383_15_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – API health check task
  prefs: []
  type: TYPE_NORMAL
- en: 'The `status_code: 200` parameter helps validate the API call and task success
    since you are expecting `OK success status`; you do not need to add additional
    validation tasks. If the status code is anything other than `200`, the task will
    fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the sample output for when you execute the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – API health check sample output ](img/B18383_15_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – API health check sample output
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only need the returned content (result) of the API call, then modify
    the `msg` parameter by setting it to `msg: “{{ health_status.content }}”`. By
    doing this, you will get a more accurate result, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – API call returned content ](img/B18383_15_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – API call returned content
  prefs: []
  type: TYPE_NORMAL
- en: The `uri` call will return detailed JSON output. Filter out the content as needed.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Request Methods
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the API or the web endpoint, different HTTP methods will be available,
    such as GET, POST, PUT or DELETE. Refer to [https://www.w3schools.com/tags/ref_httpmethods.asp](https://www.w3schools.com/tags/ref_httpmethods.asp)
    to understand more about HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task is to fetch the items in the ToDo list, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – Fetching the items in the ToDo app using the API ](img/B18383_15_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – Fetching the items in the ToDo app using the API
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the playbook, you will get the list of ToDo items, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 – ToDo items fetched using the API call ](img/B18383_15_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 – ToDo items fetched using the API call
  prefs: []
  type: TYPE_NORMAL
- en: The individual items can be handled by filtering the JSON output. This will
    allow you to retrieve the exact content as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For creating or updating new items, use the `POST HTTP` method, along with
    content to post and other details as needed. Let’s add a new item to the ToDo
    list by using the `POST` method and the `body` content. The first step is to prepare
    the data to post. In this case, you have a dictionary variable called `new_item`
    that contains item details, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18 – Variable for the new ToDo item ](img/B18383_15_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.18 – Variable for the new ToDo item
  prefs: []
  type: TYPE_NORMAL
- en: 'The task to `POST` the content to the ToDo list requires a few more parameters,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19 – Adding a new task to the ToDo app via an API call ](img/B18383_15_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.19 – Adding a new task to the ToDo app via an API call
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`status_code: 201`-`201` is the status code for `created`. If you do not mention
    `status_code`, Ansible will use a value of `200` (default) and the task will show
    as failed (for example, `"msg": "Status code was 201 and not [200]: OK (unknown
    bytes)"`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body_format: json`: The default value is `raw`. This is where you are passing
    the JSON formatted input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the sample output for the tasks when you execute
    the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.20 – Output of the tasks ](img/B18383_15_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.20 – Output of the tasks
  prefs: []
  type: TYPE_NORMAL
- en: This simple demonstration explains the different ways to interact with an API
    endpoint using Ansible. Depending on the API endpoint you want to manage, explore
    more automation use cases and workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the API calls may require you to prepare complex `body` content, and
    in such cases, use Ansible Jinja2 templates; this will be covered in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible uri Module and REST APIs
  prefs: []
  type: TYPE_NORMAL
- en: The `uri` module is a multipurpose module with parameters available for most
    API operations, including credentials, certificates, agent configuration, and
    more. Check out the module documentation at [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Akamai API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume there’s a situation where you want to automate a DNS management
    device such as Akamai and no supported Ansible modules are available. Fortunately,
    the Akamai device provides a simple API endpoint for managing the DNS entries.
    Use the same in Ansible to automate the necessary operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API needs to be input in a complex body format. For that, a Jinja2 template
    called `akamai-url-block-format.j2` can be used, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21 – The Jinja2 template for preparing the Akamai API call body
    ](img/B18383_15_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.21 – The Jinja2 template for preparing the Akamai API call body
  prefs: []
  type: TYPE_NORMAL
- en: 'The `akamai-dns-block.yaml` playbook contains a few variables, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22 – Variables for Akamai DNS blocking ](img/B18383_15_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.22 – Variables for Akamai DNS blocking
  prefs: []
  type: TYPE_NORMAL
- en: Remember to keep the sensitive items (such as credentials) in encrypted format
    using Ansible Vault (or **Credentials** in the Ansible automation controller).
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of DNS entries (`dns_list`) can be converted into the desired format
    using the `template` lookup plugin and passed to the `uri` module (`body: “{{
    dns_list_templated }}”`), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.23 – The Akamai API call using the uri module ](img/B18383_15_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.23 – The Akamai API call using the uri module
  prefs: []
  type: TYPE_NORMAL
- en: You need to add all validation and verification tasks as required before executing
    the API POST calls. Refer to the Akamai documentation ([https://techdocs.akamai.com/home/page/products-tools-a-z](https://techdocs.akamai.com/home/page/products-tools-a-z))
    for the products to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to automate non-supported operations using
    raw commands and API calls. In the next section, you will explore Ansible modules
    and the basic steps to create custom modules for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom modules for Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you learned how to automate operations if the standard
    modules are not available for specific tasks. But modules are the standard way
    of implementing automation and help you develop Ansible playbooks without worrying
    about the complex operations in the backend. If you know the backend operations
    and how to execute the tasks in the backend, then create a module for Ansible
    to execute a specific operation. Finally, contribute it back to the community
    via Ansible collections. That is the way the open source community grows.
  prefs: []
  type: TYPE_NORMAL
- en: Facts to check before creating a custom Ansible module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use any programming language (which can be called by the Ansible API,
    the `ansible` command, or the `ansible-playbook` command), libraries, and methods
    for your new Ansible module. Most of the Ansible modules that you are using now
    are written in the Python programming language. Before developing a new module,
    check yourself on the following facts:'
  prefs: []
  type: TYPE_NORMAL
- en: If the specific task can be completed using an Ansible role, then develop a
    role instead of an Ansible module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the actual execution is happening on the control node (instead of a managed
    node) then create an action plugin instead of a module (read *Developing plugins*
    at [https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml)
    for more details).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are similar modules available, then modify that module, add features,
    and contribute it back to the community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the module you are planning to develop requires a lot of dependencies, then
    try to create it as an Ansible collection with all the dependencies, custom libraries,
    and plugins as required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should You Develop an Ansible Module?
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the Ansible documentation at [https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.xhtml)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using your custom module without an Ansible collection (or as a
    standalone module), then make sure the module script has been copied to the right
    location. The following are the common locations and methods we can use to store
    custom modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `DEFAULT_MODULE_UTILS_PATH` in the Ansible configuration and mention all
    the directories to look for modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the modules to the user’s directory: `~/.ansible/plugins/modules/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the modules to system directory: `/usr/share/ansible/plugins/modules/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ANSIBLE_LIBRARY` environment variable can be configured to set the custom
    module directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the configured module paths for Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.24 – Ansible module path ](img/B18383_15_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.24 – Ansible module path
  prefs: []
  type: TYPE_NORMAL
- en: If the module is used for a specific Ansible role, then store the module inside
    the `library` directory of the role. Ansible will automatically detect the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the module is being used by playbooks and different roles, then store it
    in the `library` directory of the project directory. The following screenshot
    shows an example of `ansible.cfg` with `library` configured:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 15.25 – Library path in ansible.cfg ](img/B18383_15_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.25 – Library path in ansible.cfg
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Module Directory Configuration
  prefs: []
  type: TYPE_NORMAL
- en: Read the documentation at [https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.xhtml)
    to learn more about adding modules and plugins locally.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use simple bash scripts for Ansible
    modules and explore more with Python-based Ansible modules.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Ansible modules using bash scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules are simply reusable scripts for executing a specific task. Before moving
    on, you will need to create a simple bash script and use it as an Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: '`library/customhello.sh` is a simple Bash script that displays the operating
    system, hostname, and a custom message, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.26 – Bash script for an Ansible module ](img/B18383_15_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.26 – Bash script for an Ansible module
  prefs: []
  type: TYPE_NORMAL
- en: Notice the echo line, where the output is formatted as JSON. The module should
    provide a defined interface (that also accepts arguments) and should return the
    result or information to Ansible by printing a JSON string to `stdout` before
    exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a playbook with a task for calling this custom module, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.27 – Ansible playbook with the custom hello module task ](img/B18383_15_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.27 – Ansible playbook with the custom hello module task
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute this playbook, the bash script will be executed in the backend,
    and Ansible will get information from the script, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.28 – Ansible playbook output for the custom module ](img/B18383_15_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.28 – Ansible playbook output for the custom module
  prefs: []
  type: TYPE_NORMAL
- en: This is a very basic concept of an Ansible module and its parameters and variables.
    Expand it as required.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Ansible Modules
  prefs: []
  type: TYPE_NORMAL
- en: Following the best practices will help you create quality Ansible modules that
    can be enhanced when required. Refer to the documentation ([https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml))
    and Ansible module architecture ([https://docs.ansible.com/ansible/latest/dev_guide/developing_program_flow_modules.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_program_flow_modules.xhtml))
    to learn more about developing Ansible modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn more about custom modules by following the
    Ansible module development guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Ansible modules using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a module, follow the best practices as much as possible and
    increase the reusability of the module by adding appropriate documentation, examples
    or expected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the `library/hello_message.py` file in the `Chapter-15` directory of
    this book’s GitHub repository and explore the standard module components inside
    the Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: The script starts with a `ansible_python_interpreter` to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the copyright and other contact information as needed after that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DOCUMENTATION` block is a very important part of the module since it helps
    users understand the usages of this module, such as its available parameters,
    options to use, field types, and so on. The following screenshot shows the documentation
    portion of our custom `hello_message.py` module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 15.29 – Module documentation ](img/B18383_15_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.29 – Module documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EXAMPLES` block contains the sample usage of the module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 15.30 – EXAMPLE part of the module ](img/B18383_15_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.30 – EXAMPLE part of the module
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RETURN` block should contain the sample output or result of the module
    being returned after being executed successfully:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 15.31 – The module’s RETURN block ](img/B18383_15_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.31 – The module’s RETURN block
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there’s the actual script. This contains all the necessary libraries
    and dependencies, just like a normal Python script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 15.32 – The script portion of an Ansible module ](img/B18383_15_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.32 – The script portion of an Ansible module
  prefs: []
  type: TYPE_NORMAL
- en: Module Format and Documentation
  prefs: []
  type: TYPE_NORMAL
- en: Following the best practices will help those who are using the module to understand
    how it’s used. Refer to https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_documenting.xhtml#developing-modules-documenting
    to learn more about the module format and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the module using the `ansible-doc` command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.33 – Custom module details after using the ansible-doc command
    ](img/B18383_15_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.33 – Custom module details after using the ansible-doc command
  prefs: []
  type: TYPE_NORMAL
- en: 'When scrolling down using the keyboard, you will see the `EXAMPLES` and `RETURN
    VALUES` sections of the module’s documentation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.34 – Ansible custom module documentation details after using the
    ansible-doc command ](img/B18383_15_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.34 – Ansible custom module documentation details after using the ansible-doc
    command
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the module inside the `hello-python.yaml` playbook and pass the `message`
    and `name` module parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.35 – Using the hello_message module in the playbook ](img/B18383_15_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.35 – Using the hello_message module in the playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and verify its output, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.36 – Verifying the playbook’s execution and the hello_message module
    ](img/B18383_15_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.36 – Verifying the playbook’s execution and the hello_message module
  prefs: []
  type: TYPE_NORMAL
- en: Check the `Chapter-15` directory in this book’s GitHub repository to learn more
    about Ansible custom modules. Also, refer to the *Further reading* section at
    the end of this chapter for more resources on Ansible custom module development.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible collections and contributing back
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous section, store and distribute modules, roles, and
    libraries as an Ansible collection. This collection can be distributed to the
    public via Ansible Galaxy ([https://galaxy.ansible.com/](https://galaxy.ansible.com/))
    or internally using Red Hat Ansible **Private Automation Hub** (**PAH**).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to export a collection to Ansible Galaxy.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the collection directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following screenshot shows a typical Ansible collection’s directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.37 – Ansible collection directory structure ](img/B18383_15_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.37 – Ansible collection directory structure
  prefs: []
  type: TYPE_NORMAL
- en: In our scenario, we will make various adjustments without moving the original
    playbooks and module directories. (This is only for demonstration purposes; it
    is possible to keep the collection directories and files in the root of your GitHub
    repository.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `ansible-galaxy role init` command, use the `ansible-galaxy
    collection init` command to initialize the collection with the base directories
    and structure. In this example, we will be manually creating the collection and
    subdirectories to demonstrate the required directory structure and files for the
    collection. This will also allow us to reuse the existing playbooks and modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `collection` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `collection/playbook` directory and copy the playbooks into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `collection/plugins/modules` directory and copy the custom modules
    into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `collection/meta/runtime.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `collection/galaxy.yml`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.38 – galaxy.yml for the Ansible collection ](img/B18383_15_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.38 – galaxy.yml for the Ansible collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `collection/README.md` with the necessary documentation and details.
    Add/update the `.gitignore` file (in the root of the GitHub repository) and add
    the following content (this is for ignoring unwanted files when you sync the content
    to the GitHub server):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have prepared the collection’s content, you must build and publish
    it to Ansible Galaxy. This will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an Ansible collection to Ansible Galaxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Publish the collection to Ansible Galaxy via a GUI or using the CLI. Follow
    these steps to publish the collection using the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to Ansible Galaxy and get the Ansible Galaxy API key (token) from [https://galaxy.ansible.com/me/preferences](https://galaxy.ansible.com/me/preferences).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Export the token to an environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the collection archive using the `ansible-galaxy collection build` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.39 – Building the Ansible collection archive ](img/B18383_15_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.39 – Building the Ansible collection archive
  prefs: []
  type: TYPE_NORMAL
- en: Use `--force` to overwrite the collection archive if there’s an existing archive
    with the same version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, publish the collection to Ansible Galaxy using the `ansible-galaxy collection
    publish` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.40 – Publishing the collection to Ansible Galaxy ](img/B18383_15_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.40 – Publishing the collection to Ansible Galaxy
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the published collection in the Ansible Galaxy portal ([https://galaxy.ansible.com/my-content/namespaces](https://galaxy.ansible.com/my-content/namespaces)),
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.41 – New collection published in Ansible Galaxy ](img/B18383_15_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.41 – New collection published in Ansible Galaxy
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the collection and view its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.42 – Ansible collection content ](img/B18383_15_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.42 – Ansible collection content
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you created a subdirectory (`collection`) where you can keep
    the collection’s content and build the archive. As I mentioned earlier, keep the
    collection’s content in the root directory of the GitHub repository. Refer to
    [https://github.com/ginigangadharan/ansible-collection-custom-modules](https://github.com/ginigangadharan/ansible-collection-custom-modules)
    to see a sample collection repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use Ansible to automate non-supported and
    non-standard operations using the Ansible `raw` module. You explored the `raw`
    command’s execution on servers, network devices, firewall devices, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned how to interact with the devices that provide API-based operations.
    The Ansible `uri` module was used to interact with a ToDo application; you explored
    the options for fetching and adding items to the application via APIs. You also
    learned about the API-based operations for devices and explored some sample usage
    using the Akamai DNS API.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `raw` command and API-based operations, you learned about
    Ansible custom modules and how to create custom modules using bash and Python.
    In the end, you distributed the custom modules to Ansible Galaxy as an Ansible
    content collection.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have explored a common production use case where you can use
    Ansible as a perfect automation tool and Red Hat Ansible Automation Platform as
    an enterprise automation solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the best practices in Ansible, such
    as storing playbooks and their content, organizing inventories, the YAML style
    guide, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Network Automation with Ansible*: [https://www.ansible.com/integrations/networks](https://www.ansible.com/integrations/networks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Developing Ansible modules*: [https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible module best practices – conventions, tips, and pitfalls*: [https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_best_practices.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_best_practices.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Control your content with a private Automation Hub (Ansible blog)*: [https://www.ansible.com/blog/control-your-content-with-private-automation-hub](https://www.ansible.com/blog/control-your-content-with-private-automation-hub)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
