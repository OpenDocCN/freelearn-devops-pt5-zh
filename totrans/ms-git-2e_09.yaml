- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing Your Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git* (the previous chapter), taught you how to use Git to work together as
    a team, focusing on repository-to-repository interaction. It described different
    ways of setting up repositories for collaboration, presenting different collaborative
    workflows, such as centralized and integration manager workflows. It also showed
    how Git manages information about remote repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will find out how you can exchange information between
    your local repository and remote repositories, and how Git can manage credentials
    that might be needed to access remote repositories.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also teach you how to provide your changes upstream, so that
    they appear in the official history of the project, in its canonical repository.
    This can be done by pushing your changes to a central repository, pushing them
    to your own publishing repository and sending some kind of a pull request to the
    integration manager, or even exchanging patches.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Transport protocols used by Git and their advantages and disadvantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing credentials (passwords, keys) for remote repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Publishing changes: push and pull requests, and exchanging patches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bundles for offline transfer and speeding up the initial clone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote transport helpers and their use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport protocols and remote helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, URLs in the configuration of remote repository contain information
    about the transport protocol, the address of the remote server (where appropriate),
    and the path to the repository. Sometimes, the server that provides access to
    the remote repository supports various transport protocols; you need to select
    which one to use. This section is intended to help with this choice.
  prefs: []
  type: TYPE_NORMAL
- en: Local transport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the remote repository is on the same local filesystem, you can use either
    the path to the repository or the `file://` schema to specify the repository URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The former implies the `--local` option to the Git clone, which bypasses the
    smart Git-aware mechanism and simply makes a copy (or a hard link for immutable
    files under `.git/objects`, though you can avoid this with the `--no-hardlinks`
    option); the latter is slower but can be used to get a clean copy of a repository
    (for example, after history rewriting done to remove an accidentally committed
    password or another secret; which is described in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*, in the *Rewriting* *history* section).
  prefs: []
  type: TYPE_NORMAL
- en: This transport is a nice option for quickly grabbing work from someone else’s
    working repository, or for sharing work using a shared filesystem with the appropriate
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: As a special case, a single dot (`.`) denotes the current repository. This means
    that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: is, assuming that `pull.rebase` is set to false, roughly equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Smart transports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the repository you want to fetch from is on another machine, you need to
    access the Git server. Nowadays, Git-aware smart servers are most commonly encountered.
    The smart downloader negotiates which revisions are necessary, and creates a customized
    `packfile` to send to a client. Similarly, during the push, the Git server talks
    to Git on the user’s machine (to the client) to find which revisions to upload.
  prefs: []
  type: TYPE_NORMAL
- en: Git-aware smart servers use the `git upload-pack` downloader for fetching and
    `git receive-pack` for pushing. You can tell Git where to find them if they are
    not in `PATH` (but, for example, are installed in one’s home directory) with the
    `--upload-pack` and `--receive-pack` options for fetching and pushing, or the
    `uploadpack` and `receivepack` configuration variables in the `remote.<name>`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: With very few exceptions (such as the repository using submodules accessed by
    an ancient Git instance that does not understand them), Git transport is backward-
    and forward-compatible—the client and server negotiate what capabilities they
    can both use.
  prefs: []
  type: TYPE_NORMAL
- en: The native Git protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The native transport, using `git://` URLs, provides read-only anonymous access
    (though you could, in theory, configure Git to allow pushing by enabling the `receive-pack`
    service, either from the command line via the `--enable=receive-pack` option,
    or via the `daemon.receivePack` boolean-valued configuration variable—using this
    mechanism is not recommended at all, even in a closed local network).
  prefs: []
  type: TYPE_NORMAL
- en: The Git protocol does no authentication, including no server authentication,
    and should be used with caution on unsecured networks. The `git daemon` TCP server
    for this protocol normally listens on port `9418`; you need to be able to access
    this port (through the firewall) to be able to use the native Git protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Trivia
  prefs: []
  type: TYPE_NORMAL
- en: There is no secure version of the **git://** protocol. There is no **git://**
    over TLS like there is for the FTP and HTTP protocols—namely, FTPS and HTTPS.
    On the other hand, one can consider SSH transport, as used by Git, to be the **git://**
    protocol over SSH.
  prefs: []
  type: TYPE_NORMAL
- en: The SSH protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git upload-pack` or `git receive-pack` on the server, using SSH to execute
    the remote command. There is no possibility for anonymous, unauthenticated access,
    though you could, as a workaround, set up a guest account for it (passwordless
    or with an empty password).
  prefs: []
  type: TYPE_NORMAL
- en: Using public-private key authentication allows access without requiring you
    to provide a password on every connection. You might, however, need to provide
    it once to unlock a password-protected private key. You can read more about authentication
    in the *Credentials/password management* section in this chapter. Many Git hosting
    sites and software forges require key authentication for accessing repositories
    via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the SSH protocol, you can use the URL syntax with `ssh://` as the protocol
    part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `scp`-like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The SSH protocol additionally supports the `~username` expansion, just like
    the native Git transport (`~` is the home directory of the user you log in as,
    and `~user` is the home directory of `user`), in both syntax forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: SSH uses the first contact authentication for servers (**TOFU**—short for **Trust
    On First Use**)—it remembers the key that the server side previously used, and
    warns the user if it has changed, asking for confirmation (the server key could
    have been changed legitimately, for example, due to an SSH server reinstall).
    You can check the server key fingerprint on the first connection.
  prefs: []
  type: TYPE_NORMAL
- en: The smart HTTP(S) protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Git also supports the smart HTTP(S) protocol, which requires a Git-aware CGI
    or server module—for example, `git-http-backend` (itself a CGI module). This protocol
    uses the following URL syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By default, without any other configuration, Git allows anonymous downloads
    (`git fetch`, `git pull`, `git clone`, and `git ls-remote`), but requires that
    the client is authenticated for upload (`git push`).
  prefs: []
  type: TYPE_NORMAL
- en: Standard HTTP authentication is used if authentication is required to access
    a repository, which is done by the HTTP server software. Using SSL/TLS with HTTPS
    ensures that if the password is required (for example, if the server uses basic
    HTTP authentication), then it is sent encrypted and the server identity is verified
    (using server CA certificate).
  prefs: []
  type: TYPE_NORMAL
- en: Legacy (dumb) transports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some transports do not require any Git-aware smart server—they don’t need Git
    installed on the server (for smart transports, at least `git-upload-pack` and/or
    `git-receive-pack` is needed). Those are the FTP(S) and dumb HTTP(S) protocol
    transports (nowadays, implemented using the `remote-curl` helper).
  prefs: []
  type: TYPE_NORMAL
- en: 'These transports need only the appropriate stock server (an FTP server, or
    a web server), and up-to-date data from `git update-server-info`. When fetching
    from such a server, Git uses the so-called **commit walker** downloader: going
    down from fetched branches and tags, Git walks down the commit chain, and downloads
    objects or packs containing missing revisions and other data (for example, file
    content at revision).'
  prefs: []
  type: TYPE_NORMAL
- en: This transport is inefficient (in terms of bandwidth, but especially in terms
    of latency), but on the other hand, it can be resumed if interrupted. Nevertheless,
    there are better solutions than using dumb protocols—namely, involving bundles
    (see the *Offline transport with bundles* section in this chapter), when the network
    connection to the server is unreliable enough that you can’t get the clone operation
    to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing to a dumb server is possible only via the HTTP and HTTPS protocols.
    It requires the web server to support WebDAV, and Git has to be built with the
    *expat* library linked. The FTP and FTPS protocols are read-only (supporting only
    `clone`, `fetch`, and `pull`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a design feature, Git can automatically upgrade dumb protocol URLs to smart
    URLs. Conversely, a Git-aware HTTP server can downgrade to the backward-compatible
    dumb protocol (at least for fetching: smart HTTP servers don’t support WebDAV-based
    dumb HTTP push operation). This feature allows the use of the same HTTP(S) URL
    for both dumb and smart access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Offline transport with bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, there is no direct connection between your machine and the server
    holding the Git repository that you want to fetch from. Or, perhaps there is no
    server running, and you want to copy changes to another machine anyway. Maybe
    your network is down. Perhaps you’re working somewhere on-site and don’t have
    access to the local network for security reasons. Maybe your wireless/Ethernet
    card just broke.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the `git bundle` command. This command will package up everything that
    would normally be transferred over the wire, putting objects and references into
    a special binary archive file called `bundle` (like `packfile`, only with branches
    and so on). You need to specify which commits are to be packed—something that
    network protocols do automatically for you for online transport.
  prefs: []
  type: TYPE_NORMAL
- en: Trivia
  prefs: []
  type: TYPE_NORMAL
- en: When you are using one of the smart transports, a **want/have negotiation**
    phase takes place, where the client tells the server what it does have in its
    repository and which advertised references on the server it wants, to find common
    revisions. This is then used by the server to create a packfile, and to send the
    client only what’s necessary, minimizing the bandwidth use.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to move this bundle (this archive) by some means to your machine.
    It can be done, for example, by so-called `git clone` or `git fetch` with the
    filename of the bundle in place of the repository URL.
  prefs: []
  type: TYPE_NORMAL
- en: Proxies for Git transports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When direct access to the server is not possible, for example, from within a
    firewalled LAN, sometimes you can connect via a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: For the native Git protocol (`git://`), you can use the `core.gitProxy` configuration
    variable, or the `GIT_PROXY_COMMAND` environment variable to specify a proxy command—for
    example, `ssh`. This can be set on a per-remote basis with special syntax for
    the `core.gitProxy` value—namely, `<command> for <remote>;` for example, `"ssh"`
    `for kernel.org`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `http.proxy` configuration variable or appropriate *curl* environment
    variables such as `http_proxy` to specify the HTTP proxy server to use for the
    HTTP(S) protocol (`http(s)://`). This can be set on a per-remote basis with the
    `remote.<remote name>.proxy` configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure SSH (using its configuration files—for example, `~/.ssh/config`)
    to use tunneling (port forwarding) or a proxy command (for example, the `netcat/nc;`
    or `netcat` mode of SSH—that is, `ssh -W –`—if your SSH implementation supports
    this feature). It is a recommended solution for the SSH proxy; if neither tunneling
    nor using a proxy is possible, you can use the `ext::` transport-helper, as shown
    later in this chapter, in the *Transport relay with remote* *helpers* section.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning and updating with bundles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s assume that you want to transfer the history of a project (say, limited
    to the `master` branch for simplicity) from `machineA` (for example, your work
    computer) to `machineB` (for example, an onsite computer). There is, however,
    no direct connection between those two machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a bundle that contains the whole history of the `master` branch
    (see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*),
    and tag this point of history to know what we bundled, which will be needed later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the bundle file was created outside the working directory. This is a matter
    of choice; storing it outside of the repository means that you don’t have to worry
    about accidentally adding it to your project history, or having to add a new `ignore`
    rule. The `*.bundle` file extension is OR simply a matter of the naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'For security reasons, to avoid information disclosure about the parts of history
    that were deleted but not purged (for example, an accidentally committed file
    with a password), Git only allows fetching from **git show-ref**-compatible references:
    branches, remote-tracking branches, and tags.'
  prefs: []
  type: TYPE_NORMAL
- en: The same restrictions apply when creating a bundle. This means, for example,
    that (for implementation reasons) you cannot run **git bundle creates master^1**.
    Though, of course, because you control the server end, as a workaround you can
    create a new branch for **master^**, (temporarily) rewind **master**, or check
    out the detached **HEAD** at **master^**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you transfer the just-created `repo.bundle` file to `machineB` (via email,
    on a USB pen drive, and so on). Because this bundle consists of a self-contained,
    whole subset of the history, down to the first (parent-less) root commit, you
    can create a new repository by cloning from it, by simply putting the bundle filename
    in place of the repository URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops. We didn’t bundle `HEAD`, so the Git clone didn’t know which branch is
    current and therefore should be checked out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Because a bundle can be treated as a remote repository, we could have simply
    used the **git ls-remote ../repo.bundle** command here instead of **git bundle**
    **list-heads ../repo.bundle**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, with this bundle being as it is, we need to specify which branch
    to check out to avoid the problem (this would not be necessary if we had bundled
    `HEAD` too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of cloning again, we can fix the problem with the failed checkout by
    selecting the current branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, here, Git guessed that when trying to switch to a non-existent
    local branch, `master`, what we actually wanted was to create a local branch to
    create new commits to submit to the remote `master` branch. In other words, create
    a local branch following (tracking) the remote branch with the same name existing
    in the `origin` remote. What Git did is the same as if we ran the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To update the repository on `machineB` cloned from the bundle, you can fetch
    or pull after replacing the original bundle stored at `/home/user/repo.bundle`
    with the one with incremental updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a bundle containing changes since the last transfer in our example,
    go to `machineA` and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will bundle all changes since the `lastbundle` tag; this tag denotes what
    was copied with the previous bundle (see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083),
    *Exploring Project History*, the *Double-dot notation* section, for an explanation
    of double-dot syntax). After creating a bundle, this will update the tag (using
    `-f` or `--force` to replace it), like was done the first time when creating a
    bundle, so that the next bundle can also be created incrementally from the now
    current point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to copy the bundle to `machineB`, *replacing* the old one. At
    this point, one can simply perform the pull operation to update the repository,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using a bundle to update an existing repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you might have a repository cloned already, only for the network
    to fail. Or, perhaps you moved outside the **local area network** (**LAN**), and
    now you have no access to the server. The end result is that you have an existing
    repository, but no direct connection to the upstream (to the repository we cloned
    from).
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you don’t want to bundle up the whole repository, which is wasteful,
    like in the *Cloning and updating with bundles* section, you need to find some
    way to specify the cut-off point (the base) in such a way that it is surely present
    in the target repository (which you want to update). You can specify the range
    of revisions to pack into the bundle using almost any technique from [*Chapter
    4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*. The only limitation
    is that the history, as was said earlier, must start at a branch or tag (anything
    that `git show-ref` accepts). You can, of course, check the range with the `git`
    `log` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commonly used solutions for specifying the range of revisions to pack into
    a bundle are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the tag that is present in both repositories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git bundle create ../``repo.bundle v0.1..master`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a cut-off based on the time of commit creation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git bundle create ../repo.bundle --``since=1.week master`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bundle just the last few revisions, limiting the revision range by the number
    of commits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git bundle create ../repo.bundle -``5 master`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s better to pack in too much than too little. You can check whether the
    repository has the requisite commits to fetch from the bundle with **git bundle
    verify**. If you pack in too little, you’ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '**user@machineB repo$ git pull ../****repo.bundle master**'
  prefs: []
  type: TYPE_NORMAL
- en: '**error: Repository lacks these** **prerequisite commits:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**error: ca3cdd6bb3fcd0c162a690d5383bdb8e8144b0d2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after transporting it to `machineB`, you can use the bundle file just
    like a regular repository to do a one-off pull (putting the bundle filename in
    place of the URL or the remote name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t want to deal with the merge, you can fetch into the remote-tracking
    branch (the `<remote branch>:<remote-tracking branch>` notation used here, which
    is known as *refspec*, will be explained in [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced* *Branching Techniques*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use `git remote add` to create a new shortcut, using
    the path to the bundle file in place of the repository URL. Then, you can simply
    deal with bundles as described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a bundle to help with the initial clone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smart transports provide much more effective transport than dumb ones. On the
    other hand, the concept of a resumable clone using smart transport remains elusive
    to this day (it is not available in Git version 2.34, though perhaps somebody
    will implement it in the future). For large projects with a long history and with
    a large number of files, the initial clone might be quite large (for example,
    `linux-next` is more than 2.7 GB) and take a pretty long time. This might be a
    problem if the network is unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip – workaround
  prefs: []
  type: TYPE_NORMAL
- en: You can work around the issue of an unreliable network by using a shallow clone
    or a sparse clone (see [*Chapter 12*](B21194_12.xhtml#_idTextAnchor302), *Managing*
    *Large Repositories*) and widening it step by step until you arrive at the full
    repository. There are some third-party tools that do this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a bundle from the source repository, for example, with the following
    command (which needs to run on the server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Some servers may offer such bundles to help with the initial clone. There is
    a practice where a bundle intended for cloning is available at the same URL as
    the repository, but with a `.bundle` suffix instead of `.git`. For example, `https://git.example.com/user/repo.git`
    has its bundle available at `https://git.example.com/user/repo.bundle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then download such a bundle, which is an ordinary static file, using
    any resumable transport: HTTP(S), FTP(S), rsync, or even BitTorrent (with the
    appropriate client that supports resuming the download).'
  prefs: []
  type: TYPE_NORMAL
- en: With modern Git, the user can specify the bundle URI with the `--bundle-uri`
    command-line option, or a bundle list can be advertised by a Git server. A list
    of bundle URIs can also be saved in a config file. Fetching from bundle servers
    (such as [https://github.com/git-ecosystem/git-bundle-server](https://github.com/git-ecosystem/git-bundle-server))
    is then automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Remote transport helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When Git doesn’t know how to handle a certain transport protocol (when one
    tries to use a protocol that doesn’t have built-in support), it attempts to use
    the appropriate **remote helper** for a protocol, if one exists. That’s why if
    there is an error within the protocol part of the repository URL—Git responds
    with an error message that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This error message means that Git tried to find `git-remote-shh` to handle the
    `shh` protocol (actually a typo for `ssh`), but didn’t find an executable with
    such a name.
  prefs: []
  type: TYPE_NORMAL
- en: You can explicitly request a specific remote helper with the `<transport>::<address>`
    syntax, where `<transport>` defines the helper (`git remote-<transport>`), and
    `<address>` is a string that the helper uses to find the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern Git implements support for the dumb HTTP, HTTPS, FTP, and FTPS protocols
    with the `curl` family of remote helpers: `git-remote-http`, `git-remote-https`,
    `git-remote-ftp`, and `git-remote-ftps`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Transport relay with remote helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Git includes two generic remote helpers that can be used to proxy smart transports:
    the `git-remote-fd` helper to connect to the remote server via either a bidirectional
    socket or a pair of pipes, and the `git-remote-ext` helper to use an external
    command to connect to the remote server.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the latter, which uses the `"ext::<command> <arguments">"` syntax
    for the repository URL, Git runs the specified command to connect to the server,
    passing data for the server to the standard input of the command, and receiving
    a response on its standard output. This data is assumed to be passed to a `git://`
    server, `git-upload-pack`, `git-receive-pack`, or `git-upload-archive` (depending
    on the situation).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s assume that you have your repository on a LAN host where
    you can log in using SSH. However, for security reasons, this host is not visible
    on the internet, and you need to go through the gateway host: `login.example.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The trouble is that—also for security reasons—this gateway host either doesn’t
    have Git installed (reducing the attack surface) or doesn’t have your repository
    present (it uses a different filesystem). This means that you cannot use the ordinary
    SSH protocol—not unless you can set up an `ssh -L`). The SSH transport is just
    `git-receive-pack` / `git-upload-pack` accessed remotely via SSH, with the path
    to the repository as a parameter. This means that you can use the `ext::` remote
    helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `%S` will be expanded by Git into the full name of the appropriate service—`git-upload-pack`
    for fetching and `git-receive-pack` for pushing. The `-t` option is needed if
    logging to the internal host uses interactive authentication (for example, a password).
    Note that you need to give the name (`repo`, here) to the result of cloning; otherwise,
    Git will use the command (`ssh`) as the repository name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can also use **"ext::ssh [<parameters>...] %S '<repository>'"** to use specific
    options for SSH transport—for example, selecting the keypair to use without needing
    to edit **.ssh/config**.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only possible solution—though there is no built-in support for
    sending the SSH transport through a proxy like there is for the native `git://`
    protocol (among others, `core.gitProxy`) and for HTTP (among others, `http.proxy`),
    you can do it by configuring the SSH using the `ProxyCommand` config option, or
    by creating an SSH tunnel.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you can also use the `ext::` remote helper to proxy the `git://`
    protocol—for example, with the help of `socat`—including using a single proxy
    for multiple servers. See the `git-remote-ext(1)` manpage for details and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using foreign SCM repositories as remotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The remote helper mechanism is very powerful. It can also be used to interact
    with other version control systems, transparently using their repositories as
    if they were native Git repositories. Though there is no such built-in helper
    (unless you count the `contrib/` area in the Git sources), you can find the `git-remote-hg`,
    `gitifyhg`, or `git-cinnabar` helper to access Mercurial repositories, and `git-remote-bzr`
    to access Bazaar repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, those remote helper bridges will allow you to clone, fetch,
    and push to and from the Mercurial or Bazaar repositories as if they were Git
    ones, using the `<helper>::<URL>` syntax. For example, to clone the Mercurial
    repository, you can simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There is also the `remote.<remote name>.vcs` configuration variable, if you
    don’t like using the `<helper>::` prefix in the repository URL. With this method,
    you can use the same URL for Git as for the original **version control** **system**
    (**VCS**).
  prefs: []
  type: TYPE_NORMAL
- en: Foreign version control system clients
  prefs: []
  type: TYPE_NORMAL
- en: The alternative approach to using remote helper bridges is to use a specialized
    client, such as **git-svn** for Subversion, or **git-p4** for Perforce. Those
    clients interact with the foreign VCS (usually a centralized VCS), manage and
    update the Git repository based on this interaction, and update the foreign repository
    based on changes present in the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, one needs to remember impedance mismatches between different version
    control systems, and the limitations of the remote helper mechanism. Some features
    do not translate at all or do not translate well—for example, octopus merges (with
    more than two parent commits) in Git, or multiple anonymous branches (heads) in
    Mercurial.
  prefs: []
  type: TYPE_NORMAL
- en: With remote helpers, there is also no place to fix mistakes, replace references
    to other revisions with target native syntax, and otherwise clean up artifacts
    created by repository conversions—as can and should be done with one-time conversion
    when changing version control systems. (Such a cleanup can be done with, for example,
    the help of the `reposurgeon` third-party tool.)
  prefs: []
  type: TYPE_NORMAL
- en: 'With remote helpers, you can even use things that are not version control repositories
    in the strict sense; for example, with the *Git-Mediawiki* project, you can use
    Git to view and edit a MediaWiki-based wiki (for example, Wikipedia), treating
    the history of pages as a Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Besides that, there are remote helpers that allow additional transport protocols,
    or storage options—such as `git-remote-s3bundle` to store the repository as a
    bundle file on Amazon S3, or `git-remote-codecommit` for AWS CodeCommit (if you
    don’t want to or cannot use HTTPS authentication with static credentials). There
    is also `git-ssb` to encode repositories in a peer-to-peer log store via the Secure
    ScuttleButt protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Credentials/password management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, with the exception of the local transport (where filesystem permissions
    control access), publishing changes to the remote repository requires authentication
    (the user identifies itself) and authorization (the given user has permission
    to perform the push operation). Sometimes, fetching the repository also requires
    authentication and authorization, like with private repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used **credentials** for authentication are *username* and *password*.
    You can put the username in the HTTP and SSH repository URLs if you are not concerned
    about information leakage (in respect of leaking the information about valid usernames),
    or you can use the **credential helper** mechanism. You should *never* put passwords
    in URLs, even though it is technically possible for HTTP ones—the password can
    be visible to other people, for example when they are listing processes.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the mechanism inherent in the underlying transport engine, be it `SSH_ASKPASS`
    for SSH or the `~/.netrc` file for curl-based transport, Git provides its own
    integrated solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Asking for passwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the Git commands that interactively ask for a password (and a username
    if it is not known)—such as `git svn`, the HTTP interface, or IMAP authentication—can
    be told to use an external program. The program is invoked with a suitable prompt
    (a so-called **authentication domain**, describing what the password is for),
    and Git reads the password from the standard output of this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git will try the following places to ask the user for usernames and passwords;
    see the `gitcredentials(7)` manpage:'
  prefs: []
  type: TYPE_NORMAL
- en: The program specified by the **GIT_ASKPASS** environment variable, if set (Git-specific
    environment variables always have higher precedence than configuration variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the **core.askpass** configuration variable is used, if set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the **SSH_ASKPASS** environment variable is used, if set (it is not
    Git-specific, that is why it is consulted later in the sequence)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the user is prompted on the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This `askpass` external program is usually selected according to the desktop
    environment of the user (after installing it, if necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: (**x11-**)**ssh-askpass** provides a plain X-window dialog asking for the username
    and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is **ssh-askpass-gnome** for GNOME and **ksshaskpass** for KDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mac-ssh-askpass** can be used for macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**win-ssh-askpass** can be used for MS Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git comes with a cross-platform password dialog in Tcl/Tk—`git-gui--askpass`—to
    accompany the `git gui` graphical interface and the `gitk` history viewer.
  prefs: []
  type: TYPE_NORMAL
- en: The Git configuration precedence (that we have seen an example of here) will
    be described in more detail in [*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320),
    *Customizing and* *Extending Git*.
  prefs: []
  type: TYPE_NORMAL
- en: Public key authentication for SSH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the SSH transport protocol, there are additional authentication mechanisms
    besides passwords. One of them is `gitolite` uses—[https://gitolite.com](https://gitolite.com)).
  prefs: []
  type: TYPE_NORMAL
- en: The idea of public key authentication is that the user creates a `ssh-keygen`.
    The public key is then sent to the server, for example, by using `ssh-copy-id`
    (which also adds the public key, `*.pub`, at the end of the `~/.ssh/authorized_keys`
    file on the remote server), or by pasting it into a web form on a hosting service.
    You can then log in with your private key that is on your local machine, for example,
    as `~/.ssh/id_rsa`. You might need to configure SSH (in `~/.ssh/config` on Linux,
    and a similar configuration file on MS Windows) to use a specific identity file
    for a given connection (hostname) if it is not the default identity key.
  prefs: []
  type: TYPE_NORMAL
- en: Another convenient way to use public key authentication is with an authentication
    agent such as `ssh-agent` (or Pageant from PuTTY on MS Windows). Utilizing an
    agent also makes it more convenient to work with passphrase-protected private
    keys—you need to provide the password only once, to the agent, at the time of
    adding the key (which might require user action, for example, running `ssh-add`
    for `ssh-agent`).
  prefs: []
  type: TYPE_NORMAL
- en: Credential helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It can be cumbersome to input the same credentials over and over. For SSH, you
    can use public key authentication, but there is no true equivalent for other transports.
    Git credential configuration provides two methods to at least reduce the number
    of questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the static configuration of default usernames (if one is not provided
    in the URL) for a given **authentication context**—for example, hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It helps if you don’t have secure storage for credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The second is to use external programs from which Git can request both usernames
    and passwords—**credential helpers**. These programs usually interface with secure
    storage (a keychain, keyring, wallet, credentials manager, and so on) provided
    by the desktop environment or the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Git, by default, includes at least the `cache` and `store` helpers. The `cache`
    helper (`git-credential-cache`) stores credentials in memory for a short period
    of time; by default, it caches usernames and passwords for 15 minutes. The `store`
    helper (`git-credential-store`) stores *unencrypted* credentials for an indefinitely
    long time on disk, in files readable only by the user (similar to `~/.netrc`);
    there is also a third-party `netrc` helper (`git-credential-netrc`) for GPG-encrypted
    `netrc/authinfo` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting a credential helper to use (and its options) can be configured either
    globally or per authentication context, as in the previous example. Global credentials
    configuration looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will make Git use the `cache` credential helper, which will then cache
    credentials for 300 seconds (5 minutes). If the credential helper name is not
    an absolute path (for example, `/usr/local/bin/git-kde-credentials-helper`), Git
    will prepend the `git credential-` prefix to the helper’s name. You can check
    what types of credential helpers are available with `git help -a | grep credential-`.
    Git for Windows also includes, optionally, `git credential-helper-selection`.
  prefs: []
  type: TYPE_NORMAL
- en: There exist credential helpers that use secure storage of the desktop environment.
    When you are using them, you need to provide the password only once, to unlock
    the storage (some helpers can be found in the `contrib/` area in Git sources).
    There is `git-credential-libsecret` for GNOME and KDE, `git-credential-osxkeychain`
    for the macOS Keychain, and `git-credential-manager` for Microsoft’s cross-platform
    **Git Credential** **Manager** (**GCM**).
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `git-credential-oauth` to avoid having to set up personal access
    tokens or SSH keys. With this solution, the first time you authenticate, the helper
    opens a browser window to the host. Subsequent access uses cached credentials.
    Here, one can use the fact that Git supports multiple credential helpers. GitHub,
    GitLab, and Bitbucket are among the Git hosting services that support OAuth authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Git will use credential configuration for the most specific authentication context,
    though if you want to distinguish the HTTP URL by pathname (for example, providing
    different usernames to different repositories on the same host), you need to set
    the `useHttpPath` configuration variable to `true`. If there are multiple helpers
    configured for context, each will be tried in turn, until Git acquires both a
    username and a password.
  prefs: []
  type: TYPE_NORMAL
- en: Historical note
  prefs: []
  type: TYPE_NORMAL
- en: Before the introduction of credential helpers, one could use *askpass* programs
    that interface with the desktop environment keychain—for example, **kwalletaskpass**
    (for KDE Wallet) or **git-password** (for the macOS Keychain).
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your changes upstream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Collaborative workflows* section in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development with Git* explained various repository setups. Here,
    we’ll learn about a few common patterns for contributing to a project. We’ll see
    what our main options for publishing changes are.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting work on new changes, you should usually sync with the main development,
    incorporating the official version into your repository. This, and the work of
    the maintainer, is left to be described in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging* *Changes Together*.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing to a public repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a **centralized workflow**, publishing your changes consists simply of **pushing**
    them to the central server, as shown in *Figure 6**.2*. Because you share this
    central repository with other developers, it can happen that somebody has already
    pushed to the branch you are trying to update (the non-fast-forward case). In
    this scenario, you need to pull (fetch and merge, or fetch and rebase) others’
    changes, before being able to push yours. This case is shown at the start of the
    *Updating your repository (with merge)* section in [*Chapter 1*](B21194_01.xhtml#_idTextAnchor015),
    *Git Basics* *in Practice*.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible system with a similar workflow is when your team submits each
    set of changes to the code review system—for example, Gerrit. One available option
    is to push to a special ref, `refs/for/<branchname>` (which is named after a target
    branch), in a special repository. Then, the change review server makes each set
    of changes land automatically on a separate per-set ref (for example, `refs/changes/<change-id>`
    for commits belonging to a series with the given change ID).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In both peer-to-peer (see *Figure 6**.3*) and maintainer workflows, or the hierarchical
    workflow variant (*Figure 6**.4* and *Figure 6**.5*, respectively), the first
    step in getting your changes included in the project is to perform the push operation,
    but pushing to *your own* “public” repository (visible to the appropriate group)
    of your fork of the project. Then, you need to ask your co-developers, or the
    project maintainer, to merge your changes. You can do this, for example, by generating
    a **pull request**, as described below.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a pull request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In all workflows other than the centralized workflow, one needs to send a notification
    that changes are available in the public repository to co-developers, to the maintainer,
    or to integration managers. The `git request-pull` command can help with this
    step. Given the starting point (the bottom of the revision range of interest),
    the URL or the name of the remote public repository, and optionally, the commit
    to end at (if it is not the `HEAD`), this command will generate a summary of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The pull request contains the SHA-1 of the base of the changes (which is the
    revision just before the first commit, in the series proposed for pull), the title
    of the base commit, the URL, the branch of the public repository (suitable as
    `git pull` parameters), the title of the final commit, the `git shortlog` output),
    and `git diff --stat` output) of the changes. This output can be sent to the maintainer—for
    example, by email.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21194_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – “New pull request” action shown in a list of branches on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: A lot of Git hosting software and services include a built-in equivalent of
    `git request-pull` (for example, the **Create pull request** action in GitHub).
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging patches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many larger projects (and many open source projects) have established procedures
    for accepting changes in the form of **patches**, for example, to lower the barrier
    to entry for contributing. If you want to send a one-off code proposal to a project
    but do not plan to be a regular contributor, sending patches might be easier than
    a full collaboration setup (acquiring permission to commit in the centralized
    workflow, setting up a personal public repository for forking and similar workflows—on
    GitHub, that would consist of **forking** the project). Besides, one can generate
    patches with any compatible tool, and the project can accept patches no matter
    what is the version control setup.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, with the proliferation of various free Git hosting services, it might
    be more difficult to set up an email client for sending properly formatted patch
    emails—though services such as *GitGitGadget* (for submitting patches to the Git
    project mailing list), or the older *submitGit* service, could help. Git itself
    also includes commands for sending mail, namely **git send-email** and **git imap-send**,
    both of which need configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, patches, being a text representation of changes, can be easily
    understood by computers and humans alike. This makes them universally appealing,
    and very useful for *code review* purposes. Many open source projects historically
    used the public mailing list for that purpose: you can email a patch to this list
    and the public can review and comment on your changes (with services such as *public-inbox*
    and *lore+lei*, it is possible even without subscribing to the mailing list).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate email versions of each commit series, turning them into mbox-formatted
    patches, you can use the `git format-patch` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can use any revision range specifier with this command. The most commonly
    used is limiting by the number of commits, as in the preceding example, or by
    using the double-dot revision range syntax—for example, `@{u}..` (see [*Chapter
    4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*, the *Double-dot
    notation* section). When generating a larger number of patches, it is often useful
    to select a directory to save generated patches. This can be done with the `-o
    <directory>` option. The `-M` option for `git format-patch` (passed to `git diff`)
    turns on rename detection; this can make patches smaller and easier to review.
  prefs: []
  type: TYPE_NORMAL
- en: 'The patch files end up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is actually a complete email in the mbox format. The subject (after stripping
    the `[PATCH]` prefix) and everything up to the three-dash line (`---`) forms the
    commit message—the description of the change. To email this to a mailing list
    or a developer, you can use either `git send-email` or `git imap-send`, or any
    email client capable of sending plain text email. The maintainer can then use
    `git am` to apply the patch series, creating commits automatically; there’s more
    about this in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229), *Merging Changes
    Together*, in the *Applying a series of commits from* *patches* section.
  prefs: []
  type: TYPE_NORMAL
- en: Email subject convention for patches
  prefs: []
  type: TYPE_NORMAL
- en: The **[PATCH]** prefix is there to make it easier to distinguish patches from
    other emails. This prefix can—and often does—include additional information, such
    as the number in the series (set) of patches, the revision of the series, the
    information about it being a **work in progress** (**WIP**), or the **Request
    For Comments** (**RFC**) status—for example, **[****RFC/PATCHv4 3/8]**.
  prefs: []
  type: TYPE_NORMAL
- en: You can also edit these patch files to add more information for prospective
    reviewers—for example, information about alternative approaches, the differences
    between previous revisions of the patch (previous attempts), or a summary and/or
    references to the discussion on implementing the patch (for example, on a mailing
    list). You add such text between the `---` line and the beginning of the patch,
    before the summary of changes (`diffstat`); it will be ignored by `git am`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip – range diff
  prefs: []
  type: TYPE_NORMAL
- en: If the series of patches is undergoing revision and needs to be redone in a
    different way, it is recommended practice to provide in the cover letter the **git
    range-diff** output, showing the differences between one iteration of the series
    and the other.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to choose a transport protocol (if the
    remote server offers such a choice), and a few tricks such as using foreign repositories
    as if they were native Git repositories and offline transport with bundles.
  prefs: []
  type: TYPE_NORMAL
- en: Contact with remote repositories can require providing credentials—usually,
    the username and password, to be able to, for example, push to the repository.
    This chapter described how Git can help make this part easier thanks to credential
    helpers.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your changes and sending them upstream may involve different mechanisms,
    depending on the workflow. This chapter described push, pull request, and patch-based
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two following chapters expand on the topic of collaboration: [*Chapter
    8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching Techniques*,
    explores relations between local branches and branches in a remote repository,
    and how to set up branches for collaboration, while [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging Changes Together*, talks about the opposite issue—how to join the results
    of parallel work.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How can one clone a large repository when the connection to the host is quite
    unreliable, but you can log in to the host with the remote repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you need to get your changes into the canonical repository in the centralized
    workflow, and what do you need to do in the integration manager workflow?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set up Git so you would need to provide a password only once, and
    not for each contact with the remote?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use Git to interact with foreign version-control system repositories,
    to submit commits and download updates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to the questions given above:'
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution is to use **git bundle** on the remote host, and send
    the generated file via resumable transport such as HTTPS, rsync, or BitTorrent,
    or simply transport it via removable media such as a USB stick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the centralized workflow, you need to push to said central canonical repository,
    which might require merging changes from others first; in the integration manager
    workflow, you need to either push to your public repository and send some kind
    of pull request (for example, with **git request-pull** and email) against the
    canonical repository, or send patches by email to the maintainer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can set up a credential helper appropriate for the operating system and
    desktop environment used; for SSH transport, you can also use **ssh-agent** or
    the equivalent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With appropriate tools, you can either use Git to work as a client for a foreign
    version control system (for example, **git svn**) or use a remote transport helper
    to treat a foreign repository as a Git remote (for example, **git-cinnabar**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scott Chacon and Ben Straub: *Pro Git, 2nd Edition* (2014) [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 7.12 Git Tools –* *Bundling*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 7.14 Git Tools -* *Credential Storage*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bundle URI: [https://git-scm.com/docs/bundle-uri](https://git-scm.com/docs/bundle-uri)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anthony Heddings: *Should You Use HTTPS or SSH For Git?* (2021) [https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https](https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A visual guide to SSH* *tunnels* [https://robotmoon.com/ssh-tunnels/](https://robotmoon.com/ssh-tunnels/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Carl Tashian: *SSH Tips & Trick* – *Add a second factor to your SSH login*
    (2020) [https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh](https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Greg Kroah-Hartman: *“Patches carved into stone tablets”, or why the Linux
    kernel developers rely on plain text email*, a Kernel Recipes 2016 talk [https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/](https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
