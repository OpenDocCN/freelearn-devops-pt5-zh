- en: Chapter 5. Managing Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using Gitolite is that you do not need to create new
    repositories manually, set their permissions, and so on. Gitolite does all this
    for you, based on the contents of a specific file (`conf/gitolite.conf`) in the
    gitolite-admin repository. In this chapter, we will show how you can add new repositories
    to Gitolite, as well as how to bring in existing repositories in to Gitolite's
    ambit.
  prefs: []
  type: TYPE_NORMAL
- en: Adding repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add a new repository, you will need to do the following in your clone of
    the gitolite-admin repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, edit the `conf/gitolite.conf` file. This file should have some content
    already, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This basically says that only the user called `adam` has the permission to make
    changes to the `gitolite-admin` repository, and all users have the permission
    to make changes to the testing repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new repository, you will need to add a repo line, as well as at least
    one access control rule. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will create a repository called `my-repo-1`, making `adam` the only user
    who can read or write it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not add an access rule, the repository is not created. For example,
    if you had the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: then the `my-repo-1` repository is neither created, not even recognized by Gitolite
    in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can specify more than one repository name in the `repo` line,
    so the following command is perfectly fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding existing repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a repository, as described in the previous section, will create an empty,
    bare, repository on the server. You can then populate that repository by pushing
    whatever content you like. This is certainly one way to bring existing content
    under Gitolite's control, as long as those repositories did not have their own
    Git hooks in place earlier.
  prefs: []
  type: TYPE_NORMAL
- en: However, most sites will have several existing repositories that need to be
    brought under Gitolite's control, and the technique of creating an empty repository
    and pushing content from a workstation can be really slow, especially if the content
    is already available on the server. This section will tell you how to do this
    quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always advisable to have backups so that you can recover if something
    unexpected happens while following the procedure described.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure the existing repositories you are looking at are bare repositories.
    A bare Git repository is a repository that does not have a working tree. You cannot
    reliably push to a repository that has a working tree attached, so server repositories
    must always be bare. A bare repository is usually created by passing the `--bare`
    option to the `git init` or `git clone` commands. A later section in this chapter
    describes how to convert non-bare repositories to bare repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Next, move or copy the bare repositories to `$HOME/repositories`, which is where
    Gitolite expects to find all the repositories it is managing. When doing this,
    make sure the name of the repository ends in `.git`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In common Git usage, it is merely a convention to name bare repositories with
    names ending in `.git`, while non-bare repositories do not have an extension.
    With Gitolite however, the trailing `.git` is necessary; it is no longer just
    a convention.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have all the repositories in place, run the `gitolite setup` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in a clone of the gitolite-admin repository, add these repositories
    to the `conf/gitolite.conf` file as described earlier, save the changes, add,
    commit, and push.
  prefs: []
  type: TYPE_NORMAL
- en: Common problems and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may need to modify the procedure described earlier under some circumstances.
    This section will describe some of the problems that you may find and how to work
    around them.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership and permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gitolite expects that all the files and directories inside `$HOME/repositories`
    are owned by the Gitolite hosting user, and that this user is allowed to write
    to all of them. If this condition is not met, both Git and Gitolite will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: The most common reason for such a condition to be violated is that the administrator
    has copied some files (such as a bunch of existing repositories perhaps) as root.
    When files are copied as root, they are not usually given the owner and group
    ID of the directory in which they are being placed, but that of the original owner
    or the user executing the copy.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this by running `ls -alR` on the repository in question; if the
    owner and group of all the files and directories are not `git` (the hosting user),
    then you will need to modify the ownership of that repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, run the following command: (As in earlier chapters, we assume
    the Gitolite hosting user is git; if not, please substitute accordingly.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If there are no ownership problems, but for some reason you do have permission
    issues, you can omit the `chown` command and do the rest as `git` (that is, you
    do not need to log in as root).
  prefs: []
  type: TYPE_NORMAL
- en: Converting a non-bare repository to a bare repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bare repository is a repository without the working tree attached to it. Instead,
    the files and directories that, in a non-bare repository, are contained within
    the special `.git` directory are directly placed in the repository at the top
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to convert a non-bare repository to a bare repository is to clone it
    using the `--bare` option. The following command is the most generic way of doing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this makes a full copy of the source to the target, which might be
    a problem if the repository is very large. But if the source repository is on
    the same filesystem as the target, there is a very useful optimization that Git
    provides, which you can take advantage of. This is affected by adding a `-l` option
    to the `clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `-l` option tells Git to use hardlinks instead of copying the files over
    to the new repository, and is almost instantaneous, regardless of how big the
    repository actually is. Since it uses hardlinks (and not symlinks), you are free
    to delete the source repository after the clone is done; it will not harm the
    newly created target repository.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, at this point you will need to copy any hooks that already exist
    in your repository from the `hooks` directory of the source to that of the destination.
    This is because the `clone` method does not carry the hooks over.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git experts will realize that another way to convert a non-bare repo, say `my-repo`,
    is to promote the `.git` directory up one level, renaming it `my-repo.git`. That
    is, by running the command `mv my-repo/.git my-repo.git`. At this point, the old
    `my-repo` directory can be deleted. As always, make sure you have backups before
    deleting anything.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite and the update hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gitolite's access control mechanism for a push operation involves hooking into
    Git's `update` hook mechanism (see the man page for `githooks` to get details
    on the various hooks that Git provides).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if your existing repository already had an update hook, running the
    `gitolite setup` described previously will wipe out this existing hook and install
    Gitolite's own update hook in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Gitolite *does* provide a mechanism that allows your old `update` hook to also
    run, but it needs to be run by Gitolite. There is a supported mechanism for this
    called `VREF`, which will be described briefly in [Chapter 7](ch07.html "Chapter 7. Advanced
    Access Control and Configuration"), *Advanced Access Control and Configuration*,
    and in detail in [Chapter 10](ch10.html "Chapter 10. Understanding VREFs"), Understanding
    *VREFs*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you how to add your own repositories, and told you about
    some common problems that may occur when bringing in existing repositories in
    to Gitolite's control. The previous chapter has already covered adding users,
    so we are now ready to start looking at access control. Access control is the
    reason Gitolite exists, and the next chapter will (finally!) show you some basic
    access control syntax, rules, and other details.
  prefs: []
  type: TYPE_NORMAL
