- en: Storing Additional Information in Your Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding your first Git note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating notes by category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving notes from the remote repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing Git notes to a remote repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging commits in the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is powerful in many ways. One of the most powerful features of Git is that
    it has immutable history. This is powerful because nobody can squeeze something
    into the history of Git without it being noticed by the people who have cloned
    the repository. This also causes some challenges for developers, as some would
    like to change the commit messages after a commit has been released. This is possible
    in many other version control systems, but because of the immutable history with
    Git, it has Git notes. A Git note is essentially an extra `refs/notes/commits`
    reference in Git. Here, you add additional information to the commits that can
    be displayed when running a `git log` command. You can also release the notes
    into a remote repository so that people can fetch the notes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your first Git note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add some extra information to the already released code. If we were
    doing it in the actual commits, we would see the commit hashes change.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we need a repository to work in; you can use the previous
    clone of `jgit`, but to get an output from the example that''s almost identical,
    you can clone the `jgit` repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by creating a local branch, `notesMessage`, tracking `origin/stable-3.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will try and change the commit message and see that the commit hash
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checkout the branch `notesMessage` tracking `origin/stable-3.2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'List the commit hash of the `HEAD` of your branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the commit message by amending the commit using `git commit --amend`,
    and, following that, add a line above the `Change-Id:` line with `Update MANIFEST
    files`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we list the commit again and see that the commit hash has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the commit parts have changed from `f839d383e6fbbda26729db7fd57fc917fa47db44` to `9fcaa153c4afc6ee95572a58ddfa297f60b7e1cf`,
    as the commit is derived from the content in the commit, the parents of the commit,
    and the commit message. So, the commit hash will change when updating the commit
    message. Since we have changed the content of the `HEAD` commit, we are no longer
    based on the `HEAD` commit of the `origin/stable-3.2` branch. This becomes visible
    in `gitk` and `git status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, our branch has diverged from `origin/stable-3.2`;
    this is also visible from `gitk`. Note that we can specify which branches and
    commits we want to see with `gitk`. In this case, we want to see `origin/stable-3.2`
    and `HEAD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the screenshot for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c750e1d1-0166-48e5-bf5f-ea32aa1d6f6e.png)'
  prefs: []
  type: TYPE_IMG
- en: To prevent this result, we can add a note to the commit message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by resetting the branch to `origin/stable-3.2` and then adding
    a note to the commit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the same message as the previous one, but just as a note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the note directly from the command line without invoking the
    editor by using the `-m` flag and then a message. The log will now be visible
    when running `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the log output, we have a `Notes:` section with our note.
    Although it does not add the note directly in the commit message as the `--amend`
    option does, we still have our important addition to the commit message. We can
    verify with `git status` that we have no longer diverged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, you have your notes for your commit and now you want to add to them. You
    will perhaps expect that you just add the note again with more information. This
    is not the case. You have the option to append, edit, or force the note to be
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by trying to add the note again with additional information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As predicted, we cannot add the note but we can do it with the `-f` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Git overwrites the existing notes due to the `-f` flag. You can also use `--force`,
    which is the same. Verify it with `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also append a current note with `git notes append`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no output from this unless something goes wrong, but you can verify
    this by using `git log` again. To keep the output to a minimum, we are using `--oneline`.
    This will show a minimum output of the commit. But to show the note, we have to
    add `--notes`, which will show the notes for the commits in the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the output, we have the line appended to the note. If you
    try to use the `edit` option, you will see that you can only use this with the
    `-m` flag. This makes good sense, as you should edit the note and not overwrite
    or append an already created note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In other words, Git rejects editing the note and mentions other ways of doing
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `git notes add` and `git notes edit` commands without any arguments will
    do exactly the same, that is, open the configured editor and allow you to write
    a note to the commit.
  prefs: []
  type: TYPE_NORMAL
- en: Separating notes by category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous example, we can add notes to the commits; however,
    in some cases, it makes sense to store the information sorted by categories, such
    as `featureImplemented`, `defect`, and `alsoCherryPick`. As briefly explained
    at the beginning of the chapter, notes are stored in `refs/notes/commits`, but
    we can add multiple references so that we can easily sort and list the various
    scopes of the notes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start this example, we need a new branch that tracks the `origin/stable-3.1`
    branch; we name the branch `notesReferences`, and create and checkout the branch
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a situation where we have corrected a defect and did everything we could
    to ensure the quality of the commit before releasing it. Nonetheless, we had to
    make another fix for the same defect.
  prefs: []
  type: TYPE_NORMAL
- en: So, we want to add a note to the reference `refs/notes/alsoCherryPick`, which
    should indicate that if you cherry-pick this commit, you should also cherry-pick
    the other commits as they fix the same defect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will find the commit and add some extra information to
    the commit in multiple notes'' reference specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by listing the top 10 commits on the branch so we have something to copy
    and paste from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a note for the `da6e87bc3` commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to add a note for the `b4f07df` commit in the ref `alsoCherryPick`, we
    must use the `--ref` option for `git notes`. This has to be specified before the
    `add` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'No output indicates success while adding notes. Now that we have a note, we
    should be able to list it with a single `git log -1` command. However, this is
    not the case. You actually need to specify that you want to list the notes from
    the specific ref. This can be done with the `--notes=alsoCherryPick` option for
    `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see from the output, Git shows the `alsoCherryPick` notes. Git defaults
    to adding notes to `refs/notes/commits`, but we have explicitly specified to show
    `alsoCherryPick`. It would be nice if you could show the `alsoCherryPick` notes''
    reference by default so you don''t have to use `--notes=alsoCherryPick`. This
    can be done by configuring Git as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By configuring this option, you are telling Git to always list these notes.
    But what about the default notes? Have we overwritten the configuration to list
    the default `refs/notes/commits` notes? We can check this with `git log -1` to
    see if we still have the test note displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'No, we did not overwrite the setting to list notes in the default refs. Knowing
    that we can have as many `notes.displayRef` configurations as we want, we should
    add all the refs we want to use in our repository. In some situations, it is even
    better to just add `refs/notes/*`. This will configure Git to show all the notes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now add another note in `refs/notes/defect`, we should be able to list
    it without specifying which notes'' reference we want to list when using `git
    log`. We are adding to the commit that already has a note in the `alsoCherryPick`
    reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, list the commit with `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Git shows both notes, which is what we would expect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been discussing the `refs/notes/alsoCherryPick` reference and so on.
    As you know, we refer to the remote branches as references, such as `refs/remotes/origin/stable-3.2`,
    but the local branches also have references such as `refs/heads/develop`, for
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you can create a branch that starts at a specific reference, you should
    be able to create a branch that starts at the `refs/notes/alsoCherrypick` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a branch that starts from `refs/notes/alsoCherryPick`. Also, checkout
    the branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `myNotes` branch now points to `HEAD` on `refs/notes/alsoCherryPick`. Listing
    the files on the branch will show a file with the commit hash of the commit we
    have added the notes to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Showing the file content will show the text we used as note text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the abbreviated commit hash `570bba5` we added as a note for
    `b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a` is in the file. If we had a longer
    message, that message would also be shown here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieving notes from the remote repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been creating notes in our own local repository, which is fine.
    But if we want to share those notes, we have to be sure to be able to push them.
    We would also like to be able to retrieve other people's notes from the remote
    repository. Unfortunately, this is not so simple.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start, we need another clone from the local clone we already
    have. This is to show the push and fetch mechanism of Git with `git notes`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by checking out the master branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a local branch of all the `stable-3.1` branches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are checking out all these branches because we want to clone this repository
    and, by default, all the `refs/heads/*` branches will be cloned. So, when we clone
    the `chapter5` directory, you will see that we only get the branches we see if
    you execute `git branch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go one directory up so that you can create your new clone from the `chapter5`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter the `shareNotes` directory and run `git branch -a` to see that the
    only remote branches we have are the branches we checked out as local branches
    in the `chapter5` directory. After this, we are ready to fetch some notes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As predicted, the list matches the Git branch output from the `chapter5` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now prepared the setup for pushing and fetching notes. The challenge
    is that Git is not a default setup for retrieving and pushing notes, and hence
    you won''t usually see other people''s notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by showing that we did not receive the notes during the clone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the output does not show the note, and the first line makes it
    clear why. In the `chapter5` directory, we will see the note. To enable the notes
    to be fetched, we need to create a new fetch rule configuration; it needs to be
    similar to the fetch rule for `refs/heads`. Take a look at the configuration from
    `git config`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that we are fetching `refs/heads` into the `refs/remotes/origin`
    reference, but what we also want to do is fetch `refs/notes/*` into `refs/notes/*`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have it configured. If you leave out the `--add` option from
    your command, you will overwrite your current settings. Verify that the rule now
    exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try and fetch the notes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As the Git output indicates, we have received some new refs. So, let''s check
    whether we have the note on the commit now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We now have the notes in our repository, which is what we expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We fetched the notes. The reason why it works is because of the way we fetched
    them. By default, Git is configured to fetch `refs/heads/*` into `refs/remotes/origin/*`.
    This way, we can easily keep track of what is remote and what is local. The branches
    in our local repository are in `refs/heads/*`. These branches are also listed
    when you execute `git branch`.
  prefs: []
  type: TYPE_NORMAL
- en: For notes, we need to fetch `refs/notes/*` into `refs/notes/*` since we want
    to get the notes from the server and use them with the `git show`, `git log`,
    and `git notes` Git commands.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing Git notes to a remote repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have, successfully, tried to retrieve the notes from the remote repository,
    but what about your notes? How can you push them to the server? This has to be
    done with the push command just as with any other references, such as branches
    and commits.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can push the notes from the `shareNotes` repository, we have to create
    a note to be pushed, as the notes we have now are all available on the remote
    repository. The remote repository in this case is the `chapter5` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have found a commit you would like to add a note to, and you want to add
    the note to the `verified` reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the note, we can list it with the `git log` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we can see the note. If you cannot see the note, you probably missed
    `--notes=verified` for the `git log` command, since we have not configured `verified`
    as `notes.displayRef`. To push the note, we must use the `git push` command, because
    the default push rule in Git is to push branches to `refs/heads/<branchname>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, if we just try to push the note to the remote, nothing happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You will probably see a warning about `git push.default` not being configured;
    you can safely ignore this for these examples. The important part is that Git
    shows that everything is up-to-date. But we know we have created a Git note for
    a commit. So, to push these notes, we need to push our note references to the
    remote notes, references. This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, something happened; we have a new branch on the remote named `refs/notes/verified`.
    This is because we have pushed the notes to the remote. What we can do in order
    to verify it is go to the `chapter5` directory and check whether the `871ee53b52a`
    commit has a Git note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As predicted, we can see the note in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Git notes do not work as normal branches, it can be a little cumbersome
    to push them back and forth to a repository when you are trying to collaborate
    on them. Since you cannot just fetch and merge the Git notes branches as easily
    as with other branches, a clear recommendation is to build some tools to add these
    notes so that you only have one server adding the notes.
  prefs: []
  type: TYPE_NORMAL
- en: A simple, but value adding, note could be information about Jenkins builds and
    testing. This can be valuable when you have to reopen a defect. You can then actually
    see in the repository which tests were executed on the commit hash.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging commits in the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are releasing software with Git, you are bound to deal with tags. Tags
    describe the different software releases in the repository. There are two types
    of tags, a lightweight tag and an annotated tag. The lightweight tag is very similar
    to a branch, since it is just a named reference, such as `refs/tags/version123` .
    This points to the commit hash of the commit you are tagging; whereas if it were
    a branch, it would be `refs/heads/version123`. The difference is that the branch
    moves forward when you work and commit to it. A tag will always point to the same
    commit hash. We will discuss the annotated tag shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, you must go to the `chapter5` directory, where we made the
    original clone
  prefs: []
  type: TYPE_NORMAL
- en: for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We should start by tagging the commit that is ten commits behind `origin/stable-2.3`
    and is not a merge. In order to find that commit, we will use the `git log` command.
  prefs: []
  type: TYPE_NORMAL
- en: For the `git log` command, we are using the `--no-merges` option, which will
    show commits that only have one parent. The `--oneline` option we have used before
    tells Git to limit the output to one line per commit. Moreover, `-11` shows us
    the last 11 commits (10 commits before the latest).
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the commit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have found the `60d538f` commit, we should make it a lightweight
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `git tag` command to give a meaningful release name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there is no output, it is a success. To see whether the tag is available,
    use the `git tag` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `git tag` command with `-l` as a flag, since we want to list
    the tags and not tag the current `HEAD`. Some repositories have a lot of tags;
    so to prevent the list from becoming too long, you can specify which tags you
    want to list and use a `*` wildcard as we did previously. Our tag is available,
    but all it really says is that we have a tag in the repository with the name `v2.3.0.201302061315rc1`,
    and if you are using `git show v2.3.0.201302061315rc1`, you will see that the
    output is the same as `git show ea060dd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There will also be a lot of file diff information in the output, but it is
    exactly the same output. So, in order to add more information, we should use an
    annotated tag. An annotated tag is a tag where you have to add some information
    to the tag. To create an annotated tag, we use the `--annotate` tag for the `git
    tag` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-m` flag is the same as `--message`, as we want to give the tag a message.
    If you leave out the `-m` flag, Git will open the configured editor and you can
    write a full release note into the annotation of the tag. We can check the tag
    information with `git show`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can actually see the tag name and information we added with the `-m` flag.
    With the lightweight tag, we don't see anything about the tag from the output.
    We actually don't even see the tag name when using `git show` on a lightweight
    tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are very powerful as they can add valuable information to the repository,
    and since tags should be considered official releases in the repository, we should
    be very careful when working with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, you can push the tags to a remote area, and contributors to the
    repository would fetch those tags. This is where you have to be careful. With
    a legacy version control system, you can go back in time and just change the release,
    and since these legacy systems are all based on a centralized server where you
    have to be connected in order to work, changing a release is not that bad, since
    not so many people use the release or have even downloaded the release. But it
    is different in Git. If you change a tag that you have already pushed to point
    to another commit hash, then those developers who have already fetched the tag
    will not get the new tag unless they delete the tag locally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove the dangers of not getting a new tag, we will try to delete a tag
    and recreate it to point to another commit hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have deleted the tag, we are ready to recreate the tag again to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'point to `HEAD`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We have recreated the tag, and it points to `HEAD` because we did not specify
    a commit hash at the end of the command. Now, execute `git fetch` to see whether
    you can get the tag overwritten from the remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Since there is no output, the tag was probably not overwritten. Let's verify
    with
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git show`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, it is still our locally created tag. To get
    the tag from the remote again, we need to delete the local tag and do a `git fetch`.
    To delete a tag, you need to apply the `-d` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Git has fetched the tag from the server again. We can verify
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'with `git show`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: So, as you can see, we have the correct tag again, but it should also be a warning.
    Once you have pushed a tag to a remote repository, you should never change it,
    since the developers who are fetching from the repository may never know about
    the changes unless they clone again or delete the tags locally and fetch them
    again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we learned how you can tag your commits and add notes to them.
    These are powerful methods for storing additional information after a commit has
    been committed and published to a shared repository. But before you actually publish
    your commit, you have the chance to add the most valuable information for a commit.
    The commit message is where you must specify what you are doing and sometimes
    why you are doing it.
  prefs: []
  type: TYPE_NORMAL
- en: If you are solving a bug, you should list the bug ID; if you are using a special
    method to solve the problem, it is recommended that you describe why you have
    used this awesome technique to solve the problem. So, when people look back on
    your commits, they can also learn a few things about why different decisions were
    made.
  prefs: []
  type: TYPE_NORMAL
