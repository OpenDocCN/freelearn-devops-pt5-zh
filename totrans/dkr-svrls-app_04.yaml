- en: OpenFaaS on Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenFaaS 在 Docker 上
- en: This chapter will introduce OpenFaaS, a serverless framework that uses a software
    container as a unit of deployment. OpenFaaS has been designed to run and utilize
    the orchestration engine in Docker Swarm mode.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 OpenFaaS，这是一个使用软件容器作为部署单元的无服务器框架。OpenFaaS 最初是设计用来在 Docker Swarm 模式下运行并利用编排引擎的。
- en: The chapter will start by introducing OpenFaaS and explaining its architecture.
    Then we will go on to discuss how to use OpenFaaS to prepare and deploy functions.
    Finally, this chapter will end with how to install a Grafana/Prometheus dashboard
    for OpenFaaS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从介绍 OpenFaaS 和解释其架构开始。然后，我们将讨论如何使用 OpenFaaS 来准备和部署函数。最后，本章将结束于如何为 OpenFaaS
    安装 Grafana/Prometheus 仪表盘。
- en: What is OpenFaaS?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 OpenFaaS？
- en: OpenFaaS is a framework and infrastructure preparation system for building serverless
    applications. It originated from the serverless framework in the Docker Swarm
    and now supports other kinds of infrastructure backends, such as Kubernetes or
    Hyper.sh. Functions in OpenFaaS are containers. Any program written in any language
    can be packed as a function by leveraging the container technologies of Docker.
    This enables us to fully reuse the existing code to consume a wide range of web
    service events without rewriting the code. OpenFaaS is a great tool for modernizing
    old systems to run on a cloud-based infrastructure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS 是一个用于构建无服务器应用程序的框架和基础设施准备系统。它起源于 Docker Swarm 中的无服务器框架，现在支持其他类型的基础设施后端，如
    Kubernetes 或 Hyper.sh。OpenFaaS 中的函数是容器。通过利用 Docker 的容器技术，任何用任何语言编写的程序都可以打包成一个函数。这使我们能够充分重用现有代码，消费各种
    web 服务事件，而无需重写代码。OpenFaaS 是现代化旧系统以在云基础设施上运行的一个绝佳工具。
- en: 'There are several serverless frameworks out there in the cloud-native landscape.
    However, some problems need to be addressed by Alex Ellis, the original author
    of OpenFaaS. The driving factor behind the making of the framework is shaping the
    following, compelling features:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生领域，有多个无服务器框架。然而，一些问题需要由 OpenFaaS 的原创作者 Alex Ellis 来解决。推动框架创建的动力在于塑造以下具有吸引力的特性：
- en: '**Ease of use**: Basically, many serverless frameworks are complex to deploy
    by nature, as they are built by big companies and are serverless services. OpenFaaS,
    on the other hand, aims to be a serverless stack that is easy enough for developers
    and small companies to deploy and use on their own hardware. OpenFaaS also comes
    with a ready-to-use UI portal, which allows us to try out function invocation
    in the browser. OpenFaaS has autoscaling capability built in. It measures the
    load of function invocation automatically and scales instances up or down on demand.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：基本上，许多无服务器框架由于由大公司构建并且是无服务器服务，天生就很复杂。另一方面，OpenFaaS 的目标是成为一个足够简单的无服务器技术栈，让开发者和小公司能够在自己的硬件上轻松部署和使用。OpenFaaS
    还附带一个现成的 UI 门户，允许我们在浏览器中尝试函数调用。OpenFaaS 内置了自动扩展能力。它会自动测量函数调用的负载，并根据需求扩展或缩减实例。'
- en: '**Portable**: There are several orchestration engines in the container ecosystem,
    notably Docker Swarm and Google''s Kubernetes. OpenFaaS was first designed to
    work on Swarm and later on Kubernetes. Its functions are portable across these
    orchestration engines. Not only portable in a runtime sense, an OpenFaaS function
    is just a plain Docker container. This means that every kind of workload can be
    repacked as a function container and simply deployed on an OpenFaaS cluster. OpenFaaS
    runs on any infrastructure, including on-premises hardware, private clouds, and
    public clouds.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：在容器生态系统中，有多个编排引擎，尤其是 Docker Swarm 和 Google 的 Kubernetes。OpenFaaS 最初设计时是为了在
    Swarm 上运行，后来也支持 Kubernetes。它的功能在这些编排引擎之间是可移植的。OpenFaaS 不仅在运行时具有可移植性，它的功能实际上就是一个普通的
    Docker 容器。这意味着任何类型的工作负载都可以作为函数容器重新打包，并简单地部署到 OpenFaaS 集群上。OpenFaaS 可以在任何基础设施上运行，包括本地硬件、私有云和公共云。'
- en: '**Simplicity in architecture and design**: The architecture of OpenFaaS is
    simple. It consists of the API gateway for accepting requests. The API gateway
    then passes the requests to containers, functions with *watchdogs*, inside the
    cluster. Watchdog is a component of OpenFaaS which will be discussed shortly,
    in the next section. The gateway also keeps track of the number of function invocations.
    When the volume of requests is going to be large, the gateway will trigger the
    orchestration engine to scale replicas of functions on demand.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构与设计的简洁性**：OpenFaaS 的架构简单。它包括一个 API 网关，用于接受请求。然后，API 网关将请求传递给集群中的容器和带有*看门狗*的函数。看门狗是
    OpenFaaS 的一个组件，稍后将在下一节中讨论。网关还会跟踪函数调用的次数。当请求量较大时，网关会触发编排引擎按需扩展函数的副本。'
- en: '**Open and extensible platform**: OpenFaaS is designed to be open and extensible.
    With this openness and extensibility, the number of FaaS backends supported by
    OpenFaaS has been increasing over time, as anyone can contribute a new backend
    for OpenFaaS. For example, if we want to run functions directly in a container
    runtime, such as containers, for performance reasons, we can extend OpenFaaS by
    writing a new containerd backend for it.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放且可扩展的平台**：OpenFaaS 设计为开放且可扩展的。凭借这种开放性和可扩展性，OpenFaaS 支持的 FaaS 后端数量随着时间的推移不断增加，因为任何人都可以为
    OpenFaaS 提供新的后端。例如，如果我们想出于性能原因直接在容器运行时（如容器）中运行函数，我们可以通过为其编写一个新的 containerd 后端来扩展
    OpenFaaS。'
- en: '**Language agnostic**: We can write OpenFaaS functions in any language supported
    by Linux or Windows, then pack them as Docker or OCI container images.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与语言无关**：我们可以用任何 Linux 或 Windows 支持的语言编写 OpenFaaS 函数，然后将其打包为 Docker 或 OCI
    容器镜像。'
- en: Architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: We used to build our systems in the **monolithic** style. Now we use microservices. A
    microservice is definitely decomposable into smaller functions. Obviously, a function
    is the next step in architectural evolution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾经以**单体式**的方式构建系统。现在我们使用微服务。微服务可以被分解成更小的函数。显然，函数是架构演化的下一个步骤。
- en: Monolithic is a software architecture that contains distinguishable software
    concerns. Every service is built into a single deployment module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单体式是一种软件架构，其中包含可区分的软件关注点。每个服务都构建在一个单独的部署模块中。
- en: The microservice architecture, in contrast, separates coherent services inside
    a single monolithic module to be externally, loosely coupled services.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构则将一个单一的庞大模块内的协调服务分离出来，形成外部松耦合的服务。
- en: '**Function as a Service** or **FaaS** is another level of separation. In this
    architecture, a microservice is split into more fine-grained units, *functions*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数即服务**（**FaaS**）是另一个分离层次。在这种架构中，微服务被拆分为更细粒度的单元，即*函数*：'
- en: '![](img/16d65833-acfd-420e-be4f-240a0c9d9aaf.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16d65833-acfd-420e-be4f-240a0c9d9aaf.png)'
- en: 'Figure 4.1: Monolithic, microservice, and function architectures'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：单体式、微服务和函数架构
- en: OpenFaaS components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenFaaS 组件
- en: 'This section explains the components of OpenFaaS. The components are the API
    gateway, the function watchdog, and an instance of Prometheus. All are running
    on top of Docker Swarm or Kubernetes orchestration engines. The API gateway and
    the instance of Prometheus run as services, while the function watchdog runs as
    the part of function containers. The container runtime can be any modern version
    of Docker or containerd:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了 OpenFaaS 的组成部分。这些组件包括 API 网关、函数看门狗以及 Prometheus 实例。它们都运行在 Docker Swarm
    或 Kubernetes 编排引擎之上。API 网关和 Prometheus 实例作为服务运行，而函数看门狗作为函数容器的一部分运行。容器运行时可以是任何现代版本的
    Docker 或 containerd：
- en: '![](img/92b4f5eb-d334-46b7-92a5-61cc13a83fd7.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92b4f5eb-d334-46b7-92a5-61cc13a83fd7.png)'
- en: 'Figure 4.2: An overview of the OpenFaaS architecture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：OpenFaaS 架构概述
- en: 'The client could be `curl`, `faas-cli`, or any HTTP-based client that is able
    to connect to the API gateway in order to invoke a function. A function container,
    having a function watchdog as its sidecar (an implementation pattern that lets
    another sidecar process run alongside the main process in the same container),
    lives in the cluster behind the API gateway. Each service is communicating via
    the main overlay network, `func_functions` by default:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以是 `curl`、`faas-cli` 或任何能够连接到 API 网关并调用函数的基于 HTTP 的客户端。函数容器在集群中由 API 网关管理，容器内有一个作为旁路进程（这种实现模式允许另一个旁路进程与主进程在同一个容器中运行）的函数看门狗。每个服务通过默认的主覆盖网络
    `func_functions` 进行通信：
- en: '![](img/051f63a6-752b-4c3f-8f7a-5e0ae2e49a5d.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/051f63a6-752b-4c3f-8f7a-5e0ae2e49a5d.png)'
- en: 'Figure 4.3: The internal infrastructure of OpenFaaS running on Docker Swarm'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：运行在 Docker Swarm 上的 OpenFaaS 内部架构
- en: Function watchdog
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数监控程序
- en: The function watchdog is an OpenFaaS component. It is responsible for wrapping
    the real working code around a function program. The function program's requirement
    is only to accept input via the **standard input** (**stdin**) and print out the
    result, of course, to the **standard output** (**stdout**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 函数监控程序是 OpenFaaS 的一个组件。它负责将实际的工作代码封装在函数程序周围。函数程序的要求仅仅是通过 **标准输入**（**stdin**）接受输入，并将结果输出到
    **标准输出**（**stdout**）。
- en: 'The API gateway (`gateway`) connects to function containers through an overlay
    network. Each function container contains the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关（`gateway`）通过覆盖网络连接到函数容器。每个函数容器包含以下内容：
- en: Function watchdog, `fwatchdog`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数监控程序，`fwatchdog`
- en: A certain function program written in any language
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用任何语言编写的某个函数程序
- en: 'The Dockerfile describing a function container must have the `fprocess` environment
    variable pointing to the function program name and arguments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 描述函数容器的 Dockerfile 必须有一个 `fprocess` 环境变量，指向函数程序名称和参数：
- en: '![](img/8d243f05-d120-44d8-82f3-194adfe910ac.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d243f05-d120-44d8-82f3-194adfe910ac.png)'
- en: 'Figure 4.4: Interaction between function watchdog and the function program
    in the container'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：容器中函数监控程序与函数程序之间的交互
- en: Command-line interface
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行界面
- en: 'The OpenFaaS command-line interface is just another way to use OpenFaaS. The
    latest version of the CLI can be obtained directly from the installation script
    at [https://cli.openfaas.com](https://cli.openfaas.com). For both Linux and macOS,
    the CLI can be installed using the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS 命令行界面是使用 OpenFaaS 的另一种方式。CLI 的最新版本可以直接从安装脚本 [https://cli.openfaas.com](https://cli.openfaas.com)
    获取。对于 Linux 和 macOS，可以使用以下命令安装 CLI：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Currently, the installation script supports macOS and Linux running on ARM,
    ARM64, and x64 chips. The CLI has been designed to manage the life cycle of OpenFaaS
    functions. We can build, deploy, and invoke functions using sub-commands provided
    by the CLI.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，安装脚本支持运行在 ARM、ARM64 和 x64 芯片上的 macOS 和 Linux。CLI 被设计用来管理 OpenFaaS 函数的生命周期。我们可以使用
    CLI 提供的子命令来构建、部署和调用函数。
- en: The CLI actually controls OpenFaaS via a set of control plane APIs exposed by
    its API gateway.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 实际上通过 API 网关暴露的一组控制平面 API 来控制 OpenFaaS。
- en: API gateway
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 网关
- en: The OpenFaaS API gateway provides routing mechanisms to expose your functions
    to the external world.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS API 网关提供路由机制，将你的函数暴露给外部世界。
- en: When a function is invoked by an external request, the function metric will
    be collected and put into a Prometheus instance. The API gateway keeps monitoring
    a number of requests for each function, and scales it on demand by increasing
    the service replica via the Docker Swarm API. Basically, OpenFaaS fully utilizes
    the scheduling mechanism of Docker Swarm for its autoscaling. The API gateway
    also comes with a built-in user interface, called the **UI portal**. The UI allows
    us to define and invoke functions with a browser.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被外部请求调用时，函数的度量指标将被收集并放入 Prometheus 实例中。API 网关持续监控每个函数的请求数量，并通过 Docker Swarm
    API 按需扩展服务副本。基本上，OpenFaaS 完全利用 Docker Swarm 的调度机制进行自动扩展。API 网关还配备了内置用户界面，称为 **UI
    门户**。该界面允许我们通过浏览器定义和调用函数。
- en: Installing OpenFaaS
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenFaaS
- en: It is extremely simple to install OpenFaaS locally on a development machine.
    Make sure you have Docker 17.05 or later installed and you will be ready to go.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发机器上安装 OpenFaaS 极其简单。确保你安装了 Docker 17.05 或更高版本，安装完成后就可以开始使用了。
- en: 'First, we need to initialize a Swarm cluster. A single node Swarm is enough
    to be used in the development environment:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化一个 Swarm 集群。单节点 Swarm 就足够在开发环境中使用：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the Swarm cannot be initialized because the machine has *multiple network
    interfaces*, we have to specify an IP address or an interface name for the argument, `--advertise-addr`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于机器具有 *多个网络接口* 而无法初始化 Swarm，我们必须为参数 `--advertise-addr` 指定一个 IP 地址或接口名称。
- en: 'OpenFaaS can be up and running directly from its source by cloning the repository
    from GitHub. Then, check out the OpenFaaS version you want and run the `deploy_stack.sh`
    script. The following example is to start version 0.6.5 of OpenFaaS. Please note
    that there is `docker-compose.yml` in this directory, which will be used by the
    `docker_stack.sh` to deploy the OpenFaaS Docker stack:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS可以通过直接从GitHub克隆源代码并运行`deploy_stack.sh`脚本来启动。以下示例演示了如何启动OpenFaaS的版本0.6.5。请注意，此目录中有`docker-compose.yml`，该文件将被`docker_stack.sh`用来部署OpenFaaS
    Docker堆栈：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We now see that a number of services are deployed to the Docker Swarm cluster.
    It is actually done by running `docker stack deploy` behind the scenes inside
    the bash script. The Docker stack's name used by OpenFaaS is `func`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到，多个服务已部署到Docker Swarm集群中。实际上，这是通过在bash脚本中运行`docker stack deploy`命令实现的。OpenFaaS使用的Docker堆栈名称是`func`。
- en: 'To check whether services are deployed properly in the `func` stack, we use
    `docker stack ls` to list stacks and their running services:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查`func`堆栈中的服务是否正确部署，我们使用`docker stack ls`列出堆栈及其运行的服务：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we know that there is a stack of 11 services named `func`. Let''s check
    their details with `docker stack services func`. We use the format argument to
    let the `docker stack services func` command show each service''s name and port. You
    can leave out the `--format` to see all information about each service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道有一个名为`func`的11个服务的堆栈。让我们使用`docker stack services func`查看它们的详细信息。我们使用格式化参数来让`docker
    stack services func`命令显示每个服务的名称和端口。你可以省略`--format`来查看每个服务的所有信息：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After everything is up and running, the OpenFaaS portal can be opened via `http://127.0.0.1:8080`.
    The following screenshot shows the browser running OpenFaaS Portal. All available
    functions are listed in the left panel. When clicking a function name, the main
    panel will show the function''s details. We can play around with each function
    by clicking the INVOKE button on the main panel:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一切启动并运行后，可以通过`http://127.0.0.1:8080`打开OpenFaaS门户。以下截图显示了浏览器中运行的OpenFaaS门户。所有可用的函数都列在左侧面板中。点击某个函数名称后，主面板将显示该函数的详细信息。我们可以通过点击主面板上的INVOKE按钮来操作每个函数：
- en: '![](img/f55c2446-4521-4dd1-8ca0-ae9918413d81.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f55c2446-4521-4dd1-8ca0-ae9918413d81.png)'
- en: 'Figure 4.5: The OpenFaaS UI invoking an example function'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：OpenFaaS 用户界面调用示例函数
- en: We will learn how to prepare a function to run on the OpenFaaS platform in the
    next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习如何准备一个函数，以便在OpenFaaS平台上运行。
- en: Preparing a function
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备一个函数
- en: Before a function can be deployed and invoked, we need to prepare a binary program
    and pack it as a function container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数可以部署和调用之前，我们需要准备一个二进制程序并将其打包成函数容器。
- en: 'Here are the steps to package your program into a function container:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将程序打包成函数容器的步骤：
- en: Create a Dockerfile containing the `FROM` instruction to derive it from a base
    image. You can even use the Alpine base image.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`FROM`指令的Dockerfile，以从基础镜像派生出它。你甚至可以使用Alpine基础镜像。
- en: Add the function watchdog binary to the image using the `ADD` instruction. The
    function watchdog's name is `fwatchdog` and can be found on the OpenFaaS release
    page.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ADD`指令将函数监视程序二进制文件添加到镜像中。函数监视程序的名称是`fwatchdog`，可以在OpenFaaS发布页面找到。
- en: Add the function program to the image. We usually use the `COPY` instruction
    to do so.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数程序添加到镜像中。我们通常使用`COPY`指令来完成此操作。
- en: Define the environment variable named `fprocess` with the `ENV` instruction
    to point to our function program.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ENV`指令定义名为`fprocess`的环境变量，指向我们的函数程序。
- en: Expose port `8080` for this container image using the `EXPOSE` instruction with,
    of course, port number `8080`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`EXPOSE`指令暴露`8080`端口给此容器镜像，当然，端口号是`8080`。
- en: Define an entry point of this container image. We use `ENTRYPOINT` to point
    to `fwatchdog`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义此容器镜像的入口点。我们使用`ENTRYPOINT`指令指向`fwatchdog`。
- en: We will do something a bit unusual, but in the proper way, to prepare a function
    container. We use a Docker feature called **multi-stage builds** to both compile
    the program and pack the function container using a single Dockerfile.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做一些稍微不寻常的操作，但这是正确的方法，以准备一个函数容器。我们使用Docker的一个特性，称为**多阶段构建**，通过一个Dockerfile来编译程序并打包函数容器。
- en: What is multi-stage build? The multi-stage build feature allows a single Dockerfile
    to have several build stages chaining along the build process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是多阶段构建？多阶段构建特性允许一个Dockerfile在构建过程中有多个构建阶段连接在一起。
- en: With this technique, we can build a very tiny Docker image by discarding large
    image layers from the previous build stages. This feature requires Docker 17.05
    or greater.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这项技术，我们可以通过丢弃来自前一个构建阶段的较大镜像层，来构建一个非常小的 Docker 镜像。此功能需要 Docker 17.05 或更高版本。
- en: Packing a C program
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包 C 程序
- en: Here's an unusual, but simple, example of a function. In this example, we'll
    try to compile, pack, and deploy a C program as a function. Why a C program? Basically,
    if we know that we can pack a C program, then any traditional program could be
    compiled and packed in a similar way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不寻常但简单的函数示例。在这个示例中，我们将尝试将 C 程序编译、打包并部署为一个函数。为什么是 C 程序？基本上，如果我们知道可以打包 C 程序，那么任何传统程序都可以以类似的方式进行编译和打包。
- en: 'We know that when we design a function, it receives an input from `stdin` and
    sends an output to `stdout`. A C program will then send a simple sentence out
    to `stdout`, of course with `printf()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，当设计一个函数时，它从 `stdin` 接收输入并将输出发送到 `stdout`。然后，C 程序将通过 `printf()` 向 `stdout`
    发送一条简单的语句：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Normally, this C program can be compiled using `gcc` before copying and packing
    it as a container. But to make a Dockerfile self-contained, the multi-stage build
    technique will be used to compile and pack it as a function using a single `docker
    build` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这个 C 程序可以在复制并打包为容器之前使用 `gcc` 编译。但为了使 Dockerfile 自包含，将使用多阶段构建技术，通过单个 `docker
    build` 命令来编译和打包它作为一个函数。
- en: 'The following multi-stage Dockerfile consists of two stages. `State 0` starts
    with the Alpine 3.6 image, then installs `gcc` and `musl-dev` for compiling a
    C program. There is a command to build the C program statically, `gcc -static`,
    so that it does not require any shared object libraries:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下多阶段的 Dockerfile 包含两个阶段。`State 0` 从 Alpine 3.6 镜像开始，然后安装 `gcc` 和 `musl-dev`
    用于编译 C 程序。此阶段有一个命令来静态构建 C 程序，`gcc -static`，这样它就不需要任何共享对象库：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Stage 1** also starts with the Alpine 3.6 base image. It adds the `fwatchdog`
    binary directly from the OpenFaaS GitHub release page and changes its mode to
    be executable (`chmod +x`). The most important part of this Dockerfile is when
    it copies the main binary from the previous state, **Stage 0**. This can be done
    using the `COPY` instruction with the `--from` argument. The build process of
    the `func_c` container image is illustrated here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stage 1** 同样从 Alpine 3.6 基础镜像开始。它直接从 OpenFaaS GitHub 发布页面添加 `fwatchdog` 二进制文件，并将其模式更改为可执行
    (`chmod +x`)。此 Dockerfile 最重要的部分是在它从上一阶段 **Stage 0** 复制主二进制文件。这可以通过使用 `COPY` 指令与
    `--from` 参数来完成。`func_c` 容器镜像的构建过程如下所示：'
- en: '![](img/c3a2af04-0e0d-4ee6-8980-c9cac686a42e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3a2af04-0e0d-4ee6-8980-c9cac686a42e.png)'
- en: 'Figure 4.6: Illustration of multi-stage build workflow from the example'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：示例中的多阶段构建工作流程示意图
- en: 'The following line from the previous Dockerfile shows how to use the  `COPY`
    instruction to copy a file between stages. In **Stage 1**, the `COPY --from=0` means
    that the command will copy a file or a set of files from **Stage 0** to **Stage
    1**. In the previous example, it will change the `/root/main` file from **Stage
    0** to be `/usr/bin/func_c` in **Stage 1**:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前 Dockerfile 中的代码，展示了如何使用 `COPY` 指令在阶段之间复制文件。在 **Stage 1** 中，`COPY --from=0`
    表示该命令会将文件或一组文件从 **Stage 0** 复制到 **Stage 1**。在之前的示例中，它会将 `/root/main` 文件从 **Stage
    0** 更改为 **Stage 1** 中的 `/usr/bin/func_c`：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the multi-stage Dockerfile is ready, the next step is to `docker build` with
    that Dockerfile.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段 Dockerfile 准备好之后，下一步是使用该 Dockerfile 执行 `docker build`。
- en: 'Before doing this, an environment variable, `DOCKER_ID`, will be set to be
    your Docker ID. If you do not have one, please visit [https://hub.docker.com](https://hub.docker.com)
    and sign up there. The use of this `DOCKER_ID` variable will allow you to follow
    the commands without changing my Docker ID to yours for every code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作之前，将设置一个环境变量 `DOCKER_ID` 为你的 Docker ID。如果你没有 Docker ID，请访问 [https://hub.docker.com](https://hub.docker.com)
    并在那里注册。使用此 `DOCKER_ID` 变量，你可以在不每次更改我的 Docker ID 为你的情况下执行这些命令：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The running state of the function container will look like the image stack
    illustrated in *Figure 4.7*. The lowest level is the root filesystem on top of
    the operating system''s kernel. The next levels are the base image and the image
    layers mounted on top of each other, using the capability of a union filesystem.
    The top-most layer is a writable file system for each running container that represents
    an OpenFaaS function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数容器的运行状态将类似于 *图 4.7* 中所示的镜像堆栈。最底层是操作系统内核之上的根文件系统。接下来的层次是基础镜像和依次叠加的镜像层，利用联合文件系统的能力。最上层是每个运行容器的可写文件系统，代表一个
    OpenFaaS 函数：
- en: '![](img/8380331d-9016-4e54-9865-fae896372dc2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8380331d-9016-4e54-9865-fae896372dc2.png)'
- en: 'Figure 4.7: A function as a running container with a writable file system layer
    on top'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：作为运行容器的函数，顶部有一个可写的文件系统层
- en: 'With multi-stage builds, we can create a very small image containing only the
    binary files needed to be a function. By discarding the whole of **Stage 0**''s
    image layers, consisting of all compiler and dependency stuff, the final image
    size is reduced to be just around 11 MB in total. It can be checked by running
    `docker image ls $DOCKER_ID/func_c`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多阶段构建时，我们可以创建一个非常小的镜像，仅包含作为函数所需的二进制文件。通过丢弃整个 **Stage 0** 的镜像层（包括所有编译器和依赖项），最终镜像的大小被减少到大约
    11 MB。可以通过运行 `docker image ls $DOCKER_ID/func_c` 来检查：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Please note that the OpenFaaS mechanism will look for an image from the repository
    first. So, before using the container image as a function, it would be safe to
    push the image to Docker Hub, or your repository. This can simply be done using
    the `docker image push` command. Please note that you may require `docker login`
    to authenticate with Docker Hub before pushing the image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，OpenFaaS 机制会首先从仓库查找镜像。因此，在将容器镜像用作函数之前，将镜像推送到 Docker Hub 或您的仓库会更安全。这可以通过
    `docker image push` 命令简单完成。请注意，在推送镜像之前，可能需要使用 `docker login` 进行身份验证：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Defining and invoking a function with the UI
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UI 定义和调用函数
- en: 'It is really simple to define and invoke a function on OpenFaaS. After pushing
    the image, a function can be defined via the OpenFaaS UI Portal. First, open `http://127.0.0.1:8080/ui`.
    Then, you will see a clickable label, CREATE NEW FUNCTION, in the left panel.
    After clicking it, dialog for defining a function will pop up. It requires the
    Docker image name for this function; in this case, the image name will be `chanwit/func_c`.
    Again, please do not forget to change my Docker ID to yours. Second, the definition
    requires a function name. Just name it `func_c`. Third, we need to define the
    value for the `fprocess` field pointing to the command line to invoke the binary
    program. In this example, the command line will simply be `/usr/bin/func_c` inside
    the container. If the function program requires some parameters, also include
    them there. Finally, the function definition requires the name of a Docker overlay
    network to allow the API gateway to connect to the function containers. Just include
    the default one, `func_functions`, there. It is really important to note that
    if an OpenFaaS stack is deployed to another environment, and has a different overlay
    network name, you must not forget to specify the correct one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenFaaS 上定义和调用函数非常简单。在推送镜像后，可以通过 OpenFaaS UI 门户来定义函数。首先，打开 `http://127.0.0.1:8080/ui`。然后，你将在左侧面板中看到一个可点击的标签
    **CREATE NEW FUNCTION**。点击后，将弹出定义函数的对话框。它需要该函数的 Docker 镜像名称；在这个例子中，镜像名称是 `chanwit/func_c`。再次提醒，请不要忘记将我的
    Docker ID 改为你的 Docker ID。其次，定义时需要一个函数名称。就命名为 `func_c`。第三，我们需要定义 `fprocess` 字段的值，指向用于调用二进制程序的命令行。在这个示例中，命令行将在容器内简单地是
    `/usr/bin/func_c`。如果函数程序需要某些参数，也请在这里包含它们。最后，函数定义需要一个 Docker 覆盖网络的名称，以便 API 网关连接到函数容器。只需在此处包含默认的网络
    `func_functions`。需要特别注意的是，如果 OpenFaaS 堆栈部署到另一个环境，并且有不同的覆盖网络名称，必须记得指定正确的名称：
- en: '![](img/b66e0be3-f89f-4e51-a30b-5c7d78100a85.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b66e0be3-f89f-4e51-a30b-5c7d78100a85.png)'
- en: 'Figure 4.8: Defining an OpenFaaS function via the UI'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：通过 UI 定义 OpenFaaS 函数
- en: 'If everything looks fine, click CREATE to define the function. After creation,
    the `func_c` function will be listed in the left panel. Clicking on the function''s
    name will show the main panel for function invocation, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，点击 CREATE 来定义该函数。创建后，`func_c` 函数将显示在左侧面板中。点击函数名称将显示函数调用的主面板，如下所示：
- en: '![](img/34e7ba20-5f07-4f95-a1aa-ca2441561a88.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34e7ba20-5f07-4f95-a1aa-ca2441561a88.png)'
- en: 'Figure 4.9: Invocation of the func_c function with its response body'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：调用`func_c`函数及其响应体
- en: If a function requires any input, the input data in the form of text or JSON
    can be placed as the Request body. However, the `func_c` function does not accept
    any input, so just press the INVOKE button and the function will be called. In
    the example, the invocation process is completed and its status is OK: `200`.
    The API gateway gets the STDOUT from the function's binary, `/usr/bin/func_c`,
    and shows it here as the Response body in text format.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数需要任何输入，可以将文本或JSON格式的输入数据放置为请求体。然而，`func_c`函数不接受任何输入，因此只需按下INVOKE按钮，函数就会被调用。在此示例中，调用过程已完成，状态为OK：`200`。API网关从函数的二进制文件`/usr/bin/func_c`获取标准输出，并以文本格式显示为响应体。
- en: Using the OpenFaaS CLI
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenFaaS CLI
- en: 'The OpenFaaS CLI, `faas-cli`, is a command-line tool to help manage, prepare,
    and invoke functions. On Linux, the OpenFaaS CLI can be installed using the following
    command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS CLI（`faas-cli`）是一个命令行工具，帮助管理、准备和调用函数。在Linux上，可以使用以下命令安装OpenFaaS CLI：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On macOS, it can be installed via `brew` with the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，可以通过`brew`使用以下命令进行安装：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Alternatively, on Windows, `faas-cli.exe` can be downloaded directly from the
    OpenFaaS GitHub repository and run manually.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在Windows上，可以直接从OpenFaaS GitHub仓库下载`faas-cli.exe`并手动运行。
- en: However, we assume that every example is running on Linux. In the following
    example, the `hello` function will be created using OpenFaaS's template for the
    Go language, which can be found at `openfaas/fass-cli` in GitHub in the `template/go`
    directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们假设每个示例都运行在Linux系统上。在以下示例中，将使用OpenFaaS的Go语言模板创建`hello`函数，该模板可以在GitHub的`openfaas/fass-cli`库中的`template/go`目录下找到。
- en: Locally, all templates will be stored in the `template/` directory of the working
    directory. If the template directory does not exist, all templates will be fetched
    from GitHub's, `openfaas/faas-cli`. As of OpenFaaS 0.6, there are 10 available
    templates for five different programming languages there.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本地所有模板将存储在工作目录的`template/`目录下。如果模板目录不存在，所有模板将从GitHub的`openfaas/faas-cli`获取。从OpenFaaS
    0.6版本开始，那里提供了10个适用于五种不同编程语言的模板。
- en: Defining a new function
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个新函数
- en: 'To create a function written in the Go language, we use the `faas-cli new --lang=go
    hello` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Go语言编写的函数，我们使用`faas-cli new --lang=go hello`命令：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the function is created, we can check the structure of the function directory
    by running the `tree -L 2 .` command. It shows the directory at two levels of
    depth, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数后，我们可以通过运行`tree -L 2 .`命令检查函数目录的结构。该命令会显示两级深度的目录结构，如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we will look at the function definition in the `hello.yml` file. From
    `hello.yml` , there are two top-levels,  `provider` and `functions`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看`hello.yml`文件中的函数定义。在`hello.yml`文件中，有两个顶级项，`provider`和`functions`。
- en: The `provider` block tells us that its provider's name is `faas`, the default
    OpenFaaS implementation in Docker Swarm. Also, it tells us that the gateway endpoint
    is at `http://localhost:8080`, where an instance of the API gateway is running.
    In a production environment, this URL could be changed to point to the real IP
    address.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider`块告诉我们其提供者的名称是`faas`，即Docker Swarm中的默认OpenFaaS实现。同时，它告诉我们网关端点位于`http://localhost:8080`，即API网关的一个实例正在运行。在生产环境中，这个URL可以更改为指向实际的IP地址。'
- en: 'The `functions` block lists all defined functions. In the example, there is
    only the `hello` function there. This block tells us this function is written
    in the Go programming language (`lang: go`). The function''s handler specified
    by `handler: ./hello` points to the directory containing the source file of the
    real working function (`./hello/handler.go`). In the example, the output image''s
    name is specified by `image: hello`. Before building the function, we would change
    the image name to `<your Docker ID>/hello:v1` as it is a best practice to not
    use the `:latest` tag:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions`块列出了所有已定义的函数。在这个例子中，只有`hello`函数。该块告诉我们这个函数是用Go编程语言编写的（`lang: go`）。函数的处理程序由`handler:
    ./hello`指定，指向包含真实工作函数源文件的目录（`./hello/handler.go`）。在此示例中，输出镜像的名称由`image: hello`指定。在构建函数之前，我们会将镜像名称更改为`<your
    Docker ID>/hello:v1`，因为不建议使用`:latest`标签，这是最佳实践。'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Building and pushing
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建并推送
- en: 'We will edit the last line to be `image: chanwit/hello:v1`. Again, do not forget
    to replace my Docker ID with yours. We then build with the `faas-cli build` command.
    We use `-f` to specify a function definition file for the CLI. Please note that
    there will be two stages and 17 steps to build this Dockerfile:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将编辑最后一行，将其改为 `image: chanwit/hello:v1`。再次提醒，不要忘记将我的 Docker ID 替换为你自己的。然后我们使用
    `faas-cli build` 命令进行构建。我们使用 `-f` 来指定函数定义文件。请注意，构建这个 Dockerfile 会有两个阶段和 17 个步骤：'
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Go function template will be copied from the `template/go` directory to
    the `build/hello` directory.  Then the handler file, `hello/handler.go`, will
    be copied to `build/hello/function/handler.go`. The program's entry point is defined
    in `build/hello/main.go`, which in turn calls the handler function. During the
    build process, the `docker build` command will be executed internally by `faas-cli`.
    Steps defined inside the Dockerfile will be used to compile and pack the function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Go 函数模板将从 `template/go` 目录复制到 `build/hello` 目录。然后，处理器文件 `hello/handler.go` 会被复制到
    `build/hello/function/handler.go`。程序的入口点在 `build/hello/main.go` 中定义，它又调用处理器函数。在构建过程中，`faas-cli`
    会内部执行 `docker build` 命令。Dockerfile 中定义的步骤将用于编译和打包函数。
- en: 'The following figure explains how the Dockerfile, the source files, and the
    template are related to each other:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下图解释了 Dockerfile、源文件和模板之间的关系：
- en: '![](img/4fe6a32f-8abf-4365-b68c-b4d3ee99e5c6.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fe6a32f-8abf-4365-b68c-b4d3ee99e5c6.png)'
- en: 'Figure 4.10: OpenFaaS template and its related components for the Go language'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：Go 语言的 OpenFaaS 模板及其相关组件
- en: 'After the build is completed, we check the directory''s structure again. This
    time, run  `tree -L 3 .` to show the directory for three levels of depth because
    we want to inspect the contents of the `build` directory, which is created by
    the `faas-cli build` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们再次检查目录结构。这次运行 `tree -L 3 .` 来显示三层深度的目录，因为我们需要检查由 `faas-cli build` 命令创建的
    `build` 目录的内容：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can push the built image to a Docker repository directly, also with the `faas-cli
    push` command. Use `-f` to specify the specification file. The value of `functions.image` for
    the specification will be used for pushing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将构建的镜像推送到 Docker 仓库，同样使用 `faas-cli push` 命令。使用 `-f` 来指定规范文件。规范文件中 `functions.image`
    的值将用于推送：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Deploying and invoking
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署与调用
- en: 'To deploy the newly built function, we use the `faas-cli deploy` command. It
    reads the function specification with `-f`, similar to other sub-commands. In
    this example, it uses the value of the provider''s gateway to deploy the function.
    If there''s already a previous function running as a service on Docker Swarm,
    the old one will be deleted before deploying the new one. After deployment, the
    URL for manually invoking the function, such as via `curl`, will be shown:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署新构建的函数，我们使用 `faas-cli deploy` 命令。它通过 `-f` 参数读取函数规范，类似于其他子命令。在这个例子中，它使用提供者的网关值来部署函数。如果
    Docker Swarm 上已经有一个以前运行的函数作为服务，旧的函数将在部署新函数之前被删除。部署完成后，手动调用该函数的 URL（例如通过 `curl`）将显示出来：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To obtain all running functions on the cluster, we can run the `faas-cli list`
    command. The command also shows the number of invocations done on each function,
    and the number of replicas for function instances. The replicas will be increased
    automatically when the invocation rate gets high enough. All of this information
    is stored inside the instance of Prometheus. We will see it in a better way, with
    a Grafana dashboard, in the next section:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取集群中所有正在运行的函数，我们可以运行 `faas-cli list` 命令。该命令还会显示每个函数的调用次数以及函数实例的副本数。当调用频率足够高时，副本数量会自动增加。所有这些信息都存储在
    Prometheus 实例中。我们将在下一节通过 Grafana 仪表板更好地查看这些信息：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `hello` function accepts input via `stdin` and output via `stdout`. To
    test invocation of the function, a sentence is echoed and piped to the `stdin`
    of the command `faas-cli invoke`. This invocation is processed via the OpenFaaS
    framework, and all invocation stats are recorded on a Prometheus instance in the
    cluster:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello` 函数通过 `stdin` 接受输入，并通过 `stdout` 输出结果。为了测试函数的调用，我们将一句话回显并通过管道传递给 `faas-cli
    invoke` 命令的 `stdin`。这个调用通过 OpenFaaS 框架处理，所有的调用统计数据都会记录在集群中的 Prometheus 实例上：'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Templates
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: The predefined templates may be good enough for strings and developing simple
    functions, but when things get complex, it is great to know how to tweak OpenFaaS
    templates by ourselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的模板对于字符串处理和开发简单函数来说可能足够了，但当事情变得复杂时，了解如何自己调整 OpenFaaS 模板就变得非常重要。
- en: 'In this section, the Go template will be tweaked to simply reduce the number
    of build steps as an example. The following Dockerfile of the Go template can
    be found at `template/go/Dockerfile`. This Dockerfile already uses the multi-stage
    build technique:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，将调整Go模板以简化示例中的构建步骤数量。可以在`template/go/Dockerfile`找到以下Go模板的Dockerfile。此Dockerfile已经使用了多阶段构建技术：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Templates can be hosted on a custom Git repository. Here''s the structure of
    a template repository, which can be fetched by the `template` sub-command. The
    first level must be a directory named `template/`. Inside the `template` directory,
    there may be a number of directories, for example, `go/` in the following structure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以托管在自定义Git存储库中。以下是一个模板存储库的结构，可以通过`template`子命令获取。第一级必须是名为`template/`的目录。在`template`目录内，可能会有多个目录，例如，在以下结构中有`go/`目录：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After storing the whole template source in a GitHub repository, it can be pulled
    for building and tweaking later with `faas-cli template pull`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个模板源代码存储在GitHub存储库中后，可以使用`faas-cli template pull`稍后进行拉取和调整：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After pulling the tweaked template, the image can be rebuilt and the number
    of build steps is reduced to *15*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉取调整后的模板之后，可以重新构建镜像，并将构建步骤数量减少到*15*：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The OpenFaaS dashboard
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenFaaS仪表板
- en: 'A good OpenFaaS dashboard is available on the Grafana platform. To make Grafana
    work with OpenFaaS, the Grafana server must be on the same network. We can use
    the following command to run a Grafana server via `docker service create` outside
    the OpenFaaS stack. It links to the OpenFaaS stack via the `--network=func_functions` argument:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grafana平台上有一个良好的OpenFaaS仪表板。要使Grafana与OpenFaaS配合工作，Grafana服务器必须在相同的网络上。我们可以使用以下命令通过`docker
    service create`在OpenFaaS堆栈外运行Grafana服务器。它通过`--network=func_functions`参数与OpenFaaS堆栈进行链接：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, open the dashboard at `http://localhost:3000`. Log in using
    the username `admin` and password `admin`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以在`http://localhost:3000`打开仪表板。使用用户名`admin`和密码`admin`登录：
- en: '![](img/8d321df6-d5ca-474c-990b-2dd4bb165233.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d321df6-d5ca-474c-990b-2dd4bb165233.png)'
- en: 'Figure 4.11: Grafana home dashboard'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：Grafana主页仪表板
- en: 'A data source has to be created and pointed to the Prometheus server before
    using it as the source of a dashboard. Firstly, the data source name must be `prometheus`.
    Secondly, the URL needs to point to `http://prometheus:9090`. After that, we can
    click the Save and Test buttons. A green popup will be displayed if the data source
    setting is correct:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其用作仪表板数据源之前，必须创建并指向Prometheus服务器的数据源。首先，数据源名称必须为`prometheus`。其次，URL需要指向`http://prometheus:9090`。之后，我们可以点击保存和测试按钮。如果数据源设置正确，将显示绿色弹出窗口：
- en: '![](img/6e189bc6-e859-4c1c-b972-e11975a503cc.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e189bc6-e859-4c1c-b972-e11975a503cc.png)'
- en: 'Figure 4.12: Defining a new Prometheus data source in Grafana'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：在Grafana中定义一个新的Prometheus数据源
- en: 'Next, an OpenFaaS dashboard can be imported using the dashboard''s ID. We will
    use dashboard number `3434`, then click on Load to prepare to import the dashboard:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以使用仪表板的ID导入OpenFaaS仪表板。我们将使用仪表板号`3434`，然后点击加载以准备导入仪表板：
- en: '![](img/0033754c-0749-4a47-8f23-618dbbaf6b38.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0033754c-0749-4a47-8f23-618dbbaf6b38.png)'
- en: 'Figure 4.13: The dashboard importing screen in Grafana'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：在Grafana中导入仪表板的屏幕
- en: 'Next, the dialog will be changed to Importing Dashboard from Grafana.com. Here,
    it will ask us to include the dashboard name. We can leave it as the default name.
    It will also ask which data source we would like to use. Choose the Prometheus
    data source, which s already defined in the previous steps. After that, click
    the Import button to finish the importing process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对话框将更改为从Grafana.com导入仪表板。在这里，它将要求我们包括仪表板名称。我们可以将其保留为默认名称。它还会询问我们想要使用哪个数据源。选择之前步骤中已定义的Prometheus数据源。之后，点击导入按钮完成导入过程：
- en: '![](img/b107a45e-9197-485d-9b06-9bd03fa48f29.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b107a45e-9197-485d-9b06-9bd03fa48f29.png)'
- en: 'Figure 4.14: Setting the dashboard''s name and selecting the Prometheus data
    source for it'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：设置仪表板名称并选择其Prometheus数据源
- en: 'Here''s what the dashboard looks like. It displays the gateway''s health status
    in a box and the number of gateway services as a gauge. The total function invocation
    stat is displayed as a line chart with numbers. The `hello` function written in
    Go is linearly invoked more than 20,000 times. During the test, the number of
    function replicas is scaled up, from five to 20\. However, it is tested on a single
    machine, so the invocation rate does not change significantly:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是仪表板的展示。它在一个框中显示了网关的健康状态，并以仪表的形式显示网关服务的数量。总函数调用统计以线形图展示，配有数字。在测试中，Go 编写的 `hello`
    函数被线性调用超过 20,000 次。在测试过程中，函数副本的数量从 5 个扩展到了 20 个。然而，由于测试是在单机上进行的，因此调用速率没有显著变化：
- en: '![](img/45bc094a-3745-433e-b3e0-d176cb9aa4c9.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45bc094a-3745-433e-b3e0-d176cb9aa4c9.png)'
- en: 'Figure 4.15: The OpenFaaS dashboard in action'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：OpenFaaS 仪表板的实际操作
- en: 'Here''s the mechanism to allow OpenFaaS to auto-scale function replicas. First,
    when a client requests function invocation through the API gateway, the invocation
    will be stored in Prometheus. Inside Prometheus, there is an **Alert Manager**,
    which is responsible for firing events when a predefined rule is matched. OpenFaaS
    defines a rule for the **Alert Manager** to scale the number of replicas up by
    hooking the event with its **Alert Handler** URL, `http://gateway:8080/system/alert`.
    This **Alert Handler** will take care of calculating the number of replicas, checking
    the max replicas limit, and scaling the replicas of a certain function by sending
    the `scale` command to the cluster via the Swarm client API. The following diagram
    illustrates the steps behind this autoscaling mechanism:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是允许 OpenFaaS 自动扩展函数副本的机制。首先，当客户端通过 API 网关请求函数调用时，该调用将存储在 Prometheus 中。在 Prometheus
    内部，有一个 **Alert Manager**，它负责在预定义规则匹配时触发事件。OpenFaaS 为 **Alert Manager** 定义了一条规则，通过将事件与其
    **Alert Handler** URL `http://gateway:8080/system/alert` 关联，来扩展副本数量。这个 **Alert
    Handler** 将负责计算副本数量，检查最大副本限制，并通过 Swarm 客户端 API 向集群发送 `scale` 命令，从而扩展某个函数的副本。下图展示了这个自动扩展机制背后的步骤：
- en: '![](img/bf021a9b-d815-426c-87a8-31ee37c2076d.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf021a9b-d815-426c-87a8-31ee37c2076d.png)'
- en: 'Figure 4.16: The alerting mechanism of OpenFaaS to auto-scale the replicas
    of function services in the Docker Swarm'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：OpenFaaS 在 Docker Swarm 中自动扩展函数服务副本的告警机制
- en: Exercises
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here''s a list of questions to you help review all of the topics you should
    remember and understand from this chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是帮助你回顾本章中需要记住和理解的所有主题的问题列表：
- en: What are the advantages of using OpenFaaS?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 OpenFaaS 有什么优势？
- en: Please describe the OpenFaaS architecture. How does each component talk to another?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请描述 OpenFaaS 的架构。各个组件是如何相互通信的？
- en: How do we deploy an OpenFaaS stack on the Docker Swarm?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Docker Swarm 上部署 OpenFaaS 堆栈？
- en: Why does OpenFaaS use a multi-stage build?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 OpenFaaS 使用多阶段构建？
- en: How do we create a new OpenFaaS function for Node.js?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为 Node.js 创建一个新的 OpenFaaS 函数？
- en: How do we build and pack an OpenFaaS function?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何构建并打包一个 OpenFaaS 函数？
- en: What is the default name of the overlay network used by OpenFaaS?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenFaaS 使用的覆盖网络的默认名称是什么？
- en: What is the function template? What is it for?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函数模板？它的用途是什么？
- en: Describe the steps to prepare a custom template and host it on GitHub.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述准备自定义模板并将其托管在 GitHub 上的步骤。
- en: How do we define a Grafana dashboard for OpenFaaS?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为 OpenFaaS 定义 Grafana 仪表板？
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed OpenFaaS, its architecture, and how we can use it as
    a serverless framework to deploy functions in Docker Swarm. OpenFaaS has several
    compelling features, especially its ease of use. This chapter showed that deploying
    an OpenFaaS stack is quite simple in Docker Swarm infrastructure. Then, this chapter
    continued to discuss how to define, build, pack, and deploy functions in OpenFaaS.
    It also discussed an advanced topic of how to tweak and prepare custom templates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 OpenFaaS 及其架构，以及我们如何将其作为无服务器框架在 Docker Swarm 上部署函数。OpenFaaS 具有多个令人信服的特性，特别是其易用性。本章展示了在
    Docker Swarm 基础设施中部署 OpenFaaS 堆栈非常简单。接着，本章继续讨论了如何定义、构建、打包和部署 OpenFaaS 函数。它还讨论了如何调整和准备自定义模板的高级话题。
- en: Monitoring OpenFaaS is quite simple, as it comes with Prometheus built in. We
    only need to install a Grafana dashboard and connect it to the Prometheus data
    source and we will have a ready-to-use dashboard, helping us to operate an OpenFaaS
    cluster.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 OpenFaaS 非常简单，因为它内置了 Prometheus。我们只需要安装 Grafana 仪表板并将其连接到 Prometheus 数据源，就能获得一个现成的仪表板，帮助我们操作
    OpenFaaS 集群。
- en: The next chapter will introduce the Fn Project, which allows us to deploy an
    FaaS platform on a plain Docker infrastructure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍Fn项目，它允许我们在普通的Docker基础设施上部署FaaS平台。
