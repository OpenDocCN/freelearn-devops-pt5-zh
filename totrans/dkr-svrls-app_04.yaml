- en: OpenFaaS on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce OpenFaaS, a serverless framework that uses a software
    container as a unit of deployment. OpenFaaS has been designed to run and utilize
    the orchestration engine in Docker Swarm mode.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter will start by introducing OpenFaaS and explaining its architecture.
    Then we will go on to discuss how to use OpenFaaS to prepare and deploy functions.
    Finally, this chapter will end with how to install a Grafana/Prometheus dashboard
    for OpenFaaS.
  prefs: []
  type: TYPE_NORMAL
- en: What is OpenFaaS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenFaaS is a framework and infrastructure preparation system for building serverless
    applications. It originated from the serverless framework in the Docker Swarm
    and now supports other kinds of infrastructure backends, such as Kubernetes or
    Hyper.sh. Functions in OpenFaaS are containers. Any program written in any language
    can be packed as a function by leveraging the container technologies of Docker.
    This enables us to fully reuse the existing code to consume a wide range of web
    service events without rewriting the code. OpenFaaS is a great tool for modernizing
    old systems to run on a cloud-based infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several serverless frameworks out there in the cloud-native landscape.
    However, some problems need to be addressed by Alex Ellis, the original author
    of OpenFaaS. The driving factor behind the making of the framework is shaping the
    following, compelling features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of use**: Basically, many serverless frameworks are complex to deploy
    by nature, as they are built by big companies and are serverless services. OpenFaaS,
    on the other hand, aims to be a serverless stack that is easy enough for developers
    and small companies to deploy and use on their own hardware. OpenFaaS also comes
    with a ready-to-use UI portal, which allows us to try out function invocation
    in the browser. OpenFaaS has autoscaling capability built in. It measures the
    load of function invocation automatically and scales instances up or down on demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable**: There are several orchestration engines in the container ecosystem,
    notably Docker Swarm and Google''s Kubernetes. OpenFaaS was first designed to
    work on Swarm and later on Kubernetes. Its functions are portable across these
    orchestration engines. Not only portable in a runtime sense, an OpenFaaS function
    is just a plain Docker container. This means that every kind of workload can be
    repacked as a function container and simply deployed on an OpenFaaS cluster. OpenFaaS
    runs on any infrastructure, including on-premises hardware, private clouds, and
    public clouds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity in architecture and design**: The architecture of OpenFaaS is
    simple. It consists of the API gateway for accepting requests. The API gateway
    then passes the requests to containers, functions with *watchdogs*, inside the
    cluster. Watchdog is a component of OpenFaaS which will be discussed shortly,
    in the next section. The gateway also keeps track of the number of function invocations.
    When the volume of requests is going to be large, the gateway will trigger the
    orchestration engine to scale replicas of functions on demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open and extensible platform**: OpenFaaS is designed to be open and extensible.
    With this openness and extensibility, the number of FaaS backends supported by
    OpenFaaS has been increasing over time, as anyone can contribute a new backend
    for OpenFaaS. For example, if we want to run functions directly in a container
    runtime, such as containers, for performance reasons, we can extend OpenFaaS by
    writing a new containerd backend for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language agnostic**: We can write OpenFaaS functions in any language supported
    by Linux or Windows, then pack them as Docker or OCI container images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used to build our systems in the **monolithic** style. Now we use microservices. A
    microservice is definitely decomposable into smaller functions. Obviously, a function
    is the next step in architectural evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic is a software architecture that contains distinguishable software
    concerns. Every service is built into a single deployment module.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture, in contrast, separates coherent services inside
    a single monolithic module to be externally, loosely coupled services.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function as a Service** or **FaaS** is another level of separation. In this
    architecture, a microservice is split into more fine-grained units, *functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16d65833-acfd-420e-be4f-240a0c9d9aaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Monolithic, microservice, and function architectures'
  prefs: []
  type: TYPE_NORMAL
- en: OpenFaaS components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section explains the components of OpenFaaS. The components are the API
    gateway, the function watchdog, and an instance of Prometheus. All are running
    on top of Docker Swarm or Kubernetes orchestration engines. The API gateway and
    the instance of Prometheus run as services, while the function watchdog runs as
    the part of function containers. The container runtime can be any modern version
    of Docker or containerd:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92b4f5eb-d334-46b7-92a5-61cc13a83fd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: An overview of the OpenFaaS architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client could be `curl`, `faas-cli`, or any HTTP-based client that is able
    to connect to the API gateway in order to invoke a function. A function container,
    having a function watchdog as its sidecar (an implementation pattern that lets
    another sidecar process run alongside the main process in the same container),
    lives in the cluster behind the API gateway. Each service is communicating via
    the main overlay network, `func_functions` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/051f63a6-752b-4c3f-8f7a-5e0ae2e49a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The internal infrastructure of OpenFaaS running on Docker Swarm'
  prefs: []
  type: TYPE_NORMAL
- en: Function watchdog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function watchdog is an OpenFaaS component. It is responsible for wrapping
    the real working code around a function program. The function program's requirement
    is only to accept input via the **standard input** (**stdin**) and print out the
    result, of course, to the **standard output** (**stdout**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The API gateway (`gateway`) connects to function containers through an overlay
    network. Each function container contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Function watchdog, `fwatchdog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A certain function program written in any language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Dockerfile describing a function container must have the `fprocess` environment
    variable pointing to the function program name and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d243f05-d120-44d8-82f3-194adfe910ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Interaction between function watchdog and the function program
    in the container'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenFaaS command-line interface is just another way to use OpenFaaS. The
    latest version of the CLI can be obtained directly from the installation script
    at [https://cli.openfaas.com](https://cli.openfaas.com). For both Linux and macOS,
    the CLI can be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Currently, the installation script supports macOS and Linux running on ARM,
    ARM64, and x64 chips. The CLI has been designed to manage the life cycle of OpenFaaS
    functions. We can build, deploy, and invoke functions using sub-commands provided
    by the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI actually controls OpenFaaS via a set of control plane APIs exposed by
    its API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenFaaS API gateway provides routing mechanisms to expose your functions
    to the external world.
  prefs: []
  type: TYPE_NORMAL
- en: When a function is invoked by an external request, the function metric will
    be collected and put into a Prometheus instance. The API gateway keeps monitoring
    a number of requests for each function, and scales it on demand by increasing
    the service replica via the Docker Swarm API. Basically, OpenFaaS fully utilizes
    the scheduling mechanism of Docker Swarm for its autoscaling. The API gateway
    also comes with a built-in user interface, called the **UI portal**. The UI allows
    us to define and invoke functions with a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenFaaS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is extremely simple to install OpenFaaS locally on a development machine.
    Make sure you have Docker 17.05 or later installed and you will be ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to initialize a Swarm cluster. A single node Swarm is enough
    to be used in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the Swarm cannot be initialized because the machine has *multiple network
    interfaces*, we have to specify an IP address or an interface name for the argument, `--advertise-addr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenFaaS can be up and running directly from its source by cloning the repository
    from GitHub. Then, check out the OpenFaaS version you want and run the `deploy_stack.sh`
    script. The following example is to start version 0.6.5 of OpenFaaS. Please note
    that there is `docker-compose.yml` in this directory, which will be used by the
    `docker_stack.sh` to deploy the OpenFaaS Docker stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We now see that a number of services are deployed to the Docker Swarm cluster.
    It is actually done by running `docker stack deploy` behind the scenes inside
    the bash script. The Docker stack's name used by OpenFaaS is `func`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether services are deployed properly in the `func` stack, we use
    `docker stack ls` to list stacks and their running services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we know that there is a stack of 11 services named `func`. Let''s check
    their details with `docker stack services func`. We use the format argument to
    let the `docker stack services func` command show each service''s name and port. You
    can leave out the `--format` to see all information about each service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After everything is up and running, the OpenFaaS portal can be opened via `http://127.0.0.1:8080`.
    The following screenshot shows the browser running OpenFaaS Portal. All available
    functions are listed in the left panel. When clicking a function name, the main
    panel will show the function''s details. We can play around with each function
    by clicking the INVOKE button on the main panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f55c2446-4521-4dd1-8ca0-ae9918413d81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The OpenFaaS UI invoking an example function'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to prepare a function to run on the OpenFaaS platform in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before a function can be deployed and invoked, we need to prepare a binary program
    and pack it as a function container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to package your program into a function container:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dockerfile containing the `FROM` instruction to derive it from a base
    image. You can even use the Alpine base image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the function watchdog binary to the image using the `ADD` instruction. The
    function watchdog's name is `fwatchdog` and can be found on the OpenFaaS release
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the function program to the image. We usually use the `COPY` instruction
    to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the environment variable named `fprocess` with the `ENV` instruction
    to point to our function program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose port `8080` for this container image using the `EXPOSE` instruction with,
    of course, port number `8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an entry point of this container image. We use `ENTRYPOINT` to point
    to `fwatchdog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will do something a bit unusual, but in the proper way, to prepare a function
    container. We use a Docker feature called **multi-stage builds** to both compile
    the program and pack the function container using a single Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: What is multi-stage build? The multi-stage build feature allows a single Dockerfile
    to have several build stages chaining along the build process.
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, we can build a very tiny Docker image by discarding large
    image layers from the previous build stages. This feature requires Docker 17.05
    or greater.
  prefs: []
  type: TYPE_NORMAL
- en: Packing a C program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's an unusual, but simple, example of a function. In this example, we'll
    try to compile, pack, and deploy a C program as a function. Why a C program? Basically,
    if we know that we can pack a C program, then any traditional program could be
    compiled and packed in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that when we design a function, it receives an input from `stdin` and
    sends an output to `stdout`. A C program will then send a simple sentence out
    to `stdout`, of course with `printf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Normally, this C program can be compiled using `gcc` before copying and packing
    it as a container. But to make a Dockerfile self-contained, the multi-stage build
    technique will be used to compile and pack it as a function using a single `docker
    build` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following multi-stage Dockerfile consists of two stages. `State 0` starts
    with the Alpine 3.6 image, then installs `gcc` and `musl-dev` for compiling a
    C program. There is a command to build the C program statically, `gcc -static`,
    so that it does not require any shared object libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Stage 1** also starts with the Alpine 3.6 base image. It adds the `fwatchdog`
    binary directly from the OpenFaaS GitHub release page and changes its mode to
    be executable (`chmod +x`). The most important part of this Dockerfile is when
    it copies the main binary from the previous state, **Stage 0**. This can be done
    using the `COPY` instruction with the `--from` argument. The build process of
    the `func_c` container image is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3a2af04-0e0d-4ee6-8980-c9cac686a42e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Illustration of multi-stage build workflow from the example'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line from the previous Dockerfile shows how to use the  `COPY`
    instruction to copy a file between stages. In **Stage 1**, the `COPY --from=0` means
    that the command will copy a file or a set of files from **Stage 0** to **Stage
    1**. In the previous example, it will change the `/root/main` file from **Stage
    0** to be `/usr/bin/func_c` in **Stage 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As the multi-stage Dockerfile is ready, the next step is to `docker build` with
    that Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing this, an environment variable, `DOCKER_ID`, will be set to be
    your Docker ID. If you do not have one, please visit [https://hub.docker.com](https://hub.docker.com)
    and sign up there. The use of this `DOCKER_ID` variable will allow you to follow
    the commands without changing my Docker ID to yours for every code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The running state of the function container will look like the image stack
    illustrated in *Figure 4.7*. The lowest level is the root filesystem on top of
    the operating system''s kernel. The next levels are the base image and the image
    layers mounted on top of each other, using the capability of a union filesystem.
    The top-most layer is a writable file system for each running container that represents
    an OpenFaaS function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8380331d-9016-4e54-9865-fae896372dc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: A function as a running container with a writable file system layer
    on top'
  prefs: []
  type: TYPE_NORMAL
- en: 'With multi-stage builds, we can create a very small image containing only the
    binary files needed to be a function. By discarding the whole of **Stage 0**''s
    image layers, consisting of all compiler and dependency stuff, the final image
    size is reduced to be just around 11 MB in total. It can be checked by running
    `docker image ls $DOCKER_ID/func_c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that the OpenFaaS mechanism will look for an image from the repository
    first. So, before using the container image as a function, it would be safe to
    push the image to Docker Hub, or your repository. This can simply be done using
    the `docker image push` command. Please note that you may require `docker login`
    to authenticate with Docker Hub before pushing the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Defining and invoking a function with the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is really simple to define and invoke a function on OpenFaaS. After pushing
    the image, a function can be defined via the OpenFaaS UI Portal. First, open `http://127.0.0.1:8080/ui`.
    Then, you will see a clickable label, CREATE NEW FUNCTION, in the left panel.
    After clicking it, dialog for defining a function will pop up. It requires the
    Docker image name for this function; in this case, the image name will be `chanwit/func_c`.
    Again, please do not forget to change my Docker ID to yours. Second, the definition
    requires a function name. Just name it `func_c`. Third, we need to define the
    value for the `fprocess` field pointing to the command line to invoke the binary
    program. In this example, the command line will simply be `/usr/bin/func_c` inside
    the container. If the function program requires some parameters, also include
    them there. Finally, the function definition requires the name of a Docker overlay
    network to allow the API gateway to connect to the function containers. Just include
    the default one, `func_functions`, there. It is really important to note that
    if an OpenFaaS stack is deployed to another environment, and has a different overlay
    network name, you must not forget to specify the correct one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b66e0be3-f89f-4e51-a30b-5c7d78100a85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Defining an OpenFaaS function via the UI'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything looks fine, click CREATE to define the function. After creation,
    the `func_c` function will be listed in the left panel. Clicking on the function''s
    name will show the main panel for function invocation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34e7ba20-5f07-4f95-a1aa-ca2441561a88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Invocation of the func_c function with its response body'
  prefs: []
  type: TYPE_NORMAL
- en: If a function requires any input, the input data in the form of text or JSON
    can be placed as the Request body. However, the `func_c` function does not accept
    any input, so just press the INVOKE button and the function will be called. In
    the example, the invocation process is completed and its status is OK: `200`.
    The API gateway gets the STDOUT from the function's binary, `/usr/bin/func_c`,
    and shows it here as the Response body in text format.
  prefs: []
  type: TYPE_NORMAL
- en: Using the OpenFaaS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenFaaS CLI, `faas-cli`, is a command-line tool to help manage, prepare,
    and invoke functions. On Linux, the OpenFaaS CLI can be installed using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, it can be installed via `brew` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, on Windows, `faas-cli.exe` can be downloaded directly from the
    OpenFaaS GitHub repository and run manually.
  prefs: []
  type: TYPE_NORMAL
- en: However, we assume that every example is running on Linux. In the following
    example, the `hello` function will be created using OpenFaaS's template for the
    Go language, which can be found at `openfaas/fass-cli` in GitHub in the `template/go`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Locally, all templates will be stored in the `template/` directory of the working
    directory. If the template directory does not exist, all templates will be fetched
    from GitHub's, `openfaas/faas-cli`. As of OpenFaaS 0.6, there are 10 available
    templates for five different programming languages there.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a new function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a function written in the Go language, we use the `faas-cli new --lang=go
    hello` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the function is created, we can check the structure of the function directory
    by running the `tree -L 2 .` command. It shows the directory at two levels of
    depth, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we will look at the function definition in the `hello.yml` file. From
    `hello.yml` , there are two top-levels,  `provider` and `functions`.
  prefs: []
  type: TYPE_NORMAL
- en: The `provider` block tells us that its provider's name is `faas`, the default
    OpenFaaS implementation in Docker Swarm. Also, it tells us that the gateway endpoint
    is at `http://localhost:8080`, where an instance of the API gateway is running.
    In a production environment, this URL could be changed to point to the real IP
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `functions` block lists all defined functions. In the example, there is
    only the `hello` function there. This block tells us this function is written
    in the Go programming language (`lang: go`). The function''s handler specified
    by `handler: ./hello` points to the directory containing the source file of the
    real working function (`./hello/handler.go`). In the example, the output image''s
    name is specified by `image: hello`. Before building the function, we would change
    the image name to `<your Docker ID>/hello:v1` as it is a best practice to not
    use the `:latest` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Building and pushing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will edit the last line to be `image: chanwit/hello:v1`. Again, do not forget
    to replace my Docker ID with yours. We then build with the `faas-cli build` command.
    We use `-f` to specify a function definition file for the CLI. Please note that
    there will be two stages and 17 steps to build this Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Go function template will be copied from the `template/go` directory to
    the `build/hello` directory.  Then the handler file, `hello/handler.go`, will
    be copied to `build/hello/function/handler.go`. The program's entry point is defined
    in `build/hello/main.go`, which in turn calls the handler function. During the
    build process, the `docker build` command will be executed internally by `faas-cli`.
    Steps defined inside the Dockerfile will be used to compile and pack the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure explains how the Dockerfile, the source files, and the
    template are related to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fe6a32f-8abf-4365-b68c-b4d3ee99e5c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: OpenFaaS template and its related components for the Go language'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the build is completed, we check the directory''s structure again. This
    time, run  `tree -L 3 .` to show the directory for three levels of depth because
    we want to inspect the contents of the `build` directory, which is created by
    the `faas-cli build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can push the built image to a Docker repository directly, also with the `faas-cli
    push` command. Use `-f` to specify the specification file. The value of `functions.image` for
    the specification will be used for pushing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Deploying and invoking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy the newly built function, we use the `faas-cli deploy` command. It
    reads the function specification with `-f`, similar to other sub-commands. In
    this example, it uses the value of the provider''s gateway to deploy the function.
    If there''s already a previous function running as a service on Docker Swarm,
    the old one will be deleted before deploying the new one. After deployment, the
    URL for manually invoking the function, such as via `curl`, will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain all running functions on the cluster, we can run the `faas-cli list`
    command. The command also shows the number of invocations done on each function,
    and the number of replicas for function instances. The replicas will be increased
    automatically when the invocation rate gets high enough. All of this information
    is stored inside the instance of Prometheus. We will see it in a better way, with
    a Grafana dashboard, in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello` function accepts input via `stdin` and output via `stdout`. To
    test invocation of the function, a sentence is echoed and piped to the `stdin`
    of the command `faas-cli invoke`. This invocation is processed via the OpenFaaS
    framework, and all invocation stats are recorded on a Prometheus instance in the
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The predefined templates may be good enough for strings and developing simple
    functions, but when things get complex, it is great to know how to tweak OpenFaaS
    templates by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, the Go template will be tweaked to simply reduce the number
    of build steps as an example. The following Dockerfile of the Go template can
    be found at `template/go/Dockerfile`. This Dockerfile already uses the multi-stage
    build technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Templates can be hosted on a custom Git repository. Here''s the structure of
    a template repository, which can be fetched by the `template` sub-command. The
    first level must be a directory named `template/`. Inside the `template` directory,
    there may be a number of directories, for example, `go/` in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After storing the whole template source in a GitHub repository, it can be pulled
    for building and tweaking later with `faas-cli template pull`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After pulling the tweaked template, the image can be rebuilt and the number
    of build steps is reduced to *15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The OpenFaaS dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good OpenFaaS dashboard is available on the Grafana platform. To make Grafana
    work with OpenFaaS, the Grafana server must be on the same network. We can use
    the following command to run a Grafana server via `docker service create` outside
    the OpenFaaS stack. It links to the OpenFaaS stack via the `--network=func_functions` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, open the dashboard at `http://localhost:3000`. Log in using
    the username `admin` and password `admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d321df6-d5ca-474c-990b-2dd4bb165233.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Grafana home dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'A data source has to be created and pointed to the Prometheus server before
    using it as the source of a dashboard. Firstly, the data source name must be `prometheus`.
    Secondly, the URL needs to point to `http://prometheus:9090`. After that, we can
    click the Save and Test buttons. A green popup will be displayed if the data source
    setting is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e189bc6-e859-4c1c-b972-e11975a503cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Defining a new Prometheus data source in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, an OpenFaaS dashboard can be imported using the dashboard''s ID. We will
    use dashboard number `3434`, then click on Load to prepare to import the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0033754c-0749-4a47-8f23-618dbbaf6b38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: The dashboard importing screen in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the dialog will be changed to Importing Dashboard from Grafana.com. Here,
    it will ask us to include the dashboard name. We can leave it as the default name.
    It will also ask which data source we would like to use. Choose the Prometheus
    data source, which s already defined in the previous steps. After that, click
    the Import button to finish the importing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b107a45e-9197-485d-9b06-9bd03fa48f29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Setting the dashboard''s name and selecting the Prometheus data
    source for it'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the dashboard looks like. It displays the gateway''s health status
    in a box and the number of gateway services as a gauge. The total function invocation
    stat is displayed as a line chart with numbers. The `hello` function written in
    Go is linearly invoked more than 20,000 times. During the test, the number of
    function replicas is scaled up, from five to 20\. However, it is tested on a single
    machine, so the invocation rate does not change significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45bc094a-3745-433e-b3e0-d176cb9aa4c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: The OpenFaaS dashboard in action'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the mechanism to allow OpenFaaS to auto-scale function replicas. First,
    when a client requests function invocation through the API gateway, the invocation
    will be stored in Prometheus. Inside Prometheus, there is an **Alert Manager**,
    which is responsible for firing events when a predefined rule is matched. OpenFaaS
    defines a rule for the **Alert Manager** to scale the number of replicas up by
    hooking the event with its **Alert Handler** URL, `http://gateway:8080/system/alert`.
    This **Alert Handler** will take care of calculating the number of replicas, checking
    the max replicas limit, and scaling the replicas of a certain function by sending
    the `scale` command to the cluster via the Swarm client API. The following diagram
    illustrates the steps behind this autoscaling mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf021a9b-d815-426c-87a8-31ee37c2076d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: The alerting mechanism of OpenFaaS to auto-scale the replicas
    of function services in the Docker Swarm'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a list of questions to you help review all of the topics you should
    remember and understand from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of using OpenFaaS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please describe the OpenFaaS architecture. How does each component talk to another?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we deploy an OpenFaaS stack on the Docker Swarm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does OpenFaaS use a multi-stage build?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we create a new OpenFaaS function for Node.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we build and pack an OpenFaaS function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default name of the overlay network used by OpenFaaS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the function template? What is it for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the steps to prepare a custom template and host it on GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we define a Grafana dashboard for OpenFaaS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed OpenFaaS, its architecture, and how we can use it as
    a serverless framework to deploy functions in Docker Swarm. OpenFaaS has several
    compelling features, especially its ease of use. This chapter showed that deploying
    an OpenFaaS stack is quite simple in Docker Swarm infrastructure. Then, this chapter
    continued to discuss how to define, build, pack, and deploy functions in OpenFaaS.
    It also discussed an advanced topic of how to tweak and prepare custom templates.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring OpenFaaS is quite simple, as it comes with Prometheus built in. We
    only need to install a Grafana dashboard and connect it to the Prometheus data
    source and we will have a ready-to-use dashboard, helping us to operate an OpenFaaS
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce the Fn Project, which allows us to deploy an
    FaaS platform on a plain Docker infrastructure.
  prefs: []
  type: TYPE_NORMAL
