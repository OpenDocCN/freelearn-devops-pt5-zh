- en: OpenFaaS on Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenFaaS 在 Docker 上
- en: This chapter will introduce OpenFaaS, a serverless framework that uses a software
    container as a unit of deployment. OpenFaaS has been designed to run and utilize
    the orchestration engine in Docker Swarm mode.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 OpenFaaS，这是一个使用软件容器作为部署单元的无服务器框架。OpenFaaS 最初是设计用来在 Docker Swarm 模式下运行并利用编排引擎的。
- en: The chapter will start by introducing OpenFaaS and explaining its architecture.
    Then we will go on to discuss how to use OpenFaaS to prepare and deploy functions.
    Finally, this chapter will end with how to install a Grafana/Prometheus dashboard
    for OpenFaaS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从介绍 OpenFaaS 和解释其架构开始。然后，我们将讨论如何使用 OpenFaaS 来准备和部署函数。最后，本章将结束于如何为 OpenFaaS
    安装 Grafana/Prometheus 仪表盘。
- en: What is OpenFaaS?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 OpenFaaS？
- en: OpenFaaS is a framework and infrastructure preparation system for building serverless
    applications. It originated from the serverless framework in the Docker Swarm
    and now supports other kinds of infrastructure backends, such as Kubernetes or
    Hyper.sh. Functions in OpenFaaS are containers. Any program written in any language
    can be packed as a function by leveraging the container technologies of Docker.
    This enables us to fully reuse the existing code to consume a wide range of web
    service events without rewriting the code. OpenFaaS is a great tool for modernizing
    old systems to run on a cloud-based infrastructure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS 是一个用于构建无服务器应用程序的框架和基础设施准备系统。它起源于 Docker Swarm 中的无服务器框架，现在支持其他类型的基础设施后端，如
    Kubernetes 或 Hyper.sh。OpenFaaS 中的函数是容器。通过利用 Docker 的容器技术，任何用任何语言编写的程序都可以打包成一个函数。这使我们能够充分重用现有代码，消费各种
    web 服务事件，而无需重写代码。OpenFaaS 是现代化旧系统以在云基础设施上运行的一个绝佳工具。
- en: 'There are several serverless frameworks out there in the cloud-native landscape.
    However, some problems need to be addressed by Alex Ellis, the original author
    of OpenFaaS. The driving factor behind the making of the framework is shaping the
    following, compelling features:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生领域，有多个无服务器框架。然而，一些问题需要由 OpenFaaS 的原创作者 Alex Ellis 来解决。推动框架创建的动力在于塑造以下具有吸引力的特性：
- en: '**Ease of use**: Basically, many serverless frameworks are complex to deploy
    by nature, as they are built by big companies and are serverless services. OpenFaaS,
    on the other hand, aims to be a serverless stack that is easy enough for developers
    and small companies to deploy and use on their own hardware. OpenFaaS also comes
    with a ready-to-use UI portal, which allows us to try out function invocation
    in the browser. OpenFaaS has autoscaling capability built in. It measures the
    load of function invocation automatically and scales instances up or down on demand.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：基本上，许多无服务器框架由于由大公司构建并且是无服务器服务，天生就很复杂。另一方面，OpenFaaS 的目标是成为一个足够简单的无服务器技术栈，让开发者和小公司能够在自己的硬件上轻松部署和使用。OpenFaaS
    还附带一个现成的 UI 门户，允许我们在浏览器中尝试函数调用。OpenFaaS 内置了自动扩展能力。它会自动测量函数调用的负载，并根据需求扩展或缩减实例。'
- en: '**Portable**: There are several orchestration engines in the container ecosystem,
    notably Docker Swarm and Google''s Kubernetes. OpenFaaS was first designed to
    work on Swarm and later on Kubernetes. Its functions are portable across these
    orchestration engines. Not only portable in a runtime sense, an OpenFaaS function
    is just a plain Docker container. This means that every kind of workload can be
    repacked as a function container and simply deployed on an OpenFaaS cluster. OpenFaaS
    runs on any infrastructure, including on-premises hardware, private clouds, and
    public clouds.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：在容器生态系统中，有多个编排引擎，尤其是 Docker Swarm 和 Google 的 Kubernetes。OpenFaaS 最初设计时是为了在
    Swarm 上运行，后来也支持 Kubernetes。它的功能在这些编排引擎之间是可移植的。OpenFaaS 不仅在运行时具有可移植性，它的功能实际上就是一个普通的
    Docker 容器。这意味着任何类型的工作负载都可以作为函数容器重新打包，并简单地部署到 OpenFaaS 集群上。OpenFaaS 可以在任何基础设施上运行，包括本地硬件、私有云和公共云。'
- en: '**Simplicity in architecture and design**: The architecture of OpenFaaS is
    simple. It consists of the API gateway for accepting requests. The API gateway
    then passes the requests to containers, functions with *watchdogs*, inside the
    cluster. Watchdog is a component of OpenFaaS which will be discussed shortly,
    in the next section. The gateway also keeps track of the number of function invocations.
    When the volume of requests is going to be large, the gateway will trigger the
    orchestration engine to scale replicas of functions on demand.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open and extensible platform**: OpenFaaS is designed to be open and extensible.
    With this openness and extensibility, the number of FaaS backends supported by
    OpenFaaS has been increasing over time, as anyone can contribute a new backend
    for OpenFaaS. For example, if we want to run functions directly in a container
    runtime, such as containers, for performance reasons, we can extend OpenFaaS by
    writing a new containerd backend for it.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language agnostic**: We can write OpenFaaS functions in any language supported
    by Linux or Windows, then pack them as Docker or OCI container images.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used to build our systems in the **monolithic** style. Now we use microservices. A
    microservice is definitely decomposable into smaller functions. Obviously, a function
    is the next step in architectural evolution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic is a software architecture that contains distinguishable software
    concerns. Every service is built into a single deployment module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture, in contrast, separates coherent services inside
    a single monolithic module to be externally, loosely coupled services.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Function as a Service** or **FaaS** is another level of separation. In this
    architecture, a microservice is split into more fine-grained units, *functions*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16d65833-acfd-420e-be4f-240a0c9d9aaf.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Monolithic, microservice, and function architectures'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: OpenFaaS components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section explains the components of OpenFaaS. The components are the API
    gateway, the function watchdog, and an instance of Prometheus. All are running
    on top of Docker Swarm or Kubernetes orchestration engines. The API gateway and
    the instance of Prometheus run as services, while the function watchdog runs as
    the part of function containers. The container runtime can be any modern version
    of Docker or containerd:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92b4f5eb-d334-46b7-92a5-61cc13a83fd7.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: An overview of the OpenFaaS architecture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The client could be `curl`, `faas-cli`, or any HTTP-based client that is able
    to connect to the API gateway in order to invoke a function. A function container,
    having a function watchdog as its sidecar (an implementation pattern that lets
    another sidecar process run alongside the main process in the same container),
    lives in the cluster behind the API gateway. Each service is communicating via
    the main overlay network, `func_functions` by default:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/051f63a6-752b-4c3f-8f7a-5e0ae2e49a5d.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The internal infrastructure of OpenFaaS running on Docker Swarm'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Function watchdog
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function watchdog is an OpenFaaS component. It is responsible for wrapping
    the real working code around a function program. The function program's requirement
    is only to accept input via the **standard input** (**stdin**) and print out the
    result, of course, to the **standard output** (**stdout**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The API gateway (`gateway`) connects to function containers through an overlay
    network. Each function container contains the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Function watchdog, `fwatchdog`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A certain function program written in any language
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Dockerfile describing a function container must have the `fprocess` environment
    variable pointing to the function program name and arguments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d243f05-d120-44d8-82f3-194adfe910ac.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Interaction between function watchdog and the function program
    in the container'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Command-line interface
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenFaaS command-line interface is just another way to use OpenFaaS. The
    latest version of the CLI can be obtained directly from the installation script
    at [https://cli.openfaas.com](https://cli.openfaas.com). For both Linux and macOS,
    the CLI can be installed using the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Currently, the installation script supports macOS and Linux running on ARM,
    ARM64, and x64 chips. The CLI has been designed to manage the life cycle of OpenFaaS
    functions. We can build, deploy, and invoke functions using sub-commands provided
    by the CLI.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The CLI actually controls OpenFaaS via a set of control plane APIs exposed by
    its API gateway.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenFaaS API gateway provides routing mechanisms to expose your functions
    to the external world.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: When a function is invoked by an external request, the function metric will
    be collected and put into a Prometheus instance. The API gateway keeps monitoring
    a number of requests for each function, and scales it on demand by increasing
    the service replica via the Docker Swarm API. Basically, OpenFaaS fully utilizes
    the scheduling mechanism of Docker Swarm for its autoscaling. The API gateway
    also comes with a built-in user interface, called the **UI portal**. The UI allows
    us to define and invoke functions with a browser.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenFaaS
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is extremely simple to install OpenFaaS locally on a development machine.
    Make sure you have Docker 17.05 or later installed and you will be ready to go.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to initialize a Swarm cluster. A single node Swarm is enough
    to be used in the development environment:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the Swarm cannot be initialized because the machine has *multiple network
    interfaces*, we have to specify an IP address or an interface name for the argument, `--advertise-addr`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenFaaS can be up and running directly from its source by cloning the repository
    from GitHub. Then, check out the OpenFaaS version you want and run the `deploy_stack.sh`
    script. The following example is to start version 0.6.5 of OpenFaaS. Please note
    that there is `docker-compose.yml` in this directory, which will be used by the
    `docker_stack.sh` to deploy the OpenFaaS Docker stack:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We now see that a number of services are deployed to the Docker Swarm cluster.
    It is actually done by running `docker stack deploy` behind the scenes inside
    the bash script. The Docker stack's name used by OpenFaaS is `func`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether services are deployed properly in the `func` stack, we use
    `docker stack ls` to list stacks and their running services:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we know that there is a stack of 11 services named `func`. Let''s check
    their details with `docker stack services func`. We use the format argument to
    let the `docker stack services func` command show each service''s name and port. You
    can leave out the `--format` to see all information about each service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After everything is up and running, the OpenFaaS portal can be opened via `http://127.0.0.1:8080`.
    The following screenshot shows the browser running OpenFaaS Portal. All available
    functions are listed in the left panel. When clicking a function name, the main
    panel will show the function''s details. We can play around with each function
    by clicking the INVOKE button on the main panel:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f55c2446-4521-4dd1-8ca0-ae9918413d81.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The OpenFaaS UI invoking an example function'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to prepare a function to run on the OpenFaaS platform in the
    next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a function
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before a function can be deployed and invoked, we need to prepare a binary program
    and pack it as a function container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to package your program into a function container:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dockerfile containing the `FROM` instruction to derive it from a base
    image. You can even use the Alpine base image.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the function watchdog binary to the image using the `ADD` instruction. The
    function watchdog's name is `fwatchdog` and can be found on the OpenFaaS release
    page.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the function program to the image. We usually use the `COPY` instruction
    to do so.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the environment variable named `fprocess` with the `ENV` instruction
    to point to our function program.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose port `8080` for this container image using the `EXPOSE` instruction with,
    of course, port number `8080`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an entry point of this container image. We use `ENTRYPOINT` to point
    to `fwatchdog`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will do something a bit unusual, but in the proper way, to prepare a function
    container. We use a Docker feature called **multi-stage builds** to both compile
    the program and pack the function container using a single Dockerfile.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: What is multi-stage build? The multi-stage build feature allows a single Dockerfile
    to have several build stages chaining along the build process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, we can build a very tiny Docker image by discarding large
    image layers from the previous build stages. This feature requires Docker 17.05
    or greater.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Packing a C program
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's an unusual, but simple, example of a function. In this example, we'll
    try to compile, pack, and deploy a C program as a function. Why a C program? Basically,
    if we know that we can pack a C program, then any traditional program could be
    compiled and packed in a similar way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that when we design a function, it receives an input from `stdin` and
    sends an output to `stdout`. A C program will then send a simple sentence out
    to `stdout`, of course with `printf()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Normally, this C program can be compiled using `gcc` before copying and packing
    it as a container. But to make a Dockerfile self-contained, the multi-stage build
    technique will be used to compile and pack it as a function using a single `docker
    build` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The following multi-stage Dockerfile consists of two stages. `State 0` starts
    with the Alpine 3.6 image, then installs `gcc` and `musl-dev` for compiling a
    C program. There is a command to build the C program statically, `gcc -static`,
    so that it does not require any shared object libraries:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Stage 1** also starts with the Alpine 3.6 base image. It adds the `fwatchdog`
    binary directly from the OpenFaaS GitHub release page and changes its mode to
    be executable (`chmod +x`). The most important part of this Dockerfile is when
    it copies the main binary from the previous state, **Stage 0**. This can be done
    using the `COPY` instruction with the `--from` argument. The build process of
    the `func_c` container image is illustrated here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3a2af04-0e0d-4ee6-8980-c9cac686a42e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Illustration of multi-stage build workflow from the example'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line from the previous Dockerfile shows how to use the  `COPY`
    instruction to copy a file between stages. In **Stage 1**, the `COPY --from=0` means
    that the command will copy a file or a set of files from **Stage 0** to **Stage
    1**. In the previous example, it will change the `/root/main` file from **Stage
    0** to be `/usr/bin/func_c` in **Stage 1**:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the multi-stage Dockerfile is ready, the next step is to `docker build` with
    that Dockerfile.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing this, an environment variable, `DOCKER_ID`, will be set to be
    your Docker ID. If you do not have one, please visit [https://hub.docker.com](https://hub.docker.com)
    and sign up there. The use of this `DOCKER_ID` variable will allow you to follow
    the commands without changing my Docker ID to yours for every code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The running state of the function container will look like the image stack
    illustrated in *Figure 4.7*. The lowest level is the root filesystem on top of
    the operating system''s kernel. The next levels are the base image and the image
    layers mounted on top of each other, using the capability of a union filesystem.
    The top-most layer is a writable file system for each running container that represents
    an OpenFaaS function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8380331d-9016-4e54-9865-fae896372dc2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: A function as a running container with a writable file system layer
    on top'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'With multi-stage builds, we can create a very small image containing only the
    binary files needed to be a function. By discarding the whole of **Stage 0**''s
    image layers, consisting of all compiler and dependency stuff, the final image
    size is reduced to be just around 11 MB in total. It can be checked by running
    `docker image ls $DOCKER_ID/func_c`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Please note that the OpenFaaS mechanism will look for an image from the repository
    first. So, before using the container image as a function, it would be safe to
    push the image to Docker Hub, or your repository. This can simply be done using
    the `docker image push` command. Please note that you may require `docker login`
    to authenticate with Docker Hub before pushing the image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Defining and invoking a function with the UI
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is really simple to define and invoke a function on OpenFaaS. After pushing
    the image, a function can be defined via the OpenFaaS UI Portal. First, open `http://127.0.0.1:8080/ui`.
    Then, you will see a clickable label, CREATE NEW FUNCTION, in the left panel.
    After clicking it, dialog for defining a function will pop up. It requires the
    Docker image name for this function; in this case, the image name will be `chanwit/func_c`.
    Again, please do not forget to change my Docker ID to yours. Second, the definition
    requires a function name. Just name it `func_c`. Third, we need to define the
    value for the `fprocess` field pointing to the command line to invoke the binary
    program. In this example, the command line will simply be `/usr/bin/func_c` inside
    the container. If the function program requires some parameters, also include
    them there. Finally, the function definition requires the name of a Docker overlay
    network to allow the API gateway to connect to the function containers. Just include
    the default one, `func_functions`, there. It is really important to note that
    if an OpenFaaS stack is deployed to another environment, and has a different overlay
    network name, you must not forget to specify the correct one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b66e0be3-f89f-4e51-a30b-5c7d78100a85.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Defining an OpenFaaS function via the UI'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything looks fine, click CREATE to define the function. After creation,
    the `func_c` function will be listed in the left panel. Clicking on the function''s
    name will show the main panel for function invocation, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34e7ba20-5f07-4f95-a1aa-ca2441561a88.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Invocation of the func_c function with its response body'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: If a function requires any input, the input data in the form of text or JSON
    can be placed as the Request body. However, the `func_c` function does not accept
    any input, so just press the INVOKE button and the function will be called. In
    the example, the invocation process is completed and its status is OK: `200`.
    The API gateway gets the STDOUT from the function's binary, `/usr/bin/func_c`,
    and shows it here as the Response body in text format.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Using the OpenFaaS CLI
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenFaaS CLI, `faas-cli`, is a command-line tool to help manage, prepare,
    and invoke functions. On Linux, the OpenFaaS CLI can be installed using the following
    command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On macOS, it can be installed via `brew` with the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Alternatively, on Windows, `faas-cli.exe` can be downloaded directly from the
    OpenFaaS GitHub repository and run manually.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: However, we assume that every example is running on Linux. In the following
    example, the `hello` function will be created using OpenFaaS's template for the
    Go language, which can be found at `openfaas/fass-cli` in GitHub in the `template/go`
    directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Locally, all templates will be stored in the `template/` directory of the working
    directory. If the template directory does not exist, all templates will be fetched
    from GitHub's, `openfaas/faas-cli`. As of OpenFaaS 0.6, there are 10 available
    templates for five different programming languages there.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Defining a new function
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a function written in the Go language, we use the `faas-cli new --lang=go
    hello` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the function is created, we can check the structure of the function directory
    by running the `tree -L 2 .` command. It shows the directory at two levels of
    depth, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we will look at the function definition in the `hello.yml` file. From
    `hello.yml` , there are two top-levels,  `provider` and `functions`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The `provider` block tells us that its provider's name is `faas`, the default
    OpenFaaS implementation in Docker Swarm. Also, it tells us that the gateway endpoint
    is at `http://localhost:8080`, where an instance of the API gateway is running.
    In a production environment, this URL could be changed to point to the real IP
    address.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The `functions` block lists all defined functions. In the example, there is
    only the `hello` function there. This block tells us this function is written
    in the Go programming language (`lang: go`). The function''s handler specified
    by `handler: ./hello` points to the directory containing the source file of the
    real working function (`./hello/handler.go`). In the example, the output image''s
    name is specified by `image: hello`. Before building the function, we would change
    the image name to `<your Docker ID>/hello:v1` as it is a best practice to not
    use the `:latest` tag:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Building and pushing
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will edit the last line to be `image: chanwit/hello:v1`. Again, do not forget
    to replace my Docker ID with yours. We then build with the `faas-cli build` command.
    We use `-f` to specify a function definition file for the CLI. Please note that
    there will be two stages and 17 steps to build this Dockerfile:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Go function template will be copied from the `template/go` directory to
    the `build/hello` directory.  Then the handler file, `hello/handler.go`, will
    be copied to `build/hello/function/handler.go`. The program's entry point is defined
    in `build/hello/main.go`, which in turn calls the handler function. During the
    build process, the `docker build` command will be executed internally by `faas-cli`.
    Steps defined inside the Dockerfile will be used to compile and pack the function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure explains how the Dockerfile, the source files, and the
    template are related to each other:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fe6a32f-8abf-4365-b68c-b4d3ee99e5c6.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: OpenFaaS template and its related components for the Go language'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'After the build is completed, we check the directory''s structure again. This
    time, run  `tree -L 3 .` to show the directory for three levels of depth because
    we want to inspect the contents of the `build` directory, which is created by
    the `faas-cli build` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can push the built image to a Docker repository directly, also with the `faas-cli
    push` command. Use `-f` to specify the specification file. The value of `functions.image` for
    the specification will be used for pushing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Deploying and invoking
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy the newly built function, we use the `faas-cli deploy` command. It
    reads the function specification with `-f`, similar to other sub-commands. In
    this example, it uses the value of the provider''s gateway to deploy the function.
    If there''s already a previous function running as a service on Docker Swarm,
    the old one will be deleted before deploying the new one. After deployment, the
    URL for manually invoking the function, such as via `curl`, will be shown:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To obtain all running functions on the cluster, we can run the `faas-cli list`
    command. The command also shows the number of invocations done on each function,
    and the number of replicas for function instances. The replicas will be increased
    automatically when the invocation rate gets high enough. All of this information
    is stored inside the instance of Prometheus. We will see it in a better way, with
    a Grafana dashboard, in the next section:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `hello` function accepts input via `stdin` and output via `stdout`. To
    test invocation of the function, a sentence is echoed and piped to the `stdin`
    of the command `faas-cli invoke`. This invocation is processed via the OpenFaaS
    framework, and all invocation stats are recorded on a Prometheus instance in the
    cluster:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Templates
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The predefined templates may be good enough for strings and developing simple
    functions, but when things get complex, it is great to know how to tweak OpenFaaS
    templates by ourselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, the Go template will be tweaked to simply reduce the number
    of build steps as an example. The following Dockerfile of the Go template can
    be found at `template/go/Dockerfile`. This Dockerfile already uses the multi-stage
    build technique:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Templates can be hosted on a custom Git repository. Here''s the structure of
    a template repository, which can be fetched by the `template` sub-command. The
    first level must be a directory named `template/`. Inside the `template` directory,
    there may be a number of directories, for example, `go/` in the following structure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After storing the whole template source in a GitHub repository, it can be pulled
    for building and tweaking later with `faas-cli template pull`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After pulling the tweaked template, the image can be rebuilt and the number
    of build steps is reduced to *15*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The OpenFaaS dashboard
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good OpenFaaS dashboard is available on the Grafana platform. To make Grafana
    work with OpenFaaS, the Grafana server must be on the same network. We can use
    the following command to run a Grafana server via `docker service create` outside
    the OpenFaaS stack. It links to the OpenFaaS stack via the `--network=func_functions` argument:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, open the dashboard at `http://localhost:3000`. Log in using
    the username `admin` and password `admin`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d321df6-d5ca-474c-990b-2dd4bb165233.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Grafana home dashboard'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'A data source has to be created and pointed to the Prometheus server before
    using it as the source of a dashboard. Firstly, the data source name must be `prometheus`.
    Secondly, the URL needs to point to `http://prometheus:9090`. After that, we can
    click the Save and Test buttons. A green popup will be displayed if the data source
    setting is correct:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e189bc6-e859-4c1c-b972-e11975a503cc.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Defining a new Prometheus data source in Grafana'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, an OpenFaaS dashboard can be imported using the dashboard''s ID. We will
    use dashboard number `3434`, then click on Load to prepare to import the dashboard:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0033754c-0749-4a47-8f23-618dbbaf6b38.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: The dashboard importing screen in Grafana'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the dialog will be changed to Importing Dashboard from Grafana.com. Here,
    it will ask us to include the dashboard name. We can leave it as the default name.
    It will also ask which data source we would like to use. Choose the Prometheus
    data source, which s already defined in the previous steps. After that, click
    the Import button to finish the importing process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b107a45e-9197-485d-9b06-9bd03fa48f29.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Setting the dashboard''s name and selecting the Prometheus data
    source for it'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the dashboard looks like. It displays the gateway''s health status
    in a box and the number of gateway services as a gauge. The total function invocation
    stat is displayed as a line chart with numbers. The `hello` function written in
    Go is linearly invoked more than 20,000 times. During the test, the number of
    function replicas is scaled up, from five to 20\. However, it is tested on a single
    machine, so the invocation rate does not change significantly:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45bc094a-3745-433e-b3e0-d176cb9aa4c9.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: The OpenFaaS dashboard in action'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the mechanism to allow OpenFaaS to auto-scale function replicas. First,
    when a client requests function invocation through the API gateway, the invocation
    will be stored in Prometheus. Inside Prometheus, there is an **Alert Manager**,
    which is responsible for firing events when a predefined rule is matched. OpenFaaS
    defines a rule for the **Alert Manager** to scale the number of replicas up by
    hooking the event with its **Alert Handler** URL, `http://gateway:8080/system/alert`.
    This **Alert Handler** will take care of calculating the number of replicas, checking
    the max replicas limit, and scaling the replicas of a certain function by sending
    the `scale` command to the cluster via the Swarm client API. The following diagram
    illustrates the steps behind this autoscaling mechanism:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf021a9b-d815-426c-87a8-31ee37c2076d.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: The alerting mechanism of OpenFaaS to auto-scale the replicas
    of function services in the Docker Swarm'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a list of questions to you help review all of the topics you should
    remember and understand from this chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of using OpenFaaS?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please describe the OpenFaaS architecture. How does each component talk to another?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we deploy an OpenFaaS stack on the Docker Swarm?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does OpenFaaS use a multi-stage build?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we create a new OpenFaaS function for Node.js?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we build and pack an OpenFaaS function?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default name of the overlay network used by OpenFaaS?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the function template? What is it for?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the steps to prepare a custom template and host it on GitHub.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we define a Grafana dashboard for OpenFaaS?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed OpenFaaS, its architecture, and how we can use it as
    a serverless framework to deploy functions in Docker Swarm. OpenFaaS has several
    compelling features, especially its ease of use. This chapter showed that deploying
    an OpenFaaS stack is quite simple in Docker Swarm infrastructure. Then, this chapter
    continued to discuss how to define, build, pack, and deploy functions in OpenFaaS.
    It also discussed an advanced topic of how to tweak and prepare custom templates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring OpenFaaS is quite simple, as it comes with Prometheus built in. We
    only need to install a Grafana dashboard and connect it to the Prometheus data
    source and we will have a ready-to-use dashboard, helping us to operate an OpenFaaS
    cluster.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce the Fn Project, which allows us to deploy an
    FaaS platform on a plain Docker infrastructure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
