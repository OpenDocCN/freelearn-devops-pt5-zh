<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-194"><a id="_idTextAnchor194"/>11</h1>
<h1 id="_idParaDest-195"><a id="_idTextAnchor195"/>Managing Kubernetes Using Ansible</h1>
<p>Due to the containerization of applications and the revolution in microservices, Kubernetes-based platforms have become popular. The containerization of applications and container orchestration using Kubernetes provide additional layers and complexity to infrastructure that requires automated solutions for managing a large number of components.</p>
<p>In the previous chapter, you learned about the capabilities of Ansible to build and manage container images and containers. When it comes to container orchestration tools, such as Kubernetes or Red Hat OpenShift, there are Ansible collections available with modules and plugins for supporting and managing your Kubernetes and Red Hat OpenShift clusters and resources. </p>
<p>Using Ansible for Kubernetes resource management will help you to implement more integrations in your DevOps workflow and <strong class="bold">Continuous</strong><strong class="bold"> Integration/Continuous Deployment</strong> (<strong class="bold">CI/CD</strong>) pipelines to deploy your applications very flexibly. </p>
<p>In this chapter, we will cover the following topics: </p>
<ul>
<li>An introduction to Kubernetes </li>
<li>Managing Kubernetes clusters using Ansible </li>
<li>Configuring Ansible for Kubernetes</li>
<li>Deploying applications to Kubernetes using Ansible</li>
<li>Scaling Kubernetes applications</li>
<li>Executing commands inside a Kubernetes Pod</li>
</ul>
<p>We will learn about using the Ansible collection for Kubernetes management and automating Kubernetes cluster operations and resource management with it. </p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor196"/>Technical requirements</h1>
<p>The following are the technical requirements to proceed with this chapter:</p>
<ul>
<li>One Linux machine for the Ansible control node</li>
<li>A working Kubernetes cluster with API access (refer to <a href="https://minikube.sigs.k8s.io/docs/start">https://minikube.sigs.k8s.io/docs/start</a> to spin up a local Kubernetes cluster)</li>
<li>Basic knowledge about containers and Kubernetes</li>
</ul>
<p>All the Ansible code, Ansible playbooks, commands, and snippets for this chapter can be found in the GitHub repository at <a href="https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-11">https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-11</a>.  </p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor197"/>An introduction to Kubernetes</h1>
<p><strong class="bold">Kubernetes</strong> is an open source container orchestration platform where we can deploy and manage our <a id="_idIndexMarker624"/>containerized applications without worrying about the underlying layers. This model of service is known as <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>), where <a id="_idIndexMarker625"/>developers have the freedom to deploy their applications and other required resources, such as storage, network, and secrets, without assistance from the platform team.</p>
<p>The Kubernetes platform contains many components to manage container deployment and orchestration, as shown in <em class="italic">Figure 11.1</em>:</p>
<div><div><img alt="Figure 11.1 – The components of a Kubernetes cluster (source: https://kubernetes.io/docs/concepts/overview/components/) " height="487" src="img/B18383_11_01.jpg" width="1066"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The components of a Kubernetes cluster (source: <a href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a>)</p>
<p>Let’s briefly have <a id="_idIndexMarker626"/>a look at these components in the following sections.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor198"/>The Kubernetes control plane</h2>
<p>The control plane is <a id="_idIndexMarker627"/>responsible for making decisions on behalf of the cluster <a id="_idIndexMarker628"/>and application, such as scheduling the application Pods, detecting and responding to Pod failures, and managing cluster nodes. The control plane has multiple components to handle these operations, as follows:</p>
<ul>
<li><strong class="bold">kube-apiserver</strong> – Exposes <a id="_idIndexMarker629"/>the Kubernetes cluster API that will take care of all central management and communications. Each and every task inside a Kubernetes cluster is operated via the Kubernetes API server.</li>
<li><strong class="bold">kube-controller-manager</strong> – Consists of several controller processes, such as a Node <a id="_idIndexMarker630"/>controller, Job controller, Service account controller, and Endpoints controller.</li>
<li><strong class="bold">etcd</strong> – A <strong class="bold">high-availability</strong> (<strong class="bold">HA</strong>) key-value <a id="_idIndexMarker631"/>store used <a id="_idIndexMarker632"/>for storing Kubernetes cluster data.</li>
<li><strong class="bold">kube-scheduler</strong> – Helps <a id="_idIndexMarker633"/>to select nodes for deploying Pods.</li>
</ul>
<h2 id="_idParaDest-199"><a id="_idTextAnchor199"/>Components on the nodes</h2>
<p>These are the <a id="_idIndexMarker634"/>Kubernetes components <a id="_idIndexMarker635"/>running on every node in the cluster, managing the application Pods and its network:</p>
<ul>
<li><strong class="bold">Container runtime</strong> – The actual software that is running the containers in the backend, such as <strong class="bold">containerd</strong> and <strong class="bold">CRI-O</strong></li>
<li><strong class="bold">kubelet</strong> – Takes care of the running containers, as per specifications</li>
<li><strong class="bold">kube-proxy</strong> – Helps to implement Kubernetes Services by maintaining network rules on the nodes</li>
</ul>
<p>Like any other <a id="_idIndexMarker636"/>open source project, Kubernetes is <a id="_idIndexMarker637"/>also free to use and supported <a id="_idIndexMarker638"/>by the Kubernetes user and developer community (<a href="https://kubernetes.io/community">https://kubernetes.io/community</a>). If an organization is looking for enterprise Kubernetes distributions and support, there are different Kubernetes distributions available on the market as turnkey solutions, such as Red Hat OpenShift, Rancher, and VMware Tanzu.</p>
<p>Explaining the Kubernetes platform, concepts, and architecture is beyond the scope of this book. You can find more details in the <em class="italic">Further reading</em> section at the end of this chapter. </p>
<p>For using Ansible with Kubernetes, we can use <strong class="bold">minikube</strong>, which is a local Kubernetes cluster for learning about <a id="_idIndexMarker639"/>and developing Kubernetes Deployments. Refer to the documentation at <a href="https://minikube.sigs.k8s.io/docs/start">https://minikube.sigs.k8s.io/docs/start</a>, where you will find installation instructions for Linux, Windows, and macOS platforms.</p>
<p class="callout-heading">The Kubernetes Documentation</p>
<p class="callout">Refer to the Kubernetes documentation at <a href="https://kubernetes.io/docs/home">https://kubernetes.io/docs/home</a> to learn more about Kubernetes. Also refer to <em class="italic">Top 15 Free Kubernetes Courses</em> (<a href="https://www.techbeatly.com/kubernetes-free-courses">https://www.techbeatly.com/kubernetes-free-courses</a>) to learn the basics about Kubernetes. </p>
<p>In the next section, we will learn about the Ansible method for managing Kubernetes clusters.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor200"/>Managing Kubernetes clusters using Ansible</h1>
<p>Deploying a <a id="_idIndexMarker640"/>Kubernetes cluster involves many <a id="_idIndexMarker641"/>steps, including preparing nodes, installing container runtime packages, and configuring networking. There are multiple methods we can use for deploying Kubernetes clusters within testing or production environments. The installation method for a Kubernetes cluster also depends on your requirements, whether you are using single-node clusters or multi-node clusters with HA or you require the option to scale the cluster whenever needed, for example. </p>
<p><strong class="bold">Kubespray</strong> is a production-grade <a id="_idIndexMarker642"/>Kubernetes cluster deployment <a id="_idIndexMarker643"/>method that uses Ansible as its <a id="_idIndexMarker644"/>foundation for provisioning and orchestration. Using Kubespray, it is possible deploy a Kubernetes cluster on top of bare-metal servers, virtual machines, and private cloud or public cloud platforms (for example, AWS, GCE, Azure, and OpenStack). </p>
<p>Kubespray is highly customizable and you can configure the cluster with different Kubernetes components of your choice, as follows:</p>
<ul>
<li>A supported <strong class="bold">Container Network Interface</strong> (<strong class="bold">CNI</strong>) – Calico, Flannel, Kube-router, Kube-OVN, Weave, or <a id="_idIndexMarker645"/>Multus</li>
<li>A supported <strong class="bold">Container Runtime Interface</strong> (<strong class="bold">CRI</strong>) – containerd, Docker, CRI-O, Kata <a id="_idIndexMarker646"/>Containers, or gVisor</li>
<li>Supported cloud providers – AWS, Azure, OpenStack, or vSphere</li>
<li>A supported <strong class="bold">Ingress</strong> – Kube-vip, ALB <a id="_idIndexMarker647"/>Ingress, MetalLB, or Nginx</li>
<li>Supported operating systems – Debian, Fedora CoreOS, Flatcar Container Linux, openSUSE, Red Hat Enterprise Linux, CentOS, or Amazon Linux 2</li>
</ul>
<p>Kubernetes deployment <a id="_idIndexMarker648"/>using Kubespray is explained in the documentation (<a href="https://kubespray.io">https://kubespray.io</a>) and other online guides. </p>
<p>Once provisioned, the Kubernetes cluster can be scaled as needed (by adding or removing nodes) using Kubespray without worrying about the manual configurations of the new nodes and cluster-joining steps. Refer to the following information box and the <em class="italic">Further reading</em> section at the end of this chapter for links to further information on Kubespray.</p>
<p class="callout-heading">Kubespray</p>
<p class="callout">Refer to the documentation (<a href="https://kubespray.io">https://kubespray.io</a>) and project repository (<a href="https://github.com/kubernetes-sigs/kubespray">https://github.com/kubernetes-sigs/kubespray</a>) to learn more about the different options available with Kubespray. Also, check out <a href="https://www.techbeatly.com/deploying-kubernetes-with-kubespray">https://www.techbeatly.com/deploying-kubernetes-with-kubespray</a> for a detailed guide on how to deploy a multi-node Kubernetes cluster using Kubespray.</p>
<p>For the demonstration of Ansible use cases, we have used a minikube Kubernetes environment, as follows:</p>
<div><div><img alt="Figure 11.2 – minikube Kubernetes cluster details " height="442" src="img/B18383_11_02.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – minikube Kubernetes cluster details</p>
<p>Refer to <a id="_idIndexMarker649"/>the documentation (<a href="https://minikube.sigs.k8s.io/docs/start">https://minikube.sigs.k8s.io/docs/start</a>) for <a id="_idIndexMarker650"/>more details on how to create a minikube environment. </p>
<p>We will learn how to configure Ansible for Kubernetes cluster access and check cluster resources in the next section.</p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor201"/>Configuring Ansible for Kubernetes</h1>
<p>Ansible can <a id="_idIndexMarker651"/>communicate with Kubernetes <a id="_idIndexMarker652"/>clusters using the Kubernetes Python libraries or directly via the Kubernetes API, as shown in <em class="italic">Figure 11.3</em>:</p>
<div><div><img alt="Figure 11.3 – Communication between Ansible and Kubernetes  " height="286" src="img/B18383_11_03.jpg" width="758"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Communication between Ansible and Kubernetes </p>
<p>Ansible <a id="_idIndexMarker653"/>modules and plugins for managing <a id="_idIndexMarker654"/>Kubernetes are available in the <code>kubernetes.core</code> Ansible collection. (The Ansible Kubernetes collection was released as <code>community.kubernetes</code> prior to the release of <code>kubernetes.core</code> 1.1.) We will install, configure, and use the <code>kubernetes.core</code> collection in the following sections.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor202"/>Python requirements</h2>
<p>To communicate <a id="_idIndexMarker655"/>with the Kubernetes or OpenShift API, use the <strong class="bold">Python client for the OpenShift API</strong> (<a href="https://github.com/openshift/openshift-restclient-python">https://github.com/openshift/openshift-restclient-python</a>) Python library. Before using any of the Kubernetes modules, you need to install the required Python libraries, as follows:</p>
<pre class="source-code">
$ pip install openshift
$ pip install PyYAML</pre>
<p>If you are using Ansible inside a Python virtual environment, then remember to activate it and install the libraries within it.</p>
<p class="callout-heading">The Python Library for Kubernetes</p>
<p class="callout">The OpenShift REST client depends on the Kubernetes Python client (<a href="https://github.com/kubernetes-client/python">https://github.com/kubernetes-client/python</a>) and this Kubernetes Python client will be installed as part of the dependencies. Also check the Ansible Content Collection for Red Hat OpenShift (Ansible blog) – <a href="https://www.ansible.com/blog/introducing-the-ansible-content-collection-for-red-hat-openshift">https://www.ansible.com/blog/introducing-the-ansible-content-collection-for-red-hat-openshift</a> </p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor203"/>Installing the Ansible Kubernetes collection</h2>
<p>Install the <a id="_idIndexMarker656"/>Ansible Kubernetes collection <a id="_idIndexMarker657"/>from Ansible Galaxy (<a href="https://galaxy.ansible.com/kubernetes/core">https://galaxy.ansible.com/kubernetes/core</a>), as follows:</p>
<ol>
<li>Configure the <code>ansible.cfg</code> object type with the collection path if you want to install the collection inside the project directory:</li>
</ol>
<div><div><img alt="Figure 11.4 - Configure collection path in ansible.cfg " height="194" src="img/B18383_11_04.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 - Configure collection path in ansible.cfg</p>
<ol>
<li value="2">Install the <code>kubernetes.core</code> collection:</li>
</ol>
<div><div><img alt="Figure 11.5 - Install kubernetes.core collection " height="114" src="img/B18383_11_05.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 - Install kubernetes.core collection</p>
<p>The <code>kubernetes.core</code> collection will be installed inside the collection directory (<code>COLLECTIONS_PATHS = ./collections</code>) as you mentioned in the <code>ansible.cfg</code> file.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor204"/>Connecting Ansible to Kubernetes</h2>
<p>Ansible will <a id="_idIndexMarker658"/>try to use the <code>$HOME/.kube/config</code> file, which is the default Kubernetes configuration file (<code>kubeconfig</code>) containing <a id="_idIndexMarker659"/>Kubernetes cluster details, credential details, and connection contexts. If your <code>kubeconfig</code> file is residing in a different path or has a different filename, then specify this in the Kubernetes <code>module</code> parameter inside the Ansible playbook.</p>
<p>As we mentioned earlier, we have a Kubernetes cluster running on minikube. The <code>kubeconfig</code> file and certificate credentials are copied to the Ansible control node, as shown in the following figure:</p>
<div><div><img alt="Figure 11.6 – The kubeconfig file and certificates " height="248" src="img/B18383_11_06.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – The kubeconfig file and certificates</p>
<p>If you are using basic authentication (a username and password) for accessing the cluster, then specify these details inside the Kubernetes module itself.</p>
<p>For production environments, remember to follow best practices for storing the credentials, certificates, and access keys, using Ansible Vault or any other secret management system.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor205"/>Installing the kubectl CLI tool</h2>
<p>Since we are <a id="_idIndexMarker660"/>working from the control node, install the <code>kubectl</code> CLI tool on the machine and execute the <code>kubectl</code> command to verify the resources that we will be creating using Ansible. </p>
<p>If you have a machine installed with <code>kubectl</code> and access to the Kubernetes cluster, then skip this step.</p>
<p>Follow <a id="_idIndexMarker661"/>the <code>kubectl</code> installation document (<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux">https://kubernetes.io/docs/tasks/tools/install-kubectl-linux</a>) and use the appropriate method suitable for your environment (since we are running the Ansible control node on a Red Hat <a id="_idIndexMarker662"/>Enterprise Linux machine, the following commands are based on Red Hat Enterprise Linux/Fedora distributions):</p>
<ol>
<li value="1">Add the repository for the <code>kubectl</code> package.</li>
</ol>
<div><div><img alt="Figure 11.7 – Add the repository for the kubectl package " height="333" src="img/B18383_11_07.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Add the repository for the kubectl package</p>
<ol>
<li value="2">Install the <code>kubectl</code> package:</li>
</ol>
<div><div><img alt="Figure 11.8 – Installing the kubectl utility " height="114" src="img/B18383_11_08.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Installing the kubectl utility</p>
<ol>
<li value="3">Configure the <code>KUBECONFIG</code> environment variable, as our <code>kubeconfig</code> filename is different (<code>/home/ansible/.kube/minikube-config</code>) from the default filename (<code>/home/ansible/.kube/config</code>):</li>
</ol>
<div><div><img alt="Figure 11.9 – Configure the KUBECONFIG environment variable " height="114" src="img/B18383_11_09.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Configure the KUBECONFIG environment variable</p>
<ol>
<li value="4">Verify the <code>kubectl</code> CLI version and cluster details.</li>
</ol>
<div><div><img alt="Figure 11.10 – kubectl version information " height="255" src="img/B18383_11_10.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – kubectl version information</p>
<p>The <code>kubectl</code> CLI is <a id="_idIndexMarker663"/>able to access the cluster and we will go on to use it in the following sections to verify the resources in the Kubernetes cluster.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor206"/>Verifying the Kubernetes cluster details using Ansible</h2>
<p>Collecting <a id="_idIndexMarker664"/>the cluster details and <a id="_idIndexMarker665"/>resource information is an important step. The Kubernetes cluster details can be collected using the <code>kubectl</code> CLI, as shown in <em class="italic">Figure 11.11</em>:</p>
<div><div><img alt="Figure 11.11 – Kubernetes cluster details, collected using the kubectl CLI " height="334" src="img/B18383_11_11.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Kubernetes cluster details, collected using the kubectl CLI</p>
<p>Use the <code>kubernetes.core.k8s_info</code> module to collect similar details about the Kubernetes cluster using Ansible (prior to Ansible 2.9, the module was called <code>k8s_facts</code>). </p>
<p>Follow these steps to create our first Ansible playbook to interact with a Kubernetes cluster:</p>
<ol>
<li value="1">Create <code>Chapter-11/k8s-details.yaml</code>, as follows:</li>
</ol>
<div><div><img alt="Figure 11.12 – The task for fetching Pod details from the kube-system namespace " height="466" src="img/B18383_11_12.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – The task for fetching Pod details from the kube-system namespace</p>
<p>We are <a id="_idIndexMarker666"/>fetching the Pod details <a id="_idIndexMarker667"/>from the <code>kube-system</code> namespace in the Kubernetes cluster. Note the <code>hosts: localhost</code> line as the execution needs to happen on <code>localhost</code>. The Python libraries will take care of the Kubernetes operations.</p>
<ol>
<li value="2">Execute the playbook and verify the output. You will see a lot of details about the Pods running inside the <code>kube-system</code> namespace, as shown in <em class="italic">Figure 11.13</em>:</li>
</ol>
<div><div><img alt="Figure 11.13 – Pod details from a Kubernetes namespace " height="800" src="img/B18383_11_13.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Pod details from a Kubernetes namespace</p>
<ol>
<li value="3">Add one <a id="_idIndexMarker668"/>more task in the same <a id="_idIndexMarker669"/>playbook to collect the Kubernetes cluster node details.</li>
</ol>
<div><div><img alt="Figure 11.14 – The task to get the Kubernetes node details " height="353" src="img/B18383_11_14.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – The task to get the Kubernetes node details</p>
<ol>
<li value="4">Execute the playbook again and verify the results. </li>
</ol>
<p>See the node name (in this case, <code>minikube</code>), as in the output in <em class="italic">Figure 11.15</em>. If you have multiple nodes, you will see multiple entries here.</p>
<div><div><img alt="Figure 11.15 – Fetching the Kubernetes cluster node details " height="494" src="img/B18383_11_15.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Fetching the Kubernetes cluster node details</p>
<p>Customize <a id="_idIndexMarker670"/>the playbook for different <a id="_idIndexMarker671"/>clusters by using different <code>kubeconfig</code> files or providing the credential details in the module itself, such <a id="_idIndexMarker672"/>as <code>api_key</code>, <code>client_cert</code>, and <code>client_key</code>. Refer to the <code>kubernetes.core.k8s_info</code> module (<a href="https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_info_module.xhtml">https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_info_module.xhtml</a>) for more details.</p>
<p>Now, you have learned how to communicate with Kubernetes clusters using Ansible modules and how to fetch cluster details. In the next section, we will learn more about Ansible for Kubernetes automation by creating resources and objects in Kubernetes clusters.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor207"/>Deploying applications to Kubernetes using Ansible</h1>
<p>Containerized <a id="_idIndexMarker673"/>applications can be <a id="_idIndexMarker674"/>deployed inside Kubernetes via the Kubernetes dashboard (web UI) or using the <code>kubectl</code> CLI (<a href="https://kubernetes.io/docs/reference/kubectl">https://kubernetes.io/docs/reference/kubectl</a>). By using Ansible, we can automate most of the deployment <a id="_idIndexMarker675"/>operations that take place inside our <a id="_idIndexMarker676"/>Kubernetes clusters. Since <a id="_idIndexMarker677"/>Ansible can easily integrate <a id="_idIndexMarker678"/>within CI/CD pipelines, it is possible to achieve more control over your application deployments in a containerized environment such as Kubernetes.</p>
<p>Applications are deployed <a id="_idIndexMarker679"/>inside logical isolated groups called Kubernetes <strong class="bold">namespaces</strong>. There can be default namespaces and Kubernetes cluster-related namespaces, and we can also create additional namespaces as required to deploy applications. <em class="italic">Figure 11.16</em> demonstrates the relation between Deployments, Pods, Services, and namespaces in a Kubernetes cluster:</p>
<div><div><img alt="Figure 11.16 – Kubernetes Deployments and namespaces " height="268" src="img/B18383_11_16.jpg" width="634"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Kubernetes Deployments and namespaces</p>
<p>In the following exercise, we will deploy an application in Kubernetes by creating a dedicated namespace, Deployment configuration, and Service:</p>
<ol>
<li value="1">Prepare the <code>Chapter-11/todo-app-deploy.yaml</code> Deployment definition file, which will be used to create a Kubernetes Deployment resource in the next steps. We can create <code>ginigangadharan/todo-app:latest</code> image that we created in <a href="B18383_10.xhtml#_idTextAnchor178"><em class="italic">Chapter 10</em></a>, <em class="italic">Managing Containers Using Ansible</em>.</li>
</ol>
<div><div><img alt="Figure 11.17 – The Kubernetes definition file for the to-do app Deployment " height="654" src="img/B18383_11_17.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – The Kubernetes definition file for the to-do app Deployment</p>
<ol>
<li value="2">Prepare <a id="_idIndexMarker680"/>a <code>Chapter-11/todo-app-service.yaml</code> Kubernetes Service definition file to expose the <a id="_idIndexMarker681"/>application using <code>NodePort 300080</code>. Use <a id="_idIndexMarker682"/>different <code>NodePort</code>, <code>ClusterIP</code>, or <code>LoadBalancer</code> type Services depending on the Kubernetes cluster that you are using.  </li>
</ol>
<div><div><img alt="Figure 11.18 – The Kubernetes definition file for the to-do app Service " height="414" src="img/B18383_11_18.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – The Kubernetes definition file for the to-do app Service</p>
<ol>
<li value="3">Create <a id="_idIndexMarker683"/>a <code>Chapter-11/k8s-app-deploy.yaml</code> playbook <a id="_idIndexMarker684"/>and add <a id="_idIndexMarker685"/>contents, as follows:</li>
</ol>
<div><div><img alt="Figure 11.19 – A playbook to deploy the application in Kubernetes " height="494" src="img/B18383_11_19.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – A playbook to deploy the application in Kubernetes</p>
<ol>
<li value="4">Execute the playbook:</li>
</ol>
<div><div><img alt="Figure 11.20 – Execute the playbook to deploy todo-app " height="114" src="img/B18383_11_20.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – Execute the playbook to deploy todo-app</p>
<ol>
<li value="5">Verify <a id="_idIndexMarker686"/>that the namespace <a id="_idIndexMarker687"/>was created <a id="_idIndexMarker688"/>using the <code>kubectl</code> CLI, as shown in <em class="italic">Figure 11.21</em>:</li>
</ol>
<div><div><img alt="Figure 11.21 – A Kubernetes namespace created using Ansible " height="149" src="img/B18383_11_21.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – A Kubernetes namespace created using Ansible</p>
<ol>
<li value="6">Add a task in the same playbook to create the Deployment using the <code>todo-app-deploy.yaml</code> Deployment definition file and to create the Kubernetes Service resource using the <code>todo-app-service.yaml</code> file, as follows:</li>
</ol>
<div><div><img alt="Figure 11.22 – Tasks to create Deployment and Service resources in Kubernetes " height="466" src="img/B18383_11_22.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – Tasks to create Deployment and Service resources in Kubernetes</p>
<ol>
<li value="7">Execute the playbook again to create the Deployment.</li>
<li>Verify that the Deployment, Pods, ReplicaSet, and Service resources were created, as shown in <em class="italic">Figure 11.23</em>:</li>
</ol>
<div><div><img alt="Figure 11.23 – Deployment, Pod, and Service created by Ansible " height="389" src="img/B18383_11_23.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – Deployment, Pod, and Service created by Ansible</p>
<ol>
<li value="9">As we <a id="_idIndexMarker689"/>are using a minikube <a id="_idIndexMarker690"/>cluster, we can <a id="_idIndexMarker691"/>get the exposed Service details using the <code>minikube service list</code> command from the machine running the minikube cluster (not from the Ansible control node), as shown in <em class="italic">Figure 11.24</em>:</li>
</ol>
<div><div><img alt="Figure 11.24 – Exposed Service details in a minikube cluster " height="389" src="img/B18383_11_24.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – Exposed Service details in a minikube cluster</p>
<p>Find the URL for the <code>todo-app</code> application (<code>http://192.168.64.10:30080</code>, in this case) based on the name and use it in the next step.</p>
<ol>
<li value="10">Access <a id="_idIndexMarker692"/>the application from a <a id="_idIndexMarker693"/>web browser <a id="_idIndexMarker694"/>using the URL <code>http://192.168.64.10:30080</code>, as shown in <em class="italic">Figure 11.25</em>:</li>
</ol>
<div><div><img alt="Figure 11.25 – Accessing the to-do app deployed in a Kubernetes cluster " height="334" src="img/B18383_11_25.jpg" width="1082"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.25 – Accessing the to-do app deployed in a Kubernetes cluster</p>
<ol>
<li value="11">Expand the playbook with more resources and configurations as part of your application deployment. For example, we can create an Ingress resource with the Ingress definition, as follows:</li>
</ol>
<div><div><img alt="Figure 11.26 – Ingress resource definition for the to-do app " height="565" src="img/B18383_11_26.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.26 – Ingress resource definition for the to-do app</p>
<ol>
<li value="12">Use the <a id="_idIndexMarker695"/>Ingress definition <a id="_idIndexMarker696"/>in the Ansible <a id="_idIndexMarker697"/>task to create an Ingress resource, as follows:</li>
</ol>
<div><div><img alt="Figure 11.27 – Create an Ingress resource using Ansible " height="248" src="img/B18383_11_27.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.27 – Create an Ingress resource using Ansible</p>
<p>We can also pass the Deployment information in the form of variables and integrate them into our CD workflow.</p>
<p>You have learned how to deploy applications and Service resources in Kubernetes using Ansible. Most of the resources in Kubernetes can be created using the <code>kubernetes.core.k8s</code> module with the resource definition files. However, there are other useful modules in the <code>kubernetes.core</code> collection and we will go on to learn how to use a few of them, such as scaling applications and running commands inside a Pod.</p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor208"/>Scaling Kubernetes applications</h1>
<p>The <strong class="bold">ReplicaSet</strong> resource in Kubernetes ensures that a specified number of application Pod replicas are running <a id="_idIndexMarker698"/>as part of the Deployment. This mechanism <a id="_idIndexMarker699"/>will help to scale the application horizontally whenever needed and without additional resource configurations. A ReplicaSet resource will be created when you create a deployment resource in Kubernetes, as shown in <em class="italic">Figure 11.28</em>:</p>
<div><div><img alt="Figure 11.28 – A ReplicaSet resource created as part of Deployment " height="389" src="img/B18383_11_23.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.28 – A ReplicaSet resource created as part of Deployment</p>
<p>Specify the initial number of replicas inside the Deployment definition file as <code>replicas: 1</code> . ReplicaSet will scale the number of Pods based on the replica number. </p>
<p>When there is extra traffic on the application Pods, scale the application using the <code>kubectl scale</code> command, as follows (modify the Deployment, not the ReplicaSet):</p>
<div><div><img alt="Figure 11.29 – Scaling an application using kubectl " height="124" src="img/B18383_11_29.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.29 – Scaling an application using kubectl</p>
<p>Wait for the replication changes to take effect and check the resource details again. You will find <a id="_idIndexMarker700"/>multiple Pods (three) now running, as shown in <em class="italic">Figure 11.30</em>:</p>
<div><div><img alt="Figure 11.30 – An application scaled up using a ReplicaSet resource " height="466" src="img/B18383_11_30.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.30 – An application scaled up using a ReplicaSet resource</p>
<p>The traffic will be distributed to all Pods using the <code>service/todoapp-svc</code> module as a load balancer. Refer to <em class="italic">Figure 11.31</em>, which highlights the multiple <em class="italic">endpoints</em>, which are Pod IP addresses:</p>
<div><div><img alt="Figure 11.31 – A Kubernetes Service with multiple Pod replicas as endpoints " height="547" src="img/B18383_11_31.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.31 – A Kubernetes Service with multiple Pod replicas as endpoints</p>
<p>We can manage the scaling of the Kubernetes application based on traffic and conditions <a id="_idIndexMarker701"/>automatically using Ansible. We will learn more about the <code>kubernetes.core.k8s_scale</code> module and practice using it in the next section.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor209"/>Scaling Kubernetes Deployments using Ansible</h2>
<p>The <code>k8s_scale</code> module <a id="_idIndexMarker702"/>is part of the <code>kubernetes.core</code> collection <a id="_idIndexMarker703"/>and we can use it <a id="_idIndexMarker704"/>for scaling up or scaling down Kubernetes Deployments.</p>
<p>Before proceeding with the exercise, remember to scale down the application to one replica (<code>--replicas=1</code>), as follows:</p>
<div><div><img alt="Figure 11.32 – Scale down todo-app replica " height="140" src="img/B18383_11_32.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.32 – Scale down todo-app replica</p>
<p>Follow these steps to create Ansible artifacts for scaling a Kubernetes application:</p>
<ol>
<li value="1">Create a <code>Chapter-11/k8s-app-scale.yaml</code> playbook and add content, as follows:</li>
</ol>
<div><div><img alt="Figure 11.33 – An Ansible playbook to scale a Kubernetes Deployment " height="547" src="img/B18383_11_33.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.33 – An Ansible playbook to scale a Kubernetes Deployment</p>
<p>Adjust <code>wait_timeout: 30</code> depending on your next task in the workflow. For example, increase the value to ensure the Pod replicas are created and running successfully before proceeding with the next task.</p>
<ol>
<li value="2">Execute the playbook:</li>
</ol>
<div><div><img alt="Figure 11.34 – Execute Kubernetes Deployment scaling playbook " height="114" src="img/B18383_11_34.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.34 – Execute Kubernetes Deployment scaling playbook</p>
<ol>
<li value="3">Verify <a id="_idIndexMarker705"/>the Pod replicas using <a id="_idIndexMarker706"/>the <code>kubectl</code> command, as shown in <em class="italic">Figure 11.35</em>:</li>
</ol>
<div><div><img alt="Figure 11.35 – Pod replicas after scaling " height="230" src="img/B18383_11_35.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.35 – Pod replicas after scaling</p>
<p>Customize the <a id="_idIndexMarker707"/>scaling based on several <a id="_idIndexMarker708"/>conditions, as follows:</p>
<ul>
<li><code>current_replicas: x</code>: This will change the replicas only if the current number of replicas matches the <code>current_replicas</code> value.</li>
<li><code>src: deployment.ym</code>l: This will read the Deployment and the replicas definition from a file.</li>
<li><code>wait: no</code>: This will not wait for the scaling to complete.</li>
</ul>
<p>Refer <a id="_idIndexMarker709"/>to the <code>k8s_scale</code> module documentation for more details (<a href="https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_scale_module.xhtml">https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_scale_module.xhtml</a>).</p>
<p>In the next section, we will learn about the <code>k8s_exec</code> module and how to use it to troubleshoot Pods.</p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor210"/>Executing commands inside a Kubernetes Pod</h1>
<p>In a normal <a id="_idIndexMarker710"/>situation, we do not need to log in to a <a id="_idIndexMarker711"/>Pod or container, as the application is exposed on some ports and Services are talking over these exposed ports. However, when there are issues, we need to access the containers and check what is happening inside, by checking logs, accessing other Pods, or running any necessary troubleshooting commands. </p>
<p>Use the <code>kubectl exec</code> command if you are doing this troubleshooting or information gathering manually:</p>
<div><div><img alt="Figure 11.36 – Execute commands inside a Pod using the kubectl utility " height="114" src="img/B18383_11_36.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.36 – Execute commands inside a Pod using the kubectl utility</p>
<p>However, when we automate Kubernetes operations using Ansible, use the <code>k8s_exec</code> module and automate the verification tasks or validation tasks as well.</p>
<p>For such scenarios, we can deploy debug Pods using suitable images (for example, images with <a id="_idIndexMarker712"/>required utilities, such as <code>ping</code>, <code>curl</code>, or <code>netstat</code>) and <a id="_idIndexMarker713"/>execute validation commands from these Pods. A typical deployment scenario with test Pods (<code>curl-pod</code>) is shown in <em class="italic">Figure 11.37</em>, as follows:</p>
<div><div><img alt="Figure 11.37– A debug Pod to validate and verify applications " height="458" src="img/B18383_11_37.jpg" width="1085"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.37– A debug Pod to validate and verify applications</p>
<p>In the following <a id="_idIndexMarker714"/>scenario, we will create a playbook to deploy a <code>curl-pod</code> Pod using a <code>busyboxplus</code> image (<a href="https://hub.docker.com/r/radial/busyboxplus">https://hub.docker.com/r/radial/busyboxplus</a>) and verify the <code>todoapp-svc</code> Service from the <code>curl-pod</code> Pod:</p>
<ol>
<li value="1">Create the <code>curl-app-pod.yaml</code> definition file for the <code>curl-pod</code> Pod, as follows:</li>
</ol>
<div><div><img alt="Figure 11.38 – Kubernetes Deployment definition for a curl-pod Pod " height="484" src="img/B18383_11_38.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.38 – Kubernetes Deployment definition for a curl-pod Pod</p>
<p>We have <a id="_idIndexMarker715"/>added a <code>sleep 50000</code> command; otherwise, the <a id="_idIndexMarker716"/>Pod will exit without running any processes.</p>
<ol>
<li value="2">Create a <code>Chapter-11/curl-app-deploy.yaml</code> playbook and add content, as follows:</li>
</ol>
<div><div><img alt="Figure 11.39 – Ansible playbook for deploying curl-pod " height="524" src="img/B18383_11_39.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.39 – Ansible playbook for deploying curl-pod</p>
<ol>
<li value="3">Add a task to execute the <code>curl</code> command inside the <code>curl-pod</code> Pod to verify whether <a id="_idIndexMarker717"/>the <code>todoapp-svc</code> Service is <a id="_idIndexMarker718"/>accessible or not. Then, add tasks for displaying the output of the <code>curl</code> command, and validate the success and fail status (<code>curl_output.failed == true</code>), as follows:</li>
</ol>
<div><div><img alt="Figure 11.40– Tasks to execute the curl command inside the curl-pod Pod and to display its status " height="599" src="img/B18383_11_40.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.40– Tasks to execute the curl command inside the curl-pod Pod and to display its status</p>
<p>The last task is optional but adding more validations and messages will help you to implement a better workflow.</p>
<ol>
<li value="4">Once the verification is complete, delete the <code>curl-pod</code> Pod, as we do not require it anymore.</li>
</ol>
<div><div><img alt="Figure 11.41 – Remove the curl-pod Pod after testing " height="282" src="img/B18383_11_41.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.41 – Remove the curl-pod Pod after testing</p>
<ol>
<li value="5">Execute <a id="_idIndexMarker719"/>the playbook and verify the <a id="_idIndexMarker720"/>output. We can see the <code>curl</code> output as shown in <em class="italic">Figure 11.42</em> if the <code>todoapp-svc</code> Service is reachable from the <code>curl-pod</code> Pod:</li>
</ol>
<div><div><img alt="Figure 11.42 – The curl command output for todoapp-svc " height="950" src="img/B18383_11_42.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.42 – The curl command output for todoapp-svc</p>
<p>The <code>kubernetes.core.k8s_exec</code> module is very useful for the validation and verification <a id="_idIndexMarker721"/>of Kubernetes applications and cluster <a id="_idIndexMarker722"/>management using Ansible. The command can be executed inside a debug Pod, as we learned in the preceding exercise, or even inside the application Pod for verifying facts. </p>
<p>Explore the <code>kubernetes.core</code> collection and find other useful modules and plugins to automate your Kubernetes Deployments and resources.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor211"/>Summary</h1>
<p>In this chapter, we have learned about the Ansible collection for Kubernetes cluster and resource management. We started by covering the basics of Kubernetes components and discussed how to use Kubespray to deploy and manage Kubernetes clusters and their supported features. </p>
<p>After that, we learned the method of connecting a Kubernetes cluster to Ansible to automate cluster operations. We have used the Kubernetes Ansible collection to deploy applications and scale Deployments. We have also learned how to execute commands inside a running Kubernetes Pod using Ansible, which can be utilized for validation and troubleshooting purposes. This chapter has provided a brief introduction to Kubernetes automation using Ansible and other important information, such as Kubernetes content collection and methods of connecting Ansible to Kubernetes.</p>
<p>In the next chapter, you will learn about the different available methods of integrating your CI/CD and communication tools using Ansible. We will learn more about the enterprise version of Ansible, which is called Ansible Automation Platform, and its flexible integration features. </p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor212"/>Further reading </h1>
<p>For more information on the topics covered in this chapter, please refer to the following links:</p>
<ul>
<li><em class="italic">Introduction to Ansible for Kubernetes guide</em> – <a href="https://docs.ansible.com/ansible/latest/collections/kubernetes/core/docsite/scenario_guide.xhtml">https://docs.ansible.com/ansible/latest/collections/kubernetes/core/docsite/scenario_guide.xhtml</a> </li>
<li><em class="italic">Play with Kubernetes – free hands-on labs</em> – <a href="https://labs.play-with-k8s.com/">https://labs.play-with-k8s.com/</a> </li>
<li><em class="italic">CRI-O</em> – <a href="https://cri-o.io">https://cri-o.io</a> </li>
<li><em class="italic">containerd</em> – <a href="https://containerd.io/">https://containerd.io/</a></li>
<li><em class="italic">Top 15 Free Kubernetes Courses</em> – <a href="https://www.techbeatly.com/kubernetes-free-courses/">https://www.techbeatly.com/kubernetes-free-courses/</a> </li>
<li><em class="italic">What is Kubernetes?</em> – <a href="https://www.redhat.com/en/topics/containers/what-is-kubernetes">https://www.redhat.com/en/topics/containers/what-is-kubernetes</a> </li>
<li><em class="italic">Free OpenShift labs</em> – <a href="http://learn.openshift.com">learn.openshift.com</a> </li>
<li><em class="italic">The Ansible kubernetes.core collection</em> – <a href="https://galaxy.ansible.com/kubernetes/core">https://galaxy.ansible.com/kubernetes/core</a> or <a href="https://console.redhat.com/ansible/automation-hub/repo/published/kubernetes/core">https://console.redhat.com/ansible/automation-hub/repo/published/kubernetes/core</a> </li>
<li><em class="italic">The Ansible community.kubernetes collection</em> – <a href="https://galaxy.ansible.com/community/kubernetes">https://galaxy.ansible.com/community/kubernetes</a> </li>
<li><em class="italic">Templating (Jinja2)</em> – <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.xhtml">https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.xhtml</a> </li>
<li><em class="italic">What is PaaS?</em> – <a href="https://www.redhat.com/en/topics/cloud-computing/what-is-paas">https://www.redhat.com/en/topics/cloud-computing/what-is-paas</a></li>
<li><em class="italic">Microk8s</em> – <a href="https://microk8s.io">https://microk8s.io</a></li>
<li><em class="italic">Red Hat OpenShift</em> – <a href="https://www.redhat.com/en/technologies/cloud-computing/openshift">https://www.redhat.com/en/technologies/cloud-computing/openshift</a> </li>
<li><em class="italic">Kubespray</em> – <a href="https://kubespray.io">https://kubespray.io</a>, <a href="https://github.com/kubernetes-sigs/kubespray">https://github.com/kubernetes-sigs/kubespray</a> </li>
</ul>
</div>
<div><div></div>
</div>
</div></body></html>