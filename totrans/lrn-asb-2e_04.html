<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-65"><a id="_idTextAnchor202"/>4</h1>
<h1 id="_idParaDest-66"><a id="_idTextAnchor203"/>Deploying a LAMP Stack</h1>
<p>This chapter will look at deploying a complete LAMP stack using the various core modules that ship with Ansible. We will target <a id="_idTextAnchor204"/>the local Multipass virtual machine we first used in <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing and </em><em class="italic">Running Ansible</em>.</p>
<p>We will discuss the following:</p>
<ul>
<li>The playbook layout – how our playbook is going to be structured</li>
<li>Linux – preparing the Linux server</li>
<li>Apache – installing and configuring Apache</li>
<li>MariaDB – installing and configuring MariaDB</li>
<li>PHP – installing and configuring PHP</li>
</ul>
<p>This chapter covers the following topics:</p>
<ul>
<li>The playbook structure</li>
<li>The LAMP stack</li>
<li>The LAMP playbook</li>
</ul>
<p>Before we start writing the playbook, we will discuss the structure we will use after we briefly discuss what we need for the chapter.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor205"/>Technical requirements</h1>
<p>We will again use the local <a id="_idTextAnchor206"/>Multipass <a id="_idTextAnchor207"/>virtual machine we launched in the previous chapters. As we will be installing all the elements of a LAMP stack on the virtual machine, your Multipass virtual machine will need to be able to download packages from the internet; in all, there is around 500 MB of packages and configuration to download.</p>
<p>You can find a complete copy of the playbook in the repository accompanying this book at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor208"/>The playbook structure</h1>
<p>In <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing and Running Ansible</em>, the playbooks we ran were as basic as possible. They have been in a<a id="_idIndexMarker201"/> single file, accompanied by a host inventory file, and, if required, a template file. Then, in <a href="B21620_02.xhtml#_idTextAnchor080"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Ansible Galaxy</em>, we extended our playbook files to include roles rather than putting all our tasks, handlers, and variables into one file.</p>
<p>As you can see from the following layout, there are several folders and files:</p>
<div><div><img alt="﻿Figure 4.1 – The folder structure we will use for our playbook" src="img/B21620_04_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor209"/>Figure 4.1 – The folder structure we will use for our playbook</p>
<p>While there is a copy of the structure in the repository, let’s work on creating the structure and discuss each item as we create it. The first folder we need to create is our top-level folder. This is the folder that will contain our playbook folders and files:</p>
<pre class="console">
$ mkdir Chapter04
$ cd Chapter04</pre> <p>The next folder we are going to create is one called <code>group_vars</code>. This will contain the variable files used in our playbook. For now, we are going to create a single variable file called <code>common.yml</code>:</p>
<pre class="console">
$ mkdir group_vars
$ touch group_vars/common.yml</pre> <p>Next, we are going to create two files – our host inventory file, which we will name <code>hosts</code>, and our master playbook, which is typically called <code>site.yml</code>:</p>
<pre class="console">
$ touch production
$ touch site.yml</pre> <p>The final folder we are going to create manually is called <code>roles</code>. Here, we are going to use the <code>ansible-galaxy</code> command, which we learned about in <a href="B21620_02.xhtml#_idTextAnchor080"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Ansible Galaxy</em>, to create a role called <code>common</code>. To do this, we use the following commands:</p>
<pre class="console">
$ mkdir roles
$ ansible-galaxy role init roles/common</pre> <p>This should create all the files <a id="_idIndexMarker202"/>needed to start writing the <code>common</code> role.</p>
<p>The <code>cloud-init.yaml</code>, <code>example_key</code>, <code>example_key.pub</code>, and <code>hosts.example</code> files are all lifted straight from <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing and Running Ansible</em>, and <a href="B21620_02.xhtml#_idTextAnchor080"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Ansible Galaxy</em>, so we will not cover them again in this chapter.</p>
<p class="callout-heading">Note</p>
<p class="callout">While we will work through each of the files individually in this and the following sections, a complete copy of the playbook is available in the accompanying GitHub repository.</p>
<p>Let’s look at each of the four roles in our playbook and install and configure our LAMP stack.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor210"/>The LAMP stack</h1>
<p>The LAMP stack <a id="_idIndexMarker203"/>is the term used to describe an all-in-one web and database server. Typically, the components are as follows:</p>
<ul>
<li><strong class="bold">Linux</strong> is the <a id="_idIndexMarker204"/>underlying operating system; in our case, we will u<a id="_idTextAnchor211"/>se Ubuntu 22.04</li>
<li><strong class="bold">Apache</strong> is the <a id="_idIndexMarker205"/>web server element of the stack</li>
<li><strong class="bold">MariaDB</strong> is what we <a id="_idIndexMarker206"/>will use as the database component of the stack; typically, it is based on <strong class="bold">MySQL</strong>, which<a id="_idIndexMarker207"/> could also be used</li>
<li><strong class="bold">PHP</strong> is the dynamic<a id="_idIndexMarker208"/> language used by the web server to generate content</li>
</ul>
<p>A <a id="_idIndexMarker209"/>common <a id="_idIndexMarker210"/>variation of the <strong class="bold">LAMP</strong> stack is called <strong class="bold">LEMP</strong>; this replaces <strong class="bold">Apache</strong> with <strong class="bold">NGINX</strong>, which is <a id="_idIndexMarker211"/>pronounced <em class="italic">engine-x</em>, hence the <em class="italic">E</em> rather than<a id="_idIndexMarker212"/> the <em class="italic">N</em>.</p>
<p>We are going to look at creating roles to deal with these components; these are as follows:</p>
<ul>
<li><code>common</code>: This role will prepare our Ubuntu server, installing any supporting packages and services we need</li>
<li><code>apache</code>: This role will install the Apache web server and configure a default virtual host</li>
<li><code>mariadb</code>: This role will not only install MariaDB but also secure the installation and create a default database and user, as well as optionally download and import a database to use</li>
<li><code>php</code>: This role will install PHP and configure a set of common PHP modules, and if we set the option to a database admin tool written in PHP, we can interact with our test database via the browser</li>
</ul>
<p>Let us begin by looking at the <code>common</code> role.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor212"/>The common role</h2>
<p>In the<a id="_idIndexMarker213"/> previous <a id="_idIndexMarker214"/>section of this chapter, we used the <code>ansible-galaxy role init</code> command to create the <code>common</code> role. This creates several folders and files; as discussed in <a href="B21620_02.xhtml#_idTextAnchor080"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Ansible Galaxy</em>, we will not go into any detail here but instead dive straight into the role itself.</p>
<p>Let’s make a start by adding some tasks.</p>
<h3>Updating installed packages</h3>
<p>First of all, let’s update our server <a id="_idIndexMarker215"/>by adding the following to the beginning of the <code>roles/common/tasks/main.yml</code> file:</p>
<pre class="source-code">
- name: "Update apt cache and upgrade packages"
  ansible.builtin.apt:
    name: "*"
    state: "latest"
    update_cache: true</pre> <p>You will notice a difference from when we last used the <code>ansible.builtin.apt module</code> to update all the installed packages.</p>
<p>We now start the task using the <code>name</code> key; this will print out the content of the value we assigned to the <code>name</code> key when the playbook runs, which will give us a better idea of what is going on during the playbook run, rather than just printing the name of the module that is executed.</p>
<h3>Installing common packages</h3>
<p>Now that we have updated<a id="_idIndexMarker216"/> the installed packages, let’s install the packages we want to install on all the Linux servers we will target with the Playbook:</p>
<pre class="source-code">
- name: "Install common packages"
  ansible.builtin.apt:
    state: "present"
    pkg: "{{ common_packages }}"</pre> <p>As you can<a id="_idTextAnchor213"/> see, we again use the <code>ansible.builtin.apt</code> module, and we have added a descriptive name for the task. Rather than providing a list of packages in the task, we use a variable called <code>common_packages</code>, which is <a id="_idTextAnchor214"/>defined in the <code>roles/common/defaults/main.yml</code> file as follows:</p>
<pre class="source-code">
common_packages:
<a id="_idTextAnchor215"/>  - "ntp"
  - "sntp"
  - "ntp-doc"
  - "vim"
  - "git"
  - "unzip"</pre> <p>As you can see, we install <code>ntp</code>, <code>sntp</code>, and <code>ntp-doc</code>; we will configure <code>ntp</code> shortly. Next, we install <code>vim</code>, <code>git</code>, and <code>unzip</code>, as they are always helpful to have installed on a server.</p>
<p>Another thing that you may have noticed is that we pass a list of packages using <code>{{ common_packages }}</code> to the <code>pkg</code> key in the <code>ansible.builtin.apt</code> module, resulting in the module looping through the list of packages we pass in and installing them all in one go, rather <a id="_idIndexMarker217"/>than having to call the module to install each package individually.</p>
<h3>Configuring Network Time Protocol (NTP)</h3>
<p>Next, we copy<a id="_idIndexMarker218"/> the <code>ntp.conf</code> file from the <code>templates</code> folder, adding the list of NTP servers as we have done in the previous chapters, and then informing Ansible to restart NTP whenever the configuration file changes.</p>
<h3>Creating a key, group, and user</h3>
<p>In <a id="_idIndexMarker219"/>the <code>roles/common/defaults/main.yml</code> file, the<a id="_idIndexMarker220"/> following<a id="_idIndexMarker221"/> v<a id="_idTextAnchor216"/>ariable is defined:</p>
<pre class="source-code">
users:
  - {
      name: "lamp",
      group: "lamp",
      state: "present",
      key: "/tmp/id_ssh_lamp_rsa",
    }</pre> <p>This is slightly different from the variables we have used so far, as it is a single variable called <code>users</code>, which is made up of a single item, and that item contains the <code>name</code>, <code>group</code>, <code>state</code>, and <code>key</code> key-value pairs.</p>
<p>Because we are <a id="_idIndexMarker222"/>using items, we need to change our approach to how we use the variables within the task, the first of which in <code>roles/common/tasks/main.yml</code> creates an OpenSSH key pair; if <a id="_idIndexMarker223"/>one doesn’t already exist, we need to save<a id="_idIndexMarker224"/> it at the path that is defined in the <code>key</code> key-value pair:</p>
<pre class="source-code">
- name: "Generate a ssh keypair"
  community.crypto.openssh_keypair:
    path: "{{ item.key }}"
  with_items: "{{ users }}"
  delegate_to: "localhost"
  become: false</pre> <p>Working through the task, y<a id="_idTextAnchor217"/>ou can see that we use the <code>community.crypto.openssh_keypair</code> module, in which we pass just one value, which is the path to the file where we would like our OpenSSH key stored.</p>
<p>As you can see, we use the <code>{{ item.key }}</code> variable to enter the path, but we do not define that the variable is called <code>users</code> here; instead, we use the <code>with_items</code> option and pass in the <code>{{ users }}</code> variable here.</p>
<p>While we only pass one item in this example, you could take this approach to execute a single task multiple times – for example, if our variable lo<a id="_idTextAnchor218"/>oked like this:</p>
<pre class="source-code">
users:
  - {
      name: "lamp",
      group: "lamp",
      state: "present",
      key: "/tmp/id_ssh_lamp_rsa",
    }
  - {
      name: "user2",
      group: "lamp",
      state: "present",
      key: "/tmp/id_ssh_user2_rsa",
    }</pre> <p>Then, when the task is executed, it would create two OpenSSH keys, and the subsequent tasks, which we will get into in a moment, would create a single group called <code>lamp</code> and then two<a id="_idIndexMarker225"/> users, <code>lamp</code> and <code>user2</code>.</p>
<p>Back to the task at hand – you will notice that we have def<a id="_idTextAnchor219"/>ined two other options, <code>delegate_to</code> and <code>be<a id="_idTextAnchor220"/>come</code>.</p>
<p>If we were to run the <code>community.crypto.openssh_keypair</code> <a id="_idTextAnchor221"/>module without defining <code>delegate_to</code>, then the module will be executed on the remote host, which is not what we want to happen in this case, as we want a copy of the private and public portions of the OpenSSH key on our <a id="_idIndexMarker226"/>local machine. Therefore, by using <code>localhost</code> as the value in the <code>delegate_to</code> option, we tell Ansible to run this task locally.</p>
<p>The next <a id="_idIndexMarker227"/>option, <code>become</code>, tells Ansible not to become an escalated user using the <code>sudo</code> command, which is the default action for all the hosts we have defined at the top of our main <code>site.yml</code> playbook file – this is because we want the <code>community.crypto.openssh_keypair</code> module to run as the user you are logged in as, rather than your local machine’s root user.</p>
<p>The l<a id="_idTextAnchor222"/>ogic for this task, minus the <code>delegate_to</code> and <code>become</code> options, as we want the remainder of the tasks to be executed against the target machine, is followed through to the remaining tasks in the role, starting with creating the group by executing the <code>ansible. </code><code>builtin.group</code> module:</p>
<pre class="source-code">
- name: "Add group for our users"
  ansible.builtin.group:
    name: "{{ item.group }}"
    state: "{{ item.state }}"
  with_items: "{{ users }}"</pre> <p>Once the group has been created, we can then add the user using <code>ansible.builtin.user</code>, or users if we have defined more than one item in the <code>users</code> variable:</p>
<pre class="source-code">
- name: "Add users to our group"
  ansible.builtin.user:
    name: "{{ item.name }}"
    group: "{{ item.group }}"
    comment: "{{ item.name }}"
    state: "{{ item.state }}"
  with_items: "{{ users }}"</pre> <p>The final task in the <a id="_idIndexMarker228"/>role takes the public portion of the OpenSSH key, which<a id="_idIndexMarker229"/> we generated earlier, and adds the <a id="_idIndexMarker230"/>contents to the user(s) created during the previous task, using the <code>ansible.builtin.authorized_key</code> module:</p>
<pre class="source-code">
- name: "Add keys to our users"
  ansible.posix.authorized_key:
    user: "{{ item.name }}"
    key: "{{ lookup('file', item.key + '.pub') }}"
  with_items: "{{ users }}"</pre> <p>You may have noticed that the value we pass for the <code>key</code> option is new to us; this uses the <code>lookup</code> plugin to read the file’s contents at the <code>item.key</code> path with <code>.pub</code> appended to the end, meaning, in our case, it re<a id="_idTextAnchor223"/>ads the contents of the file at <code>/tmp/id_ssh_lamp_rsa.pub</code>. This file is the public portion of the OpenSSH key-pair, which was created when we executed the <code>"generate a ssh keypair"</code> task earlier in the role.</p>
<p>The <code>lookup</code> plugin is designed to be executed locally, so in this case, we do not need to use the <code>delegate_to</code> and <code>become</code> options, as we want the task to be executed on the target host because that is where our user has been created, but we want to populate the <code>/home/lamp/.ssh/authorized_key</code> file on the remote host with the contents of the <code>/tmp/id_ssh_lamp_rsa.pub</code> file that we have on our local host.</p>
<p>That concludes the tasks in the <code>common</code> role; before we move on to the next role, which will install and configure <code>apache</code>, you should know one more thing.</p>
<p>The <code>"generate a ssh keypair"</code> task will not overwrite any existing key-pairs when executed, meaning the first time you run the role and no files exist at <code>/tmp/id_ssh_lamp_rsa</code> and <code>/tmp/id_ssh_lamp_rsa.pub</code>, the key-pair will be created, and <a id="_idIndexMarker231"/>on subsequent Playbook runs, as the files now exist, the <a id="_idIndexMarker232"/>task will return an <code>community.crypto.openssh_keypair</code> module to create the key-pair.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor224"/>The Apache role</h2>
<p>Once the <code>common</code> role has finished <a id="_idIndexMarker234"/>running our remote host, we will be ready to install <a id="_idIndexMarker235"/>and configure the Apache web server.</p>
<h3>Installing t<a id="_idTextAnchor225"/>he Apache packages</h3>
<p>The first <a id="_idIndexMarker236"/>task in <code>roles/apache/tasks/main.yml</code> installs the packages we need to run the Apache <a id="_idIndexMarker237"/>web server; it uses the <code>ansible.builtin.apt</code> module and looks like the following:</p>
<pre class="source-code">
- name: "Install apache packages"
  ansible.builtin.apt:
    state: "present"
    pkg: "{{ apache_packages }}"</pre> <p>As you can see, it calls a variable called <code>{{ apac<a id="_idTextAnchor226"/>he_packages }}</code>, which is defined in <code>roles/apache/defaults/main.yml</code> as follows:</p>
<pre class="source-code">
apache_packages:
  - "apache2"
  - "apache2-ssl-dev"
  - "ca-certificates"
  - "openssl"</pre> <p>As we learned when we walked through the <code>common</code> role, this will install the four packages defined in the variable.</p>
<p>Once Apache <a id="_idIndexMarker238"/>has been installed, which is a single task, we<a id="_idIndexMarker239"/> can now progress to configuring our Apache installation.</p>
<h3>Configuring Apache</h3>
<p>The first task<a id="_idIndexMarker240"/> when configuring Apache is to take the user that was<a id="_idIndexMarker241"/> created when the <code>common</code> role was run and add them to the Apache group; to do this, we run the following task:</p>
<pre class="source-code">
- name: "Add user to apache group"
  ansible.builtin.user:
    name: "{{ item.name }}"
    groups: "{{ apache_group }}"
    append: true
  with_items: "{{ users }}"</pre> <p>This takes the <code>{{ users }}</code> variable from the previous role and loops over the items defined in the variable, adding the user to the group defined under the <code>{{ apache_group }}</code> variable in the <code>roles/apache/defaults/main.yml</code> file. A full list of the variables defined to configure Apache, which we will use throughout the next few tasks, is as follows:</p>
<pre class="source-code">
a<a id="_idTextAnchor227"/>pache_group: "www-data"
web_root: "web"
document_root: "/home/{{ users.0.name }}/{{ web_root }}"
index_file: index.html
vhost_path: "/etc/apache2/sites-enabled/"
vhost_default_file: "000-default.conf"
vhost_our_file: "vhost.conf"</pre> <p>You may have <a id="_idIndexMarker242"/>noticed that the value of the <code>document_root</code> variable <a id="_idIndexMarker243"/>is a little different from the ones we have used so far; there’ll be more on that in a moment.</p>
<p>The next task creates a folder within the users directly, which we will use to store the files served via Apache:</p>
<pre class="source-code">
- name: "Create the document root for our website"
  ansible.builtin.file:
    dest: "{{ document_root }}"
    state: directory
    mode: "0755"
    owner: "{{ users.0.name }}"
    group: "{<a id="_idTextAnchor228"/>{ apache_group }}"</pre> <p>As you can see, we use <code>{{ users.0.name }}</code> as we did for the <code>document_root</code> variable value; why is this?</p>
<p>As we know, the <code>common</code> role only c<a id="_idTextAnchor229"/>reates a single user; we can’t simply use <code>{{ users.name }}</code>, as the <code>name</code> key exists within an item within the variable, so using <code>{{ users.name }}</code> would result in an error, stating that the variable can’t be found.</p>
<p>Because of this, we can reference the first item in the list of items by using its position within the list, which, because Ansible counts from zero, will be <code>0</code> rather than <code>1</code>.</p>
<p>Using the values that we have defined in the defaults for the <code>common</code> and <code>apache</code> roles, this task will create a folder at <code>/home/lamp/web/</code>; the <code>lamp</code> user would own the folder and would be assigned to the <code>www-data</code> group, which is the group the Apache process will run as.</p>
<p>The next task <a id="_idIndexMarker244"/>will ensure the correct read, write, and execute <a id="_idIndexMarker245"/>permissions are set on the <code>/</code><code>home/lamp/</code> folder:</p>
<pre class="source-code">
- name: "Set the permissions on the user folder"
  ansible.builtin.file:
    dest: /home/{{ users.0.name }}/
    state: directory
    mode: "0755"
    owner: "{{ users.0.name }}"</pre> <p>That task concludes configuring the folder structure needed to serve our web pages; now, it is time to configure Apache itself.</p>
<p>The first thing we need to do is remove the default virtual host configuration file; to do this, we will execute the following task:</p>
<pre class="source-code">
- name: "Remove the apache default vhost config"
  ansible.builtin.file:
    path: "{{ vhost_path }}{{ vhost_default_file }}"
    state: absent
  notify: "Restart apache2"</pre> <p>This uses the <code>ansible.builtin.file</code> module to set the state of the file defined by <code>{{ vhost_default_file }}</code> in the <code>{{ vhost_path }}</code> folder to <code>absent</code>, which means, if the file exists, remove it.</p>
<p>It also uses <code>notify</code> to call the <code>"Restart apache2"</code> handler, which is defined as the following task in the <code>roles/apache/handlers/main.yml</code> file:</p>
<pre class="source-code">
- name: "Restart apache2"
  ansible.builtin.service:
    name: "apache2"
    state: "restarted"
    enabled: true</pre> <p>Once the <a id="_idIndexMarker246"/>d<a id="_idTextAnchor230"/>efault file has been removed, we can <a id="_idIndexMarker247"/>add our virtual host configuration file.</p>
<p>The template for this virtual host configuration file can be found at <code>roles/apache/templates/vhost.conf.j2</code>, and it contains the following:</p>
<pre class="source-code">
# {{ ansible_managed }}
&lt;VirtualHost *:80&gt;
  ServerName {{ ansible_hostname }}
  DocumentRoot {{ document_root }}
  DirectoryIndex {{ index_file }}
  &lt;Directory {{ document_root }}&gt;
    AllowOverride All
    Require all granted
  &lt;/Directory&gt;
&lt;/VirtualHost&gt;</pre> <p>When loaded, this configuration file serves the contents of the <code>{{ document_root }}</code> folder when someone visits the site’s URL in their browser.</p>
<p>The task to deploy this template file to the remote host looks like the following:</p>
<pre class="source-code">
- name: "Copy the our vhost.conf to the sites-enabled folder"
  ansible.builtin.template:
    src: vhost.conf.j2
    dest: "{{ vhost_path }}{{ vhost_our_file }}"
    mode: "0644"
  notify: "Restart apache2"</pre> <p>As you can see, this also calls the <code>"Restart apache2"</code> handler if there are any changes to the file.</p>
<p>With <a id="_idIndexMarker248"/>Apache now configured, there is one <a id="_idIndexMarker249"/>final task.</p>
<h3>Optionally copying an index.html file</h3>
<p>The<a id="_idIndexMarker250"/> final task in this role uses the following <code>variables</code> block:</p>
<pre class="source-code">
html_deploy: true
html_heading: "Success !!!"
html_body: |
  This HTML page has been deployed using Ansible to &lt;b&gt;{{ ansible_host }}&lt;/b&gt;.&lt;br&gt;
  The user is &lt;b&gt;{{ users.0.name }}&lt;/b&gt; who is in the &lt;b&gt;{{ apache_group }}&lt;/b&gt; group.&lt;br&gt;
  The weboot is &lt;b&gt;{{ document_root }}&lt;/b&gt;, the default index file is &lt;b&gt;{{ index_file }}&lt;/b&gt;.&lt;br&gt;</pre> <p>As you can see, it contains a heading and some HTML code for the body; these variables are used by the following task:</p>
<pre class="source-code">
- name: "Copy the test HTML page to the document root"
  ansible.builtin.template:
    src: index.html.j2
    dest: "{{ document_root }}/index.html"
    mode: "0644"
    owner: "{{ users.0.name }}"
    group: "{{ apache_group }}"
  when: html_deploy</pre> <p>This uses a <a id="_idIndexMarker251"/>template that can be found at <code>roles/apache/templates/index.html.j2</code> and looks like the following:</p>
<pre class="source-code">
&lt;!--{{ ansible_managed }}--&gt;
&lt;!doctype html&gt;
&lt;title&gt;{{ html_heading }}&lt;/title&gt;
&lt;style&gt;
  body { text-align: center; padding: 150px; }
  h1 { font-size: 50px; }
  body { font: 20px Helvetica, sans-serif; color: #333; }
  article { display: block; text-align: left; width: 650px; margin: 0 auto; }
&lt;/style&gt;
&lt;article&gt;
    &lt;h1&gt;{{ html_heading }}&lt;/h1&gt;
    &lt;div&gt;
        &lt;p&gt;{{ html_body }}&lt;/p&gt;
    &lt;/div&gt;
&lt;/article&gt;</pre> <p>However, the task is only called if the <code>html_deploy</code> variable is set to <code>true</code>; this is managed by the <a id="_idTextAnchor231"/>following statement at the end of the task:</p>
<pre class="source-code">
when: html_deploy</pre> <p>So, if, for any <a id="_idIndexMarker252"/>reason, the <code>html_deploy</code> variable is not equal to <code>true</code>, then the task will be skipped when the playbook is executed.</p>
<p>That’s all we need to do to install and configure Apache; let us now look at installing the M in LAMP and review the role to install and configure MariaDB.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor232"/>The MariaDB role</h2>
<p>Of the four roles<a id="_idIndexMarker253"/> we cover in this chapter, this, the MariaDB one, is the most <a id="_idIndexMarker254"/>complicated, as it installs MariaDB, configures it, and optionally downloads and imports a sample database.</p>
<p>Let’s start by covering the installation.</p>
<h3>Installing MariaDB</h3>
<p>You may have <a id="_idIndexMarker255"/>started to <a id="_idIndexMarker256"/>spot a trend in the roles; the tasks always start with installing a fe<a id="_idTextAnchor233"/>w packages, and MariaDB is no different.</p>
<p>The task from <code>roles/mariadb/tasks/main.yml</code> is as follows:</p>
<pre class="source-code">
- name: "Install mariadb packages"
  ansible.builtin.apt:
    state: "present"
    pkg: "{{ mariadb_packages }}"</pre> <p>The <code>mariadb_packages</code> variable in <code>roles/mariadb/defaults/main.yml</code> looks like the following:</p>
<pre class="source-code">
mariadb_pa<a id="_idTextAnchor234"/>ckages:
<a id="_idTextAnchor235"/>  - "mariadb-server"
  - "mariadb-client"
  - "python3-pymysql"</pre> <p>As you can see, we installed the MariaDB client and server. Also, we installed the <code>python3-pymysql</code> package; this is required for the tasks that need to interact with MariaDB once it is installed to function. Without it, Ansible cannot establish a connection to and interact with our MariaDB server.</p>
<p>Once the packages have been installed, we need to start the MariaDB server by using the following task:</p>
<pre class="source-code">
- name: "Start mariadb"
  ansible.builtin.service:
    name: mariadb
    state: started
    enabled: true</pre> <p>You might be thinking, why aren’t we using a handler as we have done for previous tasks? Well, handlers are <a id="_idIndexMarker257"/>only called once the playbook execution has been completed and Ansible knows all the services that need to be restarted.</p>
<p>However, in this case, we need to interact with the MariaDB service to be able to configure it as part of the playbook run, so rather than using a handler, we just start the service as a task using the<a id="_idIndexMarker258"/> same block we would use as the handler.</p>
<p>Now that MariaDB is installed and started, we can start the configuration.</p>
<h3>Configuring MariaDB</h3>
<p>Before we dive <a id="_idIndexMarker259"/>into the tasks, quickly <a id="_idIndexMarker260"/>look at the variables in <code>roles/mariadb/defaults/main.yml</code>, which will be used to configure our MariaDB server:</p>
<pre class="source-code">
mariadb_root_username: "root"
mariadb_root_password: "Pa55W0rd123"
mariadb_hosts:
  - "127.0.0.1"
  - "::1"
  - "{{ ansible_nodename }}"
  - "%"
  - "localhost"</pre> <p>Now that we know what variables we will use, it’s time to work through the configuration, which is a little complex due to the default way that MariaDB is configured when it starts immediately after installation.</p>
<p>By default, MariaDB starts with no password in place, meaning that anyone can connect to the database as the root user, which is not ideal, so the first thing we need to do is to secure our installation by setting the root password.</p>
<p>That sounds easy enough, you might be thinking to yourself.</p>
<p>Technically, it is; however, if the playbook were to be run a second time, meaning that there is now a password set, then the task we are about to define, which sets the initial password, will error, as we need to configure the task not to use a password. Once the password has been set, the server will only accept a connection using the already set password.</p>
<p>We also need to consider <a id="_idIndexMarker261"/>that once a password has been configured, we need to use<a id="_idIndexMarker262"/> that password each time we need to connect to the MariaDB server – so we need an easy way to ensure we can connect smoothly once the password has been set.</p>
<p>Luckily, there is a function built into MariaDB and MySQL that allows you to put your credentials into a file on the server; the file should be placed in the home directory of the user you are logged in as. Once in place, each time you attempt to connect to the database server using that user, the database client will read the file and connect you, without yo<a id="_idTextAnchor236"/>u having to type the credentials – this file should be called <code>~/.my.cnf</code> (the <code>~/</code> part is a shortcut for the user’s home folder).</p>
<p>For our s<a id="_idTextAnchor237"/>cenario, this works because we can check for the presence of the <code>~/.my.cnf</code> file, and if it is not there, then it will be safe to assume that the password has not been configured yet.</p>
<p>The task that checks for the presence of the file is as follows:</p>
<pre class="source-code">
- name: "Check to see if the ~/.my.cnf file exists"
  ansible.builtin.stat:
    path: ~/.my.cnf
  register: mycnf</pre> <p>This uses the <code>ansible.builtin.stat</code> module to check for the file and then uses the <code>register</code> option to register a runtime variable, called <code>mycnf</code>.</p>
<p>Now that we have a dynamically registered variable that contains details on whether the <code>~/.my.cnf</code> file exists on the remote host’s filesystem or not, we ca<a id="_idTextAnchor238"/>n now proceed with changing the password or skip the task if the <code>~/.my.cnf</code> file is present.</p>
<p>Ansible has several <a id="_idIndexMarker263"/>built-in modules to interact with MySQL and MariaDB; the one we<a id="_idIndexMarker264"/> will use here is <code>ansible.builtin.mysql_user</code>:</p>
<pre class="source-code">
- name: "Change mysql root password if we need to"
  community.mysql.mysql_user:
    name: "{{ mariadb_root_username }}"
    host: "{{ item }}"
    password: "{{ mariadb_root_password }}"
    check_implicit_admin: "yes"
    priv: "*.*:ALL,GRANT"
    login_user: "{{ mariadb_root_username }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
  with_items: "{{ mariadb_hosts }}"
  when: not mycnf.stat.exists</pre> <p>In the task, we in<a id="_idTextAnchor239"/>struct Ansible to set the password for the user defined in the <code>{{ mariadb_root_username }}</code> variable to the password stored in the <code>{{ mariadb_root_password }}</code> variable, giving the user full admin access to all the databases across all possible host combinations, which are defined in the <code>{{ mariadb_hosts }}</code>, which we loop over using the <code>with_items</code> function.</p>
<p>When logging in to do this, Ansible should use the <code>{{ mariadb_root_username }}</code> username and connect over a Unix socket, which can be found at <code>/var/run/mysqld/mysqld.sock</code>; this means we don’t have to establish a network connection to interact with the database because, if we did, Ansible wouldn’t be able to connect, as it can’t send a blank password.</p>
<p>Finally, only run this task when the <code>mycnf.stat.exists</code> variable is equal to <code>false</code>.</p>
<p>Now that we have set the actual password and secured the MariaDB installation, we need to create the <code>~/.my.cnf</code> file to carry on with the configuration.</p>
<p>To do this, we will again use a template, which can be found at <code>roles/mariadb/templates/my.cnf.j2</code>. This template looks like the following:</p>
<pre class="source-code">
# {{ ansible_managed }}
[client]
user='{{ mariadb_root_username }}'
password='{{ mariadb_root_password }}'</pre> <p>As you can see, it contains the username and password needed to connect to the database server.</p>
<p>Because the file contains <a id="_idIndexMarker265"/>credentials, when the task creates the file on the server, we need <a id="_idIndexMarker266"/>to ensure that the file can only be read and written to by the root user, by setting the read, write, and execute permissions of the file as it is created:</p>
<pre class="source-code">
- name: "Set up ~/.my.cnf file"
  ansible.builtin.template:
    src: "my.cnf.j2"
    dest: "~/.my.cnf"
    mode: "0600"</pre> <p>Now that we have the <code>~/.my.cnf</code> file on the remote host, we can progress with securing our MariaDB installation; the subsequent task removes the <code>anonymous</code> user, again looping through the hosts that user could be associated with:</p>
<pre class="source-code">
- name: "Delete anonymous MySQL user"
  community.mysql.mysql_user:
    user: ""
    host: "{{ item }}"
    state: absent
  with_items: "{{ mariadb_hosts }}"</pre> <p>The final task that deals with securing our MariaDB installation removes the default <code>test</code> database:</p>
<pre class="source-code">
- name: "Remove the MySQL test database"
  community.mysql.mysql_db:
    db: "test"
    state: "absent"</pre> <p>The remainder of the <a id="_idIndexMarker267"/>tasks in the role, such as copying the <code>index.html</code> file in <a id="_idIndexMarker268"/>the <code>apache</code> role, are optional, so let’s review those tasks now.</p>
<h3>Downloading and importing the example database</h3>
<p>There is one more <a id="_idIndexMarker269"/>block of variables in <code>roles/mariadb/defaults/main.yml</code>; these deal with downloading and<a id="_idIndexMarker270"/> importing an example database. There are a lot of keys in the <code>mariadb_sample_database</code> variable, starting with the flag to enable the option, the URL of the file to download, and the path to save it to:</p>
<pre class="source-code">
mariadb_sample_database:
  create_database: true
  source_url: "https://github.com/russmckendrick/test_db/archive/master.zip"
  path: "/tmp/test_db-master"</pre> <p>Next, we have the name of the example database being created as well as the username and password to use for the new database:</p>
<pre class="source-code">
  db_name: "employees"
  db_user: "employees"
  db_password: "employees"</pre> <p>Finally, there is a list of the files that need to be imported. The first two files contain the schema:</p>
<pre class="source-code">
  dump_files:
    - "employees.sql"
    - "show_elapsed.sql"</pre> <p>The remaining files contain the actual data to be loaded:</p>
<pre class="source-code">
    - "load_departments.dump"
    - "load_employees.dump"
    - "load_dept_emp.dump"
    - "load_dept_manager.dump"
    - "load_titles.dump"
    - "load_salaries1.dump"
    - "load_salaries2.dump"
    - "load_salaries3.dump"</pre> <p>Now that we <a id="_idIndexMarker271"/>know what variables are<a id="_idIndexMarker272"/> defined, we can work through the remaining tasks, the first of which downloads and unarchives the ZIP file that contains the example database files:</p>
<pre class="source-code">
- name: "Download and unarchive the sample database data"
  ansible.builtin.unarchive:
    src: "{{ mariadb_sample_database.source_url }}"
    dest: /tmp
    remote_src: "yes"
  when: mariadb_sample_database.create_database</pre> <p>As you can see, the <code>ansible.builtin.unarchive</code> module allows you to download and unarchive the file, meaning we can do everything we need in a single task. Also, we only run the <code>when</code> task when the <code>mariadb_sample_database.create_database</code> equals <code>true</code>. We will do this for the remainder of the tasks and even expand upon the <code>when</code> statement toward the end of the role.</p>
<p>The next task creates the example database:</p>
<pre class="source-code">
- name: "Create the sample database"
  community.mysql.mysql_db:
    db: "{{ mariadb_sample_database.db_name }}"
    state: present
  when: mariadb_sample_database.create_database</pre> <p>Once the <a id="_idIndexMarker273"/>database has been created, we<a id="_idIndexMarker274"/> can run a task that creates the user and assigns permissions to the newly created user to access the database we just added:</p>
<pre class="source-code">
- name: "Create the user for the sample database"
  community.mysql.mysql_user:
    name: "{{ mariadb_sample_database.db_user }}"
    password: "{{ mariadb_sample_database.db_password }}"
    priv: "{{ mariadb_sample_database.db_name }}.*:ALL"
    state: present
  with_items: "{{ mariadb_hosts }}"
  when: mariadb_sample_database.create_database</pre> <p>We are now down to the final two tasks, and here is where we need to add a little more logic to our playbook to ensure that we only import the example data once; if we don’t have the logic in place, we can run into all sorts of problems if the playbook is rerun and could risk data being overwritten or duplicate data being inserted if the import task is allowed to run again.</p>
<p>As the databases are stored on the host’s filesystem, we can use the same logic that we used to check for the presence of the <code>~/.my.cnf</code> file, but this time, we check for a database file:</p>
<pre class="source-code">
- name: "Check to see if we need to import the sample database dumps"
  ansible.builtin.stat:
    path: /var/lib/mysql/{{ mariadb_sample_database.db_name }}/{{ mariadb_sample_database.db_name }}.frm
  register: db_imported
  when: mariadb_sample_database.create_database</pre> <p>We register <a id="_idIndexMarker275"/>a variable called <code>db_imported</code>, which we will use with the <code>when</code> condition of the next and final task; this<a id="_idIndexMarker276"/> is the one that loops through <code>mariadb_sample_database.dump_files</code> and imports the databases:</p>
<pre class="source-code">
- name: "Import the sample database"
  community.mysql.mysql_db:
    name: "{{ mariadb_sample_database.db_name }}"
    state: import
    target: "{{ mariadb_sample_database.path }}/{{ item }}"
  with_items: "{{ mariadb_sample_database.dump_files }}"
  when: db_imported is defined and not db_imported.stat.exists<a id="_idTextAnchor240"/></pre> <p>We have changed the <code>when</code> condition slightly here; rather than referencing <code>mariadb_sample_database.create_database</code>, we only use <code>db_imported</code>.</p>
<p>The first part ensures that the playbook doesn’t error if we decide not to import the database by setting <code>mariadb_sample_database.create_database</code> to <code>false</code>, as <code>db_imported</code> can only be defined if <code>mariadb_sample_database.create_database</code> is set to <code>true</code>, as the task that sets the <code>db_imported</code> variable is only ever executed when that condition is met.</p>
<p>As you can also see, we use <code>and</code>, thus adding a second condition to the <code>when</code> statement; this means that the task will only be executed if <code>db_imported is defined</code> and <code>not db_imported.stat.exists</code> are both met.</p>
<p>That final<a id="_idIndexMarker277"/> task brings us to the end of the <a id="_idIndexMarker278"/>MariaDB role and leaves us with one role to work through – the PHP role.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor241"/>The PHP role</h2>
<p>This, our final role, installs<a id="_idIndexMarker279"/> PHP, optionally copies a PHP Info file along with it, and installs a <a id="_idIndexMarker280"/>database management interface written in PHP, called Adminer, so that we can access the database server we used in the previous role.</p>
<h3>Installing the PHP packages</h3>
<p>It should come as no surprise to<a id="_idIndexMarker281"/> you that the first task executed in the<a id="_idIndexMarker282"/> PHP role install<a id="_idTextAnchor242"/>s the packages needed for us to run PHP.</p>
<p>The full list of packages is defined in the <code>roles/php/default/main.yml</code> file, as follows:</p>
<pre class="source-code">
php_packages:
  - "php"
  - "php-cli"
  - "php-curl"
  - "php-gd"
  - "php-intl"
  - "php-mbstring"
  - "php-mysql"
  - "php-soap"
  - "php-xml"
  - "php-xmlrpc"
  - "php-zip"
  - "libapache2-mod-php"</pre> <p>The task itself looks familiar:</p>
<pre class="source-code">
- name: "Install php packages"
  ansible.builtin.apt:
    state: "present"
    pkg: "{{ php_packages }}"
  notify: "Restart apache2"</pre> <p>The thing to note is that we restart Apache once PHP is installed because we run PHP as an Apache module. So, once installed, Apache needs to be restarted to load in the module and enable PHP on our Apache web server.</p>
<p>That’s it. PHP is<a id="_idIndexMarker283"/> installed, and Apache asks to be <a id="_idIndexMarker284"/>restarted; everything from here is optional.</p>
<h3>Copying the PHP Info file</h3>
<p>The next task<a id="_idIndexMarker285"/> is a simple one that copies <code>roles/php/files/info.php</code> to<a id="_idIndexMarker286"/> the web root of the server if the <code>php_info</code> variable is set to <code>true</code>:</p>
<pre class="source-code">
- name: "Copy the PHP info to the document root"
  ansible.builtin.copy:
    src: info.php
    dest: "{{ document_root }}/info.php"
    mode: "0755"
    owner: "{{ users.0.name }}"
    group: "{{ apache_group }}"
  when: php_info</pre> <p>The only difference is that we copy the file from our local host to the remote one with this task – we do not use the <code>ansible.builtin.template</code> module this time but instead, the <code>ansible.builtin.copy</code> one. This is because <code>info.php</code> is made up of three lines of code, none of which we need to update based on the environment or any variables <a id="_idIndexMarker287"/>we<a id="_idIndexMarker288"/> set.</p>
<h3>Installing and configuring Adminer</h3>
<p>The variables for the <a id="_idIndexMarker289"/>remaining tasks in the <code>roles/php/default/main.yml</code> file <a id="_idIndexMarker290"/>look like the following:</p>
<pre class="source-code">
adminer:
  install: true
  path: "/usr/share/adminer"
  download: "https://github.com/vrana/adminer/releases/download/v4.8.1/adminer-4.8.1-mysql.php"</pre> <p>They define where to download the file from and where on the remote to download it to, which is where the first of the three tasks comes in, as this creates the folder on the remote virtual machines filesystem for us to download Adminer to:</p>
<pre class="source-code">
- name: "Create the document root for adminer"
  ansible.builtin.file:
    dest: "{{ adminer.path }}"
    state: directory
    mode: "0755"
  when: adminer.install</pre> <p>Once we have the download target folder created, we can download Adminer itself:</p>
<pre class="source-code">
- name: "Download adminer"
  ansible.builtin.get_url:
    url: "{{ adminer.download }}"
    dest: "{{ adminer.path }}/index.php"
    mode: "0755"
  when: adminer.install</pre> <p>As you may have spotted from the download URL and destination, Adminer is a single PHP file that we save as <code>index.php</code>. So, how will we access Adminer via our Apache web server?</p>
<p>Well, to do that, we<a id="_idIndexMarker291"/> need to copy across another virtual <a id="_idIndexMarker292"/>host configuration file:</p>
<pre class="source-code">
- name: "Copy the adminer.conf to sites-enabled folder"
  ansible.builtin.template:
    src: adminer.conf.j2
    dest: "{{ vhost_path }}adminer.conf"
    mode: "0755"
  when: adminer.install
  no<a id="_idTextAnchor243"/>tify: "Restart apache2"</pre> <p>As you can see, this renders and copies across <code>roles/php/templates/adminer.conf.j2</code> to <code>adminer.conf</code>, the site-enabled folder on our remote host, and instructs the Apache service to restart to load the newly added configuration.</p>
<p>The <code>adminer.conf.j2</code> file contains the following:</p>
<pre class="source-code">
# {{ ansible_managed }}
Alias /adminer "{{ adminer.path }}"
  &lt;Directory "{{ adminer.path }}"&gt;
    DirectoryIndex index.php
    AllowOverride All
    Require all granted
  &lt;/Directory&gt;</pre> <p>This tells <a id="_idIndexMarker293"/>Apache that whenever someone<a id="_idIndexMarker294"/> visits <code>http://someurl/adminer/</code>, the Adminer <code>index.php</code> file should be served.</p>
<p>With that task covered, we have completed the walk-through of the four roles that go into installing and configuring our LAMP stack, and now it is time to review and execute the playbook itself.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor244"/>The LAMP playbook</h1>
<p>As mentioned at the start of this chapter<a id="_idIndexMarker295"/> when we discussed the playbook structure, the main playbook file is called <code>site.yml</code>, which contains the following:</p>
<pre class="source-code">
---
- name: "Install LAMP stack"
  hosts: ansible_hosts
  gather_facts: true
  become: true
  become_method: ansible.builtin.sudo
  vars_files:
    - group_vars/common.yml
  roles:
    - common
    - apache
    - mariadb
    - php</pre> <p>As you can see, it calls the four roles we have<a id="_idIndexMarker296"/> already walked through and also loads a <code>variables</code> file from <code>group_vars/common.yml</code>; this file contains an override for <code>html_body</code>, which is configured in <code>roles/apache/defaults/main.yml</code> and looks like the following:</p>
<pre class="source-code">
html_body: |
  This HTML page has been deployed using Ansible to &lt;b&gt;{{ ansible_nodename }}&lt;/b&gt;.&lt;br&gt;
  The user is &lt;b&gt;{{ users.0.name }}&lt;/b&gt; who is in the &lt;b&gt;{{ apache_group }}&lt;/b&gt; group.&lt;br&gt;
  The weboot is &lt;b&gt;{{ document_root }}&lt;/b&gt;, the default index file is &lt;b&gt;{{ index_file }}&lt;/b&gt;.&lt;br&gt;&lt;br&gt;
  You can access a &lt;a href="/info.php"&gt;PHP Info file&lt;/a&gt; or &lt;a href="/adminer/"&gt;Adminer&lt;/a&gt;.</pre> <p>This means that when we run the playbook, the <code>index.hml</code> page will have links to <code>info.php</code> and the <code>/adminer</code> URL to access the additional content easily.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>Chapter04</code> folder in the GitHub repo that accompanies this title contains the example hosts file and keys to launch a local virtual machine using Multipass. If you are following along, refer to the instructions in <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installi<a id="_idTextAnchor245"/>ng and Running Ansible</em>, for how to launch the virtual machine and prepare your own <code>hosts</code> file.</p>
<p>So, without further ado, let’s <a id="_idIndexMarker297"/>run the playbook:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml</pre> <p>On the first run, this should give us some output that looks like the following:</p>
<pre class="console">
PLAY [ansible_hosts]
TASK [Gathering Facts]
ok: [ansiblevm]
TASK [roles/common : update apt cache and upgrade packages]
ok: [ansiblevm]
…. lots of other output here ….
RUNNING HANDLER [roles/apache : restart apache2]
changed: [ansiblevm]
PLAY RECAP
ansiblevm : ok=34    changed=26    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>As you can see, the Playbook has made 26 changes to the target virtual machine.</p>
<p>Let’s run the playbook a second time:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml</pre> <p>Then, in the play recap, you should see that some tasks were skipped:</p>
<pre class="console">
PLAY RECAP
ansiblevm         : ok=30    changed=0    unreachable=0    failed=0    skipped=2    rescued=0    ignored=0</pre> <p>As expected, one of those<a id="_idIndexMarker298"/> tasks was updating the root password for the database user:</p>
<pre class="console">
TASK [roles/mariadb : change mysql root password if we need to]
skipping: [ansiblevm] =&gt; (item=127.0.0.1)
skipping: [ansiblevm] =&gt; (item=::1)
skipping: [ansiblevm] =&gt; (item=ansiblevm)
skipping: [ansiblevm] =&gt; (item=%)
skipping: [ansiblevm] =&gt; (item=localhost)
skipping: [ansiblevm]</pre> <p>The second task that is skipped is importing the database files:</p>
<pre class="console">
TASK [roles/mariadb : import the sample database]
skipping: [ansiblevm] =&gt; (item=employees.sql)
skipping: [ansiblevm] =&gt; (item=show_elapsed.sql)
skipping: [ansiblevm] =&gt; (item=load_departments.dump)
skipping: [ansiblevm] =&gt; (item=load_employees.dump)
skipping: [ansiblevm] =&gt; (item=load_dept_emp.dump)
skipping: [ansiblevm] =&gt; (item=load_dept_manager.dump)
skipping: [ansiblevm] =&gt; (item=load_titles.dump)
skipping: [ansiblevm] =&gt; (item=load_salaries1.dump)
skipping: [ansiblevm] =&gt; (item=load_salaries2.dump)
skipping: [ansiblevm] =&gt; (item=load_salaries3.dump)
skipping: [ansiblevm]</pre> <p>Both are to be expected, as that is how we configured the tasks to respond on subsequent Playbook runs.</p>
<p>Now, if you open<a id="_idIndexMarker299"/> your browser and enter <code>http://</code> and then the name of your Ansible host (for me, this was <a href="http://192.168.64.20.nip.io">http://192.168.64.20.nip.io</a>; I suspect yours will be different, so the link wi<a id="_idTextAnchor246"/>ll likely not work), then you should be greeted by the <code>index.html</code> page that Ansible generated:</p>
<div><div><img alt="Figure 4.2 – Success !!! – viewing the index.html page" src="img/B21620_04_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Success !!! – viewing the index.html page</p>
<p>Clicking on the link for the PHP Info file should take you to something like <a href="http://192.168.64.20.nip.io/info.php">http://192.168.64.20.nip.io/info.php</a>, which will display information on your PHP installation:</p>
<div><div><img alt="Figure 4.3 – Viewing the PHP Info page" src="img/B21620_04_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Viewing the PHP Info page</p>
<p>The final link to click is the one for Adminer; clickin<a id="_idTextAnchor248"/>g it will take you to <a href="http://192.168.64.20.nip.io/adminer/">http://192.168.64.20.nip.io/adminer/</a>, which will prompt you to log<a id="_idTextAnchor249"/> in:</p>
<div><div><img alt="Figure 4.4 – The Adminer login page" src="img/B21620_04_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The Adminer login page</p>
<p>To log in, use the <a id="_idIndexMarker300"/>following credentials:</p>
<ul>
<li><code>root</code></li>
<li><code>Pa55W0rd123</code></li>
<li><code>employees</code></li>
</ul>
<p>Once logged in, you will be <a id="_idIndexMarker301"/>taken straight to an overview of the <strong class="bold">employees</strong> database:</p>
<div><div><img alt="Figure 4.5 – The employees database overview" src="img/B21620_04_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The employees database overview</p>
<p>Feel free to click around, and once you have finished, ensure that you terminate the Multipass virtual machine; instructions on how to do this can be found at the end of <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing and </em><em class="italic">Running Ansible</em>.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor250"/>Summary</h1>
<p>In this chapter, we worked through writing a playbook that installs a LAMP stack on our Multipass virtual machine. We created four roles, one for each element of the stack, and within each of the roles, we built in a bit of logic that can be overridden to deploy additional elements, such as test HTML and PHP pages, and we also built in the option to create a test database that contains over 40,000 records.</p>
<p>So far, we installed some basic packages. In the next chapter, we will write a playbook that installs, configures, and maintains a WordPress installation.</p>
<p>This updated playbook will reuse some of the elements from the roles we covered in this chapter and make some improvements, as some of the elements we covered in this chapter were a little too simplistic. The biggest change is that we will not use a hardcoded password for the database instance moving forward.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor251"/>Further reading</h1>
<p>You can find the project pages for the third-party tools covered throughout the chapter at the following URLs:</p>
<ul>
<li><strong class="bold">Apache</strong>: <a href="https://httpd.apache.org/">https://httpd.apache.org/</a></li>
<li><strong class="bold"><a id="_idTextAnchor252"/></strong><strong class="bold">MariaDB</strong>: <a href="https://mariadb.org/">https://mariadb.org/</a></li>
<li><strong class="bold">Datacharmer test </strong><strong class="bold">database</strong>: <a href="https://github.com/datacharmer/test_db">https://github.com/datacharmer/test_db</a></li>
<li><strong class="bold">PHP</strong>: <a href="https://php.net/">https://php.net/</a></li>
<li><strong class="bold">Adminer</strong>: <a href="https://www.adminer.org">https://www.adminer.org</a></li>
<li><strong class="bold">NGINX</strong>: <a href="https://nginx.org">https://nginx.org</a></li>
</ul>
</div>
</body></html>