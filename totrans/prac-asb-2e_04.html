<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor207"/>4</h1>
<h1 id="_idParaDest-61"><a id="_idTextAnchor208"/>Playbooks and Roles</h1>
<p>So far in this book, we have worked mostly with ad hoc Ansible commands for simplicity and to help you to understand the fundamentals. However, the lifeblood of Ansible is most certainly the playbook, which is a logical organization of tasks (think ad hoc commands) in a structure that creates a useful outcome. This might be to deploy a web server on a newly built virtual machine, or it might be to apply a security policy. It might even involve handling the whole build process for a virtual machine! The possibilities are endless. Ansible playbooks, as we have already covered, are designed to be simple to write and easy to read – they are intended to be self-documenting and, as such, will form a valuable part of your IT processes.</p>
<p>In this chapter, we will explore playbooks in greater depth, from the basics of their creation to more advanced concepts such as running tasks in loops and blocks, performing conditional logic, and – perhaps one of the most important concepts for playbook organization and code reuse – Ansible roles. We will cover roles in more detail later, but just know that this is something you will want to use as much as possible when creating manageable playbook code.</p>
<p>Specifically, in this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the playbook framework</li>
<li>Understanding roles – the playbook organizer</li>
<li>Using conditions in your code</li>
<li>Repeating tasks with loops</li>
<li>Grouping tasks using blocks</li>
<li>Configuring play execution via strategies</li>
<li>Using <code>ansible-pull</code></li>
</ul>
<h1 id="_idParaDest-62"><a id="_idTextAnchor209"/>Technical requirements</h1>
<p>This chapter assumes that you have set up your control host with Ansible, as detailed in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, and are using the most recent version available – the examples in this chapter were tested with Ansible 8.0 and <code>ansible-core</code> 2.15. This chapter also assumes that you have at least one additional host to test against, and this should be Linux-based. Although we will give specific examples of hostnames in this chapter, you are free to substitute them with your own hostnames and/or IP addresses, and details of how to do this will be provided in the appropriate places.</p>
<p>The code bundle for this chapter is available here: <a href="https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204">https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204</a>.<a id="_idTextAnchor210"/></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor211"/>Understanding the playbook framework</h1>
<p>A <a id="_idIndexMarker243"/>playbook allows you to manage multiple configurations and complex deployments on many machines simply and easily. This is one of the key benefits of using Ansible for the delivery of complex applications. With playbooks, you can organize your tasks in a logical structure, as tasks are (generally) executed in the order they are written, allowing you to have a good deal of control over your automation processes. With that said, it is possible to perform tasks asynchronously, so where tasks are not executed in sequence, we will highlight this. Our goal is that once you complete this chapter, you will understand the best practices to write your own Ansible playbooks.</p>
<p>Although YAML format is easy to read and write, it is very pedantic when it comes to spacing. For example, you cannot use tabs to set indentation even though on the screen a tab and four spaces might look identical – in YAML, they are not. We recommend that you adopt an editor with YAML support to aid you in writing your playbooks if you are doing this for the first time – perhaps Vim, Visual Studio Code, or Eclipse – as these will help you to ensure that your indentation is correct. To test the playbooks we develop in this chapter, we will create a variant of the inventory created in <a href="B20846_03.xhtml#_idTextAnchor158"><em class="italic">Chapter 3</em></a>, <em class="italic">Defining Your Inventory</em> (unless stated otherwise):</p>
<pre class="source-code">
[frontends]
web01.example.org https_port=8443
web02.example.org http_proxy=proxy.example.org
[frontends:vars]
ntp_server=ntp.web.example.org
proxy=proxy.web.example.org
[apps]
app01.example.org
app02.example.org
[webapp:children]
frontends
apps
[webapp:vars]
proxy_server=proxy.webapp.example.org
health_check_retry=3
health_check_interval=60</pre> <p>Let’s dive<a id="_idIndexMarker244"/> right in and get started writing a playbook. In <a href="B20846_02.xhtml#_idTextAnchor099"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Fundamentals of Ansible</em>, we covered some of the basic aspects of the YAML syntax and structure required to create a playbook, so we won’t repeat these in detail here. Rather, we will build on them to show you what playbook development is all about:</p>
<ol>
<li>Create a simple playbook (called <code>myplaybook.yml</code>) to run on the hosts in the <code>frontends</code> host group defined in our inventory file. We can set the user that will access the hosts using the <code>remote_user</code> directive in the playbook, as demonstrated in the following (you can also use the <code>--user</code> switch on the command line, but as this chapter is about playbook development, we’ll ignore that for now):<pre class="source-code">
---
- hosts: frontends
  remote_user: james
  tasks:
  - name: simple connection test
    ansible.builtin.ping:
    remote_user: james</pre></li> <li>Add <a id="_idIndexMarker245"/>another task below the first, which will run the <code>ansible.builtin.shell</code> module (that will, in turn, run the <code>ls</code> command on the remote hosts). We’ll also add the <code>ignore_errors</code> directive to this task to ensure that our playbook doesn’t fail if the <code>ls</code> command fails (for example, if the directory we’re trying to list doesn’t exist). Be careful with the indentation and ensure that it matches that of the first part of the file:<pre class="source-code">
  - name: run a simple command
    ansible.builtin.shell: /bin/ls -al /nonexistent
    ignore_errors: True</pre></li> <li>Let’s see how our newly created playbook behaves when we run it with the following command:<a id="_idTextAnchor212"/><a id="_idTextAnchor213"/><pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts myplaybook.yml</strong></pre></li> </ol>
<p>The output from this playbook run should look something like the following screenshot:</p>
<div><div><img alt="Figure 4.1 – Demonstrating the execution of a playbook where errors are willfully ignored" height="1420" src="img/B20846_04_001.jpg" width="1522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Demonstrating the execution of a playbook where errors are willfully ignored</p>
<p>From the output <a id="_idIndexMarker246"/>of the playbook run, you can see that our two tasks were executed in the order in which they were specified. We can see that the <code>ls</code> command failed because we tried to list a directory that did not exist, but the playbook did not register any <code>failed</code> tasks because we set <code>ignore_errors</code> to <code>true</code> for this task (and only this task).</p>
<p>Most Ansible modules (with the exception of those that run user-defined commands such as <code>ansible.builtin.shell</code>, <code>ansible.builtin.command</code>, and <code>ansible.builtin.raw</code>) are coded to be idempotent – that is to say, if you run the same task twice, the results will be the same, and the task will not make the same change twice; if it detects that the action it is being requested to perform has been completed, then it does not perform it a second time. This, of course, is not possible for the aforementioned modules, as they could be used to perform just about any conceivable task – hence, how could the module know it was being performed twice?</p>
<p>Every module <a id="_idIndexMarker247"/>returns a set of results, and among these results is the task status. You can see these summarized at the bottom of the preceding playbook run output, and their meaning is as follows:</p>
<ul>
<li><code>ok</code>: The task ran successfully and no changes were made</li>
<li><code>changed</code>: The task ran successfully and changes were made</li>
<li><code>failed</code>: The task failed to run (but the host was reachable)</li>
<li><code>unreachable</code>: The host was unreachable to run the task on</li>
<li><code>skipped</code>: This task was skipped</li>
<li><code>ignored</code>: This task was ignored (for example, in the case of <code>ignore_errors</code>)</li>
<li><code>rescued</code>: We will see an example of this later when we look at blocks and rescue tasks</li>
</ul>
<p>These statuses can be very useful – for example, if we have a task to deploy a new Apache configuration file from a template, we know we must restart the Apache service for the changes to be picked up. However, we only want to do this if the file was actually changed – if no changes were made, we don’t want to needlessly restart Apache, as it would interrupt people who might be using the service. Hence, we can use the <code>notify</code> action, which tells Ansible to call a <code>handler</code> when (and only when) the result from a task is <code>changed</code>. In brief, a handler is a special type of task that is run as a result of a <code>notify</code>. However, unlike Ansible playbook tasks, which are performed in sequence, handlers are all grouped together and run at the very end of the play. Also, they can be notified more than once but will only be run once regardless, again preventing needless service restarts. Consider the following playbook:</p>
<pre class="source-code">
---
- name: Handler demo 1
  hosts: web01.example.org
  gather_facts: no
  become: yes
  tasks:
    - name: Update Apache configuration
      ansible.builtin.template:
        src: template.j2
        dest: /etc/apache2/apache2.conf
      notify: Restart Apache
  handlers:
    - name: Restart Apache
      ansible.builtin.service:
        name: apache2
        state: restarted</pre> <p>To keep <a id="_idIndexMarker248"/>the output concise, I’ve turned off fact-gathering for this playbook (we won’t use facts in any of the tasks). I’m also running this on just one host again for conciseness, but you are welcome to expand the demo code as you wish. If we run this task for the first time, we will see the following results:</p>
<pre class="console">
$ ansible-playbook -i hosts handlers1.yml
PLAY [Handler demo 1] **********************************************************
TASK [Update Apache configuration] *********************************************
changed: [web01.example.org]
RUNNING HANDLER [Restart Apache] ***********************************************
changed: [web01.example.org]
PLAY RECAP *********************************************************************
web01.example.org          : ok=2    changed=2    unreachable=0    failed=0    skipped=0     rescued=0    ignored=0</pre> <p>Note how<a id="_idIndexMarker249"/> the handler was run at the end, as the configuration file was updated. However, if we run this playbook a second time without making any changes to the template or configuration file, we will see something like this:</p>
<pre class="console">
$ ansible-playbook -i hosts handlers1.yml
PLAY [Handler demo 1] **********************************************************
TASK [Update Apache configuration] *********************************************
ok: [web01.example.org]
PLAY RECAP *********************************************************************
web01.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>This time, the handler was not called, as the result from the configuration task was <code>ok</code>. All handlers should have a globally unique name so that the <code>notify</code> action can call the correct handler. You <a id="_idIndexMarker250"/>can also call multiple handlers by setting a common name to use the <code>listen</code> directive – this way, you can call either the handler <code>name</code> or the <code>listen</code> string, as demonstrated in the following example:</p>
<pre class="source-code">
---
- name: Handler demo 1
  hosts: web01.example.org
  gather_facts: no
  become: yes
  handlers:
    - name: restart timesyncd
      ansible.builtin.service:
        name: systemd-timesyncd.service
        state: restarted
      listen: "restart all services"
    - name: restart apache
      ansible.builtin.service:
        name: apache2.service
        state: restarted
      listen: "restart all services"
  tasks:
    - name: restart all services
      ansible.builtin.command: echo "this task will restart all services"
      notify: "restart all services"</pre> <p>We only have one<a id="_idIndexMarker251"/> task in the playbook, but when we run it, both handlers are called. Also, remember that we said earlier that <code>ansible.builtin.command</code> was among a set of modules that were a special case because they can’t detect whether a change has occurred – as a result, they always return the <code>changed</code> value, and so, in this demo playbook, the handlers will always be notified, even when we run it a second time:</p>
<pre class="console">
$ ansible-playbook -i hosts handlers2.yml
PLAY [Handler demo 1] **********************************************************
TASK [restart all services] ****************************************************
changed: [web01.example.org]
RUNNING HANDLER [restart timesyncd] ********************************************
changed: [web01.example.org]
RUNNING HANDLER [restart apache] ***********************************************
changed: [web01.example.org]
PLAY RECAP *********************************************************************
web01.example.org          : ok=3    changed=3    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>These are some <a id="_idIndexMarker252"/>of the fundamentals that you need to know to start writing your own playbooks. With these under your belt, let’s run through a comparison of ad hoc commands and playbooks in the next<a id="_idTextAnchor214"/> <a id="_idTextAnchor215"/>section.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor216"/>Comparing playbooks and ad hoc tasks</h2>
<p>Ad hoc <a id="_idIndexMarker253"/>commands allow you to quickly create and execute one-off commands, without keeping any record of what was done (other than perhaps your shell history). These serve an important purpose and can be very valuable in getting small changes made quickly and for learning Ansible and its modules.</p>
<p>Playbooks, by contrast, are logically organized sets of tasks (each could conceivably be an ad hoc command), put together in a sequence that performs one bigger action. The addition of conditional logic, error handling, and so on means that, very often, the benefits of playbooks outweigh the usefulness of ad hoc commands. In addition, provided you keep them organized, you will have copies of all previous playbooks that you run, so you will be able to refer back (if you ever need to) to see what you ran and when.</p>
<p>Let’s develop a practical example – suppose you want to install Apache 2.4 on Ubuntu Server. There are a number of steps involved even if the default configuration is sufficient (which is unlikely, but for now, we’ll keep the example simple). If you were to perform the basic installation by hand, you would need to install the package, open up the firewall, and ensure the service is running (and runs at boot time).</p>
<p>To perform these commands in the shell, you might do the following:</p>
<pre class="console">
$ sudo apt -y install apache2
$ sudo ufw allow http
$ sudo ufw allow https
$ sudo systemctl enable apache2.service
$ sudo systemctl restart apache2.service</pre> <p>Now, for each of these commands, there is an equivalent ad hoc Ansible command that you can run. We won’t go through all of them here in the interests of space; however, let’s say you want to restart the Apache service – if so, you could run an ad hoc command similar to the following (again, we will perform it only on one host for concis<a id="_idTextAnchor217"/>eness):</p>
<pre class="console">
$ ansible -i hosts web01* -m ansible.builtin.service -a "name=apache2 state=restarted" --become</pre> <p>When run <a id="_idIndexMarker254"/>successfully, you will see pages of shell output containing all of the variable data returned from running the <code>ansible.builtin.service</code> module. A snippet of the output from running this ad hoc command is shown here for you to check yours against – the key thing being that the command resulted in the <code>changed</code> status, meaning that it ran successfully and that the service was indeed restarted:</p>
<pre class="console">
web01.example.org | CHANGED =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": true,
    "name": "apache2",
    "state": "started",</pre> <p>You, of course, could create and execute a series of ad hoc commands to replicate the multiple shell commands given previously and run them all individually. With a bit of cleverness, you should reduce this from four commands (for example, the Ansible <code>ansible.builtin.service</code> module can both enable a service at boot time and restart it in one ad hoc command). However, you would still ultimately end up with at least two or three ad hoc commands, and if you want to run these again later on another server, you will need to refer to your notes to figure out how you did it.</p>
<p>A playbook is, hence, a far more valuable way to approach this – not only will it perform all of the steps in one go but it will also give you a record of how it was done for you to refer to later on. There are multiple ways to do this, but consider the following as an example:</p>
<pre class="source-code">
---
- name: Install Apache
  hosts: web01.example.org
  gather_facts: no
  become: yes
  tasks:
    - name: Install Apache package
      ansible.builtin.apt:
        name: apache2
        state: latest
    - name: Open firewall for Apache
      community.general.ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - "http"
        - "https"
    - name: Restart and enable the service
      ansible.builtin.service:
        name: apache2
        state: restarted
        enabled: yes</pre> <p>Now, when you run this, you should see that all of our installation requirements have been completed by <a id="_idIndexMarker255"/>one fairly simple and easy-to-read playbook. There is a new concept here, loops, which we haven’t covered yet, but don’t worry – we will cover this later in the chapter:</p>
<pre class="console">
$ ansible-playbook -i hosts installapache.yml
PLAY [Install Apache] **********************************************************
TASK [Install Apache package] **************************************************
changed: [web01.example.org]
TASK [Open firewall for Apache] ************************************************
changed: [web01.example.org] =&gt; (item=http)
changed: [web01.example.org] =&gt; (item=https)
TASK [Restart and enable the service] ******************************************
changed: [web01.example.org]
PLAY RECAP *********************************************************************
web01.example.org          : ok=3    changed=3    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>As you can see, this is far better to capture what was actually done and document it in a format that someone else can easily pick up. Even though we will cover loops later on in the book, it’s fairly easy <a id="_idIndexMarker256"/>to see from the preceding example how they might work. With this established, let’s proceed to the next section to look in more detail at a couple of terms we have used several times to ensure you are clear on their meanings – <strong class="bold">pla<a id="_idTextAnchor218"/>y<a id="_idTextAnchor219"/>s</strong> and <strong class="bold">tasks</strong>.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor220"/>Defining plays and tasks</h2>
<p>So far, when <a id="_idIndexMarker257"/>we have worked with playbooks, we have created one single play per playbook (which logically is the minimum you can do). However, you can have more than one play in a playbook, and a “<em class="italic">play</em>” in Ansible terms is simply a set of <a id="_idIndexMarker258"/>tasks (and roles, handlers, and other Ansible facets) associated with a host (or group of hosts). A task is the smallest possible element of a play, and it is responsible for running a single module with a set of arguments to achieve a specific goal. Of course, in theory, this sounds quite complex, but when backed up by a practical example, it becomes quite simple to understand.</p>
<p>If we refer to our example inventory, this describes a simple two-tier architecture (we’ve left out the database tier for now). Now, suppose we want to write a single playbook to configure both the frontend servers and the application servers. We could use two separate playbooks to configure the frontend and application servers, but this risks fragmenting your code and making it difficult to organize. However, frontend servers and application servers are going to be (by their very nature) fundamentally different and so are unlikely to be configured with the same set of tasks.</p>
<p>The solution to this problem is to create a single playbook with two plays in it. The start of each play can be identified by the line at the lowest indentation (that is, zero spaces in front of it).</p>
<p>Let’s get started with building up our playbook:</p>
<ol>
<li>Add the first play to the playbook and define some simple tasks to set up the Apache server on the frontend, as shown here:<pre class="source-code">
---
- name: Play 1 - configure the frontend servers
  hosts: frontends
  become: yes
  tasks:
  - name: Install the Apache package
    ansible.builtin.apt:
      name: apache2
      state: latest
  - name: Start the Apache server
    ansible.builtin.service:
      name: apache2
      state: started</pre></li> <li>Immediately <a id="_idIndexMarker259"/>below this, in the same file, add the second play <a id="_idIndexMarker260"/>to configure the application tier servers:<pre class="source-code">
- name: Play 2 - configure the application servers
  hosts: apps
  become: true
  tasks:
  - name: Install Tomcat
    ansible.builtin.apt:
      name: tomcat9
      state: latest
  - name: Start the Tomcat server
    ansible.builtin.service:
      name: tomcat9
      state: started</pre></li> </ol>
<p>Now, you have two plays – one to install web servers in the <code>frontends</code> group and one to install application servers in the <code>apps</code> group, all combined into one simple playbook.</p>
<p>When <a id="_idIndexMarker261"/>we run <a id="_idIndexMarker262"/>this playbook, we’ll see the two plays performed sequentially, in the order they appear in the playbook. Note the presence of the <code>PLAY</code> keyword, which denotes the start of each play. Use the following command to r<a id="_idTextAnchor221"/><a id="_idTextAnchor222"/><a id="_idTextAnchor223"/>un the playbook:</p>
<pre class="console">
$ ansible-playbook -i hosts playandtask.yml</pre> <p>The output from your playbook run should look something like the following screenshot:</p>
<div><div><img alt="Figure 4.2 –  Demonstrating the execution of a playbook containing two plays" height="1536" src="img/B20846_04_002.jpg" width="1460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 –  Demonstrating the execution of a playbook containing two plays</p>
<p>There<a id="_idIndexMarker263"/> we <a id="_idIndexMarker264"/>have it – one playbook, yet two distinct plays operating on different sets of hosts from the provided inventory. This is very powerful, especially when combined with roles (which will be covered later in this book). Of course, you can have just one play in your playbook – you don’t have to have multiple ones, but it is important to be able to develop multi-play playbooks, as you will almost certainly find them useful as your environment gets more complex.</p>
<p>Playbooks are <a id="_idIndexMarker265"/>the lifeblood of Ansible automation – they extend it <a id="_idIndexMarker266"/>beyond single tasks/commands (which in themselves are incredibly powerful) to a whole series of tasks organized logically. As you extend your library of playbooks, however, how do you keep your work organized? How do you efficiently reuse the same blocks of code? In the preceding example, we installed Apache, and this might be a requirement on a number of your servers. However, should you attempt to manage them all from one playbook? Or should you perhaps keep copying and pasting the same block of code over and over again? There is a better way, and in Ansible terms, we need to start looking at roles, which we shall do in <a id="_idTextAnchor224"/>t<a id="_idTextAnchor225"/>he very next section.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor226"/>Understanding roles – the playbook organizer</h1>
<p>Roles are designed to <a id="_idIndexMarker267"/>enable you to efficiently and effectively reuse Ansible code. They always follow a known structure and often will include sensible default values for variables, error handling, handlers, and so on. Taking our Apache installation example from the<a id="_idIndexMarker268"/> previous chapter, we know that this is something that we might want to do over and over again, perhaps with a different configuration file each time, and perhaps with a few other tweaks on a per-server (or per-inventory group) basis. In Ansible, the most efficient way to support the reuse of this code in this way would be to create it as a role.</p>
<p>The process of <a id="_idIndexMarker269"/>creating roles is in fact very simple – Ansible will (by default) look within the same directory that you are running your playbook from for a <code>roles/</code> directory, and in here, you will create one subdirectory for each role. The role name is derived from the subdirectory name. There is no need to create complex metadata or anything else – it really is that simple. Within each subdirectory goes a fixed directory structure that tells Ansible what the tasks, default variables, handlers, and so on are for each role.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>roles/</code> directory is not the only place Ansible will look for roles – this is the first directory it will look in, but it will then look in <code>/etc/ansible/roles</code> for any additional roles. This can be further customized through the Ansible configuration file, as discussed in <a href="B20846_02.xhtml#_idTextAnchor099"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Fundamentals </em><em class="italic">of Ansible</em>.</p>
<p>Let’s explore this in a <a id="_idIndexMarker270"/>little more detail. Consider the following directory structure:</p>
<pre class="source-code">
site.yml
frontends.yml
dbservers.yml
roles/
   installapache/
     tasks/
     handlers/
     templates/
     vars/
     defaults/
   installtomcat/
     tasks/
     meta/</pre> <p>The preceding directory structure shows two roles defined in our hypothetical playbook directory, called <code>installapache</code> and <code>installtomcat</code>. Within each of these directories, you will see a series of subdirectories. These subdirectories do not need to exist (there’ll be more on what they mean in a minute, but, for example, if your role has no handlers, then <code>handlers/</code> does not need to be created). However, where you do require such a directory, you should populate it with a YAML file named <code>main.yml</code>. Each of these <code>main.yml</code> files will be expected to have certain contents, depending on the directory that contained them.</p>
<p>The subdirectories that can exist inside of a role are as follows:</p>
<ul>
<li><code>tasks</code>: This is the most common directory to find in a role, and it contains all of the Ansible tasks that the role should perform.</li>
<li><code>handlers</code>: All handlers used in the role should go into this directory.</li>
<li><code>defaults</code>: All default variables for the role go in here.</li>
<li><code>vars</code>: These are other role variables – these override those declared in the <code>defaults/</code> directory, as they are higher up the precedence order.</li>
<li><code>files</code>: Files needed by the role should go in here – for example, any configuration files that need to be deployed to the target hosts.</li>
<li><code>templates</code>: Distinct from the <code>files/</code> directory, this directory should contain all templates used by the role.</li>
<li><code>meta</code>: Any metadata needed for the role goes in here. For example, roles are normally executed in the order they are called from the parent playbook; however, sometimes, a role will have dependency roles that need to be run first, and if this is the case, they can be declared within this directory.</li>
</ul>
<p>For the examples<a id="_idIndexMarker271"/> we will develop in this part of this chapter, we will need an inventory, so let’s reuse the inventory we used in the previous section (included here for convenience):</p>
<pre class="source-code">
[frontends]
web01.example.org https_port=8443
web02.example.org http_proxy=proxy.example.org
[frontends:vars]
ntp_server=ntp.web.example.org
proxy=proxy.web.example.org
[apps]
app01.example.org
app02.example.org
[webapp:children]
frontends
apps
[webapp:vars]
proxy_server=proxy.webapp.example.org
health_check_retry=3
health_check_interval=60</pre> <p>Let’s get started <a id="_idIndexMarker272"/>with some practical exercises to help you to learn how to create and work with roles. We’ll start by creating a role called <code>installapache</code>, which will handle the Apache installation process we looked at in the previous section. However, here, we will expand it to cover the installation of Apache on both Fedora and Ubuntu. This is a good practice, especially if you are looking to submit your roles back to the community, as the more general-purpose they are (and the wider the range of systems they will work on), the more useful they will be to people.</p>
<p>Step through the following process to create your first role:</p>
<ol>
<li>Create the directory structure for the <code>installapache</code> role from within your chosen playbook directory – this is as simple as this:<pre class="source-code">
<code>main.yml</code> inside the <code>tasks</code> directory we just created. This won’t actually perform the Apache installation – rather, it will call one of two external tasks files, depending on the operating system detected on the target host during the fact-gathering stage. We can use a fact called <code>ansible_distribution</code>, in a <code>when</code> clause, to determine which of the task files to import:<pre class="source-code">
---
- name: import a tasks based on OS platform
  import_tasks: fedora.yml
  when: ansible_distribution == 'Fedora'
- import_tasks: ubuntu.yml
  when: ansible_distribution == 'Ubuntu'</pre></li> <li>Create <code>fedora.yml</code> in <code>roles/installapache/tasks</code> to install the latest <a id="_idIndexMarker273"/>version of the Apache web server via the <code>dnf</code> package manager. This should contain the following content:<pre class="source-code">
---
- name: Install Apache using dnf
  ansible.builtin.dnf:
    name: httpd
    state: latest
- name: Start the Apache server
  ansible.builtin.service:
    name: httpd
    state: started</pre></li> <li>Create a file called <code>ubuntu.yml</code> in <code>roles/installapache/tasks</code> to install the latest version of the Apache web server via the <code>apt</code> package manager on Ubuntu. Note how the content differs between Fedora and Ubuntu hosts:<pre class="source-code">
---
- name: Install Apache using apt
  ansible.builtin.apt:
    name: apache2
    state: latest
- name: Start the Apache server
  ansible.builtin.service:
    name: apache2
    state: started</pre></li> </ol>
<p>For now, we’re <a id="_idIndexMarker274"/>keeping our code for a role really simple – however, you can see that the preceding tasks’ files are just like an Ansible playbook, except that they lack the play definition. As they do not come under a play, they are also at a lower indentation level than in a playbook, but apart from this difference, the code should look very familiar to you. In fact, this is part of the beauty of roles – as long as you pay attention to getting the indentation level right, you can more or less use the same code in a playbook or a role.</p>
<p>Now, roles can’t be run directly – we have to create a playbook to call them, so let’s write a simple playbook to call our newly created role. This has a play definition just like we saw before, but rather than having a <code>tasks:</code> section within the play, we have a <code>roles:</code> section where the roles are declared instead. Convention dictates that this file is called <code>site.yml</code>, but you are free to call it whatever you like:</p>
<pre class="source-code">
---
- name: Install Apache using a role
  hosts: frontends
  become: true
  roles:
    - installapache</pre> <p>For clarity, your final directory structure should look like this:</p>
<pre class="source-code">
.
├── hosts
├── roles
│   └── installapache
│       └── tasks
│           ├── fedora.yml
│           ├── main.yml
│           └── ubuntu.yml
└── site.yml</pre> <p>With this completed, you<a id="_idIndexMarker275"/> can now run your <code>site.yml</code> playbook using <code>ansible-playbook</code> in the normal way – you should see output similar to this:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml
PLAY [Install Apache using a role] *********************************************
TASK [Gathering Facts] *********************************************************
ok: [web02.example.org]
ok: [web01.example.org]
TASK [installapache : Install Apache using yum] ********************************
skipping: [web01.example.org]
skipping: [web02.example.org]
TASK [installapache : Start the Apache server] *********************************
skipping: [web01.example.org]
skipping: [web02.example.org]
TASK [installapache : Install Apache using apt] ********************************
changed: [web02.example.org]
changed: [web01.example.org]
TASK [installapache : Start the Apache server] *********************************
changed: [web02.example.org]
changed: [web01.example.org]
PLAY RECAP *********************************************************************
web01.example.org          : ok=3    changed=2    unreachable=0    failed=0    skipped=2    r escued=0    ignored=0
web02.example.org          : ok=3    changed=2    unreachable=0    failed=0    skipped=2    rescued=0    ignored=0</pre> <p>That’s it – you <a id="_idIndexMarker276"/>have created, at the simplest possible level, your first role. Of course (as we discussed earlier), there is much more to a role than just the simple tasks that we have added here, and we will see expanded examples as we work through this chapter. However, the preceding example is intended to show you how quick and easy it is to get started with roles.</p>
<p>Before we look at some of the other aspects relating to roles, let’s take a look at some other ways to call your role. Ansible allows you to statically import or dynamically include roles when you write a playbook. The syntax between importing or including a role is subtly different, and notably, both go in the <code>tasks</code> section of your playbook rather than in the <code>roles</code> section. The following is a hypothetical example that shows both options in a really simple playbook. The <code>roles/</code> directory structure, including both the <code>common</code> and <code>approle</code> roles, is created in a similar manner to the preceding example:</p>
<pre class="source-code">
---
- hosts: frontends
  tasks:
  - ansible.builtin.import_role:
      name: common
  - ansible.builtin.include_role:
      name: approle</pre> <p>These<a id="_idIndexMarker277"/> features were not available in versions of Ansible earlier than 2.3, and their usage changed slightly in version 2.4 for consistency with the way that some other Ansible features work. We will not worry about the details of this here, as the core is now on release 2.15, so unless you absolutely have to run a much earlier version of Ansible, it is sufficient to assume that these two statements work, as we shall outline in the following.</p>
<p>Fundamentally, the <code>ansible.builtin.import_role</code> statement performs a static import of the role you specify at the time when all playbook code is parsed. Hence, roles brought into your playbook using the <code>ansible.builtin.import_role</code> statement are treated just like any other code in a play or role when Ansible begins parsing. Using <code>ansible.builtin.import_role</code> is basically the same as declaring your roles after the <code>roles:</code> statement in <code>site.yml</code>, just as <a id="_idTextAnchor227"/>we did in the preceding example.</p>
<p><code>ansible.builtin.include_role</code> is subtly but fundamentally different in that the role you specify is not evaluated when the playbook is parsed initially – rather, it is processed dynamically during the playbook run, at the point at which <code>ansible.builtin.include_role</code> is encountered.</p>
<p>Probably the most fundamental reason to choose between the <code>include</code> or <code>import</code> statements given in the preceding is looping – if you need to run a role within a loop, you cannot do so with <code>import_role</code>, so you must use <code>include_role</code>. There are, however, both benefits and limitations to both, and you will need to choose the most appropriate one for your scenario – the<a id="_idTextAnchor228"/> official Ansible documentation (<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static</a>) will help you to make the right decision.</p>
<p>As we have seen in this section, roles are incredibly simple to get started with and yet offer an incredibly <a id="_idIndexMarker278"/>powerful way in which to organize and reuse your Ansible code. In the next section, we will expand upon our simple task-based example by looking at adding role-specific variab<a id="_idTextAnchor229"/>l<a id="_idTextAnchor230"/>es and dependencies to your code.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor231"/>Setting up role-based variables and dependencies</h2>
<p>Variables are at<a id="_idIndexMarker279"/> the heart of making Ansible playbooks and roles reusable, as they allow the same code to be repurposed with slightly <a id="_idIndexMarker280"/>different values or configuration data. The Ansible role directory structure allows for role-specific variables to be declared in two locations. Although, at first, the difference between these two locations may not seem obvious, it is of fundamental importance.</p>
<p>Role-based variables can go in one of two locations:</p>
<ul>
<li><code>defaults/main.yml</code></li>
<li><code>vars/main.yml</code></li>
</ul>
<p>The difference between these two locations is their position in Ansi<a id="_idTextAnchor232"/>ble’s variable order of precedence (<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable">https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable</a>). Variables that go in the <code>defaults/</code> directory are one of the lowest in terms of precedence so are easily overridden. This location is where you would put variables that you want to override easily, but where you don’t want to leave a variable undefined. For example, if you install Apache Tomcat, you might build a role to install a specific version. However, you don’t want the role to exit with an error if someone forgets to set the version – rather, you would prefer to set a sensible default, such as <code>9.0</code>, that can then be overridden with inventory variables or on the command line (using the <code>-e</code> or <code>--extra-vars</code> switches). In this way, you know the role will work even without someone explicitly setting this variable, but it can easily be changed to a newer Tomcat version if desired.</p>
<p>Variables that go in the <code>vars/</code> directory, however, come much higher up on Ansible’s variable precedence ordering. These will not be overridden by inventory variables, and so it should be used for variable data that it is more important to keep static. Of course, this is not to say they can’t be overridden – the <code>-e</code> or <code>--extra-vars</code> switches are the highest order of precedence in Ansible so will override anything else that you define.</p>
<p>Most of the time, you will probably make use of the <code>defaults/</code> based variables alone, but there will doubtless be times when having the option of variables higher up the precedence ordering becomes valuable to your automation, and so it is vital to know that this option is available to you.</p>
<p>In addition <a id="_idIndexMarker281"/>to the role-based variables described previously, there is also the option to add metadata to a role using the <code>meta/</code> directory. As before, to make use of this, simply add a file called <code>main.yml</code> into this directory. To explain how you might make use of the <code>meta/</code> directory, let’s build and run a practical example that will show how it can be used. Before we get started though, it is important to note that, by default, the Ansible parser will only allow you to run a role once.</p>
<p>This is somewhat <a id="_idIndexMarker282"/>similar to the way in which we discussed handlers earlier, which can be called multiple times but ultimately are only run once at the end of the play. Roles are the same in that they can be referred to multiple times but will only actually get run once. There are two exceptions to this – the first is if the role is called more than once but with different variables or parameters, and the other is if the role being called has <code>allow_duplicates</code> set to <code>true</code> in its <code>meta/</code> directory. We shall see examples of both as we build our example:</p>
<ol>
<li>At the top level of our practical example, we will have a copy of the same inventory we have used throughout this chapter. We will also create a simple playbook called <code>site.yml</code>, which contains the following code:<pre class="source-code">
---
- name: Role variables and meta playbook
  hosts: web01.example.org
  roles:
    - platform</pre></li> </ol>
<p>Note that we are simply calling one role called <code>platform</code> from this playbook – nothing else is called from the playbook itself.</p>
<ol>
<li value="2">Let’s go ahead and create the <code>platform</code> role – unlike our previous role, this will not contain any tasks or even any variable data; instead, it will just contain a <code>meta</code> directory:<pre class="source-code">
<strong class="bold">$ mkdir -p roles/platform/meta</strong></pre></li> </ol>
<p>Inside this directory, create a file called <code>main.yml</code> with the following contents:</p>
<pre class="source-code">
---
dependencies:
- role: linuxtype
  type: "fedora"
- role: linuxtype
  type: "ubuntu"</pre> <p>This<a id="_idIndexMarker283"/> code <a id="_idIndexMarker284"/>will tell Ansible that the platform role is dependent on the <code>linuxtype</code> role. Note that we specify the dependency twice, but each time we specify it, we pass it a variable called <code>type</code> with a different value – in this way, the Ansible parser allows us to call the role twice because a different variable value has been passed to it each time it is referred to as a dependency.</p>
<ol>
<li value="3">Let’s now go ahead and create the <code>linuxtype</code> role – again, this will contain no tasks but more dependency declarations:<pre class="source-code">
<strong class="bold">$ mkdir -p roles/linuxtype/meta/</strong></pre></li> </ol>
<p>Again, create a <code>main.yml</code> file in the <code>meta</code> directory but this time containing the following:</p>
<pre class="source-code">
---
dependencies:
- role: version
- role: network</pre> <p>Once again, we create more dependencies – this time, when the <code>linuxtype</code> role is called, it, in turn, declares dependencies on roles called <code>version</code> and <code>network</code>.</p>
<ol>
<li value="4">Let’s create the <code>version</code> role first – this will have both <code>meta</code> and <code>tasks</code> directories in it:<pre class="source-code">
<strong class="bold">$ mkdir -p roles/version/meta</strong>
<strong class="bold">$ mkdir -p roles/version/tasks</strong></pre></li> </ol>
<p>In the <code>meta</code> directory, we’ll create a <code>main.yml</code> file with the following contents:</p>
<pre class="source-code">
---
allow_duplicates: true</pre> <p>This <a id="_idIndexMarker285"/>declaration is important in this example – as discussed earlier, normally, Ansible will only allow a role to be executed <a id="_idIndexMarker286"/>once, even if it is called multiple times. Setting <code>allow_duplicates</code> to <code>true</code> tells Ansible to allow the execution of the role more than once. This is required because, in the <code>platform</code> role, we call (via a dependency) the <code>linuxtype</code> role twice, which means, in turn, we will call the <code>version</code> role twice.</p>
<p>We’ll also create a simple <code>main.yml</code> file in the <code>tasks/</code> directory, which prints the value of the <code>type</code> variable that gets passed to the role:</p>
<pre class="source-code">
---
- name: Print type variable
  ansible.builtin.debug:
    var: type</pre> <ol>
<li value="5">We will now repeat the process with the <code>network</code> role – to keep our example code simple, we’ll define it with the same contents as the <code>version</code> role:<pre class="source-code">
<strong class="bold">$ mkdir -p roles/network/meta</strong>
<strong class="bold">$ mkdir -p roles/network/tasks</strong></pre></li> </ol>
<p>In the <code>meta</code> directory, we’ll again create a <code>main.yml</code> file with the following contents:</p>
<pre class="source-code">
---
allow_duplicates: true</pre> <p>Again, we’ll create a simple <code>main.yml</code> file in the <code>tasks</code> directory, which prints <a id="_idIndexMarker287"/>the value of the <code>type</code> variable<a id="_idIndexMarker288"/> that gets passed to the role:</p>
<pre class="source-code">
---
- name: Print type variable
  ansible.builtin.debug:
    var: type</pre> <p>At the end of this process, your directory structure should look like this:</p>
<pre class="source-code">
.
├── hosts
├── roles
│   ├── linuxtype
│   │   └── meta
│   │       └── main.yml
│   ├── network
│   │   ├── meta
│   │   │   └── main.yml
│   │   └── tasks
│   │       └── main.yml
│   ├── platform
│   │   └── meta
│   │       └── main.yml
│   └── version
│       ├── meta
│       │   └── main.yml
│       └── tasks
│           └── main.yml
└── site.yml
11 directories, 8 files</pre> <p>Let’s <a id="_idIndexMarker289"/>see what happens when we run this playbook. The <a id="_idIndexMarker290"/>flow should be as follows – our initial playbook statically imports the <code>platform</code> role. The <code>platform</code> role then states that it depends upon the <code>linuxtype</code> role, and the dependency is declared twice with a different value in a variable called <code>type</code> each time. The <code>linuxtype</code> role then states that it depends upon both the <code>network</code> and <code>version</code> roles, which are allowed to run more than once and print the value of <code>type</code>. Hence, we see the <code>network</code> and <code>version</code> roles called twice, printing <code>fedora</code> on the first call and <code>ubuntu</code> the second time (as this is how we originally specified the dependencies in the <code>platform</code> role). You can execut<a id="_idTextAnchor233"/><a id="_idTextAnchor234"/>e the playbook using the following command:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml</pre> <p>The output should look something like this from this playbook execution:</p>
<div><div><img alt="Figure 4.3 – An example of running a playbook using roles with dependencies" height="1190" src="img/B20846_04_003.jpg" width="1460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – An example of running a playbook using roles with dependencies</p>
<p>This is <a id="_idIndexMarker291"/>distinctly different from earlier versions <a id="_idIndexMarker292"/>of Ansible (for example, Ansible 2.7), where if you had run the same code, you would have seen only the <code>type</code> printed on the screen as <code>ubuntu</code>. This demonstrates an important point about looking at the code porting guidelines between releases of Ansible/<code>ansible-core</code> and understanding how the behavior may have changed. While, in most cases (excepting the fundamental change around collections), your automation code will work without changes from one version of Ansible to the next, this is not guaranteed, and a subtle change such as this could have catastrophic consequences in a production environment. Ansible code should be treated just as code, including testing new releases of Ansible when they are deployed.</p>
<p>This is quite an advanced example of Ansible role dependencies, but it has been provided to you to demonstrate the importance of knowing a little about variable precedence (that is, where the variable is scoped) and how the parser works. If you write <a id="_idIndexMarker293"/>simple, sequentially parsed tasks, then you <a id="_idIndexMarker294"/>may never need to know this, but I recommend that you make extensive use of the <code>debug</code> statement and test your playbook design to make sure that you don’t fall foul of this during your playbook development.</p>
<p>Now that we have looked in great detail at a number of role aspects, let’s take a look in the following section at a centralized store for p<a id="_idTextAnchor235"/>u<a id="_idTextAnchor236"/>blicly available Ansible roles – <strong class="bold">Ansible Galaxy</strong>.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor237"/>Ansible Galaxy</h2>
<p>No section on <a id="_idIndexMarker295"/>Ansible roles would be complete without a mention of Ansible Galaxy. Ansible Galaxy is a community-driven collection of Ansible roles and collections, hosted <a id="_idIndexMarker296"/>by Red Hat at <a href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a>. It contains a great many community-contributed Ansible roles and collections, and if you can conceive of an automation task, there is a good chance someone has already written code to do exactly what you want. It is well worth exploring and can get your automation project off the ground quickly, as you can start to work with a set of ready-made roles.</p>
<p>In addition to the website, the <code>ansible-galaxy</code> client is included in Ansible, and this provides a quick and convenient way for you to download and deploy roles into your playbook structure. Let’s say that you want to update the <code>arillso.motd</code>), we can download it into<a id="_idTextAnchor238"/> our roles directory using the following command:</p>
<pre class="console">
$ ansible-galaxy role install -p roles/ arillso.motd</pre> <p>That’s all you need to do – once the download is complete, you can import or include the role in your playbook, just as you would for the manually created roles we have discussed in this chapter. Note that if you don’t specify <code>-p roles/</code>, <code>ansible-galaxy</code> will install the roles into <code>~/.ansible/roles</code>, the central roles directory for your user account. This might be what you want, of course, but if you want the role downloaded directly into your playbook directory structure, you would add this parameter.</p>
<p>Another <a id="_idIndexMarker298"/>neat trick is to use <code>ansible-galaxy</code> to create an empty role directory structure for you to create your own roles in – this saves all of the manual directory and file creation we undertook in this chapter, as shown in this example:</p>
<pre class="console">
$ ansible-galaxy role init --init-path roles/ testrole
- Role testrole was created successfully
$ tree roles/testrole/
roles/testrole/
├── README.md
├── defaults
│   └── main.yml
├── files
├── handlers
│   └── main.yml
├── meta
│   └── main.yml
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml
8 directories, 8 files</pre> <p>That should <a id="_idIndexMarker299"/>give you enough information to get started on your journey into Ansible roles. I cannot stress highly enough how important it is to develop your code as roles – it might not seem important initially, but as your automation use cases expand, and your requirement to reuse code grows, you will be glad that you did. In the next section, let’s expand our look at Ansible playbooks with a discussion of the ways in whi<a id="_idTextAnchor239"/>c<a id="_idTextAnchor240"/>h conditional logic can be used in your Ansible code.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor241"/>Using conditions in your code</h1>
<p>In most<a id="_idIndexMarker300"/> of our examples so far, we have created simple sets of tasks that always run. However, as you generate tasks (whether in roles or playbooks) that you want to apply to a wider array of hosts, sooner or later, you will want to perform some kind of conditional action. This might be to only perform a task in response to the results of a previous task, or it might be to only perform a task in response to a specific fact gathered from a managed node. In this section, we will provide some practical examples of conditional logic to apply to your Ansible tasks to demonstrate how to use this feature.</p>
<p>As ever, we’ll need an inventory to get started, and we’ll reuse the inventory we have used throughout this chapter:</p>
<pre class="source-code">
[frontends]
web01.example.org https_port=8443
web02.example.org http_proxy=proxy.example.org
[frontends:vars]
ntp_server=ntp.web.example.org
proxy=proxy.web.example.org
[apps]
app01.example.org
app02.example.org
[webapp:children]
frontends
apps
[webapp:vars]
proxy_server=proxy.webapp.example.org
health_check_retry=3
health_check_interval=60</pre> <p>Suppose <a id="_idIndexMarker301"/>that you want to perform an Ansible task only on certain operating systems. We have already discussed Ansible facts, and these provide the perfect platform to start exploring conditional logic in your playbooks. Consider this – an urgent patch has been released for all of your Fedora systems, and you want to apply it immediately. You could, of course, go through and create a special inventory (or host group) for Fedora hosts, but this is additional work that you don’t necessarily need to do.</p>
<p>Instead, let’s define the task that will perform our update, adding a <code>when</code> clause containing a Jinja2 expression to it, so that the update is only performed on Fedora-based hosts:</p>
<pre class="source-code">
---
- name: Play to patch only Fedora systems
  hosts: all
  become: true
  tasks:
  - name: Patch Fedora systems
    ansible.builtin.dnf:
      name: httpd
      state: latest
    when: ansible_facts['distribution'] == "Fedora"</pre> <p>Now, when<a id="_idIndexMarker302"/> we run this task, if your test system(s) are Fedora-based (and one of mine is), you should see output similar to the following:</p>
<pre class="console">
$ ansible-playbook -i hosts condition.yml
PLAY [Play to patch only Fedora systems] ***************************************
TASK [Gathering Facts] *********************************************************
ok: [web01.example.org]
ok: [app01.example.org]
ok: [web02.example.org]
ok: [app02.example.org]
TASK [Patch Fedora systems] ****************************************************
skipping: [web02.example.org]
skipping: [app01.example.org]
skipping: [app02.example.org]
ok: [web01.example.org]
PLAY RECAP *********************************************************************
app01.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0
app02.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0
web01.example.org          : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
web02.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0</pre> <p>The<a id="_idIndexMarker303"/> preceding output shows that only one of our systems was Fedora-based, and it returned an <code>ok</code> status, meaning the patch had already been applied. Now, we can make our logic more precise – perhaps it is only our legacy systems that run on Fedora 35 that need the patch applied. In this case, we can expand the logic in our playbook to check both the distribution and major versions, as follows:</p>
<pre class="source-code">
---
- name: Play to patch only Fedora systems
  hosts: all
  become: true
  tasks:
  - name: Patch Fedora systems
    yum:
      name: httpd
      state: latest
    when: (ansible_facts['distribution'] == "Fedora" and ansible_facts['distribution_major_version'] == "35")</pre> <p>Now, if we <a id="_idIndexMarker304"/>run our modified playbook, depending on the systems you have in your inventory, you might see output similar to the following. In this case, all systems were skipped because they did not match my logical expression (and, hence, I am safe in the knowledge that I have no legacy systems in this inventory to worry about):</p>
<pre class="console">
$ ansible-playbook -i hosts condition2.yml
PLAY [Play to patch only Fedora systems] ***************************************
TASK [Gathering Facts] *********************************************************
ok: [app01.example.org]
ok: [web01.example.org]
ok: [app02.example.org]
ok: [web02.example.org]
TASK [Patch Fedora systems] ****************************************************
skipping: [web01.example.org]
skipping: [web02.example.org]
skipping: [app01.example.org]
skipping: [app02.example.org]
PLAY RECAP *********************************************************************
app01.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0
app02.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0
web01.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0
web02.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0</pre> <p>Of course, this<a id="_idIndexMarker305"/> conditional logic is not limited to Ansible facts and can be incredibly valuable when using the <code>ansible.builtin.shell</code> or <code>ansible.builtin.command</code> modules. When you run <em class="italic">any</em> Ansible module, the module returns data detailing the results of its run. You can capture this in an Ansible variable using the <code>register</code> keyword and then process it further later on in the playbook.</p>
<p>Consider the following playbook code. It contains two tasks, the first of which is to obtain the listing of the current directory and capture the output of the <code>ansible.builtin.shell</code> module in a variable called <code>shellresult</code>. We then print a simple <code>ansible.builtin.debug</code> message, but only on the condition that the <code>hosts</code> string is in the output of the <code>ansible.builtin.shell</code> module run:</p>
<pre class="source-code">
---
- name: Play to test for hosts file in directory output
  hosts: localhost
  tasks:
    - name: Gather directory listing from local system
      ansible.builtin.shell: "ls -l"
      register: shellresult
    - name: Alert if we find a hosts file
      ansible.builtin.debug:
        msg: "Found hosts file!"
      when: '"hosts" in shellresult.stdout'</pre> <p>Now, when<a id="_idIndexMarker306"/> we run this in the current directory, which if you work from the GitHub repository that accompanies this book will contain a file named <code>hosts</code>, then you should see output similar to the following:</p>
<pre class="console">
$ ansible-playbook condition3.yml
PLAY [Play to test for hosts file in directory output] *************************
TASK [Gathering Facts] *********************************************************
ok: [localhost]
TASK [Gather directory listing from local system] ******************************
changed: [localhost]
TASK [Alert if we find a hosts file] *******************************************
ok: [localhost] =&gt; {
    "msg": "Found hosts file!"
}
PLAY RECAP *********************************************************************
localhost                  : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>Yet, if the<a id="_idIndexMarker307"/> file doesn’t exist, you’ll see that the <code>ansible.builtin.debug</code> message gets skipped:</p>
<pre class="console">
$ ansible-playbook condition3.yml
PLAY [Play to test for hosts file in directory output] *************************
TASK [Gathering Facts] *********************************************************
ok: [localhost]
TASK [Gather directory listing from local system] ******************************
changed: [localhost]
TASK [Alert if we find a hosts file] *******************************************
skipping: [localhost]
PLAY RECAP *********************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0</pre> <p>You can<a id="_idIndexMarker308"/> also create complex conditions for IT operational tasks in production; however, remember that in Ansible, variables are not cast to any particular type by default, so even though the contents of a variable (or fact) might look like a number, Ansible will treat it as a string by default. If you need to perform an integer comparison instead, you must first cast the variable to an integer type. For example, here is a fragment of a playbook that will run a task only on Fedora 35 and newer:</p>
<pre class="source-code">
tasks:
  - name: Only perform this task on Fedora 35 and later
    ansible.builtin.shell: echo "only on Fedora 35 and later"
    when: ansible_facts['distribution'] == "Fedora" and ansible_facts['distribution_major_version']|int &gt;= 35</pre> <p>There are many different types of conditionals you can apply to your Ansible tasks, and this section just scratches the surface; however, it should give you a sound basis on which to expand your knowledge of applying conditions to your tasks in Ansible. Not only can you apply conditional logic to Ansible tasks but you can also run them in loops over <a id="_idTextAnchor242"/>a<a id="_idTextAnchor243"/> set of data, which we shall explore in the following section.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor244"/>Repeating tasks with loops</h1>
<p>Oftentimes, we <a id="_idIndexMarker309"/>will want to perform a single task but use it to <a id="_idIndexMarker310"/>iterate over a set of data. Perhaps you are creating new 15 new user groups on a server for various teams to utilize. It would be incredibly inefficient to have to write 15 individual tasks within an Ansible play to achieve this – and Ansible is all about efficiency and saving the user time. To enable this level of efficiency, Ansible supports looping over datasets to ensure that you can perform large-scale operations using tightly defined code. In this section, we will explore how to make practical use of loops in your Ansible playbooks.</p>
<p>As ever, we must start with an inventory to work against, and we will use our by-now familiar inventory, which <a id="_idIndexMarker311"/>we have consistently used throughout<a id="_idIndexMarker312"/> this chapter:</p>
<pre class="source-code">
[frontends]
web01.example.org https_port=8443
web02.example.org http_proxy=proxy.example.org
[frontends:vars]
ntp_server=ntp.web.example.org
proxy=proxy.web.example.org
[apps]
app01.example.org
app02.example.org
[webapp:children]
frontends
apps
[webapp:vars]
proxy_server=proxy.webapp.example.org
health_check_retry=3
health_check_interval=60</pre> <p>Let’s start with a really simple playbook to show you how to loop over a set of data in a single task. Although this is quite a contrived example, it is intended to be simple to show you the fundamentals of how<a id="_idTextAnchor245"/> loops work in Ansible. We will define a single task that runs the <code>ansible.builtin.command</code> module on a single host from the inventory and uses the <code>ansible.builtin.command</code> module to <code>echo</code> the numbers 1 through 6 in turn on the remote system (with some imagination, this could easily be extended <a id="_idIndexMarker313"/>to<a id="_idIndexMarker314"/> adding user accounts or creating a sequence of files).</p>
<p>Consider the following code:</p>
<pre class="source-code">
---
- name: Simple loop demo play
  hosts: web01.example.org
  tasks:
    - name: Echo a value from the loop
      ansible.builtin.command: echo "{{ item }}"
      loop:
        - 1
        - 2
        - 3
        - 4
        - 5
        - 6</pre> <p>The <code>loop:</code> statement defines the start of the loop, and the items in the loop are defined as a YAML list. Also, note the higher indentation level, which tells the parser they are part of the loop. When working with the loop data, we use a special variable called <code>item</code>, which contains the current value from the loop iteration to be echoed. When we run this playbook, we should see output similar to the following:</p>
<pre class="console">
$ ansible-playbook -i hosts loop1.yml
PLAY [Simple loop demo play] ***************************************************
TASK [Gathering Facts] *********************************************************
ok: [web01.example.org]
TASK [Echo a value from the loop] **********************************************
changed: [web01.example.org] =&gt; (item=1)
changed: [web01.example.org] =&gt; (item=2)
changed: [web01.example.org] =&gt; (item=3)
changed: [web01.example.org] =&gt; (item=4)
changed: [web01.example.org] =&gt; (item=5)
changed: [web01.example.org] =&gt; (item=6)
PLAY RECAP *********************************************************************
web01.example.org          : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>You can<a id="_idIndexMarker315"/> combine the conditional logic we discussed in the preceding <a id="_idIndexMarker316"/>section with loops, to make the loop operate on just a subset of its data. For example, consider the following iteration of the playbook:</p>
<pre class="source-code">
---
- name: Simple loop demo play
  hosts: web01.example.org
  tasks:
    - name: Echo a value from the loop
      ansible.builtin.command: echo "{{ item }}"
      loop:
        - 1
        - 2
        - 3
        - 4
        - 5
        - 6
      when: item|int &gt; 3</pre> <p>Now, when we<a id="_idIndexMarker317"/> run this, we can see that the task is skipped <a id="_idIndexMarker318"/>until we reach the integer value of <code>4</code> and higher in the loop contents:</p>
<pre class="console">
$ ansible-playbook -i hosts loop2.yml
PLAY [Simple loop demo play] ***************************************************
TASK [Gathering Facts] *********************************************************
ok: [web01.example.org]
TASK [Echo a value from the loop] **********************************************
skipping: [web01.example.org] =&gt; (item=1)
skipping: [web01.example.org] =&gt; (item=2)
skipping: [web01.example.org] =&gt; (item=3)
changed: [web01.example.org] =&gt; (item=4)
changed: [web01.example.org] =&gt; (item=5)
changed: [web01.example.org] =&gt; (item=6)
PLAY RECAP *********************************************************************
web01.example.org          : ok=2    changed=1    unreachable=0    failed=0    skipped=0     rescued=0    ignored=0</pre> <p>You can, of <a id="_idIndexMarker319"/>course, combine this with the conditional logic based <a id="_idIndexMarker320"/>on Ansible facts and other variables in the manner we discussed previously. Just as we captured the results of a module’s execution using the <code>register</code> keyword before, we can do so with loops. The only difference is that the results will now be stored in a dictionary, with one dictionary entry for each iteration of the loop rather than just one set of results.</p>
<p>Hence, let’s see what happens if we further enhance the playbook, as follows:</p>
<pre class="source-code">
---
- name: Simple loop demo play
  hosts: web01.example.org
  tasks:
    - name: Echo a value from the loop
      ansible.builtin.command: echo "{{ item }}"
      loop:
        - 1
        - 2
        - 3
        - 4
        - 5
        - 6
      when: item|int &gt; 3
      register: loopresult
    - name: Print the results from the loop
      ansible.builtin.debug:
        var: loopresult</pre> <p>Now, when <a id="_idIndexMarker321"/>we run the playbook, you will see pages of output <a id="_idIndexMarker322"/>containing the dictionary with the contents of <code>loopresult</code>. The following output is truncated in the interests of space but demonstrates the kind of results you should expect from running this playbook:</p>
<pre class="console">
$ ansible-playbook -i hosts loop3.yml
PLAY [Simple loop demo play] ***************************************************
TASK [Gathering Facts] *********************************************************
ok: [web01.example.org]
TASK [Echo a value from the loop] **********************************************
skipping: [web01.example.org] =&gt; (item=1)
skipping: [web01.example.org] =&gt; (item=2)
skipping: [web01.example.org] =&gt; (item=3)
changed: [web01.example.org] =&gt; (item=4)
changed: [web01.example.org] =&gt; (item=5)
changed: [web01.example.org] =&gt; (item=6)
TASK [Print the results from the loop] *****************************************
ok: [web01.example.org] =&gt; {
    "loopresult": {
        "changed": true,
        "msg": "All items completed",
        "results": [
            {
                "ansible_loop_var": "item",
                "changed": false,
                "item": 1,
                "skip_reason": "Conditional result was False",
                "skipped": true
            },
            {
                "ansible_loop_var": "item",
                "changed": false,
                "item": 2,
                "skip_reason": "Conditional result was False",
                "skipped": true
            },</pre> <p>As you can see, the <code>results</code> section of the output is a dictionary, and we can clearly see that the first two items in the list were <code>skipped</code> because the result of our <code>when</code> clause (conditional) was <code>false</code>.</p>
<p>Hence, we<a id="_idIndexMarker323"/> can see so far that loops are easy to define and work with – but you may be asking, <em class="italic">can you create nested loops?</em> The answer to that question is <em class="italic">yes</em>, but there is a catch – the special variable named <code>item</code> would clash, as both the inner and outer loops would use the same variable name. This would mean the results from your nested loop run would be, at best, unexpected.</p>
<p>Fortunately, there<a id="_idIndexMarker324"/> is a <code>loop</code> parameter called <code>loop_control</code>, which allows you to change the name of the special variable containing the data from the current <code>loop</code> iteration from <code>item</code> to something of your choosing. Let’s create a nested loop to see how this works.</p>
<p>First of all, we’ll create a playbook in the usual manner, with a single task to run in a loop. To generate our nested loop, we’ll use the <code>include_tasks</code> directive to dynamically include a single task from another YAML file, which will also contain a loop. As we intend to use this playbook in a nested loop, we’ll use the <code>loop_var</code> directive to change the name of the special loop contents variable from <code>item</code> to <code>second_item</code>:</p>
<pre class="source-code">
---
- name: Play to demonstrate nested loops
  hosts: localhost
  tasks:
    - name: Outer loop
      ansible.builtin.include_tasks: loopsubtask.yml
      loop:
        - a
        - b
        - c
      loop_control:
        loop_var: second_item</pre> <p>Then, we’ll create a second file called <code>loopsubtask.yml</code>, which contains the inner loop and is included in the preceding playbook. As we already changed the loop item variable <a id="_idIndexMarker325"/>name in the outer loop, we don’t need to change it again here. Note that the structure of this file is very much like a tasks file in a role – it is not a complete playbook but, rather, simply a list of tasks:</p>
<pre class="source-code">
---
- name: Inner loop
  ansible.builtin.debug:
    msg: "second item={{ second_item }} first item={{ item }}"
  loop:
    - 100
    - 200
    - 300</pre> <p>Now you<a id="_idIndexMarker326"/> should be able to run the playbook, and you will see Ansible iterate over the outer loop first and then process the inner loop over the data d<a id="_idTextAnchor246"/><a id="_idTextAnchor247"/>efined by the outer loop. Test this playbook by running the following command:</p>
<pre class="console">
$ ansible-playbook loopmain.yml</pre> <p>As the loop variable names do not clash, everything works exactly as we would expect:</p>
<div><div><img alt="Figure 4.4 – Demonstrating nested loops in an Ansible playbook" height="1516" src="img/B20846_04_004.jpg" width="1140"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Demonstrating nested loops in an Ansible playbook</p>
<p>Loops<a id="_idIndexMarker327"/> are simple to work with and yet very powerful, as they allow you to easily use one task to iterate <a id="_idIndexMarker328"/>over a large dataset. In the next section, we’ll loo<a id="_idTextAnchor248"/><a id="_idTextAnchor249"/>k at another construct of the Ansible language to control playbook flow – blocks.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor250"/>Grouping tasks using blocks</h1>
<p>Blocks in<a id="_idIndexMarker329"/> Ansible<a id="_idIndexMarker330"/> allow you to logically group a set of tasks together, primarily for one of two purposes. One might be to apply conditional logic to an entire set of tasks; in this example, you could apply an identical <code>when</code> clause <a id="_idIndexMarker331"/>to each of the tasks, but this is cumbersome and inefficient – it’s far better to place all of the tasks in a block and apply the conditional logic to the block itself. In this way, the logic only needs to be declared once. Blocks are also valuable when it comes to error handling and especially when it comes to recovering from an error condition. We shall explore both of these through simple practical examples in this chapter to get you up to speed with blocks in Ansible.</p>
<p>As ever, let’s ensure we have an inventory to work from:</p>
<pre class="source-code">
[frontends]
web01.example.org https_port=8443
web02.example.org http_proxy=proxy.example.org
[frontends:vars]
ntp_server=ntp.web.example.org
proxy=proxy.web.example.org
[apps]
app01.example.org
app02.example.org
[webapp:children]
frontends
apps
[webapp:vars]
proxy_server=proxy.webapp.example.org
health_check_retry=3
health_check_interval=60</pre> <p>Now, let’s <a id="_idIndexMarker332"/>dive straight in and look at an example of how you would use blocks to apply conditional logic to a set of tasks. At a high level, suppose<a id="_idIndexMarker333"/> we want to perform the following actions on all of our Fedora Linux hosts:</p>
<ul>
<li>Install the package for the Apache web server</li>
<li>Install a templated configuration</li>
<li>Start the appropriate service</li>
</ul>
<p>We could achieve this with three individual tasks, all with a <code>when</code> clause associated with them, but blocks provide us with a better way. The following example playbook shows the three tasks discussed contained in a block (note the additional level of indentation required to denote their inclusion in the block):</p>
<pre class="source-code">
---
- name: Conditional block play
  hosts: all
  become: true
  tasks:
  - name: Install and configure Apache
    block:
      - name: Install the Apache package
        ansible.builtin.dnf:
          name: httpd
          state: installed
      - name: Install the templated configuration to a dummy location
        ansible.builtin.template:
          src: templates/src.j2
          dest: /tmp/my.conf
      - name: Start the httpd service
        ansible.builtin.service:
          name: httpd
          state: started
          enabled: True
    when: ans<a id="_idTextAnchor251"/><a id="_idTextAnchor252"/>ible_facts['distribution'] == 'Fedora'</pre> <p>Run <a id="_idIndexMarker334"/>your playbook with the following command:</p>
<pre class="console">
$ ansible-playbook -i hosts blocks.yml</pre> <p>You should<a id="_idIndexMarker335"/> find that the Apache-related tasks are only run on any Fedora hosts you might have in your inventory; you should see that either all three tasks are run or are skipped – depending on the makeup and contents of your inventory, it might look something like this:</p>
<div><div><img alt="Figure 4.5 – A playbook demonstrating the use of blocks in conditional task execution" height="1392" src="img/B20846_04_005.jpg" width="1386"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – A playbook demonstrating the use of blocks in conditional task execution</p>
<p>This is<a id="_idIndexMarker336"/> very simple-to-construct but very powerful in terms of the effect it has on your ability to control the flow over large sets of tasks.</p>
<p>This time, let’s <a id="_idIndexMarker337"/>build a different example to demonstrate how blocks can help Ansible to handle error conditions gracefully. So far, you should have seen that if your playbooks encounter any errors, they are likely to stop executing at the point of failure. This is, in some situations, far from ideal, and you might want to perform some kind of recovery action in this event rather than simply halting the playbook.</p>
<p>Let’s create a new <a id="_idIndexMarker338"/>playbook, this time with the following <a id="_idIndexMarker339"/>contents:</p>
<pre class="source-code">
---
- name: Play to demonstrate block error handling
  hosts: frontends
  tasks:
    - name: block to handle errors
      block:
        - name: Perform a successful task
          ansible.builtin.debug:
            msg: 'Normally executing....'
        - name: Deliberately create an error
          ansible.builtin.command: /bin/whatever
        - name: This task should not run if the previous one results in an error
          ansible.builtin.debug:
            msg: 'Never print this message if the above command fails!!!!'
      rescue:
        - name: Catch the error (and perform recovery actions)
          ansible.builtin.debug:
            msg: 'Caught the error'
        - name: Deliberately create another error
          ansible.builtin.command: /bin/whatever
        - name: This task should not run if the previous one results in an error
          ansible.builtin.debug:
            msg: 'Do not print this message if the above command fails!!!!'
      always:
        - name: This task always runs!
          ansible.builtin.debug:
            msg: "Tasks in this part of the play will be ALWAYS executed!!!!"</pre> <p>Note <a id="_idIndexMarker340"/>that in <a id="_idIndexMarker341"/>the preceding play, we now have additional sections to <code>block</code> – as well as the tasks in <code>block</code> itself, we have two new parts labeled <code>rescue</code> and <code>always</code>. The flow of execution is as follows:</p>
<ol>
<li>All tasks in the <code>block</code> section are executed normally, in the sequence in which they are listed.</li>
<li>If a task in the <code>block</code> results in an error, no further tasks in the <code>block</code> are run:<ul><li>Tasks in the <code>rescue</code> section start to run in the order they are listed</li><li>Tasks in the <code>rescue</code> section do not run if no errors result from the <code>block</code> tasks</li></ul></li>
<li>If an error results from a task being run in the <code>rescue</code> section, no further <code>rescue</code> tasks are executed, and execution moves on to the <code>always</code> section.</li>
<li>Tasks in the <code>always</code> section are always run, regardless of any errors in either the <code>block</code> or <code>rescue</code> sections. They even ru<a id="_idTextAnchor253"/><a id="_idTextAnchor254"/>n when no errors are encountered.</li>
</ol>
<p>Test your playbook code by running the following command:</p>
<pre class="console">
$ ansible-playbook -i hosts blocks-error.yml</pre> <p>With this <a id="_idIndexMarker342"/>flow of execution in mind, you should see output similar to the following when you execute<a id="_idIndexMarker343"/> this playbook, noting that we have deliberately created two error conditions to demonstrate the flow:</p>
<div><div><img alt="Figure 4.6 – Demonstrating the use of blocks in error handling in playbooks" height="1526" src="img/B20846_04_006.jpg" width="1140"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Demonstrating the use of blocks in error handling in playbooks</p>
<p>Ansible has <a id="_idIndexMarker344"/>two special variables, which contain information <a id="_idIndexMarker345"/>you might find useful in the <code>rescue</code> block to perform your recovery actions:</p>
<ul>
<li><code>ansible_failed_task</code>: This is a dictionary containing details of the task from <code>block</code> that failed, causing us to enter the <code>rescue</code> section. You can explore this by displaying its contents using <code>ansible.builtin.debug</code>, so, for example, the name of the failing task can be obtained from <code>ansible_failed_task.name</code>.</li>
<li><code>ansible_failed_result</code>: This is the result of the failed task and behaves the same as if you had added the <code>register</code> keyword to the failing task. This saves you from having to add <code>register</code> to every single task in the block if it fails.</li>
</ul>
<p>As your playbooks get more complex and error handling gets more and more important (or, indeed, conditional logic becomes more vital), blocks will become an important part of your arsenal to write robust playbooks. Let’s proceed i<a id="_idTextAnchor255"/>n<a id="_idTextAnchor256"/> the next section to explore execution strategies to gain further control of your playbook runs.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor257"/>Configuring play execution via strategies</h1>
<p>As your <a id="_idIndexMarker346"/>playbooks become increasingly complex, it becomes more and more important that you have robust ways to debug any issues that might arise. For example, is there a way you can check the contents of a given variable (or variables) during execution without the need to insert <code>ansible.builtin.debug</code> statements throughout your playbook? Similarly, we have so far seen that Ansible will ensure that a particular task runs to completion on all inventory hosts that it applies to before moving on to the next task – is there a way to vary this?</p>
<p>When you get started with Ansible, the execution strategy that you see by default (and we have seen this so far in every playbook we have executed, even though we have not mentioned it by name) is known as <code>linear</code>. This does exactly what it describes – each task is executed in turn on all applicable hosts before the next task is started. However, there is another less commonly used strategy called <code>free</code>, which allows all tasks to be completed as fast as they can on each host, without waiting for other hosts.</p>
<p>The most <a id="_idIndexMarker347"/>useful strategy when you start to work with Ansible, however, is going to be the <code>debug</code> strategy, and this enables Ansible to drop you straight into its integrated debug environment if an error should occur in the playbook. Let’s demonstrate this by creating a playbook that has a deliberate error in it. Note the <code>strategy: debug</code> and <code>debugger: on_failed</code> statements in the play definition:</p>
<pre class="source-code">
---
- name: Play to demonstrate the debug strategy
  hosts: web01.example.org
  strategy: debug
  debugger: on_failed
  gather_facts: no
  vars:
    name: james
  tasks:
    - name: Generate an error by referencing an undefined variable
      ansible.builtin.ping: data={{ mobile }}</pre> <p>Now, if you execute this playbook, you should see that it starts to run, but then it drops you into the integrated debugger when it encounte<a id="_idTextAnchor258"/><a id="_idTextAnchor259"/>rs the deliberate error it contains. The start of the output should be similar to the following:</p>
<pre class="console">
$ ansible-playbook -i hosts debug.yml
[WARNING]: Found variable using reserved name: name
PLAY [Play to demonstrate the debug strategy] **********************************
TASK [Generate an error by referencing an undefined variable] ******************
fatal: [web01.example.org]: FAILED! =&gt; {"msg": "The task includes an option with an undefined variable. The error was: 'mobile' is undefined. 'mobile' is undefined\n\nThe error appears to be in '/home/james/Practical-Ansible-Second-Edition/Chapter 4/debug.yml': line 11, column 7, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n  tasks:\n    - name: Generate an error by referencing an undefined variable\n      ^ here\n"}
[web01.example.org] TASK: Generate an error by referencing an undefined variable (debug)&gt; p
***SyntaxError:SyntaxError('invalid syntax', ('&lt;string&gt;', 0, 0, '', 0, 0))
[web01.example.org] TASK: Generate an error by referencing an undefined variable (debug)&gt; p task_vars
{'ansible_check_mode': False,
 'ansible_config_file': None,
 'ansible_current_hosts': ['web01.example.org'],
 'ansible_dependent_role_names': [],
 'ansible_diff_mode': False,
 'ansible_facts': {},
 'ansible_failed_hosts': [],
 'ansible_forks': 5,
...
[web01.example.org] TASK: Generate an error by referencing an undefined variable (debug)&gt; quit
User interrupted execution
$</pre> <p>Note <a id="_idIndexMarker348"/>that the playbook starts executing but fails on the first task with an error, as the variable is undefined. However, rather than exiting back to the shell, it enters an interactive debugger. We’ve given a simple example of using the debugger in the preceding output, and if you’d like to learn how to use it more compreh<a id="_idTextAnchor260"/>ensively, the Ansible documentation has full details of the available commands and how to use them: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml">https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml</a>.</p>
<p>To take you through a very simple, practical debugging example, enter the <code>p task</code> command at the prompt – this will cause the Ansible debugger to print the name of the failing task, which is very useful if you are in the midst of a large playbook:</p>
<pre class="console">
[web01.example.org] TASK: Generate an error by referencing an undefined variable (debug)&gt; p task
TASK: Generate an error by referencing an undefined variable
[web01.example.org] TASK: Generate an error by referencing an undefined variable</pre> <p>Now, we know where the play failed, so let’s dig a little deeper by issuing the <code>p task.args</code> command, which will show us the arguments that were passed to the module in the task:</p>
<pre class="console">
(debug)&gt; p task.args
{'data': '{{ mobile }}'}
[web01.example.org] TASK: Generate an error by referencing an undefined variable</pre> <p>So, we can see that our module was passed the argument called <code>data</code>, with the argument value being a variable (denoted by the pairs of curly braces) called <code>mobile</code>. Hence, it might be logical to have a look at the variables available to the task to see whether this variable exists and, if so, whether the value is sensible (use the <code>p task_vars</code> command to do this):</p>
<pre class="console">
(debug)&gt; p task_vars
{'ansible_check_mode': False,
 'ansible_config_file': None,
 'ansible_current_hosts': ['web01.example.org'],
 'ansible_dependent_role_names': [],
 'ansible_diff_mode': False,
 'ansible_facts': {},
 'ansible_failed_hosts': [],
 'ansible_forks': 5,</pre> <p>The <a id="_idIndexMarker349"/>preceding output is truncated, and you will find a great many variables associated with the task – this is because any gathered facts, and internal Ansible variables, are all available to the task. However, if you scroll through the list, you will be able to confirm that there is no variable called <code>mobile</code>.</p>
<p>Hence, this should be enough information to fix your playbook. Enter <code>q</code> to quit the debugger:</p>
<pre class="console">
[web01.example.org] TASK: Generate an error by referencing an undefined variable (debug)&gt; q
User interrupted execution
$</pre> <p>The Ansible debugger is an incredibly powerful tool, and you should learn to make effective use of it, especially as your playbook complexity grows. This concludes our practical look at the various aspects of playbook design – in the next section, we’<a id="_idTextAnchor261"/>l<a id="_idTextAnchor262"/>l take a look at the ways in which you can integrate Git source code management into your playbooks.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor263"/>Using ansible-pull</h1>
<p>Of course, the<a id="_idIndexMarker350"/> ideal way to work with Ansible code is to store it in a version control repository. This is a valuable step that ensures all changes are tracked, and that everyone responsible for automation is working from the same code. However, it also presents an inefficiency – end users must remember to check out (or pull) the latest version of the code and then execute it, and while this isn’t difficult, manual tasks are both the enemy of efficiency and make it easy for errors to occur. Luckily, once again, Ansible supports us by providing tooling to ensure the most efficient approach can be achieved, and a special command called <code>ansible-pull</code> can be used to both retrieve the latest code from a Git repository and execute it, all using one command. This supports not only greater efficiency for end users (and reduces the chance of human error) but also enables automation jobs to be run unattended (for example, using a scheduler such as <code>cron</code>).</p>
<p>An important thing to note, however, is that, while the <code>ansible</code> and <code>ansible-playbook</code> commands can both operate over an entire inventory and run the playbooks against one or more remote hosts, the <code>ansible-pull</code> command is only intended to run the playbooks it obtains from your source control system on <code>localhost</code>. Hence, if you want to use <code>ansible-pull</code> throughout your infrastructure, you must install it onto every host that needs it.</p>
<p>Nonetheless, let’s see how this might work. We’ll simply run the command by hand to explore its application, but in reality, you would almost certainly install it in your <code>crontab</code> so that it runs on a regular basis, picking up any changes you make to your playbook in the version control system.</p>
<p>As stated, <code>ansible-pull</code> is only intended to run the playbook on the local system, so an inventory file is somewhat redundant – instead, we’ll use a little-used inventory specification whereby you can simply specify the inventory hosts directory as a comma-separated list on the command line. If you only have one host, you simply specify its name followed by a comma.</p>
<p>Let’s use a simple playbook from GitHub that sets the message of the day based on va<a id="_idTextAnchor264"/>riable content. To do this, we will run the following com<a id="_idTextAnchor265"/>mand (which we’ll break down in a minute):</p>
<pre class="console">
$ ansible-pull -d /tmp/ansible-set-motd -i ${HOSTNAME}, -U https://github.com/jamesfreeman959/ansible-set-motd.git site.yml -e "ag_motd_content='MOTD generated by ansible-pull'" &gt;&gt; /tmp/ansible-pull.log 2&gt;&amp;1</pre> <p>This command breaks down as follows:</p>
<ul>
<li><code>-d /tmp/ansible-set-motd</code>: This sets the working directory that will contain the checkout of the code from GitHub. Ensure this is writeable by the user account running the <code>ansible-pull</code> command.</li>
<li><code>-i ${HOSTNAME},</code>: This runs only on the current host, specified by its hostname from the appropriate shell variable.</li>
<li><code>-U </code><a href="https://github.com/jamesfreeman959/ansible-set-motd.git">https://github.com/jamesfreeman959/ansible-set-motd.git</a>: We use this URL to obtain the playbooks.</li>
<li><code>site.yml</code>: This is the name of the playbook to run from the Git repository specified earlier.</li>
<li><code>-e "ag_motd_content='MOTD generated by ansible-pull'"</code>: This sets the appropriate Ansible variable to generate the MOTD content.</li>
<li><code>&gt;&gt; /tmp/ansible-pull.log 2&gt;&amp;1</code>: This redirects the output of the command to a log file if we need to analyze it later – this is especially useful if running<a id="_idIndexMarker351"/> the command in a cron job where the<a id="_idTextAnchor266"/><a id="_idTextAnchor267"/> output would never be printed to the user’s terminal.</li>
</ul>
<p>You can test this with the following command:</p>
<pre class="console">
$ ansible-pull -d /tmp/ansible-set-motd -i ${HOSTNAME}, -U https://github.com/jamesfreeman959/ansible-set-motd.git site.yml -e "ag_motd_content='MOTD generated by ansible-pull'"</pre> <p>You should see some output similar to the following (note that log redirection has been removed to make it easier to see the output):</p>
<div><div><img alt="Figure 4.7 – Demonstrating the use of ansible-pull" height="1550" src="img/B20846_04_007.jpg" width="1140"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Demonstrating the use of ansible-pull</p>
<p>This command can be a very powerful part of your overall Ansible solution, especially as it means you don’t have to worry too much about running all of your playbooks centrally, or <a id="_idIndexMarker352"/>ensuring that they are all up to date every time you run them. The ability to schedule this in <code>cron</code> is especially powerful in a large infrastructure where, ideally, automation means things should take care of themselves.</p>
<p>This concludes our practical look at playbooks and how to author your own code – with a little <a id="_idTextAnchor268"/>r<a id="_idTextAnchor269"/>esearch into Ansible modules, you should now have enough to write your own robust playbooks with ease.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor270"/>Summary</h1>
<p>Playbooks are the lifeblood of Ansible automation, providing a robust framework within which to define logical collections of tasks and handle error conditions cleanly and robustly. The addition of roles into this mix is valuable in terms of not only organizing your code but also in terms of supporting code reuse as your automation requirements grow. Ansible playbooks provide a truly complete automation solution for your technology needs.</p>
<p>In this chapter, you learned about the playbook framework and how to start building your own playbooks. You then learned how to organize your code into roles and design your code to effectively and efficiently support reuse. We then explored some of the more advanced playbook writing topics, such as working with conditional logic, blocks, and loops. Finally, we looked at playbook execution strategies, especially with a view to being able to debug our playbooks effectively, and we wrapped up with a look at how we can run Ansible playbooks on a local machine directly from GitHub.</p>
<p>In the next chapter, we will learn how to consume and create our very own modules, providing you with the skills you need to ex<a id="_idTextAnchor271"/>p<a id="_idTextAnchor272"/>and the capabilities of Ansible to suit your own bespoke environments and contribute to the community.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor273"/>Questions</h1>
<ol>
<li>How do you restart the Apache web server in the <code>frontends</code> host group via an ad hoc command?<ol><li><code>ansible frontends -i hosts -a "</code><code>name=httpd state=restarted"</code></li><li><code>ansible frontends -i hosts -b ansible.builtin.service -a "</code><code>name=httpd state=restarted"</code></li><li><code>ansible frontends -i hosts -b -m ansible.builtin.service -a "</code><code>name=httpd state=restarted"</code></li><li><code>ansible frontends -i hosts -b -m ansible.builtin.server -a "</code><code>name=httpd state=restarted"</code></li><li><code>ansible frontends -i hosts -m restart -</code><code>a "name=httpd"</code></li></ol></li>
<li>Blocks allow you to logically make a group of tasks or perform error handl<a id="_idTextAnchor274"/>i<a id="_idTextAnchor275"/>ng:<ol><li>True</li><li>False</li></ol></li>
<li>Default strategies are implemented via the relevant modul<a id="_idTextAnchor276"/>es in the playbook:<ol><li>True</li><li>False</li></ol></li>
</ol>
<h1 id="_idParaDest-76"><a id="_idTextAnchor277"/>Further reading</h1>
<p><code>ansible-galaxy</code> and its documentation can be found here: <a href="https://galaxy.ansible.com/docs/">https://galaxy.ansible.com/docs/</a>.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-77" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor278"/>Part 2:Expanding the Capabilities of Ansible</h1>
<p>In this section, we will cover the important concepts of Ansible plugins and modules. We will cover both their effective use and how to expand Ansible’s capabilities by writing your own plugins, modules, and collections. We’ll even look at the requirements for submitting your modules and plugins back to the official Ansible project. We’ll also look at coding best practices, as well as some advanced Ansible techniques that allow you to safely automate your infrastructure even when you are working with a clustered environment.</p>
<p>This section contains the following chapters:</p>
<ul>
<li><a href="B20846_05.xhtml#_idTextAnchor279"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating and Consuming</em><em class="italic"> Modules</em></li>
<li><a href="B20846_06.xhtml#_idTextAnchor318"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating and Consuming</em><em class="italic"> Collections</em></li>
<li><a href="B20846_07.xhtml#_idTextAnchor343"><em class="italic">Chapter 7</em></a>, <em class="italic">Creating and Consuming</em><em class="italic"> Plugins</em></li>
<li><a href="B20846_08.xhtml#_idTextAnchor347"><em class="italic">Chapter 8</em></a>, <em class="italic">Coding Best Practices</em></li>
<li><a href="B20846_09.xhtml#_idTextAnchor378"><em class="italic">Chapter 9</em></a>, <em class="italic">Advanced Ansible Topics</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>