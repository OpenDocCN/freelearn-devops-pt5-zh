<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Preparing Docker Hosts</h1></div></div></div><p class="calibre8">Docker allows us to deliver applications to our customers faster. It simplifies the workflows needed to get code from development to production by enabling us to easily create and launch Docker containers. This chapter will be a quick refresher on how to get our environment ready to run a Docker-based development and operations workflow by:</p><div><ul class="itemizedlist"><li class="listitem">Preparing a Docker host</li><li class="listitem">Working with Docker images</li><li class="listitem">Running Docker containers</li></ul></div><p class="calibre8">Most parts of this chapter are concepts that we are already familiar with and are readily available on the Docker documentation website. This chapter shows selected commands and interactions with the Docker host that will be used in the succeeding chapters.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Preparing a Docker host</h1></div></div></div><p class="calibre8">It is assumed <a id="id0" class="calibre1"/>that we are already familiar with how to set up a Docker host. For most of the chapters of this book, we will run our examples against the following environment, unless explicitly mentioned otherwise:</p><div><ul class="itemizedlist"><li class="listitem">Operating system—Debian 8.2 Jessie</li><li class="listitem">Docker version—1.10.0</li></ul></div><p class="calibre8">The following command displays the operating system and Docker version:</p><div><pre class="programlisting">
<strong class="calibre2">$ ssh dockerhost</strong>
<strong class="calibre2">dockerhost$ lsb_release –a</strong>
<strong class="calibre2">No LSB modules are available.</strong>
<strong class="calibre2">Distributor ID: Debian</strong>
<strong class="calibre2">Description:   Debian GNU/Linux 8.2 (jessie)</strong>
<strong class="calibre2">Release:        8.2</strong>
<strong class="calibre2">Codename:       jessie</strong>
<strong class="calibre2">dockerhost$ docker version</strong>
<strong class="calibre2">Client:</strong>
<strong class="calibre2"> Version:     1.10.0</strong>
<strong class="calibre2"> API version:  1.21</strong>
<strong class="calibre2"> Go version:   go1.4.2</strong>
<strong class="calibre2"> Git commit:   a34a1d5</strong>
<strong class="calibre2"> Built:        Fri Nov 20 12:59:02 UTC 2015</strong>
<strong class="calibre2"> OS/Arch:      linux/amd64</strong>

<strong class="calibre2">Server:</strong>
<strong class="calibre2"> Version:     1.10.0</strong>
<strong class="calibre2"> API version:  1.21</strong>
<strong class="calibre2"> Go version:   go1.4.2</strong>
<strong class="calibre2"> Git commit:   a34a1d5</strong>
<strong class="calibre2"> Built:        Fri Nov 20 12:59:02 UTC 2015</strong>
<strong class="calibre2"> OS/Arch:      linux/amd64</strong>
</pre></div><p class="calibre8">If we haven't <a id="id1" class="calibre1"/>set up our Docker environment yet, we can follow the instructions <a id="id2" class="calibre1"/>on the Docker website found at <a class="calibre1" href="https://docs.docker.com/installation/debian">https://docs.docker.com/installation/debian</a> to prepare our Docker host.</p><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">
<strong class="calibre2">Downloading the example code</strong>
</p><p class="calibre8">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Working with Docker images</h1></div></div></div><p class="calibre8">Docker images are <a id="id3" class="calibre1"/>artifacts that contain our application and other supporting components to help run it, such as the base operating system, runtime and development libraries, and so on. They get deployed and downloaded into Docker hosts in order to run our applications as Docker containers. This section will cover the following Docker commands to work with Docker images:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">docker build</code></li><li class="listitem"><code class="literal">docker images</code></li><li class="listitem"><code class="literal">docker push</code></li><li class="listitem"><code class="literal">docker pull</code></li></ul></div><div><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">Most of the <a id="id4" class="calibre1"/>material in this section is readily available on the Docker documentation website at <a class="calibre1" href="https://docs.docker.com/userguide/dockerimages">https://docs.docker.com/userguide/dockerimages</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Building Docker images</h2></div></div></div><p class="calibre8">We will <a id="id5" class="calibre1"/>use the <code class="literal">Dockerfile</code> of <code class="literal">training/webapp</code> from the Docker Education Team to build a Docker image. The next few steps will show us how to build this web application:</p><div><ol class="orderedlist"><li class="listitem" value="1">To begin, we will <a id="id6" class="calibre1"/>clone the Git repository of <code class="literal">webapp</code>, which is available at <a class="calibre1" href="https://github.com/docker-training/webapp">https://github.com/docker-training/webapp</a> via the following command:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ git clone https://github.com/docker-training/webapp.git training-webapp</strong>
<strong class="calibre2">Cloning into 'training-webapp'...</strong>
<strong class="calibre2">remote: Counting objects: 45, done.</strong>
<strong class="calibre2">remote: Total 45 (delta 0), reused 0 (de..., pack-reused 45</strong>
<strong class="calibre2">Unpacking objects: 100% (45/45), done.</strong>
<strong class="calibre2">Checking connectivity... done.</strong>
</pre></div></li><li class="listitem" value="2">Then, let's <a id="id7" class="calibre1"/>build the Docker image with the <code class="literal">docker build</code> command by executing the following:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ cd training-webapp</strong>
<strong class="calibre2">dockerhost$ docker build -t hubuser/webapp .</strong>
<strong class="calibre2">Sending build context to Docker daemon 121.3 kB</strong>
<strong class="calibre2">Sending build context to Docker daemon</strong>
<strong class="calibre2">Step 0 : FROM ubuntu:14.04</strong>
<strong class="calibre2">Repository ubuntu already being ... another client. Waiting.</strong>
<strong class="calibre2"> ---&gt; 6d4946999d4f</strong>
<strong class="calibre2">Step 1 : MAINTAINER Docker Education Team &lt;education@docker.com&gt;</strong>
<strong class="calibre2"> ---&gt; Running in 0fd24c915568</strong>
<strong class="calibre2"> ---&gt; e835d0c77b04</strong>
<strong class="calibre2">Removing intermediate container 0fd24c915568</strong>
<strong class="calibre2">Step 2 : RUN apt-get update</strong>
<strong class="calibre2"> ---&gt; Running in 45b654e66939</strong>
<strong class="calibre2">Ign http://archive.ubuntu.com trusty InRelease</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">Removing intermediate container c08be35b1529</strong>
<strong class="calibre2">Step 9 : CMD python app.py</strong>
<strong class="calibre2"> ---&gt; Running in 48632c5fa300</strong>
<strong class="calibre2"> ---&gt; 55850135bada</strong>
<strong class="calibre2">Removing intermediate container 48632c5fa300</strong>
<strong class="calibre2">Successfully built 55850135bada</strong>
</pre></div><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">-t</code> flag is used to tag the image as <code class="literal">hubuser/webapp</code>. Tagging containers as <code class="literal">&lt;username&gt;/&lt;imagename&gt;</code> is an important convention to be able to push our Docker images in the later section. More details on the <code class="literal">docker build</code> <a id="id8" class="calibre1"/>command can be found at <a class="calibre1" href="https://docs.docker.com/reference/commandline/build">https://docs.docker.com/reference/commandline/build</a> or by running <code class="literal">docker build --help</code>.</p></div></li><li class="listitem" value="3">Finally, let's <a id="id9" class="calibre1"/>confirm that the image is already available in our Docker host with the <code class="literal">docker images</code> command:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker images</strong>
<strong class="calibre2">REPOSITORY      TAG      IMAGE ID  CREATED        VIRTUAL SIZE</strong>
<strong class="calibre2">hubuser/webapp  latest   55850135  5 minutes ago  360 MB</strong>
<strong class="calibre2">ubuntu          14.04    6d494699  3 weeks ago    188.3 MB</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Pushing Docker images to a repository</h2></div></div></div><p class="calibre8">Now that we <a id="id10" class="calibre1"/>have made a Docker image, let's push it to a repository to share and deploy across other Docker hosts. The default installation of <a id="id11" class="calibre1"/>Docker pushes images to Docker Hub. Docker Hub is a publicly hosted repository of Docker, Inc., where anyone with an account can push and share their Docker images. The following steps will show us how to do this:</p><div><ol class="orderedlist"><li class="listitem" value="1">Before being able to push to Docker Hub, we will need to authenticate with the <code class="literal">docker login</code> command, as follows:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker login</strong>
<strong class="calibre2">Username: hubuser</strong>
<strong class="calibre2">Password: ********</strong>
<strong class="calibre2">Email: hubuser@hubemail.com</strong>
<strong class="calibre2">WARNING: login credentials saved in /home/hubuser/.dockercfg.</strong>
<strong class="calibre2">Login Succeeded</strong>
</pre></div><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">If we don't <a id="id12" class="calibre1"/>have a Docker Hub account yet, we can follow the instructions to sign up for an account at <a class="calibre1" href="https://hub.docker.com/account/signup">https://hub.docker.com/account/signup</a>.</p></div></li><li class="listitem" value="2">We can now push our images to Docker Hub. As mentioned in the previous section, the tag of the image identifies <code class="literal">&lt;username&gt;/&lt;imagename&gt;</code> in the repository. Issue the <code class="literal">docker push</code> command shown as follows in order to push our image to Docker Hub:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker push hubuser/webapp</strong>
<strong class="calibre2">The push refers to a repository [hubuser/webapp] (len: 1)</strong>
<strong class="calibre2">Sending image list</strong>
<strong class="calibre2">Pushing repository hubuser/webapp (1 tags)</strong>
<strong class="calibre2">428b411c28f0: Image already pushed, skipping</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">7d04572a66ec: Image successfully pushed</strong>
<strong class="calibre2">55850135bada: Image successfully pushed</strong>
<strong class="calibre2">latest: digest: sha256:b00a3d4e703b5f9571ad6a... size: 2745</strong>
</pre></div></li></ol><div></div><p class="calibre8">Now that we have <a id="id13" class="calibre1"/>successfully pushed our Docker image, it will be available in Docker Hub. We can also get more information about the image we <a id="id14" class="calibre1"/>pushed in its Docker Hub page, which is similar to that shown in the following image. In this example, our Docker Hub URL is <code class="literal">https:// hub.docker.com/r/hubuser/webapp</code>:</p><div><img src="img/00002.jpeg" alt="Pushing Docker images to a repository" class="calibre10"/></div><p class="calibre11"> </p><div><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">More details on pushing Docker images to a repository are available at <code class="literal">docker push --help</code> and <a class="calibre1" href="https://docs.docker.com/reference/commandline/push">https://docs.docker.com/reference/commandline/push</a>.</p></div><p class="calibre8">Docker Hub is a good place to start hosting our Docker images. However, there are some cases where we want to host our own image repository. For example, when we want to save bandwidth when pulling images to our Docker hosts. Another reason could be that our Docker hosts inside <a id="id15" class="calibre1"/>a datacenter may have firewalled off the <a id="id16" class="calibre1"/>Internet. In <a class="calibre1" title="Chapter 2. Optimizing Docker Images" href="part0018_split_000.html#H5A42-afc4585f6623427885a0b0c8e5b2e22e">Chapter 2</a>, <em class="calibre9">Optimizing Docker Images</em>, we will discuss in greater detail how to run our own Docker registry to have an in-house repository of Docker images.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec09" class="calibre1"/>Pulling Docker images from a repository</h2></div></div></div><p class="calibre8">Once our <a id="id17" class="calibre1"/>Docker images are built and pushed to a <a id="id18" class="calibre1"/>repository, such as Docker Hub, we can pull them to our Docker hosts. This workflow is useful when we first build our Docker image in our development workstation Docker host and want to deploy it to our production environment's Docker host in the cloud. This removes the need to rebuild the same image in our other Docker hosts. Pulling images can also be used to grab the existing Docker images from Docker Hub to build over our own Docker images. So, instead of cloning the Git repository as we did earlier and redoing the build in another one of our Docker hosts, we can pull it instead. The next few steps will walk us through pulling the <code class="literal">hubuser/webapp</code> Docker image that we just pushed earlier:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, let's clean our existing Docker host to make sure that we will download the image from Docker Hub. Type the following command to make sure we have a clean start:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ dockerhost rmi hubuser/webapp</strong>
</pre></div></li><li class="listitem" value="2">Next, we can now download the image using <code class="literal">docker pull</code>, as follows:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker pull hubuser/webapp</strong>
<strong class="calibre2">latest: Pulling from hubuser/webapp</strong>
<strong class="calibre2">e9e06b06e14c: Pull complete</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">b37deb56df95: Pull complete</strong>
<strong class="calibre2">02a8815912ca: Already exists</strong>
<strong class="calibre2">Digest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5</strong>
<strong class="calibre2">Status: Downloaded newer image for hubuser/webapp:latest</strong>
</pre></div></li><li class="listitem" value="3">Finally, let's confirm again that we have downloaded the image successfully by executing the following command:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker images</strong>
<strong class="calibre2">REPOSITORY      TAG     IMAGE ID  CREATED      VIRTUAL SIZE</strong>
<strong class="calibre2">ubuntu          14.04   6d494699  3 weeks ago  188.3 MB</strong>
<strong class="calibre2">hubuser/webapp  latest  2a8815ca  7 weeks ago  348.8 MB</strong>
</pre></div></li></ol><div></div><div><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">More details on <a id="id19" class="calibre1"/>how to pull Docker images is <a id="id20" class="calibre1"/>available at <code class="literal">docker pull --help</code> and <a class="calibre1" href="https://docs.docker.com/reference/commandline/pull">https://docs.docker.com/reference/commandline/pull</a>.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Running Docker containers</h1></div></div></div><p class="calibre8">Now that we <a id="id21" class="calibre1"/>have pulled or built Docker images, we can run and test them with the <code class="literal">docker run</code> command. This section will review selected command-line flags that we will use throughout the succeeding chapters. This section will also use the following Docker commands to get more information about the Docker containers being run inside the Docker host:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">docker ps</code></li><li class="listitem"><code class="literal">docker inspect</code></li></ul></div><div><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">More comprehensive details on all the command-line flags are found at <code class="literal">docker run --help</code> and <a class="calibre1" href="https://docs.docker.com/reference/commandline/run">https://docs.docker.com/reference/commandline/run</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec10" class="calibre1"/>Exposing container ports</h2></div></div></div><p class="calibre8">In the <code class="literal">training/webapp</code> example, its Docker container is run as a web server. To have the application <a id="id22" class="calibre1"/>serve web traffic outside its container environment, Docker needs information on which port the application is bound to. Docker refers to this information as exposed ports. This section will walk us through how to expose port information when running our containers.</p><p class="calibre8">Going back to the <code class="literal">training/webapp</code> Docker image we worked on earlier, the application serves a Python Flask web application that listens to port <code class="literal">5000</code>, as highlighted here in <code class="literal">webapp/app.py</code>:</p><div><pre class="programlisting">import os
from flask import Flask
app = Flask(__name__)
@app.route('/')
def hello():
    provider = str(os.environ.get('PROVIDER', 'world'))
    return 'Hello '+provider+'!'
if __name__ == '__main__':
    # Bind to PORT if defined, otherwise default to 5000.
<strong class="calibre2">    port = int(os.environ.get('PORT', 5000))</strong>
    app.run(host='0.0.0.0', port=port)</pre></div><p class="calibre8">Correspondingly, the Docker image makes the Docker host aware that the application is listening on port <code class="literal">5000</code> via the <code class="literal">EXPOSE</code> instruction in the <code class="literal">Dockerfile</code>, which can be described as follows:</p><div><pre class="programlisting">FROM ubuntu:14.04
MAINTAINER Docker Education Team &lt;education@docker.com&gt;
RUN apt-get update
RUN DEBIAN_FRONTEND=noninteractive apt-get \
        install -y -q python-all python-pip 
ADD ./webapp/requirements.txt /tmp/requirements.txt
RUN pip install -qr /tmp/requirements.txt
ADD ./webapp /opt/webapp/
WORKDIR /opt/webapp
EXPOSE 5000
CMD ["python", "app.py"]</pre></div><p class="calibre8">Now that we have a <a id="id23" class="calibre1"/>basic idea of how Docker exposes our container's ports, follow the next few steps to run the <code class="literal">hubuser/webapp</code> container:</p><div><ol class="orderedlist"><li class="listitem" value="1">Use <code class="literal">docker run</code> with the <code class="literal">-d</code> flag to run the container as a daemon process, as follows:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker run --name ourapp -d hubuser/webapp</strong>
</pre></div></li><li class="listitem" value="2">Finally, confirm that the Docker host has the container running with port <code class="literal">5000</code> exposed with <code class="literal">docker ps</code>. We can do this through the following command:<div><pre class="programlisting">
<strong class="calibre2">dockerhost:~/training-webapp$ docker ps</strong>
<strong class="calibre2">CONTAINER ID  IMAGE  ...   STATUS        PORTS    NAMES</strong>
<strong class="calibre2">df3e6b788fd8  hubuser...   Up 4 seconds  5000/tcp ourapp</strong>
</pre></div></li></ol><div></div><p class="calibre8">In addition to the <code class="literal">EXPOSE</code> instruction, exposed ports can be overridden during runtime with the <code class="literal">--expose=[]</code> flag. For example, use the following command to have the <code class="literal">hubuser/webapp</code> application expose ports <code class="literal">4000</code>-<code class="literal">4500</code>:</p><div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker run -d --expose=4000-4500 \</strong>
<strong class="calibre2">                          --name app hubuser/webapp</strong>
<strong class="calibre2">dockerhost $ docker ps</strong>
<strong class="calibre2">CONTAINER ID   IMAGE      ...              PORTS                   NAMES</strong>
<strong class="calibre2">ca4dc1da26d    hubuser/webapp:latest  ...  4000-4500/tcp,5000/tcp  app</strong>
<strong class="calibre2">df3e6b788fd8   hubuser/webapp:l...         5000/tcp                ourapp</strong>
</pre></div><p class="calibre8">This ad hoc <code class="literal">docker run</code> flag is useful when debugging applications. For example, let's say our web application uses ports <code class="literal">4000</code>-<code class="literal">4500</code>. However, we normally don't want these ranges to be available in production. We can then use <code class="literal">--expose=[]</code> to enable it temporarily to spin up a debuggable container. Further details on how to use techniques such as this to <a id="id24" class="calibre1"/>troubleshoot Docker containers will be discussed in <a class="calibre1" title="Chapter 7. Troubleshooting Containers" href="part0046_split_000.html#1BRPS2-afc4585f6623427885a0b0c8e5b2e22e">Chapter 7</a>, <em class="calibre9">Troubleshooting Containers</em>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec11" class="calibre1"/>Publishing container ports</h2></div></div></div><p class="calibre8">Exposing only <a id="id25" class="calibre1"/>makes the port available inside the container. For the application to be served outside its Docker host, the port needs to be published. The <code class="literal">docker run</code> command uses the <code class="literal">-P</code> and <code class="literal">-p</code> flags to publish a container's exposed ports. This section talks about how to use these two flags to publish ports on the Docker host.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>--publish-all</h3></div></div></div><p class="calibre8">The <code class="literal">-P</code> or <code class="literal">--publish-all</code> flag publishes all the exposed ports of a container to random high <a id="id26" class="calibre1"/>ports in the Docker host port within the ephemeral port range defined in <code class="literal">/proc/sys/net/ipv4/ip_local_port_range</code>. The next few steps will go back to the <code class="literal">hubuser/webapp Docker</code> image that we were working on to explore publishing exposed ports:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, type the following command to run a container publishing all the exposed ports:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker run -P –d --name exposed hubuser/webapp</strong>
</pre></div></li><li class="listitem" value="2">Next, let's confirm that the Docker host publishes port <code class="literal">32771</code> to forward traffic to the Docker container's exposed port <code class="literal">5000</code>. Type the <code class="literal">docker ps</code> command as follows to perform this verification:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker ps</strong>
<strong class="calibre2">CONTAINER ID IMAGE  ...                PORTS                     NAMES</strong>
<strong class="calibre2">508cf1fb3e5  hubuser/webapp:latest ... 0.0.0.0:32771-&gt;5000/tcp   exposed</strong>
</pre></div></li><li class="listitem" value="3">We can also verify that the allocated port <code class="literal">32771</code> is within the configured ephemeral port range of our Docker host:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ cat /proc/sys/net/ipv4/ip_local_port_range</strong>
<strong class="calibre2">32768   61000</strong>
</pre></div></li><li class="listitem" value="4">In addition, we can confirm that our Docker host is listening on the allocated port <code class="literal">32771</code> as well via the following command:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ ss -lt 'sport = *:32771'</strong>
<strong class="calibre2">State   Recv-Q Send-Q  Local Address:Port Peer Address:Port</strong>
<strong class="calibre2">LISTEN  0      128     :::32771           :::*</strong>
</pre></div></li><li class="listitem" value="5">Finally, we can validate that the Docker host's port <code class="literal">32771</code> is indeed mapped to the running Docker container by confirming that it is the <code class="literal">training/webapp</code> Python application responding by making an actual HTTP <a id="id27" class="calibre1"/>request. Run the following command to confirm:<div><pre class="programlisting">
<strong class="calibre2">$ curl  http://dockerhost:32771</strong>
<strong class="calibre2">Hello world!</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>--publish</h3></div></div></div><p class="calibre8">The <code class="literal">-p</code> or <code class="literal">--publish</code> flag publishes container ports to the Docker host. If the container port is not <a id="id28" class="calibre1"/>yet exposed, the said container will also be exposed. According to the documentation, the <code class="literal">-p</code> flag can take the following formats to publish container ports:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">containerPort</code></li><li class="listitem"><code class="literal">hostPort:containerPort</code></li><li class="listitem"><code class="literal">ip::containerPort</code></li><li class="listitem"><code class="literal">ip:hostPort:containerPort</code></li></ul></div><p class="calibre8">By specifying the <code class="literal">hostPort</code>, we can specify which port in the Docker host the container port should be mapped to instead of being assigned a random ephemeral port. By specifying <code class="literal">ip</code>, we can restrict the interfaces that the Docker host will accept connections from to relay the packets to the mapped Docker container's exposed port. Going back to the <code class="literal">hubuser/webapp</code> example, the following is the command to map the Python application's exposed port <code class="literal">5000</code> to our Docker host's port <code class="literal">80</code> on the loopback interface:</p><div><pre class="programlisting">
<strong class="calibre2">$ ssh dockerhost</strong>
<strong class="calibre2">dockerhost$ docker run -d -p 127.0.0.1:80:5000 training/webapp</strong>
<strong class="calibre2">dockerhost$ curl http://localhost</strong>
<strong class="calibre2">Hello world!</strong>
<strong class="calibre2">dockerhost$ exit</strong>
<strong class="calibre2">logout</strong>
<strong class="calibre2">Connection to dockerhost closed.</strong>
<strong class="calibre2">$ curl http://dockerhost</strong>
<strong class="calibre2">curl: (7) Failed connect to dockerhost:80; Connection refused</strong>
</pre></div><p class="calibre8">With the preceding invocation of <code class="literal">docker run</code>, the Docker host can only serve HTTP requests in the application from <code class="literal">http://localhost</code>.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec12" class="calibre1"/>Linking containers</h2></div></div></div><p class="calibre8">The published <a id="id29" class="calibre1"/>ports described in the previous section also allow containers to talk to each other by connecting to the published Docker host ports. Another way to directly connect containers with each other is establishing container links. Linked containers allow a source container to send information to the destination containers. It enables the communicating containers to discover each other in a secure manner.</p><div><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">More details <a id="id30" class="calibre1"/>about linked containers can be found on the Docker documentation site at <a class="calibre1" href="https://docs.docker.com/userguide/dockerlinks">https://docs.docker.com/userguide/dockerlinks</a>.</p></div><p class="calibre8">In this section, we will work with the <code class="literal">--link</code> flag to connect containers securely. The next few steps give us an example of how to work with linked containers:</p><div><ol class="orderedlist"><li class="listitem" value="1">As preparation, make sure that our <code class="literal">hubuser/webapp</code> container runs with only the exposed ports. We will create a container called source that will serve as our source container. Type the following command to recreate this container:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker run --name source –d hubuser/webapp</strong>
</pre></div></li><li class="listitem" value="2">Next, we will create a destination container. We will use <code class="literal">--link</code> <code class="literal">&lt;source&gt;:&lt;alias&gt;</code> to create a link from the source container named <code class="literal">source</code> to an alias called <code class="literal">webapp</code>. Type the following command to create this link to our destination container:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker run -d --link source:webapp \</strong>
<strong class="calibre2">                   --name destination busybox /bin/ping webapp</strong>
</pre></div></li><li class="listitem" value="3">Let's now confirm that the link was made by inspecting the newly created destination <a id="id31" class="calibre1"/>container called <code class="literal">destination</code>. Execute the following command:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker inspect -f "{{ .HostConfig.Links }}" \</strong>
<strong class="calibre2">                           destination</strong>
<strong class="calibre2">[/source:/destination/webapp]</strong>
</pre></div></li></ol><div></div><p class="calibre8">What happened during the linking process was that the Docker host created a secure tunnel between the two containers. We can confirm this tunnel in the Docker host's iptables, as follows:</p><div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker inspect -f "{{ .NetworkSettings.IPAddress }}" \</strong>
<strong class="calibre2">                           source</strong>
<strong class="calibre2">172.17.0.15</strong>
<strong class="calibre2">dockerhost$ docker inspect -f "{{ .NetworkSettings.IPAddress }}" \</strong>
<strong class="calibre2">                           destination</strong>
<strong class="calibre2">172.17.0.28</strong>
<strong class="calibre2">dockerhost$ iptables -L DOCKER</strong>
<strong class="calibre2">Chain DOCKER (1 references)</strong>
<strong class="calibre2">target     prot opt source         destination         </strong>
<strong class="calibre2">ACCEPT     tcp  --  172.17.0.28    172.17.0.15       tcp dpt:5000</strong>
<strong class="calibre2">ACCEPT     tcp  --  172.17.0.15    172.17.0.28       tcp spt:5000</strong>
</pre></div><p class="calibre8">In the preceding iptables, the Docker host allowed the destination container called <code class="literal">destination (172.17.0.28)</code> to accept outbound connections to port <code class="literal">5000</code> of the source container called <code class="literal">source (172.17.0.15)</code>. The second iptable's entry allows the container called <code class="literal">source</code> to receive connections to its port <code class="literal">5000</code> from the container called <code class="literal">destination</code>.</p><p class="calibre8">In addition to the secure connections established by the Docker host between containers, the Docker host also <a id="id32" class="calibre1"/>exposes information about the source container to the destination container through the following:</p><div><ul class="itemizedlist"><li class="listitem">Environment variables</li><li class="listitem">Entries in <code class="literal">/etc/hosts</code></li></ul></div><p class="calibre8">These two sources of information will be further explored in the next section as an example use case of working with interactive containers.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec13" class="calibre1"/>Interactive containers</h2></div></div></div><p class="calibre8">By specifying the <code class="literal">-i</code> flag, we can specify that a container running in the foreground is attached to the <a id="id33" class="calibre1"/>standard input stream. By combining it with the <code class="literal">-t</code> flag, a pseudoterminal is also allocated to our container. With this, we can use our Docker container as an interactive process, similar to normal shells. This feature is useful when we want to debug and inspect what is happening inside our Docker containers. Continuing from the previous section, we can debug what happens when containers are linked through the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">To prepare, type the following command to establish an interactive container session linking to the container called <code class="literal">source</code> that we ran earlier:<div><pre class="programlisting">
<strong class="calibre2">dockerhost$ docker run -i -t --link source:webapp \</strong>
<strong class="calibre2">                       --name interactive_container \</strong>
<strong class="calibre2">                       busybox /bin/sh</strong>
<strong class="calibre2">/ # </strong>
</pre></div></li><li class="listitem" value="2">Next, let's first explore the environment variables that are exposed to the interactive destination container via the following command:<div><pre class="programlisting">
<strong class="calibre2">/ # env | grep WEBAPP</strong>
<strong class="calibre2">WEBAPP_NAME=/interactive_container/webapp</strong>
<strong class="calibre2">WEBAPP_PORT_5000_TCP_ADDR=172.17.0.15</strong>
<strong class="calibre2">WEBAPP_PORT_5000_TCP_PORT=5000</strong>
<strong class="calibre2">WEBAPP_PORT_5000_TCP_PROTO=tcp</strong>
<strong class="calibre2">WEBAPP_PORT_5000_TCP=tcp://172.17.0.15:5000</strong>
<strong class="calibre2">WEBAPP_PORT=tcp://172.17.0.15:5000</strong>
</pre></div><div><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">In general, the following environment variables are set in linked containers:</p><div><ul class="itemizedlist1"><li class="listitem"><code class="literal">&lt;alias&gt;_NAME=/container_name/alias_name</code> for each source container</li><li class="listitem"><code class="literal">&lt;alias&gt;_PORT_&lt;port&gt;_&lt;protocol&gt;</code> shows the URL of each exposed port. It also serves as a unique prefix expanding to the following more environment variables:<div><ul class="itemizedlist2"><li class="listitem"><code class="literal">&lt;prefix&gt;_ADDR</code> contains the IP address of the source container</li><li class="listitem"><code class="literal">&lt;prefix&gt;_PORT</code> shows the exposed port's number</li><li class="listitem"><code class="literal">&lt;prefix&gt;_PROTO</code> describes the protocol of the exposed port which is either TCP or UDP</li></ul></div></li><li class="listitem"><code class="literal">&lt;alias&gt;_PORT</code> shows the source container's first exposed port</li></ul></div></div></li><li class="listitem" value="3">The second <a id="id34" class="calibre1"/>container discovery feature in linked containers is an updated <code class="literal">/etc/hosts</code> file. The alias of the <code class="literal">webapp</code> linked container is mapped to the IP address of the <code class="literal">source</code> source container The name of the source container is also mapped to the same IP address. The following snippet is the content of the <code class="literal">/etc/hosts</code> file inside our interactive container session, and it contains this mapping:<div><pre class="programlisting">172.17.0.29     d4509e3da954
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
<strong class="calibre2">172.17.0.15     webapp 85173b8686fc source</strong>
</pre></div></li><li class="listitem" value="4">Finally, we can use the alias to connect to our source container. In the following example, we will connect to the web application running in our source container by making an HTTP request to its alias, <code class="literal">webapp</code>:<div><pre class="programlisting">
<strong class="calibre2">/ # nc webapp 5000</strong>
<strong class="calibre2">GET /</strong>

<strong class="calibre2">Hello world!</strong>
<strong class="calibre2">/ #</strong>
</pre></div><div><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">Interactive containers can be used to build containers as well, together with <code class="literal">docker commit</code>. However, this is a tedious process, and this development process doesn't scale beyond a single developer. Use <code class="literal">docker build</code> instead <a id="id35" class="calibre1"/>and manage our <code class="literal">Dockerfile</code> in version control.</p></div></li></ol><div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Hopefully by this time, we are refamiliarized with most of the commands that will be used throughout the book. We prepared a Docker host to be able to interact with Docker containers. We then built, downloaded, and uploaded various Docker images to develop and deploy containers to our development and production Docker hosts alike. Finally, we ran Docker containers from built or downloaded Docker images. In addition, we established some basic skills of how to communicate and interact with running containers by learning about how Docker containers are run.</p><p class="calibre8">In the next chapter, you'll learn how to optimize our Docker images. So, let's dive right in!</p></div></body></html>