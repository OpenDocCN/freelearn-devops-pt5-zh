<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-145"><a id="_idTextAnchor423"/>10</h1>
<h1 id="_idParaDest-146"><a id="_idTextAnchor424"/>Network Automation with Ansible</h1>
<p>Years ago, the standard practice was to configure every single network device by hand. This way of managing devices was possible mainly because the routers and switches were routing the traffic of physical servers, so only a little configuration was needed on each networking device, and changes were slow-paced. In addition, humans were the only ones with enough information on machines to set up networking. Everything was very manual in terms of both planning and execution.</p>
<p><strong class="bold">Virtualization</strong> changed this<a id="_idIndexMarker595"/> paradigm, as it has resulted in thousands of machines being connected to the same switch or router, each with potentially different networking requirements. Changes are fast paced and expected frequently, and with virtual infrastructures defined in code, it becomes a full-time job for a human administrator just to keep up with the changes to the infrastructure. Virtualization orchestration platforms have far better knowledge of the machine’s location and can even generate an inventory for us, as we saw in earlier chapters. Practically speaking, there is no way a human being can memorize or manage a modern, large-scale, virtualized infrastructure. As a result, it becomes clear that automation is required when configuring the network infrastructure.</p>
<p>We will learn more about this and what we can do to automate our network in this chapter by covering the following topics:</p>
<ul>
<li>Why automate network management?</li>
<li>How Ansible manages networking devices</li>
<li>How to enable network automation</li>
<li>The available Ansible networking modules</li>
<li>Connecting to network devices</li>
<li>Environment variables for network devices</li>
<li>Custom conditional statements for networking devices</li>
</ul>
<p>Let’s get started<a id="_idTextAnchor425"/>!<a id="_idTextAnchor426"/></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor427"/>Technical requirements</h1>
<p>This chapter assumes that you have set up your control host with Ansible, as detailed in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, and are using the most recent version available – the examples in this chapter were tested with Ansible 2.15. This chapter also assumes that you have at least one additional host to test against; ideally, this should be Linux-based. Since this chapter is network device-centric, we understand that not everyone will have access to specific networking equipment to test on (for example, Cisco switches).</p>
<p>Where examples are given, and you have access to such devices, please feel free to explore the examples. However, if you do not have access to any network hardware, we will give an example using the freely available Cumulus VX, which offers a fully-featured demo of Cumulus Networks’ switching environment. Although we will give specific examples of hostnames in this chapter, you are free to substitute them with your hostname and/or IP address. Details of how to do this will be provided in the appropriate places.</p>
<p>The code bundle for this chapter is available here: <a href="https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010">https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010</a>.<a id="_idTextAnchor428"/></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor429"/>Why automate network management?</h1>
<p>How we <a id="_idIndexMarker596"/>design data centers has radically changed in the last 30 years. In the 90s, a typical data center was full of physical machines, each with a particular purpose. In many companies, the servers were bought from different vendors based on the purpose of the machine. This meant that every time there was a need for new servers, network devices, and storage devices, those devices were bought, provisioned, configured, and delivered.</p>
<p>The big drawback here was the significant lag between identifying the need for the server and its delivery. At the time, this was acceptable since most companies had very few systems, and they tended to change very rarely. Also, this approach was costly as a lot of devices were underutilized.</p>
<p>With the progress of society and companies in the world of technology, it has become necessary for companies to get more efficiency from their infrastructure and cut their infrastructure deployment time and costs. These new requirements paved the way for a new idea: virtualization. By creating a virtualization cluster, you do not need physical hosts of the right size, so you can provision a number of them upfront, add them to a resource pool, and then create the right-sized machines in your virtualization platform. This decoupling means that when a new server is needed, you can create it with a few clicks and it will be ready in seconds.</p>
<p>This shift also allowed enterprises to move from a per-project infrastructure, with each project being deployed with its unique data center requirements, to one large central infrastructure that can have its behavior defined by software and configuration. This new architecture means that a single network infrastructure can support many projects, regardless of their scale. We call this a <strong class="bold">virtual data center infrastructure</strong>; in this infrastructure, we use generic design patterns as <a id="_idIndexMarker597"/>much as possible. The virtual data center infrastructure allows enterprises to deploy, switch, and serve infrastructure at a large scale to enable a multitude of projects so that they can be successfully implemented by simply subdividing them (for example, by creating virtual servers).</p>
<p>Another significant advantage of virtualization is the decoupling of workloads and physical hosts. Historically, since a workload was tied to a physical host, if the host died, the workload itself died if not correctly replicated on different hardware. Virtualization solved this problem since the workload is now tied to one or more virtual hosts, but those can be moved freely from one physical host to another by the virtualization controller.</p>
<p>This ability to provision servers quickly and the ability to move them from one host to another created an issue with networking configuration management. Before, it was acceptable for a human to tweak the configuration details while installing the new machine, but now, machines move from one host to another (and therefore from one physical switch port to another) without any human intervention. This peculiarity means that the system needs to update network configurations as well.</p>
<p>At the<a id="_idIndexMarker598"/> same time, and for similar reasons, VLANs affirmed their presence in networking, which allowed the utilization of network devices to be dramatically improved, and its costs to therefore be optimized.</p>
<p>Today, we work at an even larger scale, where virtual objects (machines, containers, functions, and so on) move in our data centers, fully managed by software systems, and where humans are less and less involved in the process.</p>
<p>In this kind of environment, automating the network configuration is a crucial part of its success.</p>
<p>Today, some companies (the famous <em class="italic">cloud providers</em>) work at a scale where manual network management is not only impracticable but impossible, even when employing huge teams of network engineers. On the other hand, there are many environments where it would be technically possible to manage network configurations manually, at least partially so, but it’s still impractical.</p>
<p>Aside from<a id="_idIndexMarker599"/> the time required to configure a network device, the biggest advantage – from my perspective – of network automation is the opportunity to drastically reduce human errors. If a human has to configure a VLAN on 100 devices, chances are they will make a few errors in the process. This is normal but problematic since those configurations must be thoroughly tested and amended. Often, the problem doesn’t stop here because when a device breaks and needs to be replaced, a human has to configure the new device in the same way as the old one was configured. Often – over time – the configurations change, and there is very often no clear way to trace this, so while replacing a faulty network device, there might be problems with some rules that were present in the previous device but are not present in the new one.</p>
<p>Now that we have discussed the need to automate network management, let’s look at how to manage networking devices with Ansi<a id="_idTextAnchor430"/>ble.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor431"/>How Ansible manages networking devices</h1>
<p>Ansible<a id="_idIndexMarker600"/> allows you to manage many different<a id="_idIndexMarker601"/> networking devices, including Arista EOS, Cisco ASA, Cisco IOS, Cisco IOS XR, Cisco NX-OS, Dell OS 6, Dell OS 9, Dell OS 10, Extreme EXOS, Extreme IronWare, Extreme NOS, Extreme SLX-OS, Extreme VOSS, F5 BIG-IP, F5 BIG-IQ, Junos OS, Lenovo CNOS, Lenovo ENOS, MikroTik RouterOS, Nokia SR OS, Pluribus Netvisor, and VyOS, as well as all OSs that support NETCONF. As you can imagine, we can make Ansible communicate with them in various ways.</p>
<p>Also, we have to remember that Ansible networking modules run on the controller host (the one where you issued the <code>ansible</code> command), while usually, the Ansible modules run on the target host. This difference is crucial because it allows Ansible to use different connection mechanisms based on the target device type. Remember that even when you have a host with SSH management capabilities (that many switches have), Ansible needs Python to be present on the target host to be able to run modules on it. Since most switches (and embedded hardware) do not have Python, Ansible will often use specific connection protocols. The key ones supported by Ansible for network device management are given here.</p>
<p>There are five main connection types that Ansible uses for connecting to those network devices, as follows:</p>
<ul>
<li><code>ansible.netcommon.network_cli</code></li>
<li><code>ansible.netcommon.netconf</code></li>
<li><code>ansible.netcommon.httpapi</code></li>
<li><code>local</code></li>
<li><code>ssh</code></li>
</ul>
<p>When <a id="_idIndexMarker602"/>you create a connection with your networking device, you<a id="_idIndexMarker603"/> need to choose the connection mechanism based on the ones supported by your devices and your needs:</p>
<ul>
<li><code>ansible.netcommon.network_cli</code> is supported by most modules, and it is the most similar to how Ansible usually works with non-networking modules. This mode uses a CLI via SSH. This protocol creates a persistent connection at the beginning of the execution, which is kept alive for the whole execution so that you don’t have to provide credentials for every task.</li>
<li><code>ansible.netcommon.netconf</code> is supported by some modules. This mode uses XML via SSH, so it applies XML-based configurations to the device. This protocol creates a persistent connection at the beginning of the execution, which is kept alive for the whole execution so that you don’t have to provide credentials for every task.</li>
<li><code>ansible.netcommon.httpapi</code> is supported by a few modules. This mode uses the HTTP API that the device publishes. This protocol creates a persistent connection at the beginning of the execution, which is kept alive for the whole execution so that you don’t have to provide credentials for every task.</li>
<li><code>local</code> is supported by most devices, but it is a deprecated connection mode. This connection mode is vendor-dependent and usually requires some vendor-specific packages to be present on Ansible’s execution host. This mode does not create a persistent connection, so you must provide the credentials at every task. When possible, avoid this mode.</li>
<li><code>ssh</code> must not be forgotten as an option. Although a large number of devices depend upon the connection modes listed before, a new breed of network devices is being created that runs Linux natively <a id="_idIndexMarker604"/>on <strong class="bold">white box</strong> switch hardware. One such example is Cumulus Networks (now part of NVIDIA), and as its software is Linux-based, all configurations can be performed over SSH as if the switch was just another Linux box.</li>
</ul>
<p>Knowing how <a id="_idIndexMarker605"/>Ansible connects to and communicates with your<a id="_idIndexMarker606"/> networking hardware is essential, as it gives you the understanding you need to build your Ansible playbooks and debug issues when things go wrong.</p>
<p>In this section, we covered the communication protocols you will come across when working with networking hardware. In the next section, we will build on this by looking at the fundamentals of starting our network automation journey w<a id="_idTextAnchor432"/>i<a id="_idTextAnchor433"/>th Ansible.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor434"/>How to enable network automation</h2>
<p>Before using<a id="_idIndexMarker607"/> Ansible for network automation, you must ensure you have everything you need. We need different requirements based on the kind of connection method we will use. For our example, we will use a Cisco IOS device with <code>network_cli</code> connectivity.</p>
<p>The only requirements for Ansible network automation to work are as follows:</p>
<ul>
<li>Ansible 2.5+</li>
<li>Proper connectivity with the network device</li>
</ul>
<p>First, we need to check the Ansible version:</p>
<ol>
<li>To <a id="_idIndexMarker608"/>ensure that you have a recent Ansible version, you can run the following command:<pre class="source-code">
<strong class="bold">$ ansible --version</strong></pre></li> </ol>
<p>This command will tell you the version of your Ansible installation.</p>
<ol>
<li value="2">If it’s 2.5 or newer, you can issue the following command (with the appropriate options) to check the connectivity of your network device:<pre class="source-code">
<strong class="bold">$ ansible all -i n1.example.org, -c network_cli -u my_user -k -m cisco.ios.ios_facts -e ansible_network_os=cisco.ios.ios all</strong></pre></li> </ol>
<p>This command should return your device’s facts, proving that we can connect. As for any other target, Ansible can retrieve facts, which is usually the first thing Ansible does when interacting with a target.</p>
<p>In this particular case, we are using the <code>–k</code> parameter to inform Ansible that we want to be prompted for a password to be used for SSH login.</p>
<p>Retrieving facts is a key step since this allows Ansible to know the current state of the device and act appropriately.</p>
<p>By running the <code>cisco.ios.ios_facts</code> module on our target device, we are just executing this first standard step (so no changes are performed), but this confirms that Ansible can connect to the device and perform commands on it.</p>
<p>As you might<a id="_idIndexMarker609"/> have imagined, you can only run the preceding command and explore its behavior if you have access to a network device running Cisco IOS. We understand that not everyone has the same networking equipment available for testing purposes (or any at all!). Fortunately for us, a new breed of switches is becoming available – white box switches. These switches are created by various manufacturers and are based on standardized hardware where you can install your network operating system. One such operating system is NVIDIA Cumulus Linux, and a freely available test version of this, called NVIDIA Cumulus VX, is available for you to download.</p>
<p class="callout-heading">Note</p>
<p class="callout">At the time of writing, the download link<a id="_idIndexMarker610"/> for NVIDIA Cumulus VX is <a href="https://www.nvidia.com/en-us/networking/ethernet-switching/cumulus-vx/">https://www.nvidia.com/en-us/networking/ethernet-switching/cumulus-vx/</a>. You will need to register to download it, but doing so gives you free access to the world of open networking.</p>
<p>Download the <a id="_idIndexMarker611"/>image appropriate to your hypervisor (for example, VirtualBox) and then run it just as you would run any other Linux virtual machine. Once you’ve done this, you can connect to the NVIDIA Cumulus VX switch, just like you would any other SSH device. For example, to run an ad hoc command to gather facts about all the switch port interfaces (that are enumerated as <code>swp1</code>, <code>swp2</code>, and <code>swpX</code> on Cumulus VX), you would run the following command:</p>
<pre class="console">
$ ansible -i vx01.example.org, -u cumulus -m ansible.builtin.setup -a 'filter=ansible_swp*' all --ask-pass</pre> <p>If successful, this should result in pages of information about the switch port interface for your Cumulus VX-powered virtual switch. On my test system, the first part of this output looks like this:</p>
<pre class="source-code">
vx01.example.org | SUCCESS =&gt; {
  "ansible_facts": {
    "ansible_swp1": {
      "active": false,
      "device": "swp1",
      "features": {
        "esp_hw_offload": "off [fixed]",
        "esp_tx_csum_hw_offload": "off [fixed]",
        "fcoe_mtu": "off [fixed]",
        "generic_receive_offload": "on",
        "generic_segmentation_offload": "on",
        "highdma": "off [fixed]",
        ...</pre> <p>As you can see, working with white box switches using an operating system such as NVIDIA Cumulus Linux has the advantage that you can connect using the standard SSH protocol and even use the <code>ansible.builtin.setup</code> module to gather facts about it. Working with<a id="_idIndexMarker612"/> other proprietary hardware is not much more difficult but requires more parameters to be specified, as we showed earlier in this chapter.</p>
<p>Now that you know the fundamentals of enabling network automation, let’s learn how to discover the appropriate networking modules for our desired automatio<a id="_idTextAnchor435"/>n<a id="_idTextAnchor436"/> task in Ansible.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor437"/>The available Ansible networking modules</h2>
<p>With the advent of Galaxy and<a id="_idIndexMarker613"/> collections, we have seen a huge increase in available<a id="_idIndexMarker614"/> Ansible content for networking. Currently, there are more than 150 collections and more than 1,000 roles on Galaxy. You can also find the most important collections on the official Ansible documentation. To find the collections, you should take the following steps:</p>
<ul>
<li>First of all, check the official documentation. By visiting <a href="https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml">https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml</a>, you can find the different device families and which connection types they use.</li>
<li>If the device you would like to manage is not on the list, you can search on Galaxy by going to <a href="https://galaxy.ansible.com">https://galaxy.ansible.com</a> and using the website’s search feature.</li>
</ul>
<p>The list of collections and modules is way too long and family-specific for us to discuss them in depth. Also, those lists are in constant update, and they tend to get continuously longer.</p>
<p>If you are familiar with configuring the device manually, you will quickly find the name of the modules reasonably natural, so it will be easy for you to understand what they do. However, let’s go through a handful of examples from the collection of Cisco IOS modules – specifically, with reference to <a href="https://galaxy.ansible.com/cisco/ios">https://galaxy.ansible.com/cisco/ios</a>:</p>
<ul>
<li><code>cisco.ios.ios_banner</code>: As the name suggests, this module will allow you to tweak and modify the login banner (which in many systems is called <em class="italic">motd</em>).</li>
<li><code>cisco.ios.ios_bgp</code>: This module allows you to configure BGP routes.</li>
<li><code>cisco.ios.ios_command</code>: This is the IOS equivalent of the <code>ansible.builtin.command</code> module and it allows you to perform many different commands. As for the <code>ansible.builtin.command</code> module, this is a very powerful module, but it’s better to use specific modules for the operations we are going to perform if they are available.</li>
<li><code>cisco.ios.ios_config</code>: This module allows us to make any changes to the device’s configuration file. Similarly to the <code>cisco.ios.ios_command</code> module, this is a very powerful module, but it’s better to use specific modules for the operation we are going to perform if they are available. The idempotency for this module is only guaranteed if no abbreviated commands are used.</li>
<li><code>cisco.ios.ios_vlan</code>: This<a id="_idIndexMarker615"/> module allows the configuration of <a id="_idIndexMarker616"/>VLANs.</li>
</ul>
<p>These are just a few examples, but there are many more modules for Cisco IOS, and if you cannot find a specific module to perform the operation you want, you can always fall back to <code>cisco.ios.ios_command</code> and <code>cisco.ios.ios_config</code>, which, thanks to their flexibility, will allow you to perform any operation you can think of.</p>
<p>In contrast, if you are working with a Cumulus Linux switch, you’ll find there are fewer modules since they are more generic.</p>
<p>As always, the Ansible documentation is your friend, and it should be your first port of call when you are learning how to automate commands on a new class of devices. In this section, we have demonstrated a simple process for finding out which Ansible modules are available for your network device, using Cisco as a specific example (though you could apply these principles to any other device). Now, let’s look at how Ansible connec<a id="_idTextAnchor438"/>t<a id="_idTextAnchor439"/>s to network devices.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor440"/>Connecting to network devices</h1>
<p>As we have seen, there are some<a id="_idIndexMarker617"/> peculiarities in Ansible networking, so specific configurations are required.</p>
<p>To <a id="_idIndexMarker618"/>manage network devices with Ansible, you need to have at least one to test on. Let’s assume we have a Cisco IOS system available to us. It is accepted that not everyone will have such a device to test on, so the following is offered as a hypothetical example only.</p>
<p>Going by the <a href="https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml">https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.xhtml</a> page, we can see that the correct <code>ansible_network_os</code> for this device is <code>cisco.ios.ios</code> and that we can connect to it using both <code>network_cli</code> and <code>local</code>. Since <code>local</code> is deprecated, we are going to use <code>network_cli</code>. Follow these steps to configure Ansible so that you can manage IOS devices:</p>
<ol>
<li>First, let’s create the inventory file with our devices in the <code>routers</code> group:<pre class="source-code">
[routers]
n1.example.org
n2.example.org
[cumulusvx]
vx01.example.org</pre></li> <li>To know which connection parameters to use, we will set Ansible’s special connection variables so that they define the connection parameters. We’ll do this in a group variables subdirectory of our playbook, so we will need to create the <code>group_vars/routers.yml</code> file with the following content:<pre class="source-code">
---
ansible_connection: network_cli
ansible_network_os: cisco.ios.ios
ansible_become: True
ansible_become_method: enable</pre></li> </ol>
<p>Thanks to these special variables, Ansible will know how to connect to your devices. We covered some of these examples earlier in this book, but as a recap, Ansible uses the values of those variables to determine their behavior in the following ways:</p>
<ul>
<li><code>ansible_connection</code>: This variable is used by Ansible to decide how to connect to the device. By choosing <code>network_cli</code>, we are instructing Ansible to connect to the CLI in SSH mode.</li>
<li><code>ansible_network_os</code>: This variable is used by Ansible to understand the device family of the device we are going to use. By choosing <code>cisco.ios.ios</code>, we are instructing Ansible to expect a Cisco IOS device.</li>
<li><code>ansible_become</code>: This variable is used by Ansible to decide whether to perform privilege escalation on the device or not. By specifying <code>True</code>, we are telling Ansible to perform privilege escalation.</li>
<li><code>ansible_become_method</code>: There are many different ways to perform privilege escalation on the various devices (normally <code>sudo</code> on a Linux server – this is the default setting), and for Cisco IOS, we must set this to <code>enable</code>.</li>
</ul>
<p>With that, you have <a id="_idIndexMarker619"/>learned the necessary steps to connect to network devices.</p>
<p>To validate that the connection is working as expected (assuming you have access to a router running Cisco IOS), you can run this simple playbook, called <code>ios_facts.yaml</code>:</p>
<pre class="source-code">
---
- name: Play to return facts from a Cisco IOS device
  hosts: routers
  gather_facts: False
  tasks:
  - name: Gather IOS facts
    cisco.ios.ios_facts:
      gather_subset: all</pre> <p>You can run this using a command such as the following:</p>
<pre class="console">
$ ansible-playbook -i hosts ios_facts.yml --ask-pass</pre> <p>If it returns successfully, this means that your configuration is correct and you’ve been able to give Ansible the necessary authorization to manage your IOS device.</p>
<p>Similarly, if you<a id="_idIndexMarker620"/> wanted to connect to a Cumulus VX device, you could add another group variables file called <code>group_vars/cumulusvx.yml</code> containing the following code:</p>
<pre class="source-code">
---
ansible_user: cumulus
become: false</pre> <p>An analogous playbook that returns all the facts about our Cumulus VX switches could look like this:</p>
<pre class="source-code">
---
- name: Simply play to gather Cumulus VX switch facts
  hosts: cumulusvx
  gather_facts: no
  tasks:
  - name: Gather facts
    ansible.builtin.setup:
      gather_subset: all</pre> <p>You can run this in a normal manner by using a command such as the following:</p>
<pre class="console">
$ ansible-playbook -i hosts cumulusvx_facts.yml --ask-pass</pre> <p>If successful, you should see the following output from your playbook run:</p>
<pre class="console">
SSH password:
PLAY [Simply play to gather Cumulus VX switch facts] ************************************************************************************************
TASK [Gather facts] ************************************************************************************************
ok: [vx01.example.org]
PLAY RECAP ************************************************************************************************
vx01.example.org : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>This <a id="_idIndexMarker621"/>demonstrates the techniques for connecting to two different types of network devices in Ansible, including one you can test by yourself without access to any special hardware.</p>
<p>Now, let’s build on this by looking at how to set environment variables for <a id="_idTextAnchor441"/>n<a id="_idTextAnchor442"/>etwork devices in Ansible.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor443"/>Environment variables for network devices</h2>
<p>Very often, the<a id="_idIndexMarker622"/> complexity of networks is high, and the<a id="_idIndexMarker623"/> network systems are very varied. For those reasons, Ansible has many variables that can help you tweak it to make Ansible fit your environment.</p>
<p>Let’s suppose you have two different networks (one for computing and one for network devices) that can’t communicate directly but have to pass through a bastion host to reach one from the other. Since we have Ansible in the computing network, we must jump networks using the bastion host to configure an IOS router in the management network. Also, our target switch needs a proxy set to reach the internet.</p>
<p>To connect to the IOS router in the management network, we will need to create a new group for our network devices, which are on a separate network. For this example, this might be specified as follows:</p>
<pre class="source-code">
[bastion_routers]
n1.example.org
n2.example.org
[bastion_cumulusvx]
vx01.example.org</pre> <p>Following the<a id="_idIndexMarker624"/> creation of our updated inventory, we can <a id="_idIndexMarker625"/>create a new group variables file, such as <code>group_vars/bastion_routers.yaml</code>, with the following content:</p>
<pre class="source-code">
---
ansible_connection: network_cli
ansible_network_os: cisco.ios.ios
ansible_become: True
ansible_become_method: enable
ansible_ssh_common_args: '-o ProxyCommand="ssh -W %h:%p -q bastion.example.org"'
proxy_env:
http_proxy: http://proxy.example.org:8080</pre> <p>We can also do the same for our Cumulus VX switches if they are behind a bastion server by creating a <code>group_vars/bastion_cumulusvx.yml</code> file:</p>
<pre class="source-code">
---
ansible_user: cumulus
ansible_become: false
ansible_ssh_common_args: '-o ProxyCommand="ssh -W %h:%p -q bastion.example.org"'
proxy_env:
http_proxy: http://proxy.example.org:8080</pre> <p>In addition to the options we discussed in the previous section, we now have two additional options:</p>
<ul>
<li><code>ansible_ssh_common_args</code>: This is a very powerful option that allows us to add additional options to the SSH connections to tweak their behavior. These options should be pretty straightforward to identify since you are already using them in your SSH configurations to simply SSH to the target machine. In this specific case, we are adding <code>ProxyCommand</code>, which is the SSH directive to perform a jump to a host (usually a bastion host) so that we can enter the target host securely.</li>
<li><code>http_proxy</code>: This option, which is below the <code>proxy_env</code> option, is key in environments where network isolation is strong, and therefore your machines can’t interact with the internet unless they use a proxy.</li>
</ul>
<p>Assuming <a id="_idIndexMarker626"/>you have set up passwordless (for example, SSH key-based) access to <a id="_idIndexMarker627"/>your bastion host, you should be able to run an ad hoc Ansible <code>ping</code> command against your Cumulus VX host, as follows:</p>
<pre class="console">
$ ansible -i hosts -m ping -u cumulus bastion_cumulusvx
vx01.example.org | SUCCESS =&gt; {
    "ansible_facts": {
    "discovered_interpreter_python": "/usr/bin/python"
  },
  "changed": false,
  "ping": "pong"
}</pre> <p>Note that using the bastion server becomes transparent – you can automate with Ansible as if you were on the same flat network. If you have access to a Cisco IOS-based device, you should be able to run a similar command against the <code>bastion_routers</code> group and achieve similarly positive results.</p>
<p>Now that you have learned the necessary steps to set environment variables for network devices and access them with Ansible, even when they are on isolated networks, let’s learn how to set conditional s<a id="_idTextAnchor444"/>t<a id="_idTextAnchor445"/>atements for networking devices.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor446"/>Custom conditional statements for networking devices</h1>
<p>Although <a id="_idIndexMarker628"/>there are no networking-specific Ansible <a id="_idIndexMarker629"/>conditionals, conditionals frequently come into play in networking-related Ansible usage.</p>
<p>In networking, it’s common to enable and disable ports. To have data be able to pass through the cable, both ports at the ends of the cable should be enabled, resulting in a connected state (some vendors will use different names for this, but the idea is the same).</p>
<p>Let’s suppose we have two Arista Networks EOS devices, and we issued the ON status on the ports and need to wait for the connection to be up before proceeding.</p>
<p>To wait for the <code>Ethernet4</code> interface to be enabled, we will need to add the following task to our playbook:</p>
<pre class="source-code">
- name: Wait for interface to be enabled
  arista.eos.eos_command:
    commands:
    - show interface Ethernet4 | json
    wait_for:
    - "result[0].interfaces.Ethernet4.interfaceStatus eq connected"</pre> <p><code>arista.eos.eos_command</code> is the module that allows us to issue free-formed commands to an Arista Networks EOS device. The command itself needs to be specified in an array in the <code>commands</code> option. With the <code>wait_for</code> option, we can specify a condition and Ansible will reiterate on the specified task until the condition is satisfied. Since the command’s output is redirected to the <code>json</code> utility, the output will be a JSON, so we can traverse its structure using Ansible’s ability to manipulate JSON data.</p>
<p>We can achieve<a id="_idIndexMarker630"/> similar results on Cumulus<a id="_idIndexMarker631"/> VX – for example, we can query the facts gathered from the switch to see whether the <code>swp2</code> port is enabled. If it is not, then we will enable it; however, if it is enabled, we will skip the command. We can do this with a simple playbook, as follows:</p>
<pre class="source-code">
---
- name: Simple play to demonstrate conditional on Cumulus Linux
  hosts: cumulusvx
  tasks:
  - name: Enable swp2 if it is disabled
    community.network.nclu:
      commands:
      - add int swp2
    commit: true
    when: not ansible_swp2.active</pre> <p>Notice the use of the <code>when</code> clause in our task, meaning we should only issue the configuration directive if <code>swp2</code> is not active. If we were to run this playbook for the first time on an unconfigured Cumulus Linux switch, we should see an output similar to the following:</p>
<pre class="console">
PLAY [Simple play to demonstrate conditional on Cumulus Linux] ***************************************************************
TASK [Gathering Facts]
***************************************************************
ok: [vx01.example.org]
TASK [Enable swp2 if it is disabled] ***************************************************************
changed: [vx01.example.org]
PLAY RECAP
***************************************************************
vx01.example.org : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>As we<a id="_idIndexMarker632"/> can see, the <code>Enable swp2</code> task, if it <a id="_idIndexMarker633"/>is disabled based on the <code>community.network.nclu</code> module, returned a <code>changed</code> state, which means that it changed the switch configuration. However, if we were to run the playbook a second time, the output should be more like this:</p>
<pre class="console">
PLAY [Simple play to demonstrate conditional on Cumulus Linux] ***************************************************************
TASK [Gathering Facts]
***************************************************************
ok: [vx01.example.org]
TASK [Enable swp2 if it is disabled] ***************************************************************
skipping: [vx01.example.org]
PLAY RECAP
***************************************************************
vx01.example.org : ok=1 changed=0 unreachable=0 failed=0 skipped=1 rescued=0 ignored=0</pre> <p>This<a id="_idIndexMarker634"/> time, the task was skipped as the<a id="_idIndexMarker635"/> Ansible facts show that the <code>swp2</code> port is already enabled. This example is elementary, but it shows how you can work with conditionals on a network device, as you have already seen conditionals being used on Linux servers earlier in this book.</p>
<p>That concludes our brief look at network device automation with Ansible – more in-depth work would require a look at network configurations and necessitate more hardware, which is beyond the scope of this book. However, I hope this information demonstrates that Ansible can be used effectively to automate and c<a id="_idTextAnchor447"/>o<a id="_idTextAnchor448"/>nfigure a wide array of network devices.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor449"/>Summary</h1>
<p>Modern large-scale infrastructures that change rapidly necessitate the automation of network tasks. Fortunately, Ansible supports a wide array of network devices, from proprietary hardware such as Cisco IOS-based devices, to open standards such as white box switches that run operating systems such as Cumulus Linux. Ansible is a powerful and supportive tool to manage your network configuration and allows you to implement changes quickly and safely. You can even replace entire devices in your network and be confident in your ability to put the correct configuration on the new device, thanks to your Ansible playbooks.</p>
<p>In this chapter, you learned about the reasons for automating network management. You then looked at how Ansible manages network devices, how to enable network automation in Ansible, and how to locate the Ansible modules necessary to perform the automation tasks you wish to complete. Then, through practical examples, you learned how to connect to network devices, set environment variables (and connect to isolated networks via bastion hosts), and apply conditional statements to Ansible tasks for network device configuration.</p>
<p>In the next chapter, we will learn how to manage Linux containers<a id="_idTextAnchor450"/> <a id="_idTextAnchor451"/>and cloud infrastructures using Ansible.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor452"/>Questions</h1>
<ol>
<li>Which of these is NOT one of the four major connection types that Ansible uses for connecting to network devices?<ol><li><code>netconf</code></li><li><code>network_cli</code></li><li><code>local</code></li><li><code>netstat</code></li><li><code>httpapi</code></li></ol></li>
<li>True or false: The <code>ansible_network_os</code> variable is used by Ansible to understand the device family of the device we are going to use.<ol><li>True</li><li>False</li></ol></li>
<li>True or false: To connect to an IOS router in a separate network, you need to specify the special connection variables for the host, possibly<a id="_idTextAnchor453"/> <a id="_idTextAnchor454"/>as inventory group variables.<ol><li>True</li><li>False</li></ol></li>
</ol>
<h1 id="_idParaDest-157"><a id="_idTextAnchor455"/>Further reading</h1>
<p>The official documentation about Ansible networking is available here: <a href="https://docs.ansible.com/ansible/latest/network/index.xhtml">https://docs.ansible.com/ansible/latest/network/index.xhtml</a>.</p>
</div>
</div></body></html>