- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Alternative Infrastructure-as-Code Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the final chapter of our **Infrastructure as Code** (**IaC**) journey!
    By now, you should be familiar with the basics of IaC and have gained hands-on
    experience with Terraform and Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you progress in your career, being aware of and adept with tools in the
    market is crucial. This chapter aims to expand your IaC toolset by introducing
    you to three additional tools: **Pulumi**, **Azure Bicep**, and **AWS CloudFormation**.'
  prefs: []
  type: TYPE_NORMAL
- en: While the previous tools we explored were cloud-agnostic, Azure Bicep and AWS
    CloudFormation are specific to their respective cloud providers. On the other
    hand, Pulumi sets itself apart by enabling you to use familiar programming languages
    such as Python to define and manage your infrastructure in actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a hands-on understanding of Pulumi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting hands-on knowledge of Azure Bicep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting hands-on expertise in AWS CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before discussing the next steps in your IaC journey, as we have a lot to cover
    in this chapter, let’s dive straight in and discuss Pulumi, which is, at the time
    of writing, the new kid on the block when it comes to IaC tools.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available here: [https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting hands-on with Pulumi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So, what is Pulumi, and why has it yet to be mentioned up* *until now?*'
  prefs: []
  type: TYPE_NORMAL
- en: Pulumi is an open source IaC platform that allows developers to define, provision,
    and manage cloud infrastructure; however, rather than using a descriptive language
    with YAML (Ansible) or HCL (Terraform), it allows you to use popular programming
    languages such as JavaScript, TypeScript, Python, Go, and C#, as well as YAML
    for non-programmers.
  prefs: []
  type: TYPE_NORMAL
- en: With Pulumi, you can build, manage, and deploy IaC more familiarly and expressively,
    making it easier to reason about complex cloud architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Pulumi supports popular cloud providers such as AWS, Azure, and Google Cloud.
    There is also support for tools such as Kubernetes, among others, all of which
    enable you to define and manage resources across multiple platforms using a single
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Great, you may be thinking to yourself – but why hasn’t it been mentioned until
    now?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that it should be considered something other than a beginner’s
    tool – given the number of different ways you can interact with it, it can be
    highly complex. It would require a dedicated book to do more than scratch the
    surface.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Links to the instructions on installing Pulumi can be found in the *Further
    reading* section at the end of this chapter if you would like to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an idea of how you would use Pulumi, let’s look at launching a few
    resources in Microsoft Azure, as we did in the early examples of Terraform and
    Ansible we covered; we will be creating a resource group and a storage account.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by using YAML and then look at the same deployment in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pulumi and YAML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two files, both of which can be found in the GitHub repository accompanying
    this book. The first file, which defines some environment-specific configurations,
    is called `Pulumi.dev.yaml` and, for our example, contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all we are doing is defining the default `location` to be used
    by the Azure Native provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second of the two files is called `Pulumi.yaml`, and it starts by defining
    some information and settings for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines, `name`, `runtime`, and `description`, all define some
    basic meta information about our deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The following two lines define the output, which in our case will be the primary
    key of the storage account that will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are defining an output variable of `primaryStorageKey`, which is taking
    its value from a variable we will define at the end; this variable will contain
    the outpoint of a function we will be running once the storage account has been
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the basics in place, let’s define the resources using a resource
    block, starting with the Azure Resource Group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is not too dissimilar structurally from Terraform and Ansible
    – here, we are defining a resource that will be referred to as `resourceGroup`,
    which has a type of `azure-native:resources:ResourceGroup`, before finally setting
    a single property that contains the `resourceGroupName` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Resource Group has been defined, we can add the storage account
    resource, which we are going to refer to as `sa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, it follows the same pattern as before; we set the resource reference
    and the type of resource we want to create and then define our `properties`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, rather than the name of the resource, which Pulumi will create
    for us, we are passing in a `sku` name, the kind of storage account we want to
    create (via `kind`), and the `resourceGroupName` key to add the resource.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we must use the `${resourceGroup.name}` variable, which takes the
    name of the resource group we referenced as `resourceGroup`. Like in Terraform,
    this ensures that the resource group is created before the storage account.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the `Pulumi.yaml` file sets the `storageAccountKeys` variable,
    which is used by the output section we start at the start of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to define a `variables` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are setting the function (`fn`), which is an `azure-native` one that
    deals with `storage` and is called `listStorageAccountKeys`. It requires two inputs
    – `accountName`, which we pass in using `${sa.name}` and, as most things need
    in Azure, the `resourceGroupName` key. So, as before, we pass this in programmatically
    by using the `${``resourceGroup.name}` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all of the code, let’s launch the resources. To do this, we
    need to issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where things get a little different than Terraform and Ansible; the
    first thing that happens is that you are asked to log in, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Running Pulumi up for the first time](img/Figure_9.01_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Running Pulumi up for the first time
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the onscreen prompts and press the *Enter* key to be taken to the login
    page. Here, you can sign up or log in using one of the many supported identity
    providers; I used GitHub. Once you have logged in or signed up, you should get
    the option to create a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Time to create a stack](img/Figure_9.02_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Time to create a stack
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your stack, Pulumi will run a check against your code
    and give you the option to deploy the update. In this case, this is going to create
    three resources – the two in Azure and our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_9.03_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Should we run the update?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the arrow keys to select **yes** and then hit the *Enter* key, Pulumi
    will deploy the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The deployment has been completed](img/Figure_9.04_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The deployment has been completed
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding output, we have the output (which I have blurred
    out the value of) and an overview of the deployment. The eagle-eyed among you
    may have also noticed a URL – clicking on it opens an overview of the deployment
    in your browser. For me, this looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Viewing the deployment in a browser](img/Figure_9.05_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Viewing the deployment in a browser
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend having a look around your stack in the browser. Once you have finished,
    you can remove the resources by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will remove the Azure resources but not the stack on the Pulumi website.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at deploying the same resources again, but instead of using
    YAML, we will use Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pulumi and Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This, as you may have already guessed, is where things start to get a little
    more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the repository that accompanies the book, you will find several files; these
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.gitignore`: This contains entries for the `venv` and `__pycache__` folders,
    which we do not need to check into version control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__main__.py`: This is the main Python code; we will cover this in more detail
    shortly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pulumi.dev.yaml`: This contains the environment config and has the same contents
    as we used YAML rather than Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pulumi.yaml`: This contains the basic metadata for our deployment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.txt`: Like most Python scripts, there are external dependencies;
    this file lists these so that they can be installed using `pip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the `requirements.txt` file. As mentioned, this contains
    the dependencies needed to run our Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are just two dependencies – Pulumi and the Azure Native
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, we have the `Pulumi.yaml` file. Even though we are using
    Python, it contains the basic information and settings for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `runtime` is now `python`, and some settings define the folder
    where the Python virtual environment (`virtualenv`) will be stored. In our case,
    this is `venv` and is in the same folder as the rest of our project files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final file is the `__main__.py` file and is where our resources are defined.
    The first part of the file imports the Python libraries needed to deploy the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, of the two dependencies defined in the `requirements.txt` file,
    we are importing all of the `pulumi` library; however, `storage` and `resources`
    from the `pulumi_azure_native` library as the Resource Group and storage account,
    respectively, are the only two resources that we are launching. Therefore, we
    do not need to load the entire library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we must define the Resource Group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I wouldn’t call myself a Python programmer – I know enough to be dangerous and
    run the basics – but I am sure you will agree that the code looks simple enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define the storage account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, it is a little different from what we dealt with when defining our infrastructure
    in YAML or HCL.
  prefs: []
  type: TYPE_NORMAL
- en: But again, it is simple enough to follow what is going on within the code, mainly
    as we have already deployed this same project using Pulumi and YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also means you should have an idea of what is coming up next – that is,
    the function to grab the storage account key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is where things turn a little more into a traditional Python script; it
    is still relatively straightforward to follow what is going on but if, like me,
    you are not a Python developer, you may find it a little more challenging to write
    the preceding code from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try deploying the code. To do this, we simply use the same command as
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice some differences when you first run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Installing the dependencies](img/Figure_9.06_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Installing the dependencies
  prefs: []
  type: TYPE_NORMAL
- en: As you may have already guessed, first, the dependencies defined in the `requirements.txt`
    file must be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our dependencies have been installed, we drop back to the same options
    as we were presented with when we deployed the YAML version of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Back in familiar territory](img/Figure_9.07_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Back in familiar territory
  prefs: []
  type: TYPE_NORMAL
- en: Again, you get a URL to view your stack on the Pulumi website, and you can terminate
    the resources by running the `pulumi` `destroy` command.
  prefs: []
  type: TYPE_NORMAL
- en: So, why do this?
  prefs: []
  type: TYPE_NORMAL
- en: Most of the audience for this book, I imagine, comes from an operations or system
    administration background rather than a programming one – this means you are more
    familiar with working with configuration files of all types and understand the
    steps you need to take to deploy your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Pulumi aims to appeal to people from that background as well as developers by
    offering them a way of defining their infrastructure in a language that is familiar
    to them; as you may recall from the start of this section, JavaScript, TypeScript,
    Python, Go, and C# are all supported.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that you can move your IaC into your existing build and
    deployment pipelines. For example, let’s say you have a mature C# build, test,
    and deployment workflow. If you are using Pulumi, you should be able to introduce
    your IaC into the process quickly.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the start of this section, we have yet to begin to unlock the
    power of Pulumi in this section – but I am sure you will agree that it opens up
    many possibilities when approaching your IaC deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the last of the cloud-agnostic tools, let’s look
    at the two cloud-native tools before we finish.
  prefs: []
  type: TYPE_NORMAL
- en: Getting hands-on knowledge of Azure Bicep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure Bicep** is the first of the two cloud-specific IaC tools we will be
    looking at in this chapter. For quite a while, if you wanted to use the native
    tool provided by Microsoft, you would need to write an ARM template.'
  prefs: []
  type: TYPE_NORMAL
- en: When we discussed Microsoft Azure in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, we stated that ARM is short for Azure Resource
    Manager – that is, the API that powers all of Azure. You will have been using
    ARM when using the Azure portal, command-line tools, PowerShell, or any IaC tool
    we have covered to launch or manage your Microsoft Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: The best way I can think to describe ARM templates is that they are the JSON
    payloads that are sent to the API – I won’t include an example of what an ARM
    template looks like as there is a lot of it, but I have included an example file
    called `arm-template-example.json` in the same folder as the Bicep file in the
    accompanying repository. As you can see, there is a lot of it; the file is just
    short of 120 lines of code – and all that does is define a storage account.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have provided a quick explanation of ARM templates, let’s look
    at Bicep.
  prefs: []
  type: TYPE_NORMAL
- en: Bicep is a `main.bicep`.
  prefs: []
  type: TYPE_NORMAL
- en: Working through the Bicep file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of our Bicep code sets the parameters, of which we are going
    to set three up, starting with the type of storage account we will be launching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, here, we provide an array of the `allowed` possible values before
    defining a parameter (`param`) called `storageAccountType` with a string value
    of `Standard_LRS`. This means that if we override the default parameter at runtime,
    it will only accept one of the allowed parameters rather than just any old string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second and third parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The former sets the `location` parameter by inheriting the location of the
    Resource Group; we also use the ID of the Resource Group to generate a unique
    string for the storage account’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `uniqueString` function takes the Resource Group ID, which in itself is
    unique to your deployment, and uses that to generate a string. This means that
    you know a consistent string is being generated rather than a random string each
    time the Bicep code is executed. However, as it is based on the Resource Group
    ID that is unique to your deployment, you should never have two strings that are
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have defined our three parameters, we can add the code to create
    the storage account resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block to do this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a `resource` block that is going to be referred to as
    `sa`; it uses the `Microsoft.Storage/storageAccounts@2022-09-01` API endpoint.
    We are also passing in the parameters for `name`, `location`, and `sku`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final two lines of code set some output, which is the storage account name
    and the ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that’s something missing… have you guessed what it is?
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Bicep file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you guessed the following, then you would be correct:'
  prefs: []
  type: TYPE_NORMAL
- en: “*Hang on a minute; we are referencing a Resource Group, but we are not defining
    a block* *for one.*”
  prefs: []
  type: TYPE_NORMAL
- en: By default, both Bicep and ARM templates expect you to deploy into a resource
    rather than have one defined within the Bicep file.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that you may have noticed is that I haven’t given any instructions
    on how to install Azure Bicep.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is that Bicep is built into the Azure CLI, which we will
    also use to create a resource group. Do this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When I ran the command, I got the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will create a resource group called `rg-bicep-example` in the UK
    South region, which we can now deploy our Bicep file into by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output quite a bit of information, but the two import bits we are
    interested in are the outputs. For me, these looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `storageAccountId` and `storageAccountName` are visible.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The following command deletes the whole resource group and everything within
    it, so please be careful and only run if you want everything to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove the resources we launched with Bicep by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Again, this section wasn’t planned to be a deep dive into Bicep; I wanted to
    give a basic example to show you how IaC tools are not just limited to the “big
    two” of Terraform and Ansible. We have yet to come close to scratching the surface
    of what is possible with Bicep.
  prefs: []
  type: TYPE_NORMAL
- en: Since Microsoft first launched the alpha release of Bicep in August 2020, it
    has quickly grown and become a first-class citizen within the Azure ecosystem;
    for example, all of the official Azure documentation now includes references to
    and examples of both ARM templates and Bicep code for launching and interacting
    with your Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as we have experienced, it is built directly into the Azure CLI, meaning
    you already have it at your disposal if you are already working with Microsoft
    Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss why you should use Bicep over one of the other tools, let’s
    look at the other cloud-native option – AWS CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting hands-on with AWS CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS CloudFormation** is a service provided by Amazon Web Services that enables
    you to manage and provision your AWS resources using templates.'
  prefs: []
  type: TYPE_NORMAL
- en: Of all the tools we have looked at in this book, AWS CloudFormation is the oldest,
    with its original public release in May 2010\. Also, in the description, I described
    it as a service that uses templates – this all makes the approach slightly different
    than the other tools we have covered.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation uses JSON or YAML templates to describe your desired AWS resources
    and their configurations. These templates define a stack, which is a collection
    of related resources that can be created, updated, or deleted together.
  prefs: []
  type: TYPE_NORMAL
- en: It provides automatic rollback and drift detection capabilities to help you
    maintain the desired state of your infrastructure. CloudFormation can automatically
    revert to the previous working state if a stack update fails. Drift detection
    allows you to identify and correct discrepancies between the actual infrastructure
    and the desired state defined in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Also, before deploying a stack, you can estimate the cost of the resources defined
    in your template. Additionally, you can use tags to categorize and track costs
    associated with specific resources, projects, or environments.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at deploying a single Amazon S3 bucket using both the AWS command
    line and the AWS Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudFormation template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s look at the template file we will be using. I prefer to use YAML
    over JSON as it is much easier to read and follow what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: The template we will be using is split into four small sections. The template
    is a small 20-line file; I have seen templates containing several hundred lines
    of code, so this is the most basic example we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start of the template contains some basic information, including a description
    of what the template does and which format to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must set some `Parameters`; in our case, this is just going to be
    `BucketName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the resources, where we define our S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must set an output that returns the name of the bucket we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are some differences in how parameters are referenced;
    I am not a fan of using syntax such as `!Ref BucketName` only because the other
    tools, all of which came after, use a similar way of referencing parameters/variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our template, let’s look at using the AWS CLI to deploy the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Using the AWS CLI to deploy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AWS CLI makes it easy to deploy our template. To deploy the S3 bucket,
    run the following command, making sure you update the name of the bucket at the
    end of the command to your own. This is because bucket names need to be unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once deployed, you should get some output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have just deployed the stack but not the resources – the stack, which is
    an AWS service, will be deploying those for you in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the stack we just launched and the resources managed by it, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what creating a stack in the AWS Management Console looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Using the AWS Management Console to deploy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once logged into the AWS Management Console, go to CloudFormation and click
    the **Create** **stack** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step of creating a stack is to define your template. Since you already
    have one, ensure that **Template is ready** is selected. Then, select the **Upload
    a template file** option and press the **Choose file** button to upload your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Completing step one](img/Figure_9.08_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Completing step one
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to provide some details about the stack and update any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Entering details of the stack](img/Figure_9.09_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Entering details of the stack
  prefs: []
  type: TYPE_NORMAL
- en: Step three is where you configure options for the stack; here, you can define
    tags and permissions and control the actions taken should a deployment fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our deployment, you can leave all of the options at their defaults – however,
    I recommend that you review them before clicking on the **Next** button to proceed
    to the final step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Reviewing the stack options](img/Figure_9.10_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Reviewing the stack options
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to review your stack before clicking the **Submit** button,
    triggering the stack’s creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Reviewing the deployment](img/Figure_9.11_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Reviewing the deployment
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can review your resources. Once you have finished, clicking on
    **Delete** will remove the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that you will have noticed is that there are some sample templates,
    as well as a template designer. Loading one of the samples into the designer gives
    you a graphical view of the template and a drag-and-drop interface that you can
    use to design your templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Designing your template](img/Figure_9.12_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Designing your template
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are options to export your finished template as JSON or
    YAML; in our example, there are just over 700 lines of code in the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: This is the biggest reason you want to use the designer and AWS Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudFormation can quickly become very complex, and it doesn’t lend itself
    well to sitting in front of an empty file and starting to code – I find it very
    overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we looked at three additional IaC tools, all of which
    work slightly differently from the two primary tools we looked at in previous
    chapters. So, why would you choose these over Terraform or Ansible?
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19537_02.xhtml#_idTextAnchor085), *Ansible and Terraform beyond
    the Documentation*, we concluded that you should choose the best tool for the
    job rather than trying to fit your project to the tool; the same goes for the
    tools we have discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When planning your IaC project, having an excellent working knowledge of more
    than one tool is always a bonus; throughout this book, there have been occasions
    when either Terraform or Ansible hasn’t supported a task we were trying to perform,
    so we had to use the built-in tools that provide support for the target cloud’s
    API.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a project in Azure, for example, where coverage for the latest services
    in the tools may be behind by several months, then using Azure Bicep may be the
    best choice as you know you are exclusively targeting Azure; Bicep has day 1 support
    for 99.9% of all new Azure services.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, you may have to work alongside developers who want to bring your deployments
    into their existing processes and procedures; therefore, using Pulumi may be more
    suitable than introducing one of the other tools.
  prefs: []
  type: TYPE_NORMAL
- en: So, what should your immediate next steps be?
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have access to a lab or a free cloud account. In that case, I recommend
    choosing a typical deployment and working through the steps covered in the first
    three chapters to define your project and then execute your IaC project.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting, ensure you know what your end deployment will look like and
    how it needs to be configured. From there, you should be able to break it down
    into tasks, which will give you an idea of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an idea of the tasks and dependencies, this should allow you to
    work out the order in which the tasks would need to be executed – this is where
    you should choose which tool to use. However, you shouldn’t do this before as
    you need to know if you need a decorative or imperative tool and you must know
    the compatibility and service support each tool would need for your deployment
    to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Once you know what it is you are deploying, in which order, and using which
    tool, you can open a blank file and start to write your code.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend writing some code and doing a test deployment – to deal with any
    issues – and then terminating the resources once you have resolved the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Do not leave it to the end to try and debug your code. Also, ensure that when
    you do test deployments, you remove them – otherwise, you may end up introducing
    dependency issues into your deployments as resources may already exist, and therefore
    any issues or errors within your code may not reveal themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Expect a lot of trial and error, especially if you are new to IaC deployments.
    Many considerations may not be completely apparent if you are used to deploying
    resources using the Azure portal or AWS Management Console, as these interfaces
    take a lot of the heavy lifting from you and do quite a bit of work in the background
    to make the process of launching your resources as smooth as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once you have something up and running, make sure you show as many
    people as possible, give them access to your code if appropriate – show them it
    being deployed, try and sell them on the benefits of taking an IaC approach to
    their projects, and be as supportive as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for allowing me to accompany you on this journey; I wish you every
    success with your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pu[lumi:](https://www.pulumi.com/docs/get-started/install/)
  prefs: []
  type: TYPE_NORMAL
- en: '[Download and installation instructions:](https://www.pulumi.com/docs/get-started/install/)
    https://www.pulumi.com/docs/get-started/install/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with Azure: [https://www.pulumi.com/docs/get-started/azure/](https://www.pulumi.com/docs/get-started/azure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with AWS: [https://www.pulumi.com/docs/get-started/aws/](https://www.pulumi.com/docs/get-started/aws/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Importing your infrastructure and converting your existing IaC: [https://www.pulumi.com/docs/guides/adopting/](https://www.pulumi.com/docs/guides/adopting/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Bicep:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bicep overview: [https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download and install: [https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn Bicep Live: [https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/](https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS CloudFormation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Product page: [https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Full documentation: [https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
