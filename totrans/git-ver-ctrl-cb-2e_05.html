<html><head></head><body>
        

                            
                    <h1 class="header-title">Storing Additional Information in Your Repository</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Adding your first Git note</li>
<li>Separating notes by category</li>
<li>Retrieving notes from the remote repository</li>
<li>Pushing Git notes to a remote repository</li>
<li>Tagging commits in the repository</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Git is powerful in many ways. One of the most powerful features of Git is that it has immutable history. This is powerful because nobody can squeeze something into the history of Git without it being noticed by the people who have cloned the repository. This also causes some challenges for developers, as some would like to change the commit messages after a commit has been released. This is possible in many other version control systems, but because of the immutable history with Git, it has Git notes. A Git note is essentially an extra <kbd>refs/notes/commits</kbd> reference in Git. Here, you add additional information to the commits that can be displayed when running a <kbd>git log</kbd> command. You can also release the notes into a remote repository so that people can fetch the notes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding your first Git note</h1>
                
            
            
                
<p>We will add some extra information to the already released code. If we were doing it in the actual commits, we would see the commit hashes change.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before we start, we need a repository to work in; you can use the previous clone of <kbd>jgit</kbd>, but to get an output from the example that's almost identical, you can clone the <kbd>jgit</kbd> repository as follows:</p>
<pre style="padding-left: 30px"><strong>$ git clone https://git.eclipse.org/r/jgit/jgit chapter5</strong>
<strong>$ cd chapter5</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We start by creating a local branch, <kbd>notesMessage</kbd>, tracking <kbd>origin/stable-3.2</kbd>.<br/>
Then, we will try and change the commit message and see that the commit hash changes:</p>
<ol>
<li>Checkout the branch <kbd>notesMessage</kbd> tracking <kbd>origin/stable-3.2</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b notesMessage  --track origin/stable-3.2</strong>
<strong>Branch notesMessage set up to track remote branch stable-3.2 from origin.</strong>
<strong>Switched to a new branch 'notesMessage'</strong></pre>
<ol start="2">
<li>List the commit hash of the <kbd>HEAD</kbd> of your branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit f839d383e6fbbda26729db7fd57fc917fa47db44</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Wed Dec 18 21:16:13 2013 +0100</strong>
    
<strong>    Prepare post 3.2.0 builds</strong>
    
<strong>    Change-Id: Ie2bfdee0c492e3d61d92acb04c5bef641f5f132f</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong></pre>
<ol start="3">
<li>Change the commit message by amending the commit using <kbd>git commit --amend</kbd>, and, following that, add a line above the <kbd>Change-Id:</kbd> line with <kbd>Update MANIFEST files</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --amend</strong></pre>
<ol start="4">
<li>Now, we list the commit again and see that the commit hash has changed:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit 5ccc9c90d29badb1bd860d29860715e0becd3d7b</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Wed Dec 18 21:16:13 2013 +0100</strong>
    
<strong>    Prepare post 3.2.0 builds</strong>
    
<strong>    Update MANIFEST files<br/></strong>
<strong>    Change-Id: Ie2bfdee0c492e3d61d92acb04c5bef641f5f132f</strong>
<strong>    Signed-off-by: Matthias Sohn matthias.sohn@sap.com</strong></pre>
<ol start="5">
<li>Notice that the commit parts have changed from <kbd>f839d383e6fbbda26729db7fd57fc917fa47db44</kbd> to <kbd>9fcaa153c4afc6ee95572a58ddfa297f60b7e1cf</kbd>, as the commit is derived from the content in the commit, the parents of the commit, and the commit message. So, the commit hash will change when updating the commit message. Since we have changed the content of the <kbd>HEAD</kbd> commit, we are no longer based on the <kbd>HEAD</kbd> commit of the <kbd>origin/stable-3.2</kbd> branch. This becomes visible in <kbd>gitk</kbd> and <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong>
<strong>On branch notesMessage</strong>
<strong>Your branch and 'origin/stable-3.2' have diverged,</strong>
<strong>and have 1 and 1 different commit each, respectively.</strong>
<strong>(use "git pull" to merge the remote branch into yours)</strong>
    
<strong>nothing to commit, working directory clean</strong></pre>
<ol start="6">
<li>As you can see from the output, our branch has diverged from <kbd>origin/stable-3.2</kbd>; this is also visible from <kbd>gitk</kbd>. Note that we can specify which branches and commits we want to see with <kbd>gitk</kbd>. In this case, we want to see <kbd>origin/stable-3.2</kbd> and <kbd>HEAD</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>$ gitk origin/stable-3.2 HEAD</strong> </pre>
<p class="mce-root" style="padding-left: 60px">The following is the screenshot for this:</p>
<div><img class="alignnone size-full wp-image-211 image-border" src="img/c750e1d1-0166-48e5-bf5f-ea32aa1d6f6e.png" style="width:27.08em;height:14.17em;"/></div>
<ol start="7">
<li>To prevent this result, we can add a note to the commit message.<br/>
Let's start by resetting the branch to <kbd>origin/stable-3.2</kbd> and then adding a note to the commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard origin/stable-3.2</strong>
<strong>HEAD is now at f839d38 Prepare post 3.2.0 builds</strong></pre>
<ol start="8">
<li>Now, add the same message as the previous one, but just as a note:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes add -m "Update MANIFEST files"</strong></pre>
<ol start="9">
<li>We have added the note directly from the command line without invoking the editor by using the <kbd>-m</kbd> flag and then a message. The log will now be visible when running <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
    
<strong>commit f839d383e6fbbda26729db7fd57fc917fa47db44</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Wed Dec 18 21:16:13 2013 +0100</strong>
    
<strong>    Prepare post 3.2.0 builds</strong>
    
<strong>    Change-Id: Ie2bfdee0c492e3d61d92acb04c5bef641f5f132f</strong>
    <strong>Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>Notes:</strong>
    <strong>Update MANIFEST files</strong></pre>
<ol start="10">
<li>As you can see from the log output, we have a <kbd>Notes:</kbd> section with our note. Although it does not add the note directly in the commit message as the <kbd>--amend</kbd> option does, we still have our important addition to the commit message. We can verify with <kbd>git status</kbd> that we have no longer diverged:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong>
<strong>On branch notesMessage</strong>
<strong>Your branch is up-to-date with 'origin/stable-3.2'.</strong>
    
<strong>nothing to commit, working directory clean</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>So, you have your notes for your commit and now you want to add to them. You will perhaps expect that you just add the note again with more information. This is not the case. You have the option to append, edit, or force the note to be created:</p>
<ol>
<li>Start by trying to add the note again with additional information:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes add -m "Update MANIFESTS files for next version"</strong>
<strong>error: Cannot add notes. Found existing notes for object f839d383e6fbbda26729db7</strong>
<strong>fd57fc917fa47db44. Use '-f' to overwrite existing notes</strong></pre>
<ol start="2">
<li>As predicted, we cannot add the note but we can do it with the <kbd>-f</kbd> flag:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes add -f -m "Update MANIFESTS files for next version"</strong>
<strong>Overwriting existing notes for object f839d383e6fbbda26729db7fd57fc917fa47db44</strong></pre>
<ol start="3">
<li>Git overwrites the existing notes due to the <kbd>-f</kbd> flag. You can also use <kbd>--force</kbd>, which is the same. Verify it with <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit f839d383e6fbbda26729db7fd57fc917fa47db44</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Wed Dec 18 21:16:13 2013 +0100</strong>
    
 <strong>   Prepare post 3.2.0 builds</strong>
    
    <strong>Change-Id: Ie2bfdee0c492e3d61d92acb04c5bef641f5f132f</strong>
    <strong>Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>Notes:</strong>
   <strong>Update MANIFESTS files for next version</strong></pre>
<ol start="4">
<li>You can also append a current note with <kbd>git notes append</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes append -m "Verified by John Doe"</strong></pre>
<ol start="5">
<li>There is no output from this unless something goes wrong, but you can verify this by using <kbd>git log</kbd> again. To keep the output to a minimum, we are using <kbd>--oneline</kbd>. This will show a minimum output of the commit. But to show the note, we have to add <kbd>--notes</kbd>, which will show the notes for the commits in the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1 --notes --oneline</strong>
<strong>f839d38 Prepare post 3.2.0 builds</strong>
<strong>Notes:</strong>
<strong>    Update MANIFESTS files for next version</strong>
    
<strong>    Verified by John Doe</strong></pre>
<ol start="6">
<li>As we can see from the output, we have the line appended to the note. If you try to use the <kbd>edit</kbd> option, you will see that you can only use this with the <kbd>-m</kbd> flag. This makes good sense, as you should edit the note and not overwrite or append an already created note:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes edit -m "John Doe"</strong>
<strong>The -m/-F/-c/-C options have been deprecated for the 'edit' subcommand.</strong>
<strong>Please use 'git notes add -f -m/-F/-c/-C' instead.</strong></pre>
<ol start="7">
<li>In other words, Git rejects editing the note and mentions other ways of doing it.</li>
</ol>
<p>The <kbd>git notes add</kbd> and <kbd>git notes edit</kbd> commands without any arguments will do exactly the same, that is, open the configured editor and allow you to write a note to the commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Separating notes by category</h1>
                
            
            
                
<p>As we saw in the previous example, we can add notes to the commits; however, in some cases, it makes sense to store the information sorted by categories, such as <kbd>featureImplemented</kbd>, <kbd>defect</kbd>, and <kbd>alsoCherryPick</kbd>. As briefly explained at the beginning of the chapter, notes are stored in <kbd>refs/notes/commits</kbd>, but we can add multiple references so that we can easily sort and list the various scopes of the notes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To start this example, we need a new branch that tracks the <kbd>origin/stable-3.1</kbd> branch; we name the branch <kbd>notesReferences</kbd>, and create and checkout the branch with the following command:</p>
<pre><strong>$ git checkout -b notesReferences --track origin/stable-3.1</strong>
<strong>Branch notesReferences set up to track remote branch stable-3.1 from origin.</strong>
<strong>Switched to a new branch 'notesReferences'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Imagine a situation where we have corrected a defect and did everything we could to ensure the quality of the commit before releasing it. Nonetheless, we had to make another fix for the same defect.</p>
<p>So, we want to add a note to the reference <kbd>refs/notes/alsoCherryPick</kbd>, which should indicate that if you cherry-pick this commit, you should also cherry-pick the other commits as they fix the same defect.</p>
<p>In this example, we will find the commit and add some extra information to the commit in multiple notes' reference specifications:</p>
<ol>
<li>Start by listing the top 10 commits on the branch so we have something to copy and paste from:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -10 --oneline</strong>
<strong>da6e87b Prepare post 3.1.0 builds</strong>
<strong>16ca725 JGit v3.1.0.201310021548-r</strong>
<strong>c6aba99 Fix order of commits in rebase todo file header</strong>
<strong>5a2a222 Prepare post 3.1.0 RC1 builds</strong>
<strong>6f0681e JGit v3.1.0.201309270735-rc1</strong>
<strong>a065a06 Attempt to fix graph layout when new heads are introduced</strong>
<strong>b4f07df Prepare re-signing pgm's ueberjar to avoid SecurityException</strong>
<strong>aa4bbc6 Use full branch name when getting ref in BranchTrackingStatus</strong>
<strong>570bba5 Ignore bitmap indexes that do not match the pack checksum</strong>
<strong>801aac5 Merge branch 'stable-3.0'</strong></pre>
<ol start="2">
<li>Add a note for the <kbd>da6e87bc3</kbd> commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes add -m "test note"</strong></pre>
<ol start="3">
<li>Now, to add a note for the <kbd>b4f07df</kbd> commit in the ref <kbd>alsoCherryPick</kbd>, we must use the <kbd>--ref</kbd> option for <kbd>git notes</kbd>. This has to be specified before the <kbd>add</kbd> option:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes --ref alsoCherryPick add -m "570bba5" b4f07df</strong></pre>
<ol start="4">
<li>No output indicates success while adding notes. Now that we have a note, we should be able to list it with a single <kbd>git log -1</kbd> command. However, this is not the case. You actually need to specify that you want to list the notes from the specific ref. This can be done with the <kbd>--notes=alsoCherryPick</kbd> option for <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1 b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a --notes=alsoCherryPick</strong>
<strong>commit b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Tue Sep 24 09:11:47 2013 +0200</strong>
    
<strong>    Prepare re-signing pgm's ueberjar to avoid SecurityException</strong>
<strong>More output...</strong>
<strong>    Change-Id: Ia302e68a4b2a9399cb18025274574e31d3d3e407</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>Notes (alsoCherryPick):</strong>
<strong>   570bba5</strong></pre>
<ol start="5">
<li>As you see from the output, Git shows the <kbd>alsoCherryPick</kbd> notes. Git defaults to adding notes to <kbd>refs/notes/commits</kbd>, but we have explicitly specified to show <kbd>alsoCherryPick</kbd>. It would be nice if you could show the <kbd>alsoCherryPick</kbd> notes' reference by default so you don't have to use <kbd>--notes=alsoCherryPick</kbd>. This can be done by configuring Git as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config notes.displayRef "refs/notes/alsoCherryPick"</strong></pre>
<ol start="6">
<li>By configuring this option, you are telling Git to always list these notes. But what about the default notes? Have we overwritten the configuration to list the default <kbd>refs/notes/commits</kbd> notes? We can check this with <kbd>git log -1</kbd> to see if we still have the test note displayed:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit da6e87bc373c54c1cda8ed563f41f65df52bacbf</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Thu Oct 3 17:22:08 2013 +0200</strong>
    
<strong>    Prepare post 3.1.0 builds</strong>
    
<strong>    Change-Id: I306a3d40c6ddb88a16d17f09a60e3d19b0716962</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>Notes:</strong>
<strong>    test note</strong></pre>
<ol start="7">
<li>No, we did not overwrite the setting to list notes in the default refs. Knowing that we can have as many <kbd>notes.displayRef</kbd> configurations as we want, we should add all the refs we want to use in our repository. In some situations, it is even better to just add <kbd>refs/notes/*</kbd>. This will configure Git to show all the notes:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config notes.displayRef 'refs/notes/*'</strong></pre>
<ol start="8">
<li>If we now add another note in <kbd>refs/notes/defect</kbd>, we should be able to list it without specifying which notes' reference we want to list when using <kbd>git log</kbd>. We are adding to the commit that already has a note in the <kbd>alsoCherryPick</kbd> reference:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes --ref defect add -m "Bug:24435" b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong></pre>
<ol start="9">
<li>Now, list the commit with <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1 b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong>
<strong>commit b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Tue Sep 24 09:11:47 2013 +0200</strong>
    
<strong>    Prepare re-signing pgm's ueberjar to avoid SecurityException</strong>
<strong>    See http://dev.eclipse.org/mhonarc/lists/jgit-dev/msg02277.html</strong>
    
<strong>    Change-Id: Ia302e68a4b2a9399cb18025274574e31d3d3e407</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>Notes (alsoCherryPick):</strong>
<strong>    570bba5</strong>
    
<strong>Notes (defect):</strong>
<strong>    Bug:24435</strong></pre>
<ol start="10">
<li>Git shows both notes, which is what we would expect.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have been discussing the <kbd>refs/notes/alsoCherryPick</kbd> reference and so on. As you know, we refer to the remote branches as references, such as <kbd>refs/remotes/origin/stable-3.2</kbd>, but the local branches also have references such as <kbd>refs/heads/develop</kbd>, for instance.</p>
<p>Since you can create a branch that starts at a specific reference, you should be able to create a branch that starts at the <kbd>refs/notes/alsoCherrypick</kbd> reference:</p>
<ol>
<li>Create a branch that starts from <kbd>refs/notes/alsoCherryPick</kbd>. Also, checkout the branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b myNotes notes/alsoCherryPick</strong>
<strong>Switched to a new branch 'myNotes'</strong></pre>
<ol start="2">
<li>The <kbd>myNotes</kbd> branch now points to <kbd>HEAD</kbd> on <kbd>refs/notes/alsoCherryPick</kbd>. Listing the files on the branch will show a file with the commit hash of the commit we have added the notes to:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ls</strong>
<strong>b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong></pre>
<ol start="3">
<li>Showing the file content will show the text we used as note text:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cat b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong>
<strong>570bba5</strong></pre>
<ol start="4">
<li>As you can see, the abbreviated commit hash <kbd>570bba5</kbd> we added as a note for <kbd>b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</kbd> is in the file. If we had a longer message, that message would also be shown here.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrieving notes from the remote repository</h1>
                
            
            
                
<p>So far, we have been creating notes in our own local repository, which is fine. But if we want to share those notes, we have to be sure to be able to push them. We would also like to be able to retrieve other people's notes from the remote repository. Unfortunately, this is not so simple.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before we can start, we need another clone from the local clone we already have. This is to show the push and fetch mechanism of Git with <kbd>git notes</kbd>:</p>
<ol>
<li>Start by checking out the master branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout master</strong>
<strong>Checking out files: 100% (1529/1529), done.</strong>
<strong>Switched to branch 'master'</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong></pre>
<ol start="2">
<li>Now, create a local branch of all the <kbd>stable-3.1</kbd> branches:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch stable-3.1 origin/stable-3.1</strong>
<strong>Branch stable-3.1 set up to track remote branch stable-3.1 from origin.</strong></pre>
<ol start="3">
<li>We are checking out all these branches because we want to clone this repository and, by default, all the <kbd>refs/heads/*</kbd> branches will be cloned. So, when we clone the <kbd>chapter5</kbd> directory, you will see that we only get the branches we see if you execute <kbd>git branch</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch</strong>
<strong>* master</strong>
<strong>myNotes</strong>
<strong>notesMessage</strong>
<strong>notesReference</strong>
<strong>stable-3.1</strong></pre>
<ol start="4">
<li>Now, go one directory up so that you can create your new clone from the <kbd>chapter5</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ..</strong>
<strong>$ git clone ./chapter5 shareNotes</strong>
<strong>Cloning into 'shareNotes'...</strong>
<strong>done.</strong></pre>
<ol start="5">
<li>Now, enter the <kbd>shareNotes</kbd> directory and run <kbd>git branch -a</kbd> to see that the only remote branches we have are the branches we checked out as local branches in the <kbd>chapter5</kbd> directory. After this, we are ready to fetch some notes:</li>
</ol>
<pre style="padding-left: 60px"><strong>$</strong> <strong>cd shareNotes</strong>
<strong>$ git branch -a</strong>
<strong>* master</strong>
<strong>remotes/origin/HEAD -&gt; origin/master</strong>
<strong>remotes/origin/master</strong>
<strong>remotes/origin/myNotes</strong>
<strong>remotes/origin/notesMessage</strong>
<strong>remotes/origin/notesReference</strong>
<strong>remotes/origin/stable-3.1</strong></pre>
<ol start="6">
<li>As predicted, the list matches the Git branch output from the <kbd>chapter5</kbd> directory.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We have now prepared the setup for pushing and fetching notes. The challenge is that Git is not a default setup for retrieving and pushing notes, and hence you won't usually see other people's notes:</p>
<ol>
<li>We start by showing that we did not receive the notes during the clone:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1 b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a --notes=alsoCherryPick</strong>
<strong>warning: notes ref refs/notes/alsoCherryPick is invalid</strong>
<strong>commit b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Tue Sep 24 09:11:47 2013 +0200</strong>
    
<strong>    Prepare re-signing pgm's ueberjar to avoid SecurityException</strong></pre>
<ol start="2">
<li>As expected, the output does not show the note, and the first line makes it clear why. In the <kbd>chapter5</kbd> directory, we will see the note. To enable the notes to be fetched, we need to create a new fetch rule configuration; it needs to be similar to the fetch rule for <kbd>refs/heads</kbd>. Take a look at the configuration from <kbd>git config</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --get remote.origin.fetch</strong>
<strong>+refs/heads/*:refs/remotes/origin/* </strong></pre>
<ol start="3">
<li>This shows that we are fetching <kbd>refs/heads</kbd> into the <kbd>refs/remotes/origin</kbd> reference, but what we also want to do is fetch <kbd>refs/notes/*</kbd> into <kbd>refs/notes/*</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --add remote.origin.fetch '+refs/notes/*:refs/notes/*'</strong></pre>
<ol start="4">
<li>You should now have it configured. If you leave out the <kbd>--add</kbd> option from your command, you will overwrite your current settings. Verify that the rule now exists:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --get-all  remote.origin.fetch</strong>
<strong>+refs/heads/*:refs/remotes/origin/*</strong>
<strong>+refs/notes/*:refs/notes/*</strong></pre>
<ol start="5">
<li>Now, try and fetch the notes:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fetch</strong>
<strong>From /tmp/chapter5</strong>
<strong>* [new ref] refs/notes/alsoCherryPick -&gt; refs/notes/alsoCherryPick<br/>* [new ref] refs/notes/commits -&gt; refs/notes/commits<br/>* [new ref] refs/notes/defect -&gt; refs/notes/defect</strong></pre>
<ol start="6">
<li>As the Git output indicates, we have received some new refs. So, let's check whether we have the note on the commit now:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1 b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a --notes=alsoCherryPick</strong>
<strong>commit b4f07df357fccdff891df2a4fa5c5bd9e83b4a4a</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Tue Sep 24 09:11:47 2013 +0200</strong>

<strong>    Prepare re-signing pgm's ueberjar to avoid SecurityException</strong>
<strong>More output...</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Notes (alsoCherryPick):</strong>
<strong>    570bba5</strong></pre>
<ol start="7">
<li>We now have the notes in our repository, which is what we expected.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We fetched the notes. The reason why it works is because of the way we fetched them. By default, Git is configured to fetch <kbd>refs/heads/*</kbd> into <kbd>refs/remotes/origin/*</kbd>. This way, we can easily keep track of what is remote and what is local. The branches in our local repository are in <kbd>refs/heads/*</kbd>. These branches are also listed when you execute <kbd>git branch</kbd>.</p>
<p>For notes, we need to fetch <kbd>refs/notes/*</kbd> into <kbd>refs/notes/*</kbd> since we want to get the notes from the server and use them with the <kbd>git show</kbd>, <kbd>git log</kbd>, and <kbd>git notes</kbd> Git commands.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pushing Git notes to a remote repository</h1>
                
            
            
                
<p>We have, successfully, tried to retrieve the notes from the remote repository, but what about your notes? How can you push them to the server? This has to be done with the push command just as with any other references, such as branches and commits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Before we can push the notes from the <kbd>shareNotes</kbd> repository, we have to create a note to be pushed, as the notes we have now are all available on the remote repository. The remote repository in this case is the <kbd>chapter5</kbd> directory:</p>
<ol>
<li>You have found a commit you would like to add a note to, and you want to add the note to the <kbd>verified</kbd> reference:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git notes --ref verified add -m "Verified by john.doe@example.com" 871ee53b52a</strong></pre>
<ol start="2">
<li>Now that we have added the note, we can list it with the <kbd>git log</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --notes=verified -1 871ee53b52a</strong>
<strong>commit 871ee53b52a7e7f6a0fe600a054ec78f8e4bff5a</strong>
<strong>Author: Robin Rosenberg &lt;robin.rosenberg@dewire.com&gt;</strong>
<strong>Date:   Sun Feb 2 23:26:34 2014 +0100</strong>
    
<strong>    Reset internal state canonical length in WorkingTreeIterator when moving</strong>
    
<strong>    Bug: 426514</strong>
<strong>    Change-Id: Ifb75a4fa12291aeeece3dda129a65f0c1fd5e0eb</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>Notes (verified):</strong>
<strong>    Verified by john.doe@example.com</strong></pre>
<ol start="3">
<li>As expected, we can see the note. If you cannot see the note, you probably missed <kbd>--notes=verified</kbd> for the <kbd>git log</kbd> command, since we have not configured <kbd>verified</kbd> as <kbd>notes.displayRef</kbd>. To push the note, we must use the <kbd>git push</kbd> command, because the default push rule in Git is to push branches to <kbd>refs/heads/&lt;branchname&gt;</kbd>.</li>
</ol>
<p style="padding-left: 60px">So, if we just try to push the note to the remote, nothing happens:</p>
<pre style="padding-left: 60px"><strong>$ git push</strong>
<strong>Everything up-to-date</strong></pre>
<ol start="4">
<li>You will probably see a warning about <kbd>git push.default</kbd> not being configured; you can safely ignore this for these examples. The important part is that Git shows that everything is up-to-date. But we know we have created a Git note for a commit. So, to push these notes, we need to push our note references to the remote notes, references. This can be done as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git push origin refs/notes/*</strong>
<strong>Counting objects: 3, done.</strong><br/><strong>Delta compression using up to 4 threads.</strong><br/><strong>Compressing objects: 100% (2/2), done.</strong><br/><strong>Writing objects: 100% (3/3), 294 bytes | 294.00 KiB/s, done.</strong><br/><strong>Total 3 (delta 0), reused 0 (delta 0)</strong><br/><strong>To /Users/kneth/tmp/./chapter5</strong><br/><strong> * [new branch] refs/notes/verified -&gt; refs/notes/verified<br/></strong></pre>
<ol start="5">
<li>Now, something happened; we have a new branch on the remote named <kbd>refs/notes/verified</kbd>. This is because we have pushed the notes to the remote. What we can do in order to verify it is go to the <kbd>chapter5</kbd> directory and check whether the <kbd>871ee53b52a</kbd> commit has a Git note:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ../chapter5/</strong>
<strong>$ git log --notes=verified -1 871ee53b52a</strong>
<strong>commit 871ee53b52a7e7f6a0fe600a054ec78f8e4bff5a</strong>
<strong>Author: Robin Rosenberg &lt;robin.rosenberg@dewire.com&gt;</strong>
<strong>Date:   Sun Feb 2 23:26:34 2014 +0100</strong>
    
<strong>    Reset internal state canonical length in WorkingTreeIterator when moving</strong>
    
<strong>    Bug: 426514</strong>
<strong>    Change-Id: Ifb75a4fa12291aeeece3dda129a65f0c1fd5e0eb</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>Notes (verified):</strong>
<strong>    Verified by john.doe@example.com</strong></pre>
<ol start="6">
<li>As predicted, we can see the note in this directory.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Since Git notes do not work as normal branches, it can be a little cumbersome to push them back and forth to a repository when you are trying to collaborate on them. Since you cannot just fetch and merge the Git notes branches as easily as with other branches, a clear recommendation is to build some tools to add these notes so that you only have one server adding the notes.</p>
<p>A simple, but value adding, note could be information about Jenkins builds and testing. This can be valuable when you have to reopen a defect. You can then actually see in the repository which tests were executed on the commit hash.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tagging commits in the repository</h1>
                
            
            
                
<p>If you are releasing software with Git, you are bound to deal with tags. Tags describe the different software releases in the repository. There are two types of tags, a lightweight tag and an annotated tag. The lightweight tag is very similar to a branch, since it is just a named reference, such as <kbd>refs/tags/version123</kbd> . This points to the commit hash of the commit you are tagging; whereas if it were a branch, it would be <kbd>refs/heads/version123</kbd>. The difference is that the branch moves forward when you work and commit to it. A tag will always point to the same commit hash. We will discuss the annotated tag shortly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before we start, you must go to the <kbd>chapter5</kbd> directory, where we made the original clone<br/>
for this chapter.</p>
<p>We should start by tagging the commit that is ten commits behind <kbd>origin/stable-2.3</kbd> and is not a merge. In order to find that commit, we will use the <kbd>git log</kbd> command.</p>
<p>For the <kbd>git log</kbd> command, we are using the <kbd>--no-merges</kbd> option, which will show commits that only have one parent. The <kbd>--oneline</kbd> option we have used before tells Git to limit the output to one line per commit. Moreover, <kbd>-11</kbd> shows us the last 11 commits (10 commits before the latest).</p>
<p>Find the commit as follows:</p>
<pre><strong>$ </strong><strong>git checkout stable-2.3 </strong><br/><strong>$ git log -11 --no-merges --oneline</strong>
<strong>49ec6c1 Prepare 2.3.2-SNAPSHOT builds</strong>
<strong>63dcece JGit v2.3.1.201302201838-r</strong>
<strong>3b41fcb Accept Change-Id even if footer contains not well-formed entries</strong>
<strong>5d7b722 Fix false positives in hashing used by PathFilterGroup</strong>
<strong>9a5f4b4 Prepare post 2.3.0.201302130906 builds</strong>
<strong>19d6cad JGit v2.3.0.201302130906</strong>
<strong>3f8ac55 Replace explicit version by property where possible</strong>
<strong>1c4ee41 Add better documentation to DirCacheCheckout</strong>
<strong>e9cf705 Prepare post 2.3rc1 builds</strong>
<strong>ea060dd JGit v2.3.0.201302060400-rc1</strong>
<strong>60d538f Add getConflictingNames to RefDatabase</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Now that we have found the <kbd>60d538f</kbd> commit, we should make it a lightweight tag:</p>
<ol>
<li>Use the <kbd>git tag</kbd> command to give a meaningful release name:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git tag 'v2.3.0.201302061315rc1' ea060dd</strong></pre>
<ol start="2">
<li>Since there is no output, it is a success. To see whether the tag is available, use the <kbd>git tag</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git tag -l "v2.3.0.2*"</strong>
<strong>v2.3.0.201302061315rc1</strong>
<strong>v2.3.0.201302130906</strong></pre>
<ol start="3">
<li>We are using the <kbd>git tag</kbd> command with <kbd>-l</kbd> as a flag, since we want to list the tags and not tag the current <kbd>HEAD</kbd>. Some repositories have a lot of tags; so to prevent the list from becoming too long, you can specify which tags you want to list and use a <kbd>*</kbd> wildcard as we did previously. Our tag is available, but all it really says is that we have a tag in the repository with the name <kbd>v2.3.0.201302061315rc1</kbd>, and if you are using <kbd>git show v2.3.0.201302061315rc1</kbd>, you will see that the output is the same as <kbd>git show ea060dd</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show v2.3.0.201302061315rc1</strong>
<strong>commit ea060dd8e74ab588ca55a4fb3ff15dd17343aa88</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Wed Feb 6 13:15:01 2013 +0100</strong>
    
<strong>       JGit v2.3.0.201302060400-rc1</strong>
    
<strong>    Change-Id: Id1f1d174375f7399cee4c2eb23368d4dbb4c384a</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>diff --git a/org.eclipse.jgit.ant.test/META-INF/MANIFEST.MF b/org.eclipse.jgit.a <br/>... More output</strong>
    
<strong>$ git show ea060dd</strong>
<strong>commit ea060dd8e74ab588ca55a4fb3ff15dd17343aa88</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Wed Feb 6 13:15:01 2013 +0100</strong>
    
<strong>        JGit v2.3.0.201302060400-rc1</strong>
    
<strong>    Change-Id: Id1f1d174375f7399cee4c2eb23368d4dbb4c384a</strong>
<strong>    Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>diff --git a/org.eclipse.jgit.ant.test/META-INF/MANIFEST.MF b/org.eclipse.jgit.a<br/>... More output<br/></strong></pre>
<ol start="4">
<li>There will also be a lot of file diff information in the output, but it is exactly the same output. So, in order to add more information, we should use an annotated tag. An annotated tag is a tag where you have to add some information to the tag. To create an annotated tag, we use the <kbd>--annotate</kbd> tag for the <kbd>git tag</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git tag --annotate -m "Release Maturity rate 97%" 'v2.3.0.201409022257rc2' 1c4ee41</strong></pre>
<ol start="5">
<li>The <kbd>-m</kbd> flag is the same as <kbd>--message</kbd>, as we want to give the tag a message. If you leave out the <kbd>-m</kbd> flag, Git will open the configured editor and you can write a full release note into the annotation of the tag. We can check the tag information with <kbd>git show</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show 'v2.3.0.201409022257rc2'</strong>
<strong>tag v2.3.0.201409022257rc2</strong>
<strong>Tagger: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Sun Feb 9 22:58:28 2014 +0100</strong>
    
<strong>Release Maturity rate 97%</strong>
    
<strong>commit 1c4ee41dc093266c19d4452879afe5c0f7f387f4</strong>
<strong>Author: Christian Halstrick christian.halstrick@sap.com<br/>... More output<br/></strong></pre>
<ol start="6">
<li>We can actually see the tag name and information we added with the <kbd>-m</kbd> flag. With the lightweight tag, we don't see anything about the tag from the output. We actually don't even see the tag name when using <kbd>git show</kbd> on a lightweight tag.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Tags are very powerful as they can add valuable information to the repository, and since tags should be considered official releases in the repository, we should be very careful when working with them.</p>
<p>Naturally, you can push the tags to a remote area, and contributors to the repository would fetch those tags. This is where you have to be careful. With a legacy version control system, you can go back in time and just change the release, and since these legacy systems are all based on a centralized server where you have to be connected in order to work, changing a release is not that bad, since not so many people use the release or have even downloaded the release. But it is different in Git. If you change a tag that you have already pushed to point to another commit hash, then those developers who have already fetched the tag will not get the new tag unless they delete the tag locally:</p>
<ol>
<li>To prove the dangers of not getting a new tag, we will try to delete a tag and recreate it to point to another commit hash:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git tag -d v1.3.0.201202121842-rc4</strong>
<strong>Deleted tag 'v1.3.0.201202121842-rc4' (was d1e8804)</strong></pre>
<ol start="2">
<li>Now that we have deleted the tag, we are ready to recreate the tag again to<br/>
point to <kbd>HEAD</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git tag -a -m "Local created tag" v1.3.0.201202121842-rc4</strong></pre>
<ol start="3">
<li>We have recreated the tag, and it points to <kbd>HEAD</kbd> because we did not specify a commit hash at the end of the command. Now, execute <kbd>git fetch</kbd> to see whether you can get the tag overwritten from the remote repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fetch</strong></pre>
<ol start="4">
<li>Since there is no output, the tag was probably not overwritten. Let's verify with<br/>
<kbd>git show</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show v1.3.0.201202121842-rc4</strong>
<strong>tag v1.3.0.201202121842-rc4</strong>
<strong>Tagger: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Wed May 2 16:27:25 2018 +0200</strong>
    
<strong>Local created tag</strong>
    
<strong>commit 1c4ee41dc093266c19d4452879afe5c0f7f387f4</strong></pre>
<ol start="5">
<li>As you can see from the output, it is still our locally created tag. To get the tag from the remote again, we need to delete the local tag and do a <kbd>git fetch</kbd>. To delete a tag, you need to apply the <kbd>-d</kbd> flag:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git tag -d v1.3.0.201202121842-rc4</strong>
<strong>Deleted tag 'v1.3.0.201202121842-rc4' (was 28be24b)</strong>
<strong>$ git fetch</strong>
<strong>From https://git.eclipse.org/r/jgit/jgit</strong>
<strong>* [new tag]       v1.3.0.201202121842-rc4 -&gt; v1.3.0.201202121842-rc4</strong></pre>
<ol start="6">
<li>As you can see, Git has fetched the tag from the server again. We can verify<br/>
with <kbd>git show</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git show v1.3.0.201202121842-rc4</strong>
<strong>tag v1.3.0.201202121842-rc4</strong>
<strong>Tagger: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Mon Feb 13 00:57:56 2012 +0100</strong>
    
<strong>JGit 1.3.0.201202121842-rc4</strong>
<strong>-----BEGIN PGP SIGNATURE-----</strong>
<strong>Version: GnuPG/MacGPG2 v2.0.14 (Darwin)</strong>
  
    <strong>iF4EABEIAAYFAk84UhMACgkQWwXM3hQMKHbwewD/VD62MWCVfLCYUIEz20C4Iywx</strong>
    <strong>4OOl5TedaLFwIOS55HcA/ipDh6NWFvJdWK3Enm2krjegUNmd9zXT+0pNjtlJ+Pyi</strong>
    <strong>=LRoe</strong>
<strong>-----END PGP SIGNATURE-----</strong>
    
<strong>commit 53917539f822afa12caaa55db8f57c29570532f3</strong></pre>
<ol start="7">
<li>So, as you can see, we have the correct tag again, but it should also be a warning. Once you have pushed a tag to a remote repository, you should never change it, since the developers who are fetching from the repository may never know about the changes unless they clone again or delete the tags locally and fetch them again.</li>
</ol>
<p>In this chapter, we learned how you can tag your commits and add notes to them. These are powerful methods for storing additional information after a commit has been committed and published to a shared repository. But before you actually publish your commit, you have the chance to add the most valuable information for a commit. The commit message is where you must specify what you are doing and sometimes why you are doing it.</p>
<p>If you are solving a bug, you should list the bug ID; if you are using a special method to solve the problem, it is recommended that you describe why you have used this awesome technique to solve the problem. So, when people look back on your commits, they can also learn a few things about why different decisions were made.</p>


            

            
        
    </body></html>