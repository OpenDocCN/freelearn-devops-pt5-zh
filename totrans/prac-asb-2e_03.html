<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor158"/>3</h1>
<h1 id="_idParaDest-48"><a id="_idTextAnchor159"/>Defining Your Inventory</h1>
<p>As we discussed in the preceding two chapters, Ansible cannot do anything until you tell it which hosts it is responsible for. This is, of course, logical—you wouldn’t want any automation tool, regardless of how easy it is to use and set up, to simply go out and take control of every single device on your network. Hence, at the bare minimum, you must tell Ansible what hosts it is going to automate tasks on, and this, in the most fundamental terms, is what an inventory is.</p>
<p>However, there is so much more to inventories than just a list of automation targets. Ansible inventories can be provided in several formats; they can be either static or dynamic, and they can contain important variables that define how Ansible interacts with each host (or groups of hosts). Hence, they deserve a chapter to themselves, and in this chapter, we shall perform a practical exploration of inventories and how to use them to your best advantage as you automate your infrastructure with Ansible.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating an inventory file and adding hosts</li>
<li>Generating a dynamic inventory file</li>
<li>Special host management using patterns<a id="_idTextAnchor160"/></li>
</ul>
<h1 id="_idParaDest-49"><a id="_idTextAnchor161"/>Technical requirements</h1>
<p>This chapter assumes that you have set up your control host with Ansible, as detailed in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, and you are using the most recent version available—the examples in this chapter were tested with Ansible 8.0 and <code>ansible-core</code> 2.15.0. This chapter also assumes that you have at least one additional host to test against, and this should be Linux-based. Although we will give specific examples of hostnames in this chapter, you are free to substitute them with your own hostnames and/or IP addresses, and details of how to do this will be provided in the appropriate places.</p>
<p>The code bundle for this chapter is available here: <a href="https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%203">https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%203</a>.<a id="_idTextAnchor162"/></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor163"/>Creating an inventory file and adding hosts</h1>
<p>Whenever you see a reference to “<em class="italic">creating an inventory</em>” in Ansible, you are normally quite safe to assume<a id="_idIndexMarker189"/> that it is a static inventory. Ansible supports two types of inventory—static and dynamic—and we will cover the latter of these two later in this chapter. Static inventories are by their very nature static; they are unchanging unless a human manually edits them. This is great when you are starting out and testing Ansible, as it provides you with a very quick and easy way to get up and running quickly. Even in small, closed environments, static inventories are a great way to manage your environment, especially when changes to the infrastructure are infrequent.</p>
<p>Most Ansible installations will look for a default inventory file in <code>/etc/ansible/hosts</code> (though this path is configurable in the Ansible configuration file, as discussed in <a href="B20846_02.xhtml#_idTextAnchor099"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Fundamentals of Ansible</em>). You are welcome to populate this file or to provide your own inventory for each playbook run, and it is commonplace to see inventories provided alongside playbooks—after all, when you start to build them out with variables and groupings, they become a code asset just as your playbooks and roles do, so it makes sense to commit them to source control alongside your other automation code. As you will have seen in the earlier chapters of this book, Ansible commands use the <code>-i</code> flag to specify the location of the inventory file if not using the default. We’ve already seen examples of this in this book, but as a refresher, this might look like the following example:</p>
<pre class="console">
$ ansible -i /home/cloud-user/inventory all -m ansible.builtin.ping</pre> <p>Most static inventory files you will come across are created in INI format, though it is important to note that other formats are supported. The most common format you will find after INI-formatted files are YAML ones—more details of the types of inventory files you can work with may be found here:<a id="_idTextAnchor164"/> <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.xhtml">https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.xhtml</a>.</p>
<p>In this chapter, we will provide some examples of both INI and YAML formatted inventory files for you to consider, as you must have an awareness of both. Personally, I have worked with Ansible for many years and only worked with either INI-formatted files or dynamic inventories, but they say knowledge is power and so it will do no harm to learn a little about both formats.</p>
<p>Let’s start by creating a <a id="_idIndexMarker190"/>static inventory file. This inventory file will be separate from the default inventory.</p>
<p>Create an inventory file in <code>/etc/ansible/my_inventory</code> using the following INI-formatted code<a id="_idTextAnchor165"/>:</p>
<pre class="source-code">
target1.example.org ansible_host=192.168.81.142 ansible_port=3333
target2.example.org ansible_port=3333 ansible_user=james
target3.example.org ansible_host=192.168.81.143 ansible_port=5555</pre> <p>The blank lines between inventory hosts are not required—they have been inserted simply to make the inventory more readable in this book. This inventory file is very simple and does not include any grouping; however, when referencing the inventory, you can still refer to all the hosts together using the special <code>all</code> group, which is implicitly defined regardless of how you format and divide your inventory file.</p>
<p>Each line in the preceding file contains one inventory host. The first column contains the inventory hostname that Ansible will use (which can be accessed through the <code>inventory_hostname</code> magic variable we discussed in <a href="B20846_02.xhtml#_idTextAnchor099"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Fundamentals of Ansible</em>). All the parameters on the same line after that are variables that are assigned to the host. These can be user-defined variables or special Ansible variables, as we have set here.</p>
<p>There are many such variables, but the preceding examples specifically include the following:</p>
<ul>
<li><code>ansible_host</code>: If the inventory hostname cannot be accessed directly—perhaps because it is not in DNS, for example—this variable contains the hostname or IP address that Ansible will connect to instead</li>
<li><code>ansible_port</code>: By default, Ansible attempts all communication over port <code>22</code> for SSH—if you have an SSH daemon running on another port, you can tell Ansible about it using this variable</li>
<li><code>ansible_user</code>: By default, Ansible will attempt to connect to the remote host using the current user account you are running the Ansible command from—you can override this in several ways, of which this is one</li>
</ul>
<p>Hence, the preceding<a id="_idIndexMarker191"/> three hosts can be summarized as follows:</p>
<ul>
<li>The <code>target1.example.org</code> host should be connected to using the <code>192.168.81.142</code> IP address, on port <code>3333</code></li>
<li>The <code>target2.example.org</code> host should be connected to on port <code>3333</code> also, but this time, using the <code>james</code> user rather than the account running the Ansible command</li>
<li>The <code>target3.example.org</code> host should be connected to using the <code>192.168.81.143</code> IP address, on port <code>5555</code></li>
</ul>
<p>In this way, even with no further constructs, you can begin to see the power of static INI-formatted inventories.</p>
<p>Now, if you wanted to create exactly the same inventory as the preceding, but this time, format it as YAML, you would specify it as follows (we’ll call this file <code>my_inventory.yaml<a id="_idTextAnchor166"/></code>):</p>
<pre class="source-code">
---
ungrouped:
  hosts:
    target1.example.org:
      ansible_host: 192.168.81.142
      ansible_port: 3333
    target2.example.org:
      ansible_port: 3333
      ansible_user: james
    target3.example.org:
      ansible_host: 192.168.81.143
      ansible_port: 5555</pre> <p>You may come across inventory file examples containing parameters such as <code>ansible_ssh_port</code>, <code>ansible_ssh_host</code>, and <code>ansible_ssh_user</code>—these variable names (and others like them) were used in Ansible versions before 2.0. Backward compatibility has been maintained for many of these, but you should update them where possible as this compatibility may be removed at some point in the future.</p>
<p>Now, if you were to<a id="_idIndexMarker192"/> run the preceding inventory within Ansible using a simple <code>ansible.builtin.shell</code> command, the result would appear as follows<a id="_idTextAnchor167"/>:</p>
<pre class="console">
$ ansible -i /etc/ansible/my_inventory.yaml all -m ansible.builtin.shell -a 'echo hello-yaml' -f 5
target1.example.org | CHANGED | rc=0 &gt;&gt;
hello-yaml
target2.example.org | CHANGED | rc=0 &gt;&gt;
hello-yaml
target3.example.org | CHANGED | rc=0 &gt;&gt;
hello-yaml</pre> <p>That covers the basics of creating a simple static inventory file. Let’s now expand upon this by adding host groups to the inventory in the next part of this chap<a id="_idTextAnchor168"/>t<a id="_idTextAnchor169"/>er.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor170"/>Using host groups</h2>
<p>There is rarely <a id="_idIndexMarker193"/>one playbook that will suit an entire infrastructure, and although it is easy to tell Ansible to use an alternate inventory for a different playbook, this could get very messy, very quickly, with potentially hundreds of small inventory files dotted around your network. You can imagine how quickly this would get unmanageable, and Ansible is supposed to make things more manageable, not the opposite. One possible simple solution to this is to start adding groups to your inventories.</p>
<p>Let’s assume you have a simple three-tier web architecture, with multiple hosts in each tier for high availability and/or load<a id="_idIndexMarker194"/> balancing. The three tiers in this architecture might be the following:</p>
<ul>
<li>Frontend servers</li>
<li>Application servers</li>
<li>Database servers</li>
</ul>
<p>With this architecture set out, let’s set about creating an inventory for it, again mixing up the YAML and INI formats to give you experience in both. To keep the examples clear and concise, we’ll assume that you can access<a id="_idIndexMarker195"/> all servers using their <strong class="bold">Fully Qualified Domain Names</strong> (<strong class="bold">FQDNs</strong>), and hence won’t add any host variables in these inventory files. There is nothing to stop you from doing this, of course, and every example is different.</p>
<p>First of all, let’s create the inventory for the three-tier frontend using the INI format. We will call this file <code>hostsgroups-ini</code>, and the contents of this file should look something like<a id="_idTextAnchor171"/> this:</p>
<pre class="source-code">
loadbalancer.example.org
[frontends]
web01.example.org
web02.example.org
[apps]
app01.example.org
app02.example.org
[databases]
db01.example.org
db02.example.org</pre> <p>In the preceding inventory, we have created three groups, called <code>frontends</code>, <code>apps</code>, and <code>databases</code>. Note that, in INI-formatted inventories, group names go inside square braces. Under each group name goes the server names that belong to each group, so the preceding example shows two servers in each group. Notice the outlier at the top, <code>loadbalancer.example.org</code>—this host isn’t in any group. All ungrouped hosts must go at the very top of an INI-formatted file.</p>
<p>Before we proceed any<a id="_idIndexMarker196"/> further, it’s worth noting that inventories can also contain groups of groups, which is incredibly useful for processing certain tasks by a different division. The preceding inventory stands in its own right, but what if our frontend servers are built on Ubuntu, and the app and database servers are built on Fedora? There will be some fundamental differences in the ways we handle these hosts—for example, we might use the <code>ansible.builtin.apt</code> module to manage packages on Ubuntu and the <code>ansible.builtin.dnf</code> module on Fedora.</p>
<p>We could, of course, handle this case using facts gathered from each host as these will contain the operating system details. We could also create a new version of the inventory, as follows:</p>
<pre class="source-code">
loadbalancer.example.org
[frontends]
web01.example.org
web02.example.org
[apps]
app01.example.org
app02.example.org
[databases]
db01.example.org
db02.examp<a id="_idTextAnchor172"/>le.org
[fedora:children]
apps
databases
[ubuntu:children]
frontends</pre> <p>With the use of the <code>children</code> keyword in the group definition (inside the square braces), we can create groups of groups; hence, we can perform clever groupings to help our playbook <a id="_idIndexMarker197"/>design without having to specify each host more than once.</p>
<p>This structure in INI format is quite readable but takes some getting used to when it is converted into YAML format. The code listed next shows the YAML version of the preceding inventory—the two are identical as far as Ansible is concerned, but it is left to you to decide which format you prefer working with:</p>
<pre class="source-code">
all:
  hosts:
    loadbalancer.example.org:
  children:
    fedora:
      children:
        apps:
          hosts:
            app01.example.org:
            app02.example.org:
        databases:
          hosts:
            db01.example.org:
            db02.example.org:
    ubuntu:
      children:
        frontends:
          hosts:
            web01.example.org:
            web02.example.org:</pre> <p>You can see that the <code>children</code> keyword is still used in the YAML-formatted inventory, but now the structure is more hierarchical than it was in the INI format. The indentation might be easier for <a id="_idIndexMarker198"/>you to follow, but note how the hosts are ultimately defined at quite a high level of indentation—this format could be more difficult to extend, depending on your desired approach.</p>
<p>When you want to work with any of the groups from the preceding inventory, you would simply reference it either in your playbook or on the command line. Extending our previous example, we can run the following:</p>
<pre class="console">
$ ansible -i hostgroups-yaml all -m ansible.builtin.shell -a 'echo hello-yaml' -f 5</pre> <p>Note the <code>all</code> keyword in the middle of that line. That is the special <code>all</code> group that is implicit in all inventories and is explicitly mentioned in your previous YAML example. If we wanted to run the same command, but this time on just the <code>fedora</code> group hosts from the previous YAML inventory, we would run this variation of the command:</p>
<pre class="console">
$ ansible -i hostgroups-yaml fedora -m ansible.builtin.shell -a 'echo hello-yaml' -f 5
app01.example.org | CHANGED | rc=0 &gt;&gt;
hello-yaml
app02.example.org | CHANGED | rc=0 &gt;&gt;
hello-yaml
db01.example.org | CHANGED | rc=0 &gt;&gt;
hello-yaml
db02.example.org | CHANGED | rc=0 &gt;&gt;
hello-yaml</pre> <p>As you can see, this is a powerful way of managing your inventory and making it easy to run commands on just the<a id="_idIndexMarker199"/> hosts you want. The possibility of creating multiple groups makes life simple, especially when you want to run different tasks on different groups of servers.</p>
<p>As an aside to developing your inventories, it is worth noting that there is a quick shorthand notation that you can use to create multiple hosts. Let’s assume you have 100 app servers, all named sequentially, as follows:</p>
<pre class="source-code">
[apps]
app01.example.org
app02.example.org
...
app99.example.org
app100.example.org</pre> <p>This is entirely possible, but would be tedious and error-prone to create by hand and would produce some very hard to read and interpret inventories. Luckily, Ansible provides a quick shorthand notation to achieve this, and the following inventory snippet actually produces an inventory with the same 100 app servers that we could create manually:</p>
<pre class="source-code">
[apps]
app[01:100].example.org</pre> <p>It is also possible to use alphabetic ranges as well as numeric ones—extending our example to add some cache servers, you might have the following:</p>
<pre class="source-code">
[cache]
cache-[a:e].example.org</pre> <p>This is the same as manually creating the following:</p>
<pre class="source-code">
[cache]
cache-a.example.org
cache-b.example.org
cache-c.example.org
cache-d.example.org
cache-e.example.org</pre> <p>Now that we’ve<a id="_idIndexMarker200"/> completed our exploration of the various static inventory formats and how to create groups (and indeed, child groups), in the next section, let’s expand on our previously brief look at hos<a id="_idTextAnchor173"/>t<a id="_idTextAnchor174"/> variables.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor175"/>Adding host and group variables to your inventory</h2>
<p>We have already touched upon host variables—we saw them earlier in this chapter when we used them<a id="_idIndexMarker201"/> to override connection details such as the user account to connect with, the address to connect to, and the port to use. However, there is so much more you can do with Ansible and inventory variables, and it is important to note that they can be defined not only at the host level but also at the group level, which again provides you with some incredibly powerful ways in which you can efficiently manage your infrastructure from one central inventory.</p>
<p>Let’s build on our previous three-tier example and suppose that we need to set two variables for each of our two frontend servers. These are not special Ansible variables but instead are variables entirely of our own choosing, which we will use later on in the playbooks that run against this server. Suppose that these variables are as follows:</p>
<ul>
<li><code>https_port</code>, which defines the port that the frontend proxy should listen on</li>
<li><code>lb_vip</code>, which defines the FQDN of the load balancer in front of the frontend servers</li>
</ul>
<p>Let’s see how this is done:</p>
<ol>
<li>We could simply add these to each of the hosts in the <code>frontends</code> part of our inventory file, just as we did before with the Ansible connection variables. In this case, a portion of our INI-formatted inventory might loo<a id="_idTextAnchor176"/>k like this:<pre class="source-code">
[frontends]
web01.example.org https_port=8443 lb_vip=lb.example.org
web02.example.org https_port=8443 lb_vip=lb.example.org</pre></li> </ol>
<p>If we run an ad hoc <a id="_idIndexMarker202"/>command against this inventory, we can see the contents of both of these variables:</p>
<pre class="source-code">
<strong class="bold">$ ansible -i hostvars1-hostgroups-ini frontends -m ansible.builtin.debug -a "msg=\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\""</strong>
<strong class="bold">web01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong>
<strong class="bold">web02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong></pre> <p>This has worked just as we desired, but the approach is inefficient as you have to add the same variables to every single host.</p>
<ol>
<li value="2">Luckily, you can assign variables to a host group as well as to hosts individually. If we edited the preceding inventory to achieve this, the <code>frontends</code> section would now lo<a id="_idTextAnchor177"/>ok like this:<pre class="source-code">
[frontends]
web01.example.org
web02.example.org
[frontends:vars]
https_port=8443
lb_vip=lb.example.org</pre></li> </ol>
<p>Notice how much<a id="_idIndexMarker203"/> more readable that is? Yet, if we run the same command as before against our newly organized inventory, we see that the result is the same:</p>
<pre class="source-code">
<strong class="bold">$ ansible -i groupvars1-hostgroups-ini frontends -m ansible.builtin.debug -a "msg=\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\""</strong>
<strong class="bold">web01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong>
<strong class="bold">web02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong></pre> <ol>
<li value="3">There will be times when you want to work with host variables for individual hosts, and times when group variables are more relevant. It is up to you to determine which is better for your scenario; however, remember that host variables can be used in combination. It is also worth noting that host variables override group variables, so if we need to change the connection port to <code>8444</code> on the <code>web01.example.org</code> one, we could do th<a id="_idTextAnchor178"/>is as follows:<pre class="source-code">
[frontends]
web01.example.org https_port=8444
web02.example.org
[frontends:vars]
https_port=8443
lb_vip=lb.example.org</pre></li> </ol>
<p>Now, if we run<a id="_idIndexMarker204"/> our ad hoc command again with the new inventory, we can see that we have overridden the variable on one host:</p>
<pre class="source-code">
<strong class="bold">$ ansible -i groupvars2-hostgroups-ini frontends -m ansible.builtin.debug -a "msg=\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\""</strong>
<strong class="bold">web01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8444"</strong>
<strong class="bold">}</strong>
<strong class="bold">web02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong></pre> <p>Of course, doing this for one host alone when there are only two might seem a little pointless, but when you have an inventory with hundreds of hosts in it, this method of overriding one host will suddenly become very valuable.</p>
<ol>
<li value="4">Just for completeness, if we were to add the host variables we defined previously to our YAML version of the inventory, the <code>frontends</code> section would appear as follows (the rest of the inventory has been removed to save space):<pre class="source-code">
frontends:
  hosts:
    web01.example.org:
      https_port: 8444
    web02.example.org:
  vars:
    https_port: 8443
    lb_vip: lb.example.org</pre></li> </ol>
<p>Running the same<a id="_idIndexMarker205"/> ad hoc command as before, you can see that the result is the same as for our INI-formatted inventory:</p>
<pre class="source-code">
<strong class="bold">$ ansible -i groupvars2-hostgroups-yaml frontends -m ansible.builtin.debug -a "msg=\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\""</strong>
<strong class="bold">web01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8444"</strong>
<strong class="bold">}</strong>
<strong class="bold">web02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong></pre> <p>So far, we have covered several ways of providing host variables and group variables to your inventory; however, there is another way that deserves special mention and will become valuable to you as your inventory becomes larger and more complex.</p>
<p>Right now, our examples are small and compact and only contain a handful of groups and variables; however, when you scale this up to a full infrastructure of servers, using a single flat inventory file could, once again, become unmanageable. Luckily, Ansible also provides a solution to this. Two specially named directories, <code>host_vars</code> and <code>group_vars</code>, are automatically searched for appropriate variable content if they exist within the playbook directory. We can test this out by recreating the preceding frontend variables example using this special directory structure, rather than putting the variables into the inventory file:</p>
<ol>
<li>Let’s start by creating a new directory structure for this purpose:<pre class="source-code">
<strong class="bold">$ mkdir vartree</strong>
<strong class="bold">$ cd vartree</strong></pre></li> <li>Now, under this directory, we’ll create two more directories for <a id="_idTextAnchor179"/>the variables:<pre class="source-code">
<code>host_vars</code> directory, we’ll create a file with the name of our host that needs the proxy setting, with <code>.yml</code> appende<a id="_idTextAnchor180"/>d to it (that is, <code>web01.example.org.yml</code>). This file should conta<a id="_idTextAnchor181"/>in the following:<pre class="source-code">
---
https_port: 8444</pre></li> <li>Similarly, under the <code>group_vars</code> directory, create a YAML file named after the group to which we want to assign variables (that is, <code>frontends.yml</code>) with the fo<a id="_idTextAnchor182"/>llowing contents:<pre class="source-code">
---
https_port: 8443
lb_vip: lb.example.org</pre></li> <li>Finally, we will create our inventory file as before, except that it contains no variables:<pre class="source-code">
loadbalancer.example.org
[frontends]
web01.example.org
web02.example.org
[apps]
app01.example.org
app02.example.org
[databases]
db01.example.org
db02.example.org</pre></li> </ol>
<p>Just for clarity, your<a id="_idIndexMarker207"/> final directory structure should look like this:</p>
<pre class="source-code">
<strong class="bold">$ tree</strong>
<strong class="bold">.</strong>
<strong class="bold">├── group_vars</strong>
<strong class="bold">│   └── frontends.yml</strong>
<strong class="bold">├── host_vars</strong>
<strong class="bold">│   └── web01.example.org.yml</strong>
<strong class="bold">└── inventory</strong>
<strong class="bold">2 directories, 3 files</strong></pre> <ol>
<li value="6">Now, let’s try running our familiar ad hoc command and see what happens:<pre class="source-code">
<strong class="bold">$ ansible -i inventory frontends -m ansible.builtin.debug -a "msg=\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\""</strong>
<strong class="bold">web01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8444"</strong>
<strong class="bold">}</strong>
<strong class="bold">web02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong></pre></li> </ol>
<p>As you can see, this works exactly as before, and without further instruction, Ansible has traversed the directory structure and ingested all the variable files.</p>
<ol>
<li value="7">If you have<a id="_idIndexMarker208"/> many hundreds of variables (or need an even finer-grained approach), you can replace the YAML files with directories named after the hosts and groups. Let’s recreate the directory structure, but now with directories instead:<pre class="source-code">
<strong class="bold">$ tree</strong>
<strong class="bold">.</strong>
<strong class="bold">├── group_vars</strong>
<strong class="bold">│   └── frontends</strong>
<strong class="bold">│       ├── https_port.yml</strong>
<strong class="bold">│       └── lb_vip.yml</strong>
<strong class="bold">├── host_vars</strong>
<strong class="bold">│   └── web01.example.org</strong>
<strong class="bold">│       └── main.yml</strong>
<strong class="bold">└── inventory</strong>
<strong class="bold">4 directories, 4 files</strong></pre></li> </ol>
<p>Notice how we now have directories named after the <code>frontends</code> group and the <code>web01.example.org</code> host? Inside the <code>frontends</code> directory, we have split the variables into two files, and this can be incredibly useful for logically organizing variables in groups, especially as your playbooks get bigger and more complex. Although we have named the variables files by the name of the variable they contain, this has been done purely to help us understand the code structure here. Each variables file may contain any number of variables, and they need not hold any relation to the filename.</p>
<p>The files themselves are simply an adaptation of our previous ones:</p>
<pre class="source-code">
<strong class="bold">$ cat host_vars/web01.example.org/main.yml</strong>
<strong class="bold">---</strong>
<strong class="bold">https_port: 8444</strong>
<strong class="bold">$ cat group_vars/frontends/https_port.yml</strong>
<strong class="bold">---</strong>
<strong class="bold">https_port: 8443</strong>
<strong class="bold">$ cat group_vars/frontends/lb_vip.yml</strong>
<strong class="bold">---</strong>
<strong class="bold">lb_vip: lb.example.org</strong></pre> <p>Even with this more<a id="_idIndexMarker209"/> finely divided directory structure, the result of running the ad hoc command is still the same:</p>
<pre class="source-code">
<strong class="bold">$ ansible -i inventory frontends -m ansible.builtin.debug -a "msg=\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\""</strong>
<strong class="bold">web01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8444"</strong>
<strong class="bold">}</strong>
<strong class="bold">web02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "msg": "Connecting to lb.example.org, listening on 8443"</strong>
<strong class="bold">}</strong></pre> <ol>
<li value="8">One final thing of note before we conclude this section is, if you define the same variable at both a <a id="_idIndexMarker210"/>group level and a child group level, the variable at the child group level takes precedence. This is not as obvious to figure out as it first sounds. Consider our earlier inventory where we used child groups to differentiate between Fedora and Ubuntu hosts—if we add a variable with the same name to both the <code>ubuntu</code> child group and the <code>frontends</code> group (which is a <code>ubuntu</code> group) as follows, what will the outcome be? The inventory would look like this:<pre class="source-code">
loadbalancer.example.org
[frontends]
web01.example.org
web02.example.org
[frontends:vars]
testvar=childgroup
[apps]
app01.example.org
app02.example.org
[databases]
db01.example.org
db02.example.org
[fedora:children]
apps
databases
[ubuntu:children]
frontends
[ubuntu:vars]
testvar=group</pre></li> </ol>
<p>Now, let’s run an ad hoc command to see what value of <code>testvar</code> is actually set:</p>
<pre class="source-code">
<strong class="bold">$ ansible -i hostgroups-children-vars-ini ubuntu -m ansible.builtin.debug -a "var=testvar"</strong>
<strong class="bold">web01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "testvar": "childgroup"</strong>
<strong class="bold">}</strong>
<strong class="bold">web02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "testvar": "childgroup"</strong>
<code>frontends</code> group is a child of the <code>ubuntu</code> group in this inventory (hence, the group is listed under <code>[ubuntu:children]</code>), and so the variable value we set at the <code>frontends</code> group level wins as this is the child group in this scenario.</p>
<p>By now, you should have a pretty good idea of how to work with static inventory files. However, no look at Ansible’s<a id="_idIndexMarker212"/> inventory capabilities is complete without a look at dynamic inventories, and we shall do exactly t<a id="_idTextAnchor183"/>h<a id="_idTextAnchor184"/>is in the next section.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor185"/>Generating a dynamic inventory file</h1>
<p>In these days of cloud computing and infrastructure-as-code, the hosts you may wish to automate could change<a id="_idIndexMarker213"/> on a daily, if not hourly, basis! Keeping a static Ansible inventory up to date could become a full-time job, and hence, in many large-scale scenarios, it becomes unrealistic to attempt to use a static inventory on an ongoing basis.</p>
<p>This is where Ansible’s dynamic inventory support comes in. In short, Ansible can gather its inventory data from just about any executable file (though you will find that most dynamic inventories are written in Python)—the only requirement is that the executable returns the inventory data in a specified JSON format. You are free to create your own inventory scripts if you wish, but thankfully, many have been created already for you to use that cover a multitude of potential inventory sources including Amazon EC2, Microsoft Azure, Red Hat <a id="_idIndexMarker214"/>Satellite, <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>) directories, and many more systems.</p>
<p>When writing a book, it is difficult to know for certain which dynamic inventory script to use as an example, as it is not a given that everyone will have an Amazon EC2 account they can freely use to test against. As a result, we will use the Cobbler provisioning system by way of example, as this is freely available and easy to roll out on a Fedora system. For those interested, Cobbler is a system for dynamically provisioning and building Linux systems, and it can handle all aspects of this, including DNS, DHCP, PXE booting, and so on. Hence, if you were to use this to provision virtual or physical machines in your infrastructure, it would make sense to also use this as your inventory source, as Cobbler was responsible for building the systems in the first place and so knows all the system names.</p>
<p>This example will demonstrate to you the fundamentals of working with a dynamic inventory, which you can then take forward to use the dynamic inventory scripts for other systems. Let’s get started with this process by first installing Cobbler—the process outlined here was tested on Fedora:</p>
<ol>
<li>Your first task is to install the relevant Cobbler packages using <code>dnf</code>. Note that, at the time of writing, the SELinux policy provided with Fedora 38 does not support Cobbler’s functionality and blocks some aspects from working. Although this is not something you should do in a production environment, your simplest path to getting this demo<a id="_idIndexMarker215"/> up and running is to simply disable SELinux:<pre class="source-code">
<strong class="bold">$ sudo dnf install -y cobbler</strong>
<code>cobblerd</code> service is configured to listen on the loopback address by checking the settings in <code>/etc/cobbler/settings</code>—the relevant snippet of the file is shown here and should appear as follows:<pre class="source-code">
# default, localhost
server: 127.0.0.1</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">This is not a public listening address, so please <em class="italic">do not use</em> <code>0.0.0.0</code>. You can also set it to the IP address of the Cobbler server.</p>
<ol>
<li value="3">With this step complete, you can start the <code>cobblerd</code> service using <code>systemctl</code>:<pre class="source-code">
<strong class="bold">$ sudo systemctl enable --now cobblerd.service</strong>
<code>/boot</code> directory, assuming you have installed Cobbler on Fedora 38. On the test system used for this demo, the following commands were used; however, you must replace the version number in the <code>vmlinuz</code> and <code>initramfs</code> filenames with the appropriate version numbers from your system’s <code>/</code><code>boot</code> directory:<pre class="source-code">
<strong class="bold">$ sudo cobbler distro add --name=Fedora38 --kernel=/boot/vmlinuz-6.2.9-300.fc38.x86_64 --initrd=/boot/initramfs-6.<a id="_idTextAnchor186"/>2.9-300.fc38.x86_64.img</strong>
<strong class="bold">$ sudo cobbler profile add --name=webservers --distro=Fedora38</strong></pre></li> </ol>
<p>This definition is quite rudimentary and would not necessarily be able to produce working server images; however, it will suffice for our simple demo as we can add some systems based on this notional Fedora 38-based image. Note that the profile name we are creating, <code>webservers</code>, will later become our inventory group name in our dynamic inventory.</p>
<ol>
<li value="5">Let’s now add those systems to Cobbler. The following two commands will add two hosts called <code>frontend01</code> and <code>frontend02</code> to our Cobbler system, using the <code>webservers</code> profil<a id="_idTextAnchor187"/>e we created previously:<pre class="source-code">
<strong class="bold">$ sudo cobbler system add --name=frontend01 --profile=webservers --dns-name=frontend01.examp<a id="_idTextAnchor188"/>le.org --interface=eth0</strong>
<strong class="bold">$ sudo cobbler system add --name=frontend02 --profile=webservers --dns-name=frontend02.example.org --interface=eth0</strong></pre></li> </ol>
<p>Note that, for Ansible to work, it must be able to reach the FQDNs specified in the <code>--dns-name</code> parameter. To achieve this, I am also adding entries to <code>/etc/hosts</code> on the Ansible control node<a id="_idIndexMarker216"/> for these two machines to ensure we can reach them later. These entries can point to any two systems of your choosing, as this is just a test.</p>
<p>At this point, you have successfully installed Cobbler, created a profile, and added two hypothetical systems to this profile. The next stage in our process is to download and configure the Ansible dynamic inventory scripts to work with these entries. To achieve this, let’s get started on the process given here:</p>
<ol>
<li>Since Ansible 3.0, most dynamic inventory scripts have been moved into Collections as this is the easiest way to distribute and update them while decoupling them from the <code>ansible-core</code> distribution. The Cobbler dynamic inventory script is included as part of the <code>community.general</code> collection, which you should find was installed as part of the Ansible 8.0 package you installed previously. You can verify this with the following command:<pre class="source-code">
<strong class="bold">$ ansible-galaxy collection list | grep community.general</strong>
<strong class="bold">community.general             6.5.0</strong></pre></li> </ol>
<p>Here, we can see that the <code>community.general</code> collection is installed and is at version 6.5.0 (collection versioning is independent of Ansible versioning).</p>
<p>If you have worked<a id="_idIndexMarker217"/> with dynamic inventory scripts in versions of Ansible before 2.9 (before Collections became mainstream), you would almost certainly have located the dynamic inventory script and made it executable, even executing it directly. This is no longer necessary in the new Collections- and Plugins-based architecture, which makes your life much easier, as you shall see shortly.</p>
<ol>
<li value="2">Referring to the documentation for the Cobbler dynamic inventory plugin (<a href="https://docs.ansible.com/ansible/latest/collections/community/general/cobbler_inventory.xhtml">https://docs.ansible.com/ansible/latest/collections/community/general/cobbler_inventory.xhtml</a>), you will see that, to use the plugin, we must create a configuration file as an inventory source. The filename must end in <code>.cobbler.yml</code> or <code>.cobbler.yaml</code>, and contain a line referencing the plugin. There are also a whole host of configuration options available (which, in our simple demo setup, aren’t necessary), but if you were working with a cloud service provider, you would certainly have to specify your region and credentials in the configuration file. In some cases, you will also have to install additional libraries or software for the inventory plugin to work, and again, the documentation page for the plugin will tell you whether this is a requirement. In my demo environment, the Cobbler server I built is accessible at the address <code>cobbler.example.org</code>, so I shall add this to the configuration file, resulting in the following:<pre class="source-code">
<strong class="bold">$ cat my.cobbler.yml</strong>
<strong class="bold">plugin: community.general.cobbler</strong>
<code>ansible-inventory</code> command, which you can use to validate the operation of the dynamic inventory:<pre class="source-code">
<strong class="bold">$ ansible-inventory -i my.cobbler.yml --graph</strong>
<strong class="bold">@all:</strong>
<strong class="bold">  |--@ungrouped:</strong>
<strong class="bold">  |--@cobbler:</strong>
<strong class="bold">  |  |--frontend01.example.org</strong>
<strong class="bold">  |  |--frontend02.example.org</strong>
<strong class="bold">  |--@cobbler_webservers:</strong>
<strong class="bold">  |  |--frontend01.example.org</strong>
<strong class="bold">  |  |--frontend02.example.org</strong>
<strong class="bold">  |--@cobbler_:</strong>
<strong class="bold">  |  |--frontend01.example.org</strong>
<strong class="bold">  |  |--frontend02.example.org</strong></pre></li> </ol>
<p>This is an incredibly powerful and rapid way to query the dynamic inventory operation and what it is returning. Notice also that all group names have had <code>cobbler_</code> placed in front of them by the plugin, so we will need to make use of this when we reference the group names.</p>
<ol>
<li value="4">You can now run an Ansible ad hoc command in the manner you are used to—the only difference this time is that you will specify the filename of the dynamic inventory plugin configuration file rather than the name of the static inventory file. Assuming you have set up hosts at the two addresses we entered into Cobbler earlier, your <a id="_idIndexMarker219"/>output should look something like that shown here:<pre class="source-code">
<strong class="bold">$ ansible -i my.cobbler.yml cobbler_webservers -m ansible.builtin.ping</strong>
<strong class="bold">frontend01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "ansible_facts": {</strong>
<strong class="bold">        "discovered_interpreter_python": "/usr/bin/python3"</strong>
<strong class="bold">    },</strong>
<strong class="bold">    "changed": false,</strong>
<strong class="bold">    "ping": "pong"</strong>
<strong class="bold">}</strong>
<strong class="bold">frontend02.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "ansible_facts": {</strong>
<strong class="bold">        "discovered_interpreter_python": "/usr/bin/python3"</strong>
<strong class="bold">    },</strong>
<strong class="bold">    "changed": false,</strong>
<strong class="bold">    "ping": "pong"</strong>
<strong class="bold">}</strong></pre></li> </ol>
<p>That’s it! You have just implemented your first dynamic inventory in Ansible. Of course, we know that many of you won’t be using Cobbler, and some of the other dynamic inventory plugins are a little more complex to get going. For example, the Amazon EC2 dynamic inventory script requires your authentication details for Amazon Web Services (or a suitable IAM account) and the installation of the Python <code>boto</code> and <code>boto3</code> libraries. How would you know to do all of this? Luckily, it is all documented in the plugin documentation, which you can access via the official Ansible documentation website, or on the command line using a command such as the following:</p>
<pre class="console">
$ ansible-doc -t inventory community.general.cobbler</pre> <p>An example of the <a id="_idIndexMarker220"/>documentation you will see is shown in the following figure:</p>
<div><div><img alt="Figure 3.1 – The Ansible CLI documentation for the community.general.cobbler plugin" height="589" src="img/B20846_03_001.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The Ansible CLI documentation for the community.general.cobbler plugin</p>
<p>The most fundamental piece of advice I can give is this: whenever you install a new collection containing a dynamic inventory plugin, be sure to check out the documentation, as the requirements will have been documented for you.</p>
<p>Before we end this section, let’s have a look at a few other handy hints for working with inventories, starting with the use of multiple invento<a id="_idTextAnchor189"/>r<a id="_idTextAnchor190"/>y sources in the next section.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor191"/>Using multiple inventory sources in the inventory directories</h2>
<p>So far in this book, we have been specifying our inventory file (either static or dynamic) using the <code>-i</code> switch in our<a id="_idIndexMarker221"/> Ansible commands. What might not be apparent is that you can specify the <code>-i</code> switch more than once and <a id="_idIndexMarker222"/>so use multiple inventories at the same time. This enables you to perform tasks such as running a playbook (or ad hoc command) across hosts from both static and dynamic inventories at the same time. Ansible will work out what needs to be done—static inventories should not be marked as executable and so will not be processed as such, whereas dynamic inventories will be. This small but clever trick enables you to combine <a id="_idIndexMarker223"/>multiple inventory sources with ease. Let’s move on, in the next section, to looking at<a id="_idIndexMarker224"/> the use of static inventory groups in combination with dynamic ones, an extension of thi<a id="_idTextAnchor192"/>s<a id="_idTextAnchor193"/> multiple-inventory functionality.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor194"/>Using static groups with dynamic groups</h2>
<p>Of course, the possibility of<a id="_idIndexMarker225"/> mixing inventories brings with it an interesting question—what happens to the groups from a dynamic inventory and a <a id="_idIndexMarker226"/>static inventory if you define both? The answer is that Ansible combines both, and this leads to an interesting possibility. As you will have observed, our Cobbler inventory script produced an Ansible group called <code>cobbler_webservers</code> from a Cobbler profile that we called <code>webservers</code>. This is common for most dynamic inventory providers; most inventory sources (for example, Cobbler and Amazon EC2) are not Ansible-aware and so do not offer groups that Ansible can directly use—they may also automatically add prefixes or separators to metadata (which may or may not be configurable). As a result, most dynamic inventory scripts will use some facet of information from the inventory source to produce groupings—the Cobbler machine profile being one such example.</p>
<p>Let’s extend our Cobbler example from the preceding section by mixing a static inventory. Suppose that we want to make our <code>cobbler_webservers</code> machines a child group of a group called <code>fedora</code> so that we can, in the future, group all Fedora machines together. We know that we only have a Cobbler profile called <code>webservers</code>, and ideally, we don’t want to start messing with the Cobbler setup to do something solely Ansible-related.</p>
<p>The answer to this is to create a static inventory file with two group definitions. The first must be the same name as the group you are expecting from the dynamic inventory, except that you should leave it blank. When Ansible combines the static and dynamic inventory contents, it will overlap the two groups and so add the hosts from Cobbler to these groups.</p>
<p>The second group definition should state that <code>cobbler_webservers</code> is a child group of the <code>fedora</code> group. The resulting f<a id="_idTextAnchor195"/>ile should look something like this:</p>
<pre class="source-code">
[cobbler_webservers]
[fedora:children]
cobbler_webservers</pre> <p>Now let’s run a simple ad hoc <code>ansible.builtin.ping</code> command in Ansible to see how it evaluates the<a id="_idIndexMarker227"/> two inventories together. Notice how we will specify the <code>fedora</code> group to run <code>ansible.builtin.ping</code> against, instead<a id="_idIndexMarker228"/> of the <code>cobbler_webservers</code> group. We know that Cobbler has no <code>fedora</code> group because we never created one, and we know that any hosts in this group must come via the <code>cobbler_webservers</code> group when you combine the two inventories, as our static inventory has no hosts in it. The results will look something like this:</p>
<pre class="console">
$ ansible -i my.cobbler.yml -i static-groups-mix-ini fedora -m ansible.builtin.ping
frontend01.example.org | SUCCESS =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
frontend02.example.org | SUCCESS =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}</pre> <p>As you can see from the preceding output, we have referenced two different inventories, one static and the other dynamic. We have combined groups, taking hosts that only exist in one inventory <a id="_idIndexMarker229"/>source, and combining them with a group that only exists in another. As you can see, this is an incredibly simple example, and it would be easy to extend this<a id="_idIndexMarker230"/> to combine lists of static and dynamic hosts or to add a custom variable to a host that comes from a dynamic inventory.</p>
<p>This is a trick of Ansible that is little known but can be very powerful as your inventories expand and grow. As we have worked through this chapter, you will have observed that we have been very precise about specifying our inventory hosts either individually or by group; for example, we explicitly told the <code>ansible</code> command to run the ad hoc command against all hosts in the <code>cobbler_webservers</code> group. In the next section, we will build on this to look at how Ansible can manage<a id="_idTextAnchor196"/> <a id="_idTextAnchor197"/>a set of hosts specified using patterns.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor198"/>Special host management using patterns</h1>
<p>We have already established<a id="_idIndexMarker231"/> that you will often want to run either an ad hoc command or a playbook against only a subsection of your inventory. So far, we have<a id="_idIndexMarker232"/> been quite precise in doing that, but let’s now expand upon this by looking at how Ansible can work with patterns to figure out which hosts a command (or playbook) should be run against.</p>
<p>As a starting point, let’s again consider an inventory that we defined earlier in this chapter for the purposes of exploring host groups and child groups. For your convenience, the inventory contents are provided again here:</p>
<pre class="source-code">
loadbalancer.example.org
[frontends]
web01.example.org
web02.example.org
[apps]
app01.example.org
app02.example.org
[databases]
db01.example.org
db02.example.org
[fedora:children]
apps
databases
[ubuntu:children]
frontends</pre> <p>To demonstrate host/group <a id="_idIndexMarker233"/>selection by pattern, we shall use the <code>--list-hosts</code> switch with the <code>ansible</code> command to see which hosts Ansible would operate on. You are <a id="_idIndexMarker234"/>welcome to expand the example to use the <code>ansible.builtin.ping</code> module, but we’ll use <code>--list-hosts</code> here in the interests of space and keeping the output concise and readable:</p>
<ol>
<li>We have already mentioned the special <code>all</code> group to specify all hosts in the inventory:<pre class="source-code">
<strong class="bold">$ ansible -i hostgroups-ini all --list-hosts</strong>
<strong class="bold">  hosts (7):</strong>
<strong class="bold">    loadbalancer.example.org</strong>
<strong class="bold">    app01.example.org</strong>
<strong class="bold">    app02.example.org</strong>
<strong class="bold">    db01.example.org</strong>
<strong class="bold">    db02.example.org</strong>
<strong class="bold">    web01.example.org</strong>
<strong class="bold">    web02.example.org</strong></pre></li> </ol>
<p>The asterisk<a id="_idIndexMarker235"/> character has the same effect as <code>all</code>, but<a id="_idIndexMarker236"/> needs to be quoted in single quotes for the shell to interpret the command properly:</p>
<pre class="source-code">
<strong class="bold">$ ansible -i hostgroups-ini '*' --list-hosts</strong>
<strong class="bold">  hosts (7):</strong>
<strong class="bold">    loadbalancer.example.org</strong>
<strong class="bold">    app01.example.org</strong>
<strong class="bold">    app02.example.org</strong>
<strong class="bold">    db01.example.org</strong>
<strong class="bold">    db02.example.org</strong>
<strong class="bold">    web01.example.org</strong>
<strong class="bold">    web02.example.org</strong></pre> <ol>
<li value="2">Use <code>:</code> to specify a logical <code>OR</code>, meaning “<em class="italic">apply to hosts either in this group or that group</em>,” as in this example:<pre class="source-code">
<strong class="bold">$ ansible -i hostgroups-ini frontends:apps --list-hosts</strong>
<strong class="bold">  hosts (4):</strong>
<strong class="bold">    web01.example.org</strong>
<strong class="bold">    web02.example.org</strong>
<strong class="bold">    app01.example.org</strong>
<code>!</code> to exclude a specific group—you can combine this with other characters such as <code>:</code> to show (for example) all hosts except those in the <code>apps</code> group. Again, <code>!</code> is a <a id="_idIndexMarker237"/>special character in the shell and so you must quote<a id="_idIndexMarker238"/> your pattern string in single quotes for it to work, as in this example:<pre class="source-code">
<strong class="bold">$ ansible -i hostgroups-ini 'all:!apps' --list-hosts</strong>
<strong class="bold">  hosts (5):</strong>
<strong class="bold">    loadbalancer.example.org</strong>
<strong class="bold">    db01.example.org</strong>
<strong class="bold">    db02.example.org</strong>
<strong class="bold">    web01.example.org</strong>
<code>:&amp;</code> to specify a logical <code>AND</code> between two groups, for example, if we want all hosts that are in the <code>fedora</code> group and the <code>apps</code> group (again, you must use single quotes in the shell):<pre class="source-code">
<strong class="bold">$ ansible -i hostgroups-ini 'fedora:&amp;apps' --list-hosts</strong>
<strong class="bold">  hosts (2):</strong>
<strong class="bold">    app01.example.org</strong>
<code>*</code> wildcards in a similar manner to what you would use in the shell, as in this example:<pre class="source-code">
<strong class="bold">$ ansible -i hostgroups-ini 'db*.example.org' --list-hosts</strong>
<strong class="bold">  hosts (2):</strong>
<strong class="bold">    db01.example.org</strong>
<strong class="bold">    db02.example.org</strong></pre></li> </ol>
<p>Another way you can limit which hosts a command is run on is to use the <code>--limit</code> switch with Ansible. This uses exactly the same syntax and pattern notation as in the preceding but has the advantage that <a id="_idIndexMarker239"/>you can use it with the <code>ansible-playbook</code> command, where specifying a <a id="_idIndexMarker240"/>host pattern on the command line is only supported for the <code>ansible</code> command itself. Hence, for example, you could run the following:</p>
<pre class="console">
$ ansible-playbook -i hostgroups-ini site.yml --limit frontends:apps
PLAY [A simple playbook for demonstrating inventory patterns] *************************************************************************************
TASK [Ping each host] *****************************************************************************************************************************
ok: [web02.example.org]
ok: [web01.example.org]
ok: [app02.example.org]
ok: [app01.example.org]
PLAY RECAP ****************************************************************************************************************************************
app01.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
app02.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
web01.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
web02.example.org          : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</pre> <p>Patterns are a<a id="_idIndexMarker241"/> very useful and important part of working with<a id="_idIndexMarker242"/> inventories, and something you will no doubt find invaluable going forward. That concludes our chapter on Ansible inventories; however, it is hoped that this has given you everything y<a id="_idTextAnchor199"/>o<a id="_idTextAnchor200"/>u need to work confidently with Ansible inventories.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor201"/>Summary</h1>
<p>Creating and managing Ansible inventories is a crucial part of your work with Ansible, and hence we have covered this fundamental concept early in this book. They are vital as, without them, Ansible would have no knowledge of what hosts it is to run automation tasks against, yet they provide so much more than this. They provide an integration point with configuration management systems, they provide a sensible source for host-specific (or group-specific) variables to be stored, and they provide you with a flexible way of running this playbook.</p>
<p>In this chapter, you learned about creating simple static inventory files and adding hosts to them. We then extended this by learning how to add host groups and assign variables to hosts. We also looked at how to organize your inventories and variables when a single flat inventory file becomes too much to handle. We then learned how to make use of dynamic inventory files, before concluding with a look at useful tips and tricks such as combining inventory sources and using patterns to specify hosts, all of which will make how you work with inventories easier and yet simultaneously more powerful.</p>
<p>In the next chapter, we will learn how to develop playbooks and roles to configur<a id="_idTextAnchor202"/>e, deploy, and manage remote machines using Ansible.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor203"/>Questions</h1>
<ol>
<li>How do you add the <code>frontends</code> group variables to your inventory?<ol><li><code>[</code><code>frontends::]</code></li><li><code>[</code><code>frontends::values]</code></li><li><code>[</code><code>frontends:host:vars]</code></li><li><code>[</code><code>frontends::variables]</code></li><li><code>[</code><code>frontends:vars]</code></li></ol></li>
<li>What enables you to automate Linux tasks such as provisioning DNS, managing DHCP, updating packages, and configuration management?<ol><li>Playbook</li><li>Yum</li><li>Cobbler</li><li>Bash</li><li>Role</li></ol></li>
<li>Ansible allows you to specify an inventory file location b<a id="_idTextAnchor204"/>y<a id="_idTextAnchor205"/> using the <code>-i</code> option on the command line:<ol><li>True</li><li>False</li></ol></li>
</ol>
<h1 id="_idParaDest-59"><a id="_idTextAnchor206"/>Further reading</h1>
<p>Details on using Ansible inventory plugins are available here: <a href="https://docs.ansible.com/ansible/latest/plugins/inventory.xhtml#using-inventory-plugins">https://docs.ansible.com/ansible/latest/plugins/inventory.xhtml#using-inventory-plugins</a></p>
</div>
</div></body></html>