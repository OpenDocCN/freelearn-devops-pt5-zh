- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Highly Available Cloud Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing with our AWS deployment, we will start to deploy services into the
    network we created in the previous chapter, and by the end of the chapter, we
    will be left with a highly available WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on top of the roles we created in the previous chapter, we will be
    doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Launching and configuring an Application Load Balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching and configuring Amazon **Relational Database Service** (**RDS**) (database)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching and configuring Amazon **Elastic File System** (**EFS**) (shared storage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching an **Elastic Compute Cloud** (**EC2**) instance and creating an **Amazon
    Machine Image** (**AMI**) from it (deploying the WordPress code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching and configuring a launch template to use the newly created AMI and
    autoscaling group (high availability)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning the deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the Playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminating all the resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous chapter, we will be using AWS; you will need the access key
    and secret key we created in the previous chapter to launch the resources needed
    for our highly available WordPress installation. Please note that we will be launching
    resources that incur charges. Again, you can find the complete playbook in the
    `Chapter11` folder of the accompanying GitHub repository at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter11/](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter11/).
  prefs: []
  type: TYPE_NORMAL
- en: Planning the deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the playbooks, we should get an idea of what we are trying
    to achieve. As mentioned, we will build on our AWS **Virtual Private Cloud** (**VPC**)
    role by adding instances and storage; our final deployment will look like the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – An overview of what we shall be launching](img/B21620_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – An overview of what we shall be launching
  prefs: []
  type: TYPE_NORMAL
- en: 'In the diagram, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 x EC2 instances (t2.micro), deployed across different availability zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x RDS instances (t2.micro)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x EFS storage across three availability zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we talk about the deployment itself, based on the diagram and specifications
    here, how much is this deployment going to cost us to run?
  prefs: []
  type: TYPE_NORMAL
- en: Costing the deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cost of running this deployment in the EU-West-1 region is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instance Type** | **#** **Number** | **Instance cost** | **Total** **Monthly
    Cost** |'
  prefs: []
  type: TYPE_TB
- en: '| EC2 instances (t2.micro) | x2 | $9.20 | $18.40 |'
  prefs: []
  type: TYPE_TB
- en: '| RDS instance (t2.micro) | x1 | $13.14 | $13.14 |'
  prefs: []
  type: TYPE_TB
- en: '| Application Load Balancer | x1 | $24.24 | $24.24 |'
  prefs: []
  type: TYPE_TB
- en: '| EFS | 5GB | $0.88 | $4.40 |'
  prefs: []
  type: TYPE_TB
- en: '| **Total** |  |  | $61.83 |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Cost of running the deployment
  prefs: []
  type: TYPE_NORMAL
- en: There will be a few other minor costs, such as bandwidth and storing the AMI
    that contains our software stack. We could also consider increasing these costs
    by adding additional redundancy, such as updating our RDS instance to a multi-AZ
    RDS primary and stand-by instance deployment and increasing the number of EC2
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: However, this introduces additional complexity to our deployment, as we are
    about to spend the rest of the chapter covering the playbook, which will be deploying
    the resources. I want to keep this playbook as simple as possible for now.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress considerations and high availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been launching WordPress on a single server, which is fine.
    Still, as we are trying to remove as many of the single points of failure within
    our deployment as possible, we must put a little thought into how we initially
    configure and launch our deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s discuss the order we need to launch our deployment. The primary
    order in which we will need to tackle the elements is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VPC, subnets, internet gateway, routing, and security groups**: These are
    all needed to launch our deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Application Elastic Load Balancer**: We will be using the public hostname
    of the Elastic Load Balancer for our installation, so this needs to be launched
    before we start our installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The RDS database instance**: Our database instance must be available before
    we launch our installation, as we need to create the WordPress database and bootstrap
    the installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The EFS storage**: We need some storage to share between the EC2 instances
    we will be launching next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, so good; however, this is where we have to start taking WordPress into
    account.
  prefs: []
  type: TYPE_NORMAL
- en: As some of you may know from experience, the current version of WordPress is
    not designed to be spread across multiple servers. We can apply plenty of hacks
    and workarounds to make WordPress play nicely in this sort of deployment; however,
    this chapter is about something other than the finer points of deploying WordPress.
    Instead, it is about using Ansible to deploy a multi-tiered web application.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we will be going for the most basic of the multi-instance WordPress
    options by deploying our code and content on the EFS volume. This means that all
    we must do is install our LEMP stack. It should be noted that this option could
    be more performant at a large scale, but it will serve our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to the list of tasks. When it comes to launching our instances, we
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch a temporary EC2 instance running Ubuntu to reuse parts of existing playbooks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the operating system and install the software stack, supporting tools,
    and configuration needed for us to install and run our WordPress installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the EFS volume, set the correct permissions, and configure it to mount
    when the instance boots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bootstrap WordPress itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an AMI from our temporary instance and then terminate the temporary instance
    as it will not be needed now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a launch template that uses the AMI we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an autoscaling group and attach the launch configuration; it should also
    register our WordPress instances with the Elastic Load Balancer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further playbook runs, which will update the operating system and non-WordPress
    configuration, should repeat the process with the existing instances up and running,
    and then, once the AMI is built, it should be deployed alongside the current instances,
    which will then be terminated once the new instances are registered with the Elastic
    Load Balancer and receiving traffic.
  prefs: []
  type: TYPE_NORMAL
- en: This will allow us to update our operating system packages and configurations
    without downtime if everything goes as planned!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of what we are trying to achieve, let’s make a start
    on our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The Playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Playbook we looked at in [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458),
    *Building Out a Cloud Network*, as a starting point, as all the roles are relevant
    to our deployment, and it already has the structure we need for our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: We will also be using the roles to deploy and configure WordPress and the supporting
    software stack we used in [*Chapter 9*](B21620_09.xhtml#_idTextAnchor411), *Moving
    to the Cloud*, with a few tweaks, which are needed as we are targeting AWS and
    not Microsoft Azure; I will let you know when we get to them.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike previous chapters, we will first look at the `site.yml` file to get an
    idea of the order in which we will run the roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three stages in the file, starting with the stage that deploys and
    configures our underlying AWS resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is the same as the `site.yml` file from [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458),
    *Building Out a Cloud Network*, with additional roles added to the list from the
    `securitygroups` role downwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the time our Playbook run gets to the second stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A file called `group_vars/generated_aws_endpoints.yml` will have been generated,
    and there should be a temporary virtual machine instance up and running, meaning
    SSH should be accessible to the host running the Playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Once this stage has been completed, our temporary virtual machine instance should
    have our software stack installed. WordPress will be freshly installed if this
    is the first time the playbook has been run, or if the playbook has detected an
    existing WordPress installation and left it alone unless there have been any changes
    to the plugin configuration from within the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final stage is then run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This stage creates an AMI from the temporary virtual machine instance, terminates
    the temporary instance as we no longer need it, creates a new version of our launch
    template, and then creates/updates the Auto Scaling Group to deploy the new version
    on the EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds simple? Well, let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: The variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Out of the box, there is a single variables file called `group_vars/common.yml`
    that contains all the static variables needed to deploy our environment.
  prefs: []
  type: TYPE_NORMAL
- en: Some additional files will be created in the `group_vars` folder throughout
    the Playbook run; they will contain some dynamically generated resources, such
    as passwords, resource names/endpoints, and other information.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss these files in more detail when we look at the tasks that create
    and interact with them; for now, we will look at the static variables defined
    within `group_vars/common.yml`, starting with the base application configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Application and resource configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start the configuration with the option to enable/disable debug when running
    the Playbook. By default, it is set to `false`; however, when running the Playbook,
    I recommend switching it to `true` and reviewing the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the application name, region, and environment reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of variables defines details for the WordPress database; as
    we will be using the Amazon RDS service, we are just using the variables that
    are defined later in the file, so we only have to update the information in one
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block is the various variables used to configure WordPress itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are no significant changes to when we last defined these in [*Chapter
    9*](B21620_09.xhtml#_idTextAnchor411)*, Moving to the Cloud*, apart from using
    the `aws_endpoints.lb` variable, which won’t be known until the Elastic Load Balancer
    has been launched. Also, for ease of use, we are reusing the password, which will
    be dynamically generated later in the file, as the WordPress admin password.
  prefs: []
  type: TYPE_NORMAL
- en: Stack configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next section overrides the defaults in the `roles/stack_install` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have removed `mariadb-server` from the list of packages as we no longer
    need to install or configure a local database server, and we have added four packages
    at the end (all labeled `# Added for AWS`). These packages install the software
    required to mount the EFS filesystem using the NFS protocol, which leads us nicely
    into the next block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this defines some basic information on where the EFS filesystem
    should be mounted, with what options and the type of filesystem it is.
  prefs: []
  type: TYPE_NORMAL
- en: Resource names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This next section builds up the names of the resources we are going to be deploying;
    there is nothing too special happening here – it is just defined like this, so
    we don’t have to update repeated information in several places manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not be covering the full `playbook_dict` block here as there is not
    much to see, although as a reminder, this is what the start of it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It just continues defining service names. The following section is where we
    start to define the variables used for the AWS resource deployment.
  prefs: []
  type: TYPE_NORMAL
- en: EC2 configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ec2` variable is split into a few different layers. Layers for the auto-scaling
    group, the AMI, and the SSH keypair follow some general settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The variables are used across instances apart from the `public_ip` reference,
    which is only used when launching the temporary virtual machine instance to bootstrap
    WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next layer defines some details about the auto-scaling group and launch
    template when used; they help define how many instances are launched, how updated
    instances are rolled out, and also, how the load balancer will check to see if
    they are healthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the details about the base AMI we will use; as you can see,
    we are using Ubuntu 22.04, which is supplied by Canonical, the publisher and maintainer
    of Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have some details on the keypair to upload to AWS and use when
    launching our Virtual Machine instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next up are the variables used when launching the RDS service.
  prefs: []
  type: TYPE_NORMAL
- en: RDS configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are all standard, apart from the `rds.db_password` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using a lookup module to add a random password to the
    `group_vars/generated_rds_passwordfile` file; we are instructing the module to
    generate a 30-character random password comprising letters and numbers only.
  prefs: []
  type: TYPE_NORMAL
- en: EFS configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we define the variables used to tell Ansible to wait and how long when
    creating the EFS resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: VPC and subnet configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This block remains unchanged from [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458),
    *Building Out a* *Cloud Network*.
  prefs: []
  type: TYPE_NORMAL
- en: Security group configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most of this block is unchanged from [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458),
    *Building Out a Cloud Network*, as we now define the SSH port as `ec2.ssh_port`.
    I have updated the EC2 group to use this reference rather than hardcoding port
    22 into the block. The only other addition is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These will be used throughout the playbook when we query the AWS API for information
    on our security groups.
  prefs: []
  type: TYPE_NORMAL
- en: The final block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As per [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458), *Building Out a Cloud
    Network*, this contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our whistle-stop tour of the `group_vars/common.yml` file; as
    you can see, structure- and content-wise, we are following the same patterns as
    the last few chapters, where we group variables into logical blocks and trying
    to reuse references as much as possible throughout so that we don’t have to repeat
    information repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: The Playbook roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have covered the variables, we can work through the roles in the
    order they appear in the `site.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The VPC, subnets, gateway, and security groups roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no changes to these roles from [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458),
    *Building Out a Cloud Network*; they are just dropped in place and work as expected.
    The remaining roles in this section of the Playbook will reference the output
    of these roles when referring to subnets, security groups, and the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Elastic Load Balancer (ELB) role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this role, we will deploy two resources, the first of which is a target group.
    This will be used when we launch our auto-scaling virtual machine instances –
    we attach our instances to the target group. Then, the target group is attached
    to the Application Elastic Load Balancer, which we will also launch in this role.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task itself is pretty static, as you can see from the code for the following
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are just referencing variables, with the only dynamic content being the ID
    of the VPC, which is referenced from the `vpc_output` variable we registered when
    launching the VPC in the VPC role.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are registering some output in this role, we will continue by adding
    a debug task straight after; in this case, the task looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we have already covered in [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458),
    *Building Out a Cloud Network*, we will not be repeating these tasks in our overview
    of the Playbook unless we are doing something different – so, from now on, if
    we are registering an output, please assume that a debug task immediately follows.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more bit of information we need before we create the ELB, and that’s
    the ID of the security group.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get this, we can loop through the `security_groups_with_rules_output` variable
    and use `set_fact` to set the `group_id` when the `group_name` contains the contents
    of the `elb_seach_string` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we need the ID of a security group, we will use this same pattern but
    update the name of the fact that is being set and the corresponding search steering
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following task provisions the Application Elastic Load Balancer, which
    will be used to distribute HTTP requests across our auto-scaling managed virtual
    machine instances to serve our WordPress site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are attaching the Application Elastic Load Balancer to the
    subnets defined listed in the `subnet_public_ids`, and we are attaching the security
    group with the ID defined in the `elb_group_id` fact that registered in the previous
    task.
  prefs: []
  type: TYPE_NORMAL
- en: We are then configuring a listener on port `80` to accept HTTP traffic and forward
    it to the Target Group we launched at the start of the role – which concludes
    the Application Elastic Load balancer role.
  prefs: []
  type: TYPE_NORMAL
- en: The Elastic File System (EFS) role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The role starts with the task which sets the `efs_group_id` using the `efs_seach_string`
    variable. Once we know the ID of the security group we are applying to the EFS
    service, we can move on to the next task.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task generates a file using a template and places it in the `group_vars`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The template file used to populate the file at `group_vars/generated_efs_targets.yml`
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using a Jinja2 `for` loop to loop through the contents of `subnet_storage_ids`,
    which will create a file that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This means that when we create the EFS file system, it will be available across
    all the availability zones in our chosen region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it will be once we load in the contents of the file we have just loaded,
    which we do in the next task, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything in place to create the EFS file system, which is done
    using this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It can take a few minutes to create the file system, and we must wait until
    this task has succeeded before we continue, which is why we are using the wait
    flag. If we don’t wait, we increase the risk that the file system will not be
    ready by the time our virtual machine is launched and unable to mount it, which
    will cause the Playbook execution to fail.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of tasks that take a while, the next role deals with launching the
    Amazon RDS instance, which we will use as the database for our WordPress site.
    This task can take up to 10 minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: The Amazon RDS role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two main parts to the role; the first does a similar task to the one
    we had to do in the previous role when we created the targets for the EFS to be
    attached to.
  prefs: []
  type: TYPE_NORMAL
- en: The RDS service differs in that rather than passing in the subnets manually
    when we deploy the service, we can create a group natively on the AWS side and
    then reference it when we launch the RDS instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task to create the RDS subnet group looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Once we have created the subnet group, we need to find the security group ID
    using the `rds_seach_string` variable and set a fact called `rds_group_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have all the information we need to launch the RDS instance, the task
    for which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned at the end of the previous task, this can take quite a while to
    deploy, typically just over 10 minutes, so when we run the Playbook, this task
    will appear to have stalled.
  prefs: []
  type: TYPE_NORMAL
- en: So please do not worry – it is busy working away in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Once this role has finished running, we will have all the core AWS resources
    we need to launch an EC2 instance, perform the software configuration, and install
    WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: The temporary EC2 instance role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we work through the tasks that launch the temporary instance, let’s go
    into a little more detail on why we need a temporary EC2 instance in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the introduction, this instance will be running Ubuntu, and
    we will be targeting it with slightly modified copies of the `stack_install`,
    `stack_config`, and `wordpress` roles that we first ran locally in [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253),
    *Deploying WordPress*, and against a single cloud instance in [*Chapter 9*](B21620_09.xhtml#_idTextAnchor411),
    *Moving to* *the Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: One of the modifications we will be making to the roles is installing the software
    needed to mount our EFS, which we will then use to store the WordPress code and
    supporting files for our WordPress installation, meaning that we have everything
    we need file-wise for WordPress on a shared file system we can then mount on multiple
    virtual machine instances.
  prefs: []
  type: TYPE_NORMAL
- en: The second change is that rather than installing a database server on our local
    instance, we will be using the Amazon RDS database service for WordPress, meaning
    that we can have multiple instances of WordPress, all being able to connect to
    a single remote database.
  prefs: []
  type: TYPE_NORMAL
- en: Great, you may be thinking to yourself, but that doesn’t explain why this is
    a temporary instance.
  prefs: []
  type: TYPE_NORMAL
- en: Well, once everything has been installed, mounted, configured, and WordPress
    bootstrapped, we will be making our own **Amazon Machine Image** (**AMI**) and
    terminating the temporary EC2 instance. Once it’s been terminated, we will take
    the AMI and configure our Auto Scaling Group to use the newly created image, which
    will either trigger the deployment of new hosts if it is our first time running
    the Playbook or it will launch more instances and terminate the old ones if we
    have already had virtual machine instances running our WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: When these virtual machine instances boot up using our custom AMI, they will
    already have NGINX and PHP installed and configured, ready to serve WordPress,
    and the EFS containing our WordPress files will be mounted, meaning that our servers
    will be good to go as soon as they are deployed.
  prefs: []
  type: TYPE_NORMAL
- en: All of this means our WordPress installation should be sound to scale up if
    we have an influx of traffic hitting the site for whatever reason, and all instances
    of our virtual machines will be running a known good configuration; in fact, it
    will be the same configuration as the other hosts serving our WordPress site.
  prefs: []
  type: TYPE_NORMAL
- en: Just as important, as we are not relying on anything on the local virtual machine
    instances filesystem, we are just as good at automatically scaling down by terminating
    hosts automatically when the influx of traffic has subsided without the risk of
    data loss or availability.
  prefs: []
  type: TYPE_NORMAL
- en: If this approach is planned right – in theory, we don’t even need SSH access
    to the hosts launched by the Auto Scaling Group as we should never need to manage
    them manually, and we can treat them as short-lived instances where we don’t have
    to care if they are running or terminated – just that we have the desired of instances
    delivering our application.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we know why we are taking this approach, let’s return to the Playbook
    and look at the tasks needed to get this temporary EC2 instance up and running
    to the point where we can SSH to it and install our software and WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to get a list of all the Ubuntu AMIs using the variables
    we covered earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The list of AMIs returned will contain all of the various AMI versions for our
    chosen Ubuntu version; we only need to know the ID of the latest version published
    by Canonical (the publisher and maintainer of Ubuntu) so we know we are using
    the most up-to-date image that contains the latest patches and any bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, each AMI returned in the list has a key called `creation_date`, the
    value of which, as you may have guessed, is the date and time the AMI was published.
    This means we can run the following task to get the ID of the latest version of
    the AMI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this takes the content of the list, which is defined as `ubuntu_ami_info.images`,
    sorts the list by `creation_date`, and then takes the ID of the `last` AMI in
    the list as, by default, they are sorted in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the ID of the most up-to-date Ubuntu AMI, we can progress with
    more preparation work before launching our EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to create an SSH key pair on the AWS side. This will contain the
    public portion of the SSH key we will use to access the EC2 instance when it is
    launched – the task to configure this looks like the following and uses the variables
    we covered earlier in the chapter to get the contents of the public portion of
    our SSH key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Finally, before we launch our EC2 instance, we need the ID of the security group,
    which allows the public IP address of our host running Ansible SSH access to the
    EC2 instance. To do this, we set a fact called `ec2_group_id` using the `ec2_seach_string`
    variable to find the correct group ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have everything in place to launch the EC2 instance using the following
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The only thing pointed out in the preceding task is that when we add the value
    for the `vpc_subnet_id` we can only pass in a single ID. As we don’t need this
    virtual machine instance to be highly available, that is not a problem, so we
    are using the first ID in the list of subnet IDs by using the `{{` `subnet_compute_ids[0]
    }}`.
  prefs: []
  type: TYPE_NORMAL
- en: When launching an EC2 instance in AWS, it goes through a few stages and, by
    default, the `amazon.aws.ec2_instance` module creates the instance and doesn’t
    wait for the status to change from *creating* to *running*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task polls the AWS API waiting for the status of our EC2 instance
    to be *running*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the previous task takes the ID of our newly created EC2 instance
    and polls the AWS API every `5` seconds, a maximum of `50` times, until the value
    of `ec2_tmp_instance_state.instances[0].state.name` is equal to `running`.
  prefs: []
  type: TYPE_NORMAL
- en: You might think to yourself that it seems a bit overkill to do that, and 99%
    of the time, you would be correct – it usually takes no more than a few checks
    for the status to change. Still, there is the odd occasion that AWS might be on
    a “go-slow,” and during testing, I have seen it take up to 15 checks, or just
    over a minute, for the status to change, so we need to take this delay into account
    in our Playbook as it could break the Playbook execution if we don’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task takes the details, the DNS name and IP address, of our now-running
    EC2 instance and adds them to the host group called `vmgroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Before we hand off to the next role, we should perform one more check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the Ansible Playbook works through the tasks so quickly that it
    is possible that even though our EC2 instance has a status of *running*, it does
    not mean that the host has finished booting, and SSH is started and is accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have confirmation that our EC2 host is accessible to our machine
    running Ansible using SSH, we can proceed to the final role in this section of
    the `site.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoints role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This role has a single task, which creates a file at `generated_aws_endpoints.yml`
    containing the name of the AWS endpoints for the EFS, RDS, and ELB resources we
    have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `endponts.j2` template file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Both the RDS and ELB endpoints are straightforward enough; for the EFS, you
    might notice something at the end – what is that for?
  prefs: []
  type: TYPE_NORMAL
- en: None of the output that is registered under the `efs_output.efs` variable contains
    just the address of the EFS endpoint. The one we are using, `filesystem_address`,
    has information on the file system mount, which is represented by appending `:/`
    to the end of the DNS address we need.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this, we are using the `split` function, passing `:` as the delimiter
    and then taking the first section, which is defined as `0`, meaning that we end
    up with everything before the `:`, which is the DNS name we are after.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a populated `group_vars/generated_aws_endpoints.yml` file,
    we can load it into the second section of the `site.yml` file as a variable file,
    saving us from having to interact with the AWS from our EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have our EC2 instance up and running, let’s get our software
    stack installed, configured, and WordPress bootstrapped.
  prefs: []
  type: TYPE_NORMAL
- en: The stack install role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tasks in this role remain unchanged from the previous times we have executed
    the Playbook because all the changes we have made are in the `stack_packages`
    variable we are passing in.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, this role does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the APT cache and ensures that the installed packages are running the
    latest available versions – which shouldn’t be too many as we are using the newest
    AMI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports the APT keys for the additional repositories we will be enabling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs the packages containing details of the additional repositories and
    enables them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs the packages listed in the `system_packages`, `extra_packages`, and
    `stack_packages` variables – `system_packages` and `extra_packages` contain the
    default values we have been using throughout, and because we are passing the updated
    `stack_packages` variable via the `group_vars/common.yml` file, this overrides
    the default values from previous chapters which are still defined in the `roles/stack_install/defaults/main.yml`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This leaves us with all the base software we need to install on the EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: The stack configuration role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the previous role, there are some amendments to this role, starting with
    additional tasks out of the gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three tasks are added to the top of `roles/stack_config/tasks/main.yml`, the
    first of which is a continuation of the checks we did towards the end of the roles
    in the last section of the `site.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this checks that port `2049` is accessible at the endpoint defined
    in `aws_endpoints.efs`; the reason why this is there is that while the EFS service
    is ready, it may take a little while for the DNS records for the endpoint to be
    updated and accessible within the VPC. As we will soon attempt to mount the EFS
    filesystem, we must ensure it is accessible before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task is to ensure that the RPC Bind service is up and running; we
    will need to mount the EFS file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The final additional task mounts the EFS and ensures that it is added to the
    file system configuration to ensure that from now on, the EFS is mounted when
    the EC2 instance boots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you will have already seen from when we covered the variables at the start
    of the chapter, we are mounting the EFS at `/var/www/`; we are making sure to
    do this before the following two tasks to ensure that our WordPress `users` home
    directory is created on the share.
  prefs: []
  type: TYPE_NORMAL
- en: These two tasks remain unchanged from the last time we installed WordPress,
    as does the value of `wordpress_system.home`, which is `/var/www/wordpress`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we have created our WordPress user and group, we can proceed with
    the rest of the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Update `/etc/nginx/nginx.conf` with some sensible defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the configuration for our default host at `/etc/nginx/conf.d/default.conf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `/etc/nginx/global` directory and copy the `restrictions.conf` and
    `wordpress_shared.conf` files there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next task is more of a quality-of-life improvement to do with the way our
    Playbook deals with PHP, as this Playbook is designed to keep our WordPress installation
    up to date by taking the base Ubuntu image and bootstrapping from scratch each
    time rather than managing the configuration in place. It is possible that the
    version of PHP could change at some point during the life of our WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, whenever the `stack_config` role has been executed, it has been using
    the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `8.1` is a hardcoded value. While we can overwrite these variables
    at the variable level elsewhere in our configuration, it would be better to work
    out which version of PHP is installed at runtime and reference that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can update these values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This means we now must find a way to populate the `php_version` variable with
    the relevant version of PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can run the `php -v` command, which returns a lot of information
    on the version of PHP installed. We then use the `head` and a few `cut` commands
    on the Linux command line using the `ansible.builtin.shell` and not a built-in
    Ansible function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a detailed breakdown of the command we are getting Ansible to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`php -v`: This command, when run, outputs the version information of the PHP
    installed on the host the command is being executed on; this output is typically
    a multi-line text that includes the PHP version along with additional information
    on how the version of the PHP was compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|`: This symbol is known as a pipe. It takes the command output on its left
    (in this case, `php -v`) and uses it as the input for the command on its right.
    It’s a way of passing data between programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head -n 1`: This command processes the input received from the previous command;
    the head command outputs the first part of the files or data it receives. `-n
    1` is an option that tells `head` to output only the first line. So, in our case,
    `head -n 1` takes the multiple lines of output from `php -v` and returns just
    the very first line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|`: Another pipe, which again passes the command output on its left, `head
    -n 1`, to the command on its right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cut -d '' '' -f 2`: This command is used for cutting out sections of each
    input line. `-d '' ''` is an option where `-d` stands for the delimiter, and `''
    ''` (a space) is the delimiter being used. This tells cut to divide each line
    into sections based on spaces. `-f 2` means *field 2*. This option tells the `cut`
    command to select the second field of the line in the standard format of the PHP
    version output; this field should be the version number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|`: Again, we have another pipe, passing the output, now just the version
    number, to the following command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cut -c 1-3`: This further processes the version number. `-c 1-3` tells `cut`
    to return only the characters in positions `1` through `3` of the string it receives.
    For a typical PHP version such as `8.2.1`, this would result in `8.2`, which is
    precisely what we need to proceed with the rest of our tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then take the output and register it as `php_version_output`, and set
    the `php_version` variable as a fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the PHP version, we can proceed with the remainder of the PHP
    tasks, which copy the `www.conf` file to `/etc/php/{{ php_version }}/fpm/pool.d/www.conf`
    and also update the `PHP.ini` file at `/etc/php/{{` `php_version }}/fpm/php.ini`.
  prefs: []
  type: TYPE_NORMAL
- en: With those files in place, we start the PHP-FPM and NGINX services, ensuring
    that they are set to start on boot.
  prefs: []
  type: TYPE_NORMAL
- en: The final task in the role is to create the `~/.my.cnf` file and populate it
    with the information of our Amazon RDS instance. All of the other MariaDB tasks,
    which are there to start and configure our local MariaDB server, are commented
    out as we no longer install a local database server, so we don’t need to run the
    tasks to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: The WordPress role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are just two tasks commented out in this role. The tasks that create the
    database and the database user are not needed because when the Amazon RDS instance
    started, the database and user were made for us, meaning these two tasks are redundant.
  prefs: []
  type: TYPE_NORMAL
- en: All other tasks remain; for more details, see [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253),
    *Deploying WordPress*.
  prefs: []
  type: TYPE_NORMAL
- en: The EC2 AMI role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that our software stack is installed and configured and WordPress is sorted,
    it is time to create the AMI from our temporary instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is get the details on our temporary EC2 instance;
    as our host group contains the DNS name of the instance, we can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the information on the instance we would like to create the
    AMI from registered as `our_instance`, we can proceed with the AMI creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There are just a few things to point out here. As you can see, we are using
    `ansible_date_time` to generate the `date` and get the current time as an `hour`
    and `minute`. We are using this both to give a unique name for the AMI and add
    a tag called `buildDate`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we are using both the date and time is that it could be possible
    that we will need to create multiple AMIs on a single day, so it is important
    that we can easily identify them by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the AMI is created, we do not need the temporary instance, so we can terminate
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the EC2 instance has been terminated, there is one more task in the role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This does exactly what it says: it pauses the Playbook execution for 2 minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: I have included this because there was the odd occasion where the AMI was created
    and shown as available. Still, for some reason, it takes a short while for it
    to appear in the results when we query the Amazon API to find our AMIs, so rather
    than introduce a potential error when the next role starts, I have found it best
    to wait a minute or two.
  prefs: []
  type: TYPE_NORMAL
- en: The auto-scaling role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have arrived at the final role of the Playbook; in this role, we will create
    all the resources needed to deploy EC2 instances using our newly created AMI and
    register them with the ELB to access our WordPress site.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is grab a list of all our AMIs from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a list of AMIs, we need to filter out the most recent one.
    To do this, we use the same logic that we used when launching the temporary EC2
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have filtered our list of AMIs down to the latest one, we need
    to set two facts, one for the name of the AMI and the other containing the ID
    of the AMI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The final bit of information we need before we start creating/updating resources
    is the ID of the security group we are using for the EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we use the `ec2_seach_string` variable to find the correct group
    ID and set a fact called `ec2_group_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we need to create or update a launch template if one already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'A launch template contains the basic configuration for the instances we will
    be launching in the auto-scaling group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: With this task, we create the launch template and then publish a version called
    after the name of our AMI so that we can quickly identify it; we then attach the
    corresponding AMI ID and security group ID and set the spec of the instances we
    want to launch.
  prefs: []
  type: TYPE_NORMAL
- en: With the launch template in place, we need to gather a few more bits of information
    from the AWS API before creating the auto-scaling group.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need the ID of the target group that we created in the ELB role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need the IDs of the subnets where we are going to be deploying the
    EC2 instances launched as part of auto-scaling group, the following task gathers
    information on the subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the information on the subnets, we need to extract just the
    IDs of each of the subnets and create a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the final bit of information we need, and we can now proceed with creating
    or updating the auto-scaling group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a lot happening in this, the final resource we will be launching,
    so let’s go into more detail.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the basic configuration standard across most of the AWS-related
    modules we have called throughout this Playbook; here, we are setting the name,
    region, and state of the resource, which will be `present` for this playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we must provide the Target Group `target_group_arns` key specifies
    the ARNs of the target groups for the load balancer, which we set to the first
    target group ARN from `elb_target_group_output` and then the `launch_template`
    key references the launch template by its name, set to the value of `launch_template_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the size and capacity settings; the `min_size`, `max_size`, and
    `desired_capacity` keys are set using `ec2.asg.min_size`, `ec2.asg.max_size`,
    and `ec2.asg.desired_capacity` variables, which define the auto-scaling group’s
    minimum, maximum, and desired number of instances.
  prefs: []
  type: TYPE_NORMAL
- en: We then have the health check configuration, setting the `health_check_period`
    and `health_check_type` keys to control how the health of the instances in the
    **auto scaling group** (**ASG**) is checked.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the Instance Replacement Settings. The `replace_all_instances` and
    `replace_batch_size` keys instruct whether all instances should be replaced and
    provide the batch size for replacing instances, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the Network Configuration, setting `vpc_zone_identifier` to use
    the list of subnet IDs stored in `subnet_ec2_ids` to distribute the instances
    in the ASG across those subnets and availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: Next up are the Wait Settings, which control whether the task should wait for
    the instances to have a status of `running` and the maximum time to wait for that
    condition to be met.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will have noticed that we are tagging in a pretty different way
    than we have been doing throughout the rest of the Playbook; the task defines
    several tags (`Name`, `Project`, `Environment`, and `Deployed_by`) with respective
    values, all marked to propagate at launch, which means that the EC2 instances
    launched by the auto-scaling group will each inherit these tags when they are
    launched.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our walk-through of the Playbook. As you will have seen, we extended
    our original AWS networking Playbook from [*Chapter 10*](B21620_10.xhtml#_idTextAnchor458),
    *Building Out a Cloud Network*, to encompass more services as well as integrating
    our WordPress roles from the Playbook we covered in [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253),
    *Deploying WordPress* – all that is left now is run the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the roles needed to deploy our resources into AWS, we
    can run the playbook. To start with, we need to let Ansible know our access key
    and secret by running the following commands with your own credentials to set
    the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With environment variables set, you kick off the Ansible run by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Unlike previous chapters, where we just looked at the end of the playbook run,
    here we will look at some highlights of what happens when we deploy our resources.
  prefs: []
  type: TYPE_NORMAL
- en: Playbook run highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not the complete playbook output, and when running the playbook, I have
    not enabled debug, so all those tasks will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have somewhere to put the subnets once we have gathered some information
    on the availability zones in our chosen region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have that information, it will loop through and include the `create_subnet.yml`
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get the results of each of the four included task runs, the first of
    which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a subnet is created for each of the zones in the `eu-west-1`
    region – this is then repeated three more times. Once the subnets have all been
    added, we grab more information on what has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the Internet Gateway role is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have remembered, there isn’t much happening in that role, unlike
    the next one, which adds the network security groups, where we start by getting
    your current public IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may recall, we create the two groups in two parts – first, we create
    the base groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we get information on the bases we have just launched and set them as
    facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we then add the rules; you will notice from the output that we are
    passing in the IDs of the groups we have created so that we can use them as part
    of the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the rules configured, we can start deploying some resources that
    use them, starting with the Target Group and ELB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then EFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now RDS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to create the temporary EC2 instance. First, we find the AMI
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the SSH key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the EC2 instance itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'With the instance configured, we need to wait for it to have a status of **running**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the instance is running, we add the newly launching EC2 instance to
    our host group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on to connecting to the EC2 host to install and configure the
    software stack and WordPress, we generate the endpoints variables file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'That concludes the first section of the `site.yml` file, and we can now SSH
    into the temporary EC2 host and install everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We then progress with the installation, which, as we have already discussed,
    is pretty much the same set of tasks that we covered *in* [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253),
    *Deploying WordPress*, and [*Chapter 9*](B21620_09.xhtml#_idTextAnchor411), *Moving
    to the Cloud* – except for these tasks, which mount the EFS file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'These tasks get the PHP version and set it as a fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that is complete, NGINX and PHP-FPM are restarted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the tasks that bootstrap our temporary EC2 instance. We can now
    move back to our local machine and run the final section of the `sites.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the AMI and terminate the temporary EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we wait for two minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we grab the details of the AMI we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have those details, we create (or if we have already run the playbook,
    update) the Launch Template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we gather the information needed for us to create/update the Auto Scaling
    Group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create the list of subnets the Auto Scaling Group will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output is repeated twice for the other two subnets we will be
    using; then, we finally create/update the Auto Scaling Group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have come to the end of our Playbook run, and we get the recap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: When I ran the playbook, it took just over 20 minutes to complete the first
    time, with subsequent runs taking around 10 minutes to finish.
  prefs: []
  type: TYPE_NORMAL
- en: So, from a single command and in 20ish minutes, we have a highly available vanilla
    WordPress installation. If you find out the public URL of your Elastic Load Balancer
    from the AWS console or by checking the value of the `elb` key in the `group_vars/generated_aws_endpoints.yml`
    file, you should be able to see your site.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating all the resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we complete this chapter, we need to look at terminating the resources;
    to do this, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This removes everything in the reverse order that we launched it, starting
    with the Auto Scaling Group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'As there can be more than one AMI, we gather some facts and then loop through
    removing everything that is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We then remove more one-off resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'As the security groups reference each other, we need to create a list of them
    in reverse order so we can attempt to delete a group that is referenced by the
    next one we are going to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that it failed towards the end; that is because the AWS
    API is having a little trouble keeping up, and the playbook is running a little
    ahead of the results it is returning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We check a few more tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get to the VPC and recap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Once the playbook has finished running, I recommend you log in to the AWS console
    and double-check that everything has been correctly removed, as you don’t want
    to incur any unexpected costs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken our AWS deployment to the next level by creating
    and launching a highly available WordPress installation. By leveraging the various
    services offered by AWS, we engineered out any single points of failure regarding
    the availability of instances and our use of availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: We also built logic into our playbook to use the same command to launch a new
    deployment or update the operating system on an existing one with a rolling deployment
    of new instance AMIs that contain our updated packages, leading to zero downtime
    during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: While the WordPress deployment is as simple as possible, deploying the production-ready
    images would remain similar when using a more complicated application.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will look at moving from the public to the private cloud
    and how Ansible interacts with VMware.
  prefs: []
  type: TYPE_NORMAL
