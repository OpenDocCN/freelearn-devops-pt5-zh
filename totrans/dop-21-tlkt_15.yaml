- en: Managing Secrets in Docker Swarm Clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Docker 1.13* introduced a set of features that allow us to centrally manage
    secrets and pass them only to services that need them. They provide a much-needed
    mechanism to provide information that should be hidden from anyone except designated
    services.'
  prefs: []
  type: TYPE_NORMAL
- en: A secret (at least from Docker's point of view) is a blob of data. A typical
    use case would be a certificate, SSH private keys, passwords, and so on. Secrets
    should stay secret meaning that they should not be stored unencrypted or transmitted
    over a network.
  prefs: []
  type: TYPE_NORMAL
- en: With all that being said, let's see them in action and continue our discussion
    through practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: All the commands from this chapter are available in the `14-secrets.sh` ([https://gist.github.com/vfarcic/906d37d1964255b40af430bb03d2a72e](https://gist.github.com/vfarcic/906d37d1964255b40af430bb03d2a72e))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since a single node is more than enough to demonstrate Docker secrets, we''ll
    start by creating a one node Swarm cluster based on Docker Machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**A note to Windows users**'
  prefs: []
  type: TYPE_NORMAL
- en: The recommendation is to run all the examples from *Git Bash* (installed through
    *Docker Toolbox* as well as *Git*). That way the commands you'll see throughout
    the book will be same as those that should be executed on *OS X* or any *Linux*
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: We created a Docker Machine node called swarm and used it to initialize the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create a secret.
  prefs: []
  type: TYPE_NORMAL
- en: '**A note to Windows users**'
  prefs: []
  type: TYPE_NORMAL
- en: For mounts (a secret is a mount as well) used in the next command to work, you
    have to stop Git Bash from altering file system paths. Set this environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`export MSYS_NO_PATHCONV=1`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the command that creates a secret is as follows (please do not
    run it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `secret create` command expects a file that contains a secret. However,
    creating a file with unencrypted secret defies the purpose of having secrets in
    the first place. Everyone can read that file. We could, delete the file after
    pushing it to Docker but that would only create unnecessary steps. Instead, we''ll
    use `-` that will allow us to pipe standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The command we just executed created a secret called `my_secret`. That information
    was sent to the remote Docker Engine using TLS connection. If we had a bigger
    cluster with multiple managers, the secret would be replicated among all.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the newly created secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The value of the secret is hidden. Even if a malicious person gains access to
    Docker Engine, the secret would still be unavailable. Truth be told, in such a
    case, our worries would be much greater that protection of a Docker secret but
    I'll leave that discussion for some other time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have encrypted the secret and stored in Swarm managers, we should
    explore ways to utilize it within our services.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new argument `--secret` was added to the `docker service create` command.
    If a secret is attached, it will be available as a file in the `/run/secrets`
    directory inside all the containers that form a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We created a service called test and attached the secret called `my_secret`.
    The service is based on `alpine` and will output the content of the secret. Since
    it is a one-shot command that will terminate quickly, we set `--restart-condition`
    to `none`. Otherwise, the service would terminate a moment after it's created,
    Swarm would reschedule it, only to see it terminate again, and so on. We would
    enter a never-ending loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The secret is available as the `/run/secrets/my_secret` file inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start discussing a more real-world example, let us remove the service
    and the secret we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A real-world example of using secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Docker Flow Proxy *([http://proxy.dockerflow.com/](http://proxy.dockerflow.com/))
    project exposes statistics that should be reserved for internal use only. Therefore,
    it needs to be protected with a `username` and `password`. Before *Docker v1.13*,
    situations like that one would be handled by allowing users to specify username
    and password through environment variables. *Docker Flow Proxy* is no exception
    and, indeed, has the *environment variables *([http://proxy.dockerflow.com/config/#environment-variables](http://proxy.dockerflow.com/config/#environment-variables))
    `STATS_USER and STATS_PASS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command that would create the service with custom `username` and `password`
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While that would protect the statistics page from ordinary users, it would
    still leave it exposed to anyone capable of inspecting the service. A simple example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The relevant part of the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The same result that does not reveal confidential information could be accomplished
    with the commands that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We created two secrets `dfp_stats_user and dfp_stats_pass` and updated our service.
    From now on, those secrets would be available inside service containers as files
    `/run/secrets/dfp_stats_user` and `/run/secrets/dfp_stats_pass`. If a secret is
    named the same as the environment variable, is in lower case, and has the `dpf_
    prefix`, it will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: If you inspect the container one more time, you'll notice that there is no trace
    of the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: We could stop here. After all, there's not much more to be said for Docker secrets.
    However, we got used to Docker stacks and it would be great if secrets would work
    in the new YAML Compose format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let''s remove the `proxy` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using secrets with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: True to the mission to have the same features available in all supported flavours,
    Docker introduced secrets in Compose YAML format *version 3.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll continue using *Docker Flow Proxy* to demonstrate how secrets work inside
    Compose files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We downloaded the `docker-flow-proxy-secrets.yml` ([https://github.com/vfarcic/docker-flow-stacks/blob/master/proxy/docker-flow-proxy-secrets.yml](https://github.com/vfarcic/docker-flow-stacks/blob/master/proxy/docker-flow-proxy-secrets.yml))
    stack from the `vfarcic/docker-flow-stacks` ([https://github.com/vfarcic/docker-flow-stacks](https://github.com/vfarcic/docker-flow-stacks))
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant parts of the definition of the stack are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The version of the format is `3.1`. The `proxy` service has the two secrets
    attached. Finally, there is a separate `secrets` section that defines the `secrets`
    as `external` entities. The alternative would be to specify secrets internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I prefer the first option that specifies secrets externally since that does
    not leave any trail. In some other cases, secrets might be used for non-secretive
    information (we'll discuss it soon) and using internal secrets specified as files
    would probably be a better option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the `stack` and check whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Statistics themselves are useless if there is no data so we''ll deploy another
    service that will be reconfigured in the `proxy` and `start` generating some stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Please wait a few moments until the services from the `go-demo` stack are running.
    You can check their status by executing `docker stack ps go-demo`. You might see
    `go-demo_main` replicas in the failed status. Do not panic. They will continue
    failing only until the `go-demo_db` is starts running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can, finally, confirm that the `proxy` is configured to use secrets
    for authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It works! With only a single additional step `docker service create`, we made
    our system more secured
  prefs: []
  type: TYPE_NORMAL
- en: Common ways to use secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until secrets were introduced, a common way to pass information to containers
    was through environment variables. While that will continue being the preferable
    way for non-confidential information, part of the setup should involve secrets
    as well. Both should be combined. The question is which method to choose and when.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious use case for Docker secrets are secrets. That was obvious, wasn't
    it. If there is a piece of information that should remain invisible to anyone
    but specific containers, it should be provided through Docker secrets. A commonly
    used pattern is to allow the same information to be specified as either environment
    variable and a secret. In case that both a set, secrets should take precedence.
    You already saw this pattern through *Docker Flow Proxy*. Every piece of information
    that can be specified through environment variables can be specified as a secret
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you might not be able to modify code of your service and adapt
    it to use secrets. Maybe it's not a question of ability but lack of desire to
    modify your code. If you fall into the latter case, I will, for now, restrain
    myself from explaining why code should be continuously refactored and imagine
    that you have a very good reason for it. In either case, the solution is usually
    to create a wrapper script that transforms secrets into whatever your service
    needs and then invoke the service. Put that script as CMD instruction in *Dockerfile*
    and you're done. Secrets stay secrets and you don't get fired from refactoring
    your code. To some this last sentence sounds silly but it's not uncommon for companies
    to consider refactoring a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: What should be a secret? No one can truly answer that question for you since
    it differs from one organization to another. Some of the examples would be usernames
    and passwords, SSH keys, SSL certificates, and so on. If you don't want others
    to know about it, make it a secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should strive for immutability and do our best to run containers that are
    exactly the same no matter where they run. True immutability means that even the
    configuration is always the same across all environments. However, that is not
    always easy and is sometimes even impossible to accomplish. Such a situation could
    be a good candidate for Docker secrets. They do not necessarily have to be used
    only as means of specifying confidential information. We can use secrets as a
    way to provide information that differs from one cluster to another. In such a
    case, pieces of configuration that should differ from one environment to another
    (example: staging and production clusters) can be stored as secrets.'
  prefs: []
  type: TYPE_NORMAL
- en: I am certain that there are quite a few other use cases I didn't even think
    about. After all, secrets are a new feature (a few weeks old from the day of this
    writing).
  prefs: []
  type: TYPE_NORMAL
- en: What now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remove your Docker Machine VM and start applying secrets to your own Swarm
    cluster. There''s not much more to be said (for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
