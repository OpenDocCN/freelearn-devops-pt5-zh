<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Using Docker Stack and Compose YAML Files to Deploy Swarm Services</h1>
            </header>

            <article>
                
<div class="packt_quote CDPAlignCenter CDPAlign">Copy and paste is a design error.<br/>
                            –David Parnas</div>
<p><br/>
The most common question I receive during my Docker-related talks and workshops is usually related to Swarm and Compose.</p>
<p><em>Someone</em>: How can I use Docker Compose with Docker Swarm?</p>
<p><em>Me</em>: You can't! You can convert your Compose files into a Bundle that does not support all Swarm features. If you want to use Swarm to its fullest, be prepared for <kbd>docker service create</kbd> commands that contain a never ending list of arguments.</p>
<p>Such an answer was usually followed with disappointment. Docker Compose showed us the advantages of specifying everything in a YAML file as opposed to trying to remember all the arguments we have to pass to docker commands. It allowed us to store service definitions in a repository thus providing a reproducible and well-documented process for managing them. Docker Compose replaced bash scripts, and we loved it. Then, Docker v1.12 came along and put a difficult choice in front of us. Should we adopt Swarm and discard Compose? Since summer 2016, Swarm and Compose were not in love anymore. It was a painful divorce.<br/>
But, after almost half a year of separation, they are back together, and we can witness their second honeymoon. Kind of… We do not need Docker Compose binary for Swarm services, but we can use its YAML files.</p>
<p><em>Docker Engine v1.13</em> introduced support for Compose YAML files within the stack command. At the same time, <em>Docker Compose v1.10</em> introduced a new <em>version 3</em> of its format. Together, they allow us to manage our Swarm services using already familiar Docker Compose YAML format.</p>
<p>I will assume you are already familiar with Docker Compose and won't go into details of everything we can do with it. Instead, we'll go through an example of creating a few Swarm services.</p>
<p>We'll explore how to create <em>Docker Flow Proxy </em>(<a href="http://proxy.dockerflow.com/">http://proxy.dockerflow.com/</a>) service through <em>Docker Compose</em> files and the <kbd>docker stack deploy</kbd> command.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Swarm cluster setup</h1>
            </header>

            <article>
                
<p>To setup an example Swarm cluster using Docker Machine, please run the commands that follow.</p>
<p>All the commands from this chapter are available in the <kbd>07-docker-stack.sh</kbd> (<a href="https://gist.github.com/vfarcic/57422c77223d40e97320900fcf76a550">https://gist.github.com/vfarcic/57422c77223d40e97320900fcf76a550</a>) Gist:</p>
<pre>
<strong><span class="hljs-built_in">cd</span> cloud-provisioning<br/><br/>git pull<br/><br/>scripts/dm-swarm.sh</strong>
</pre>
<p>Now we're ready to deploy the <kbd>docker-flow-proxy</kbd> service.<br/></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating Swarm services through Docker stack commands</h1>
            </header>

            <article>
                
<p>We'll start by creating a network:</p>
<div class="packt_tip"><strong>A note to Windows users</strong><br/>
You might experience a problem with volumes not being mapped correctly. If you see an <kbd>Invalid volume specification</kbd> error, please export the environment variable <kbd>COMPOSE_CONVERT_WINDOWS_PATHS</kbd> set to <kbd>0</kbd>:<br/>
<kbd>export COMPOSE_CONVERT_WINDOWS_PATHS=0</kbd><br/>
Please make sure that the variable is exported before you run <kbd>docker-compose</kbd> or <kbd>docker stack deploy</kbd>.</div>
<pre>
<strong><span class="hljs-built_in">eval</span> $(docker-machine env swarm-<span class="hljs-number">1</span>)<br/><br/>docker network create --driver overlay proxy</strong>
</pre>
<p>The <kbd>proxy</kbd> network will be dedicated to the <kbd>proxy</kbd> container and services that will be attached to it.</p>
<p>We'll use <kbd>docker-compose-stack.yml</kbd> (<a href="https://github.com/vfarcic/docker-flow-proxy/blob/master/docker-compose-stack.yml">https://github.com/vfarcic/docker-flow-proxy/blob/master/docker-compose-stack.yml</a>) from the <kbd>vfarcic/docker-flow-proxy</kbd> (<a href="https://github.com/vfarcic/docker-flow-proxy">https://github.com/vfarcic/do</a><a href="https://github.com/vfarcic/docker-flow-proxy">cker-flow-proxy</a>) repository to create <kbd>docker-flow-proxy and docker-flow-swarm-listener</kbd> services.</p>
<p>The content of the <kbd>docker-compose-stack.yml</kbd> file is as follows:</p>
<pre>
<strong><span class="hljs-attribute">version</span>: <span class="hljs-string">"3"</span><br/><br/><span class="haml">services:<br/><br/>  proxy:<br/>    image: vfarcic/docker-flow-proxy<br/>    ports:<br/>      -<span class="ruby"> <span class="hljs-number">80</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span><br/></span>      -<span class="ruby"> <span class="hljs-number">443</span><span class="hljs-symbol">:</span><span class="hljs-number">443</span><br/></span>    networks:<br/>      -<span class="ruby"> proxy<br/></span>    environment:<br/>      -<span class="ruby"> <span class="hljs-constant">LISTENER_ADDRESS</span>=swarm-listener<br/></span>      -<span class="ruby"> <span class="hljs-constant">MODE</span>=swarm<br/></span>    deploy:<br/>      replicas: 2<br/><br/>  swarm-listener:<br/>    image: vfarcic/docker-flow-swarm-listener<br/>    networks:<br/>      -<span class="ruby"> proxy<br/></span>    volumes:<br/>      -<span class="ruby"> /var/run/docker.<span class="hljs-symbol">sock:</span>/var/run/docker.sock<br/></span>    environment:<br/>      -<span class="ruby"> <span class="hljs-constant">DF_NOTIFY_CREATE_SERVICE_URL</span>=<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/proxy:8080/v</span>1/\<br/>docker-flow-proxy/reconfigure<br/></span>      -<span class="ruby"> <span class="hljs-constant">DF_NOTIFY_REMOVE_SERVICE_URL</span>=<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/proxy:8080/v</span>1/\<br/>docker-flow-proxy/remove<br/></span>    deploy:<br/>      placement:<br/>        constraints: [node.role == manager]<br/><br/>networks:<br/>  proxy:<br/>    external: true</span></strong>
</pre>
<p>The format is written in <em>version 3</em> (mandatory for <kbd>docker stack deploy</kbd>).</p>
<p>It contains two services; <kbd>proxy</kbd> and <kbd>swarm-listener</kbd>. Since you are already familiar with the <kbd>proxy</kbd>, I won't go into the meaning of each argument.</p>
<p>When compared with previous Compose versions, most of the new arguments are defined within deploy. You can think of that section as a placeholder for Swarm-specific arguments. In this case, we are specifying that the <kbd>proxy</kbd> service should have two replicas while the <kbd>swarm-listener</kbd> service should be constrained to manager roles. Everything else defined for those two services is using the same format as in earlier Compose versions.</p>
<p>At the bottom of the YAML file is the list of networks which are referenced within services. If a service does not specify any, the default network will be created automatically. In this case, we opted for manual creation of a network since services from other stacks should be able to communicate with the <kbd>proxy</kbd>. Therefore, we created a network manually and defined it as external in the YAML file.</p>
<p>Let's create the stack based on the YAML file we explored:</p>
<pre>
<strong>curl -o docker-compose-stack.yml \<br/>    https://raw.githubusercontent.com/\<br/>vfarcic/docker-flow-proxy/master/docker-compose-stack.yml<br/><br/>docker stack deploy \<br/>    -c docker-compose-stack.yml proxy</strong>
</pre>
<p>The first command downloaded the <span>Compose file</span> <kbd>docker-compose-stack.yml</kbd><span> (</span><a href="https://github.com/vfarcic/docker-flow-proxy/blob/master/docker-compose-stack.yml">https://github.com/vfarcic/docker-flow-proxy/blob/master/docker-compose-stack.yml</a><span>) from the</span> <kbd>vfarcic/docker-flow-proxy</kbd><span> (</span><a href="https://github.com/vfarcic/docker-flow-proxy">https://github.com/vfarcic/docker-flow-proxy</a><span>) repository. The second command created the services that form the stack.</span></p>
<p>The tasks of the stack can be seen through the <kbd>stack ps</kbd> command:</p>
<pre>
<strong>docker stack ps proxy</strong>
</pre>
<p>The output is as follows (IDs are removed for brevity):</p>
<pre>
<strong>NAME                   IMAGE                                     NODE    <br/>proxy_proxy<span class="hljs-number">.1</span>          vfarcic/docker<span class="hljs-attribute">-flow</span><span class="hljs-attribute">-proxy</span>:latest          node<span class="hljs-subst">-</span><span class="hljs-number">2</span>        <br/>proxy_swarm<span class="hljs-attribute">-listener</span><span class="hljs-number">.1</span> vfarcic/docker<span class="hljs-attribute">-flow</span><span class="hljs-attribute">-swarm</span><span class="hljs-attribute">-listener</span>:latest node<span class="hljs-subst">-</span><span class="hljs-number">1</span>       <br/>proxy_proxy<span class="hljs-number">.2</span>          vfarcic/docker<span class="hljs-attribute">-flow</span><span class="hljs-attribute">-proxy</span>:latest          node<span class="hljs-subst">-</span><span class="hljs-number">3</span>       <br/>------------------------------------------------------------<br/>DESIRED STATE CURRENT STATE         ERROR PORTS<br/>Running       Running <span class="hljs-number">2</span> minutes ago<br/>Running       Running <span class="hljs-number">2</span> minutes ago<br/>Running       Running <span class="hljs-number">2</span> minutes ago<br/></strong>
</pre>
<p>We are running two replicas of the <kbd>proxy</kbd> (for high-availability in the case of a failure) and one of the <kbd>swarm-listener</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Deploying more stacks</h1>
            </header>

            <article>
                
<p>Let's deploy another stack.</p>
<p>This time we'll use Docker stack defined in the Compose file <kbd>docker-compose-stack.yml</kbd> (<a href="https://github.com/vfarcic/go-demo/blob/master/docker-compose-stack.yml">https://github.com/vfarcic/go-demo/blob/master/docker-compose-stack.yml</a>) located in the <kbd>vfarcic/go-demo</kbd> (<a href="https://github.com/vfarcic/go-demo/">https://github.com/vfarcic/go-demo/</a>) repository. It is as follows:</p>
<pre>
<strong><span class="hljs-attribute">version</span>: <span class="hljs-string">'3'</span><br/><br/><span class="haml">services:<br/><br/>  main:<br/>    image: vfarcic/go-demo<br/>    environment:<br/>      -<span class="ruby"> <span class="hljs-constant">DB</span>=db<br/></span>    networks:<br/>      -<span class="ruby"> proxy<br/></span>      -<span class="ruby"> default<br/></span>    deploy:<br/>      replicas: 3<br/>      labels:<br/>        -<span class="ruby"> com.df.notify=<span class="hljs-keyword">true</span><br/></span>        -<span class="ruby"> com.df.distribute=<span class="hljs-keyword">true</span><br/></span>        -<span class="ruby"> com.df.servicePath=<span class="hljs-regexp">/demo<br/></span></span>        -<span class="ruby"> com.df.port=<span class="hljs-number">8080</span><br/></span><br/>  db:<br/>    image: mongo<br/>    networks:<br/>      -<span class="ruby"> default<br/></span><br/>networks:<br/>  default:<br/>    external: false<br/>  proxy:<br/>    external: true</span></strong>
</pre>
<p>The stack defines two services (<kbd>main</kbd> and <kbd>db</kbd>). They will communicate with each other through the default network that will be created automatically by the stack (no need for <kbd>docker network create</kbd> command). Since the main service is an API, it should be accessible through the <kbd>proxy</kbd>, so we're attaching <kbd>proxy</kbd> network as well.</p>
<p>The important thing to note is that we used the deploy section to define <kbd>Swarm-specific</kbd> arguments. In this case, the main service defines that there should be three replicas and a few labels. As with the previous stack, we won't go into details of each service. If you'd like to go into more depth of the labels used with the main service, please visit the <em>Running Docker Flow Proxy In Swarm Mode With Automatic Reconfiguration </em>(<a href="http://proxy.dockerflow.com/swarm-mode-auto/">http://proxy.dockerflow.com/swarm-mode-auto/</a>) tutorial.</p>
<p>Let's deploy the stack:</p>
<pre>
<strong>curl -o docker-compose-go-demo.yml \<br/>    https://raw.githubusercontent.com/\<br/>vfarcic/go-demo/master/docker-compose-stack.yml<br/><br/>docker stack deploy \<br/>    -c docker-compose-go-demo.yml go-demo<br/><br/>docker stack ps go-demo</strong>
</pre>
<p>We downloaded the stack definition, executed <kbd>stack deploy</kbd> command that created the services and run the <kbd>stack ps</kbd> command that lists the tasks that belong to the <kbd>go-demo</kbd> stack. The output is as follows (IDs and Error ports columns are removed for brevity):</p>
<pre>
<strong>NAME            IMAGE                   NODE    DESIRED STATE           <br/>go-demo_main.1  vfarcic/go-demo:latest  node-<span class="hljs-number">2</span>  Running       <br/>go-demo_db.1    mongo:latest            node-<span class="hljs-number">2</span>  Running       <br/>go-demo_main.2  vfarcic/go-demo:latest  node-<span class="hljs-number">2</span>  Running       <br/>go-demo_main.3  vfarcic/go-demo:latest  node-<span class="hljs-number">2</span>  Running       <br/><span class="hljs-keyword">--------------------------------------------------------<br/>CURRENT STATE<br/>Running <span class="hljs-number">7</span> seconds ago<br/>Running <span class="hljs-number">21</span> seconds ago<br/>Running <span class="hljs-number">19</span> seconds ago<br/>Running <span class="hljs-number">20</span> seconds ago<br/></span></strong>
</pre>
<p>Since Mongo database is much bigger than the main service, it takes more time to pull it, resulting in a few failures. The <kbd>go-demo</kbd> service is designed to fail if it cannot connect to its database. Once the <kbd>db</kbd> service is running, the main service should stop failing, and we'll see three replicas with the current state <kbd>Running</kbd>.</p>
<p>After a few moments, the <kbd>swarm-listener</kbd> service will detect the main service from the <kbd>go-demo</kbd> stack and send the <kbd>proxy</kbd> a request to reconfigure itself. We can see the result by sending an HTTP request to the <kbd>proxy</kbd>:</p>
<pre>
<strong>curl -i "http://$(docker-machine ip swarm-1)/demo/hello"</strong>
</pre>
<p>The output is as follows:</p>
<pre>
<strong><span class="hljs-status">HTTP/1.1 <span class="hljs-number">200</span> OK</span><br/><span class="hljs-attribute">Date</span>: <span class="hljs-string">Thu, 19 Jan 2017 23:57:05 GMT</span><br/><span class="hljs-attribute">Content-Length</span>: <span class="hljs-string">14</span><br/><span class="hljs-attribute">Content-Type</span>: <span class="hljs-string">text/plain; charset=utf-8</span><br/><br/><span class="erlang-repl"><span class="hljs-function_or_atom">hello</span>, <span class="hljs-function_or_atom">world</span><span class="hljs-exclamation_mark">!</span></span></strong>
</pre>
<p>The <kbd>proxy</kbd> was reconfigured and forwards all requests with the base path <kbd>/demo</kbd> to the main service from the <kbd>go-demo</kbd> stack.<br/></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">To stack or not to stack</h1>
            </header>

            <article>
                
<p>Docker stack is a great addition to the Swarm Mode. We do not have to deal with <kbd>docker service create</kbd> commands that tend to have a never ending list of arguments. With services specified in Compose YAML files, we can replace those long commands with a simple <kbd>docker stack deploy</kbd>. If those YAML files are stored in code repositories, we can apply the same practices to service deployments as to any other area of software engineering. We can track changes, do code reviews, share with others, and so on.</p>
<p>The addition of the Docker <kbd>stack</kbd> command and its ability to use Compose files is a very welcome addition to the Docker ecosystem.</p>
<p>Throughout the rest of the book, we'll use <kbd>docker service create</kbd> commands when exploring new services and <kbd>docker stack deploy</kbd> to create those we are already familiar with. If you have trouble converting <kbd>docker service create</kbd> commands into stacks, please take a look at the <kbd>vfarcic/docker-flow-stacks</kbd> (<a href="https://github.com/vfarcic/docker-flow-stacks">https://github.com/vfarcic/docker-flow-stacks</a>) repository. It contains the stacks from some of the services we'll use. I expect you to contribute with the stacks you use. Please fork the repository and make a pull request. If you have trouble making a stack, please open an issue</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Cleanup</h1>
            </header>

            <article>
                
<p>Please remove Docker Machine VMs we created. You might need those resources for some other tasks:</p>
<pre>
<strong><span class="hljs-keyword">exit</span><br/><br/>docker-machine rm <span class="hljs-operator">-f</span> swarm-<span class="hljs-number">1</span> swarm-<span class="hljs-number">2</span> swarm-<span class="hljs-number">3</span></strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>