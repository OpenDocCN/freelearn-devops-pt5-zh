<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Mirroring</h1></div></div></div><p>While most installations are happy to install Gitolite on a single server accessible to all their developers, some of them have developers in several cities around the world, and it is often useful to provide local mirrors in each city for fast access. Gitolite's mirroring feature caters to these needs in a very flexible manner.</p><p>Mirroring can<a id="id231" class="indexterm"/> be as simple or as complex as you want it. You can have one server be the master server for all repositories, with one or more slave servers carrying copies of them. You can have different servers be the master servers for different repositories, and select only some of the remaining servers as slaves instead of all of them. You can even keep some repositories out of the mirroring process if you wish.</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec71"/>Terminology and basic concepts</h1></div></div></div><p>A mirrored repository<a id="id232" class="indexterm"/> has a writable copy on one server, often called the<a id="id233" class="indexterm"/> <strong>master server</strong> for that repository, and read-only copies on one or more servers, similarly called <strong>slave servers</strong>
<a id="id234" class="indexterm"/>. The slave repositories<a id="id235" class="indexterm"/> are updated near instantaneously, subject to network speed, when the master repository is updated.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec48"/>Repository level mirroring</h2></div></div></div><p>The primary purpose <a id="id236" class="indexterm"/>of most mirroring is to make <a id="id237" class="indexterm"/>read access (over the network) faster, by providing a copy on a nearby server for fetches and clones. One might, therefore, expect a single server to be designated as the master and several others as slave servers.</p><p>However, Gitolite mirroring is defined at the <em>repository</em> level, not for the entire server as a whole. For <em>each</em> repository, the administrator decides which server holds the master (writable) copy, and which of the other servers, if any, should make slave copies available to their local users. (This is why we speak of master repository and slave repository, not master server and slave server.)</p><p>This is a very important idea that brings several advantages over mirroring the entire server as a whole.</p><p>Firstly, <a id="id238" class="indexterm"/>repositories need not be made available on servers where there are no local users of that repository. If there are very few (say one or two) users, <a id="id239" class="indexterm"/>depending on how actively developed the repository is, it might still make sense, from a network utilization point of view, to let those few users directly pull from the master or one of the other slaves. This allows branch offices with less resources to still be part of the Gitolite mirroring network if they have enough projects their local users will be working on.</p><p>Secondly, since you do not have to put <em>all</em> the master repositories on the same server, you can choose where to place the master copy of any specific repository. Usually, you'll want to place it on whichever server is closest (from a network speed point of view) to the majority of the developers who will be working on it.</p><p>Finally, repositories can be purely local to a particular server, that is, they need not be mirrored at all.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>There can only be one master repository—you cannot have different users pushing to different servers because that would lead to a merge issue, which cannot be reliably automated. (However, Gitolite does have a workaround for convenience, as we will see later.)</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec49"/>The gitolite-admin repository</h2></div></div></div><p>From the point <a id="id240" class="indexterm"/>of view of Gitolite's mirroring feature, <a id="id241" class="indexterm"/>the gitolite-admin repository is just another repository. There is nothing special about it as far as mirroring is concerned – like all other repositories, one of the servers will hold the master (writable) copy. The only difference is that <em>all</em> the other servers must be mentioned in the slave list; if a server is not mentioned, it cannot receive updates to this repository.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec72"/>Setting up mirroring</h1></div></div></div><p>Setting up <a id="id242" class="indexterm"/>mirroring has quite a few manual steps, although each step in itself is quite simple. The first step is to give each host a name, and make sure that the hosts can all talk to one another by these names. The second step is to enable mirroring on each server.</p><p>We start by installing Gitolite as normal on all the servers. Then, we edit each server's <code class="literal">$HOME/.gitolite.rc</code> file and uncomment the line defining the <code class="literal">HOSTNAME</code>, choosing a simple hostname as the value.</p><div><div><h3 class="title"><a id="tip32"/>Tip</h3><p>The hostname should be a simple word; it is of interest only to Gitolite and does not have any relation to the server's hostname as known by the operating system and DNS records.</p></div></div><p>Gitolite mirroring<a id="id243" class="indexterm"/> works by allowing the servers to communicate with each other using ssh keypairs named after these hostnames. This is the same mechanism that users use, except that the public key file for a server is named <code class="literal">server-</code>, followed by the hostname of that server. All the keys will need to be provided to all the servers, added to their gitolite-admin repositories, and pushed. Finally, each server's $HOME/.ssh/config will need a host alias to refer to all the other machines.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec50"/>Example setup</h2></div></div></div><p>An example <a id="id244" class="indexterm"/>will make this clearer. Say you have three servers jupiter, ganymede, and callisto. These servers are on IP addresses <code class="literal">10.1.1.1, 10.2.1.1</code> and <code class="literal">10.3.1.1</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">First, install Gitolite on all three servers. On Jupiter, edit <code class="literal">$HOME/.gitolite.rc</code>, and uncomment the <code class="literal">HOSTNAME</code> line, changing it as follows (don't miss the trailing comma!):<div><pre class="programlisting">
<strong>HOSTNAME    =&gt;  "jupiter",</strong>
</pre></div></li><li class="listitem">Do the same on the other two servers.</li><li class="listitem">Run <code class="literal">ssh-keygen</code> on each server to create a key pair for the server. Collect all three <code class="literal">$HOME/.ssh/id_rsa.pub</code> files (one from each server), naming them <code class="literal">server-jupiter.pub</code>, <code class="literal">server-callisto.pub</code>, and <code class="literal">server-ganymede.pub</code> respectively.</li><li class="listitem">Add these public keys to <em>all</em> the servers, just as you would add normal users (that is, <em>for each server</em>, clone the gitolite-admin repo from that server, add all these keys to the <code class="literal">keydir</code>, then add, commit, and push).</li><li class="listitem">Next, add the following lines to all three servers' <code class="literal">$HOME/.ssh/config</code> files (assuming the hosting user on all three servers is <code class="literal">git</code>):<div><pre class="programlisting">
<strong>host jupiter</strong>
<strong>    user git</strong>
<strong>    hostname 10.1.1.1</strong>
<strong>host ganymede</strong>
<strong>    user git</strong>
<strong>    hostname 10.2.1.1</strong>
<strong>host callisto</strong>
<strong>    user git</strong>
<strong>    hostname 10.3.1.1</strong>
</pre></div></li></ol></div><p>When you're done with all this, you should be able to test your setup by running ssh ganymede info from jupiter. You should get an output similar to the following:</p><div><pre class="programlisting">hello server-jupiter, this is git@ganymede.example.com running gitolite3 v3.5.3.1-7-g31d11b9 on git 1.8.3.1 </pre></div><p>Similar commands from any server to any other should generate similar responses. It is best to test all the possible combinations to avoid confusing errors later.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec51"/>Bootstrapping the mirroring process</h2></div></div></div><p>The previous step establishes communication and authentication between all servers. Once that is done and checked, the next step is to bootstrap the mirroring process by setting up mirror options for the gitolite-admin repository and pushing them.</p><p>On each server, add the following lines to the <code class="literal">conf</code> file:</p><div><pre class="programlisting">
<strong>repo gitolite-admin</strong>
<strong>    option mirror.master   = jupiter</strong>
<strong>    option mirror.slaves    = callisto ganymede</strong>
</pre></div><p>Once you add, <a id="id245" class="indexterm"/>commit, and push this change to all the repositories, Gitolite mirroring is set up and ready to go. From here on, you administer everything by pushing to the gitolite-admin repository on its master server (in our case, <code class="literal">jupiter</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec52"/>Mirroring other repositories</h2></div></div></div><p>By now you <a id="id246" class="indexterm"/>can guess what you need to do for each of the other repositories. Just add option lines as in the previous section for each of them. For example, a simple mirroring setup, where all the repositories are mirrored the same way, can be as follows:</p><div><pre class="programlisting">
<strong>repo @all</strong>
<strong>    option mirror.master   = jupiter</strong>
<strong>    option mirror.slaves    = callisto ganymede</strong>
</pre></div><p>If that's all you want, you're pretty much done with mirroring. Otherwise, add the options as required, giving each repository the correct master server name and the correct set of slave servers. Note that any repositories that don't have these settings are considered local.</p><p>If you're allowing your users to create their own repositories (see <a class="link" href="ch08.html" title="Chapter 8. Allowing Users to Create Repos">Chapter 8</a>, <em>Allowing Users to Create Repos</em>), just add mirroring option lines to those repository definitions too. The following restrictions apply to mirroring user-created repositories.</p><p>The creation <a id="id247" class="indexterm"/>of such a repository is propagated only when the first push happens to the repository on the master server. A repository created as the result of a clone or fetch will not immediately propagate to the slaves.</p><p>Changes in permissions (using the <code class="literal">perms</code> command; see <a class="link" href="ch08.html" title="Chapter 8. Allowing Users to Create Repos">Chapter 8</a>, <em>Allowing Users to Create Repos</em>, specifically the <em>Giving access to other users </em>section) also propagate only on the next push.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec73"/>Local repositories and hostname substitution</h1></div></div></div><p>We mentioned earlier that some servers can have local repositories<a id="id248" class="indexterm"/>, say if the <code class="literal">conf</code> file does not specify Gitolite mirror options for those repositories. However, local repositories are really of interest only if each server can have its own set of them. For example, say the folks on Ganymede wish to have a local repository called ganymede-news that they intend to use internally. Adding that to the <code class="literal">conf</code> file would create such a repository on Jupiter and Callisto as well; even if no one used it, it's ugly, unnecessary, and cause for future confusion. We would like to prevent this, but since the same gitolite-admin repository, with the same <code class="literal">conf/gitolite.conf</code> file and other files, is pushed to all the slave servers, it seems difficult to do so.</p><p>The feature that makes this possible is <code class="literal">HOSTNAME</code> substitution<a id="id249" class="indexterm"/>. Specifically, whenever Gitolite encounters the string <code class="literal">%HOSTNAME</code> (followed by a non-word character; that is, a character other than alphabets, digits, and underscore) in the <code class="literal">conf</code> file, it will replace it with the <code class="literal">HOSTNAME</code> of the server, as given in <code class="literal">$HOME/.gitolite.rc</code>, before processing it.</p><p>Using the <code class="literal">include</code> statement capability we saw in <a class="link" href="ch06.html" title="Chapter 6. Getting Started with Access Control">Chapter 6</a>, <em>Getting Started with Access Control</em>, you can now provide server-specific Gitolite configuration, while still keeping everything in one repository. Just add the following line to the main conf file (<code class="literal">conf/gitolite.conf</code>):</p><div><pre class="programlisting">
<strong>include "%HOSTNAME.conf"</strong>
</pre></div><p>Then, create <code class="literal">conf/jupiter.conf</code>, <code class="literal">conf/callisto.conf</code> and so on for each of your servers. Within those files, specify repo statements and rules that are unique to the respective server.</p><p>It is important to understand that when you use such an <code class="literal">include</code> statement in your main <code class="literal">conf</code> file and push, each server will see that line differently. For example, Jupiter will see it as the following line (and similarly for other servers):</p><div><pre class="programlisting">
<strong>include "jupiter.conf"</strong>
</pre></div><p>This means that the other two files (<code class="literal">ganymede.conf</code> and <code class="literal">callisto.conf</code>), while they are certainly physically present in the <code class="literal">conf</code> directory, are not actually processed at all.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec74"/>Redirecting pushes</h1></div></div></div><p>We <a id="id250" class="indexterm"/>mentioned earlier that there can only be one master repository. However, this makes things a little inconvenient from the developers' point of view. Say you would like some of your developers to take advantage of a geographically close slave server to pull updates from. This means they would have to use push to a different server than the one they presumably cloned from and regularly pull/fetch from. While Git does allow this (see man git-config and look for pushurl, for one possible way), it is still something that requires each user to do something on their machines. In addition, remember Gitolite allows different repositories to have different master servers; this is more scope for confusion on the part of the developer.</p><p>Therefore, Gitolite has a feature that makes this restriction much less onerous. If the administrator chooses, a developer can push to a slave server, and <em>the push will transparently be forwarded to the master server for that repository</em>. In fact, the user may not even know that this is happening unless the network speed makes it obvious.</p><p>This makes things very convenient for administrators; there is no longer any need to confuse developers with detailed information about where to clone and where to push for each repository they need. In fact, you can set it up so that all developers in a particular site use their local Gitolite server for all their clones, without even having to even know that Gitolite mirroring is being used!</p><p>This feature is called <strong>redirected push</strong>
<a id="id251" class="indexterm"/>, since that is exactly what happens behind the scenes. Here's how to use it. Let us say you want to allow redirected pushes (to a <code class="literal">repository foo</code>) from <code class="literal">ganymede</code> (but not <code class="literal">callisto</code>), you add the following lines to the <code class="literal">conf</code> file:</p><div><pre class="programlisting">
<strong>repo foo</strong>
<strong>    option mirror.redirectOK  = ganymede</strong>
</pre></div><p>That's it. Just list all the slaves that you trust and add them, space-separated, as a value to this option. If you trust all of them, just use the single word all instead.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec75"/>Manual synchronization</h1></div></div></div><p>Sometimes you <a id="id252" class="indexterm"/>will find that a slave server has not been updated, perhaps due to some transient network problem. One way to get it back in sync, after the network problem has been resolved, of course, is to make some change to the repository and make a push. However, this feels clumsy and inelegant.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>At present, Gitolite does not have any way of reporting on push failures, although it does log whatever messages Git itself sends back in the log files. This means admins have to actively monitor the log files for failure, or wait for users to report issues with slaves getting out of sync.</p></div></div><p>For the aesthetically sensitive, Gitolite has the mirror command. Just log on to the server that contains the<a id="id253" class="indexterm"/> master repository, and run <code class="literal">gitolite mirror push slavename reponame</code>. This will immediately bring the slave up to date.</p><p>If you would like remote users to invoke such updates, simply enable the command for remote use by uncommenting the corresponding line in <code class="literal">$HOME/.gitolite.rc</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec76"/>Switching to a different master</h1></div></div></div><p>The<a id="id254" class="indexterm"/> biggest day-to-day benefit of mirroring is clearly that it can make read access more network-efficient for projects where the development team is widely distributed, albeit at the cost of an extra server at each slave location.</p><p>However, there's obviously one more advantage. If the main server for a repository should fail, one of the mirrors can easily be removed from the list of slaves and be made the master. As long as there are no network problems, the slave should be in the same state as the master, so no commits are lost.</p><div><div><h3 class="title"><a id="tip33"/>Tip</h3><p>Mirroring is not the same as backup. It is outside the scope of this book to discuss the differences, but you should always have a reliable backup system in place for all your servers and possible workstations as well.</p></div></div><p>This simple strategy breaks down when the server that died contains the gitolite-admin repository itself. This is a bit of a catch-22 situation; you cannot push the change (in mirror options for the gitolite-admin repository) to the current master server since it is down. Yet, you cannot push to the slave server that you decided to promote to "master" status, because it does not yet know that it is the new master! (Needless to say, as a security feature, slave servers do not accept pushes from just anywhere – they will only do so from the server that they have been told is the master for the repository concerned.)</p><p>The correct way to resolve this is as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">On each slave, edit <code class="literal">$HOME/.gitolite/gitolite.conf</code>. Change the master and slave options for the gitolite-admin repository. If you used repo <code class="literal">@all</code> for these options, they will change for everyone. However, it's best to change it only for the gitolite-admin repository if at all possible.</li><li class="listitem">After saving the change to this file, run <code class="literal">gitolite setup</code>. This will override the restriction and force the change on the local server. (This cannot be done remotely, again for security reasons.)</li><li class="listitem">Now, on<a id="id255" class="indexterm"/> the administrator's workstation, clone the gitolite-admin repository from the new master, change the mirroring options for the rest of the repositories (if required), then push the change.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Summary</h1></div></div></div><p>This concludes our exploration of Gitolite's mirroring feature. While it is not something that everyone will need, for the larger sites this has some very visible benefits.</p><p>I hope you have enjoyed this exploration of Gitolite and its features. As you use Gitolite more and more, you might also have the need to look at the official documentation on <a class="ulink" href="http://gitolite.com">http://gitolite.com</a>. We hope that this book has helped you understand the concepts and rationale behind Gitolite so that you can understand the official documentation better and get your job done faster.</p></div></body></html>